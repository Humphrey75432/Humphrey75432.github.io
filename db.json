{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/img/humphrey.jpg","path":"img/humphrey.jpg","modified":0,"renderable":0},{"_id":"source/img/lengtu.jpeg","path":"img/lengtu.jpeg","modified":0,"renderable":0},{"_id":"source/img/my-little-pony.jpeg","path":"img/my-little-pony.jpeg","modified":0,"renderable":0},{"_id":"source/img/rabbit.gif","path":"img/rabbit.gif","modified":0,"renderable":0},{"_id":"source/img/sheep.jpg","path":"img/sheep.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1644993977235},{"_id":"source/img/humphrey.jpg","hash":"3500d8fbd318b9a70479a55f82c1a47c77d98ba4","modified":1644854157583},{"_id":"source/about/index.md","hash":"c3f95f5feccf86bda8ec2aef56e2e99ae444ea76","modified":1644855596886},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1644809129879},{"_id":"source/_posts/golang/go-lang-basic.md","hash":"8fac867dd21487ea1c295776ce741fbfb0c2d3a7","modified":1650720989644},{"_id":"source/_posts/java-core/ch02.md","hash":"a3efe991d79d8a09dc0d0aecee90acbcacf46963","modified":1645021087593},{"_id":"source/_posts/java-core/ch04.md","hash":"b41b57ce179ce93c1208da5fc7f695180f246e8a","modified":1645021284390},{"_id":"source/_posts/java-core/ch01.md","hash":"6938f113630b5eb3761b5aeb5c1b961f82abf119","modified":1645011779647},{"_id":"source/_posts/java-core/ch03.md","hash":"4ef0081656089829a5921448dcd3cfa5eb7f5f78","modified":1645011813264},{"_id":"source/_posts/java-core/ch05.md","hash":"1d68cfb889d646957b4845a629c0094ae22c4be5","modified":1645022013507},{"_id":"source/_posts/java-core/java-summary.md","hash":"37109ce24e7645c4156d84242b4d880720f9ae6d","modified":1645698705871},{"_id":"source/_posts/jvm/jvm-learning.md","hash":"5e64367d712b4c8e2eaab2697ebcd92c7c093987","modified":1651159496660},{"_id":"source/_posts/java-core/ch06.md","hash":"6bf02776377b0c5bf5077ec037901f95e3846e97","modified":1645023910108},{"_id":"source/_posts/java-core/java-thread-summary.md","hash":"28eea95f820cf3be6dd62c15f48dd742ff880621","modified":1646206110681},{"_id":"source/_posts/middleware/redis-learning.md","hash":"4893f23d11fc15ecb2b471ff9002eb9714d02dd6","modified":1647083736389},{"_id":"source/_posts/middleware/kafka-learning.md","hash":"db234cc7a0b0ff908772cc924fd815c7f3365e45","modified":1646361594951},{"_id":"source/_posts/javascript/es6-array-expand.md","hash":"e4421c94bf2e2bd40bc1a12b85bda8e44abddbf8","modified":1645108088170},{"_id":"source/_posts/javascript/es6-async-operate.md","hash":"428b842827974926a7d3edcf6fe4a574e354afae","modified":1645108019047},{"_id":"source/_posts/javascript/es6-class.md","hash":"c82466c2235aa61cee274cdeb67c2ec4e7c67c57","modified":1645108005921},{"_id":"source/_posts/javascript/es6-generator-function.md","hash":"42cdea87fbf40ba5b4178c981359ae048a20c672","modified":1645107866161},{"_id":"source/_posts/javascript/es6-getting-started.md","hash":"4eae531b63cd191e902280978a60322706a3576c","modified":1645108063038},{"_id":"source/_posts/javascript/es6-let-const.md","hash":"2f61d30ddefbb9e550bc3a5f291e52d05ccbf2be","modified":1645108057625},{"_id":"source/_posts/javascript/es6-function-expand.md","hash":"d1894b75a02d0ddf6c2b1d66e061508d816d11a6","modified":1645108049942},{"_id":"source/_posts/javascript/es6-num-expand.md","hash":"db9f5a67e34b34de8079285751f1ab54040ae08e","modified":1645108083761},{"_id":"source/_posts/javascript/es6-iterator.md","hash":"ca738e194961da6ff0149e07e02105e6e7b6211b","modified":1645108029845},{"_id":"source/_posts/javascript/es6-object-expand.md","hash":"9cc3d01f680d5979f6a0c154b0ef3d90c7df2cf7","modified":1645108092853},{"_id":"source/_posts/javascript/es6-program-style.md","hash":"a3d978210dc461dd8de68be46f10b587b18d56c4","modified":1645107949584},{"_id":"source/_posts/javascript/es6-promise.md","hash":"16ec571eb4d47b3d65c4b41c0c004b393aa22720","modified":1645107862383},{"_id":"source/_posts/javascript/es6-set-and-map.md","hash":"441a8211572cbf54bb1f5b6f1af171230ddefe80","modified":1645082677119},{"_id":"source/_posts/javascript/es6-proxy-and-reflect.md","hash":"16d19b5498396c29f02e99ce4795572dccb25a6e","modified":1645082655646},{"_id":"source/_posts/javascript/es6-regexp.md","hash":"9ec0313ea3d730f72d737fd0edf8e4ea4e21fa96","modified":1645108078812},{"_id":"source/_posts/javascript/es6-string.md","hash":"559b335ffbd7a23361163157918517b7619fe11e","modified":1645108073569},{"_id":"source/_posts/javascript/es6-var-expand.md","hash":"59a996617f29b8c8a77b68d6464651708c153aed","modified":1645108067403},{"_id":"source/_posts/javascript/es6-symbol.md","hash":"2f2290975fda5898460f6eed4e53a94dc8d05c64","modified":1645108044228},{"_id":"source/_posts/spring/spring-cloud-distribute-config.md","hash":"140b62ae5fa30d46368c5268d32b8064668a2aae","modified":1645364194226},{"_id":"source/_posts/mysql/mysql-index.md","hash":"4035cc7248444c703353e64ea37c091c286f901d","modified":1646306017022},{"_id":"source/_posts/spring/spring-bean-lifecycle.md","hash":"a9354fbdb493b1fc5a65027357228a2de9c0af36","modified":1646391788975},{"_id":"source/_posts/spring/spring-aop.md","hash":"692252769d1c8aa2108c49729307dd7fe3980d70","modified":1646544535595},{"_id":"source/_posts/spring/spring-cloud-open-feign.md","hash":"6c70ed49faf8f3e2f8b10c30d12623b744f6efd5","modified":1645336959386},{"_id":"source/_posts/spring/spring-cloud-ribbon.md","hash":"f96ac3983c699bc890a46b942807e552d5de6d1b","modified":1645322029586},{"_id":"source/_posts/spring/spring-summary.md","hash":"bfcf2edd67526dc5c671154302407249d3413ea0","modified":1646303298502},{"_id":"source/_posts/spring/spring-cloud-config.md","hash":"4b147de6ce602d6242f791ce2dbb4756cf1126b9","modified":1645349798698},{"_id":"source/_posts/spring/springcloud-service-consumer.md","hash":"d9c59c789b56ac6fd35e566fa6225c248f15e7c9","modified":1645320822918},{"_id":"source/_posts/spring/springcloud-getting-started.md","hash":"954ca805e9c26e34a5bc81331ba7060e2d5dc363","modified":1645260618026},{"_id":"source/_posts/distribute/distribute-concept.md","hash":"ffbc17846ebab49512c35d2292d78a99db2a7233","modified":1646366897884},{"_id":"source/_posts/frontend/css3/css3-ch02.md","hash":"f8d531f97c21c505d4ca2a23dc2916942d7650fa","modified":1645188846789},{"_id":"source/_posts/frontend/css3/css3-ch01.md","hash":"f5c2f64c716234ab4e2cac9681c18e0817713189","modified":1645188750290},{"_id":"source/_posts/frontend/css3/css3-ch03.md","hash":"2d7f5c52b374a4048eb9e9e16f4a14abc69e8967","modified":1645188893695},{"_id":"source/_posts/frontend/canvas/canvas-around-principle.md","hash":"bd7674cb9b6325c0add6e104f2f262b546ceeee7","modified":1645187875773},{"_id":"source/_posts/frontend/canvas/canvas-text.md","hash":"a98b33e9871d56b8c143a0b236c8cfbffa850b7a","modified":1645187752829},{"_id":"source/_posts/frontend/canvas/canvas-tranverse.md","hash":"fe2b3285b649bd0b5a7b4164cd7fcccf6860263d","modified":1645187764846},{"_id":"source/_posts/frontend/canvas/canvas-draw-shape.md","hash":"7bb8a2bc87b21ab00fc0f8f387acde003d357918","modified":1645187897657},{"_id":"source/_posts/frontend/canvas/canvas-getting-started.md","hash":"20ffbcef12f7343633311b07a6f198b46123b3b0","modified":1645187879791},{"_id":"source/img/my-little-pony.jpeg","hash":"92aefc0ccd6d69e72ed9abadfbf333ebb239390b","modified":1644765379872},{"_id":"source/img/lengtu.jpeg","hash":"a181605cf087e48b00cf633aca0d6eb3cde66ced","modified":1644766297059},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644732960745},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1644732960713},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1644732960714},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":1644732960715},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1644732960714},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"4e3992cacd64c6888218b0346283258e8f82a27d","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8a7f1534c228538e2ab56249d5a65829650170ed","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1644732960716},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":1644732960716},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"f3ae4395e751c4a02d5895e07856b1e8edfdda08","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1644732960746},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1644732960725},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1644732960715},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1644732960725},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1644732960746},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"f7f3494ed001e8cdcdc3e8a1d2cd1195cff2ded5","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"fd5fcb6a61ad865197a778eeae889b80484227dd","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1644732960737},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1644732960743},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1644732960738},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"08b455b848b21d57e0563b87071c4bae2b63bafe","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"df6941bd3b860180d01fd39ee859ed2d42f4d1f0","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"e8e01c5db46b383748855452aecd70fcda99f598","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1644732960736},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"c2d8bfd04bf0734b387c049402b46a06a05fc582","modified":1644732960738},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"80098e8354069631bde8edcd1181a53091a92949","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"a2993f23701de9a83e3f428300e62c5c52b4ff4b","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":1644732960741},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":1644732960745},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"5e86487de0f16c30ca3e16460ab94b57620e31c5","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1644732960745},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":1644732960737},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":1644732960741},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1644732960745},{"_id":"source/img/sheep.jpg","hash":"2f10e5756bee0bdc1f3de82c4b7a98adf42a2203","modified":1644765816950},{"_id":"source/img/rabbit.gif","hash":"5a605d911a2a266fa3040c6205b372515db64e3d","modified":1644766159511},{"_id":"public/local-search.xml","hash":"cfeea1315e7e19f10e1594bd1228335df4344b2c","modified":1651161720421},{"_id":"public/about/index.html","hash":"00927b6af0288c8d6b820d8a51a23e9d31b4787a","modified":1651161720421},{"_id":"public/2022/02/16/hello-world/index.html","hash":"6e74ba2a9135537998e9bcc97f92cb915ccd7a9f","modified":1651161720421},{"_id":"public/archives/index.html","hash":"75d09959b0b140d0f26c165b5e2060c66857a1e4","modified":1651161720421},{"_id":"public/archives/page/2/index.html","hash":"5d04eec3f08553ed282a3c0027e946a001294079","modified":1651161720421},{"_id":"public/archives/page/3/index.html","hash":"d4bae233f5b124929803b9cf9809c84c472cac42","modified":1651161720421},{"_id":"public/archives/page/4/index.html","hash":"c8775c310e3b0465d45c7c9303e27743d8cc14b6","modified":1651161720421},{"_id":"public/archives/page/5/index.html","hash":"99bc8d3e8220176a11198aab3aaaddda03b8aae1","modified":1651161720421},{"_id":"public/archives/2022/index.html","hash":"4144d47a78b63ed16ea69eb8a50a2500a306c064","modified":1651161720421},{"_id":"public/archives/2022/page/2/index.html","hash":"5d65a9e146fed45aff609a179eda8e7c0a0be579","modified":1651161720421},{"_id":"public/archives/2022/page/3/index.html","hash":"6fb3fb7de3d8774b6ba9e1d12378ab0b5e0af6c7","modified":1651161720421},{"_id":"public/archives/2022/page/4/index.html","hash":"df658256e99e48f6dd08c9f6730ec7fb03048a45","modified":1651161720421},{"_id":"public/archives/2022/page/5/index.html","hash":"dcf2ed9d7b7361af41c2fd757afabb9ff44d288c","modified":1651161720421},{"_id":"public/archives/2022/02/index.html","hash":"d41be6d0e5dd2e23140f449611547d914e816ea8","modified":1651161720421},{"_id":"public/archives/2022/02/page/2/index.html","hash":"bbdf9d51ceefed3e175e72114a84c5c48356a1c2","modified":1651161720421},{"_id":"public/archives/2022/02/page/3/index.html","hash":"8fad585474d087da08dfaf3affb5a3376b190e09","modified":1651161720421},{"_id":"public/archives/2022/02/page/4/index.html","hash":"a2e7926a34295bf7dbeac5613df6aa2986a3412c","modified":1651161720421},{"_id":"public/archives/2022/02/page/5/index.html","hash":"a32abba7da0c6fe7ca049414cd5b8afec7b30216","modified":1651161720421},{"_id":"public/archives/2022/03/index.html","hash":"4061b304864c49596a73d6ab6b1c5b3210bc94e8","modified":1651161720421},{"_id":"public/categories/服务后端开发/index.html","hash":"fa504b397684966756c45557b1aef704a07d236d","modified":1651161720421},{"_id":"public/categories/Java/index.html","hash":"a7605b99108e71ba684c8beb7052e95b7e166694","modified":1651161720421},{"_id":"public/categories/面试技巧/index.html","hash":"91f55751f3662128db225f11c6738e49b31aa455","modified":1651161720421},{"_id":"public/categories/面试盘点/index.html","hash":"8c02ccd97cdc334c3e355816f160ed13ec66a704","modified":1651161720421},{"_id":"public/categories/消息中间件/index.html","hash":"052b273fc614c281eb12cd81732672ed8d559bb3","modified":1651161720421},{"_id":"public/categories/JavaScript/index.html","hash":"a3d8b61c7eabe0f5ed80e5bdc6add177de9d7159","modified":1651161720421},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"245de6d1161be70744da921809efb5a4c287e41b","modified":1651161720421},{"_id":"public/categories/数据库/index.html","hash":"ec9ddaf0e71ece10423bb63de230813ee77b9511","modified":1651161720421},{"_id":"public/categories/Spring/index.html","hash":"d06e69f5f91cf6cc4b8df703b2cf2a96558d5607","modified":1651161720421},{"_id":"public/categories/微服务架构学习/index.html","hash":"65e6aebb35fa182fca2bbfe99393a2ed63de7c72","modified":1651161720421},{"_id":"public/categories/分布式架构设计/index.html","hash":"1e528257f3f057e463446d70d442bd13d2b14b4c","modified":1651161720421},{"_id":"public/categories/前端/index.html","hash":"5225f63a6627751621c6f7b43ae9e5037e695c21","modified":1651161720421},{"_id":"public/tags/Go语言/index.html","hash":"b75a0361dea2d425893b7ffec1a703b14c03d514","modified":1651161720421},{"_id":"public/tags/Java基础/index.html","hash":"731c1921ad57314e1546c0d4cea3b69bcca73c80","modified":1651161720421},{"_id":"public/tags/Java/index.html","hash":"5586ad5e61a2391c1a20eabde17965e949d59cfa","modified":1651161720421},{"_id":"public/tags/JVM/index.html","hash":"6907ea932e9f2e38fbd22ce91aad484693986cab","modified":1651161720421},{"_id":"public/tags/Kafka/index.html","hash":"e7a131263327a28da6256f9cf1eee3fae356f5e2","modified":1651161720421},{"_id":"public/tags/Redis/index.html","hash":"caa9a6eb8255d6fb605cd7a6b52a6e62cc8a7493","modified":1651161720421},{"_id":"public/tags/ES6基础/index.html","hash":"619c43655355aa9ca6ddee792f2f50c8ff5a6131","modified":1651161720421},{"_id":"public/tags/ES6基础/page/2/index.html","hash":"19a0be9729f7b1ce96770999e1298b22c1b1c62e","modified":1651161720421},{"_id":"public/tags/MySQL/index.html","hash":"3d41d3d551991fc3eec15b751d23783dba1994d6","modified":1651161720421},{"_id":"public/tags/Spring框架/index.html","hash":"b74aebc58eca0eef28a48010538f13461297de24","modified":1651161720421},{"_id":"public/tags/Spring-Cloud/index.html","hash":"1149520756677452b5948b129e7ea928241df470","modified":1651161720421},{"_id":"public/tags/分布式/index.html","hash":"ce017dc8543d1de03f293e234f1a304e6535f548","modified":1651161720421},{"_id":"public/tags/CSS3/index.html","hash":"3e589bd5a2eba2a6337f716f3c3b169a15709652","modified":1651161720421},{"_id":"public/tags/HTML/index.html","hash":"e92b254ce9351c28db8e65e6c8850006011500dd","modified":1651161720421},{"_id":"public/404.html","hash":"9276c6581a78b762869ac91c62e2235afea0364a","modified":1651161720421},{"_id":"public/tags/index.html","hash":"856d323724cd3883ee0ba7aedb4bfc4d08ada413","modified":1651161720421},{"_id":"public/links/index.html","hash":"b6f2b08292b2d09af342515a029de3605aaa7d5a","modified":1651161720421},{"_id":"public/2022/03/04/spring/spring-bean-lifecycle/index.html","hash":"7aae461b41ecbef4564dc34f860031bfcf73d00a","modified":1651161720421},{"_id":"public/2022/03/23/golang/go-lang-basic/index.html","hash":"641c007974d316ca4167aff784cc4873d26b8f38","modified":1651161720421},{"_id":"public/2022/03/04/spring/spring-aop/index.html","hash":"2cd4531ecbce4a9af86c061ba30c460ac5cb3df0","modified":1651161720421},{"_id":"public/2022/03/03/distribute/distribute-concept/index.html","hash":"56923fc5261f2f41d3f0d17d708f1fe509212d39","modified":1651161720421},{"_id":"public/2022/03/02/middleware/kafka-learning/index.html","hash":"87dea5654f5c55e0433c58532e26379aaac9e9cf","modified":1651161720421},{"_id":"public/2022/02/24/spring/spring-summary/index.html","hash":"fcd87e73daca9284d3bf02aa60f0a65641fb9f66","modified":1651161720421},{"_id":"public/2022/02/24/java-core/java-thread-summary/index.html","hash":"04bb6c14fab03d02ed6ac4e787f671560d0b74a7","modified":1651161720421},{"_id":"public/2022/02/24/java-core/java-summary/index.html","hash":"b9a7e01be4ccf2bba0fa7eff58e5a799dd3201ab","modified":1651161720421},{"_id":"public/2022/02/21/jvm/jvm-learning/index.html","hash":"3000b9287ba22fb3c3f10137691f10e1f069f241","modified":1651161720421},{"_id":"public/2022/02/21/middleware/redis-learning/index.html","hash":"c9f208689296234040363178c335e833d92a563a","modified":1651161720421},{"_id":"public/2022/02/21/mysql/mysql-index/index.html","hash":"3c9b7ffae426ed03159cf35b2066bedf34a360a6","modified":1651161720421},{"_id":"public/2022/02/20/spring/spring-cloud-distribute-config/index.html","hash":"2f19c23083e48f93066bcdd797d45576461cd0d0","modified":1651161720421},{"_id":"public/2022/02/20/spring/spring-cloud-config/index.html","hash":"2f7bad2d794a69665d14919be47b60acc4952ca0","modified":1651161720421},{"_id":"public/2022/02/20/spring/spring-cloud-open-feign/index.html","hash":"f085436b6cf0cafd8fec9771daa4a1b484645f96","modified":1651161720421},{"_id":"public/2022/02/20/spring/spring-cloud-ribbon/index.html","hash":"fc83e72e3d2dbf5ccb94347013ba47e6cfdbeb1c","modified":1651161720421},{"_id":"public/2022/02/19/spring/springcloud-service-consumer/index.html","hash":"cbb38bc123aae9fd3147e9fa5e46a4601a96cd7e","modified":1651161720421},{"_id":"public/2022/02/19/spring/springcloud-getting-started/index.html","hash":"68028c7f65b25aba8910f191bbbd571e6a1ed590","modified":1651161720421},{"_id":"public/2022/02/18/frontend/css3/css3-ch03/index.html","hash":"2056344d83517a51e580cebd24915b465b753ca5","modified":1651161720421},{"_id":"public/2022/02/18/frontend/css3/css3-ch02/index.html","hash":"9740da3527373e3055e1c8ba279fc882d844b702","modified":1651161720421},{"_id":"public/2022/02/18/frontend/css3/css3-ch01/index.html","hash":"d8ef7c38015a63b8f4aa986da9183d4e11ac2909","modified":1651161720421},{"_id":"public/2022/02/18/frontend/canvas/canvas-text/index.html","hash":"7c5f06c715c98917c916a23f184442b155f4022a","modified":1651161720421},{"_id":"public/2022/02/18/frontend/canvas/canvas-around-principle/index.html","hash":"8dddc9002848e8ad71a05ca81fe17995e1bc705f","modified":1651161720421},{"_id":"public/2022/02/18/frontend/canvas/canvas-tranverse/index.html","hash":"373b472f34af60a64211075efad75c59418d5537","modified":1651161720421},{"_id":"public/2022/02/18/frontend/canvas/canvas-draw-shape/index.html","hash":"4c73a57bb52c2832cf8817ca047001cb4e798047","modified":1651161720421},{"_id":"public/2022/02/18/frontend/canvas/canvas-getting-started/index.html","hash":"8598d1717055552d9b4cb3fc05e57dad51f997f0","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-async-operate/index.html","hash":"747d2a4368f7608345bd64c1304a0ee0150c58d8","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-program-style/index.html","hash":"33f2d76f9df3101f546fd6c4cf5eef30090ed793","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-class/index.html","hash":"6b910462b57609a0f65c42473d42536ecb385b8f","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-promise/index.html","hash":"d76335ef7f961edbe8696816ec55152538cd29f0","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-generator-function/index.html","hash":"26db79cab32ebae03ef9961ab87dbb008353d4e8","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-iterator/index.html","hash":"b512eb0803e2fc1f81d8c27d9dc4fe2733fc4ac4","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-proxy-and-reflect/index.html","hash":"cd4f88ec5c68ed38668901ea8670386e59345b6b","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-set-and-map/index.html","hash":"c8c9aa22734151d1afd73bcef1de33bbb97f88d9","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-symbol/index.html","hash":"8ba9fb5667c430891e4514eeed49ef47846765fe","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-object-expand/index.html","hash":"418f3f5d0430007eaf77a94092a35628a5c57728","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-function-expand/index.html","hash":"325e9ab145ce59eeb1cc1177f7eb915260ea9d32","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-array-expand/index.html","hash":"1c482526b66cb6e2fa2d5830fcbd6c4ff570afa1","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-num-expand/index.html","hash":"d76cf562df1620d4c68c062e42f54009afeb5efc","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-regexp/index.html","hash":"8e0e807153479fcdf6d21b4014bfd52838df15e0","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-string/index.html","hash":"9b5c9130e9c509c3a5eb338ca78862814e608c67","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-var-expand/index.html","hash":"ed8f573c9c75a9d9cfef1207991c9191720ff685","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-let-const/index.html","hash":"0878a7746721751c51ad083cd8b50988a984e15e","modified":1651161720421},{"_id":"public/2022/02/17/javascript/es6-getting-started/index.html","hash":"172c28f61429768d7fcba51d95a6828feb333ece","modified":1651161720421},{"_id":"public/2022/02/16/java-core/ch06/index.html","hash":"c8d9adb5ed1ebfaa95ad631aa3884effc826c2c9","modified":1651161720421},{"_id":"public/2022/02/16/java-core/ch05/index.html","hash":"ad983037e77203f3c37013dc3ad90144395c67c7","modified":1651161720421},{"_id":"public/2022/02/16/java-core/ch04/index.html","hash":"5288edcfedc38f765c1e012f62df869c6d266ad3","modified":1651161720421},{"_id":"public/2022/02/16/java-core/ch03/index.html","hash":"f950600a47d444651d38e0b9342d9d376e94af42","modified":1651161720421},{"_id":"public/2022/02/16/java-core/ch02/index.html","hash":"fdccfdf6134e788145efc9d43ac4fd5585f1365f","modified":1651161720421},{"_id":"public/2022/02/13/java-core/ch01/index.html","hash":"1dff2ca7fa89be268f17933a5d8a1224b7295856","modified":1651161720421},{"_id":"public/index.html","hash":"e60ca205242757dede2e51811695018a38656cc6","modified":1651161720421},{"_id":"public/page/2/index.html","hash":"b35d4841b213c195b4ed551686e8d3480cb26c0d","modified":1651161720421},{"_id":"public/page/3/index.html","hash":"1c3923386c5fc7c041127d5df036c6ec09258107","modified":1651161720421},{"_id":"public/page/4/index.html","hash":"7743aaaa76d6b85c7f161aea9bcb0688d3d8b28e","modified":1651161720421},{"_id":"public/page/5/index.html","hash":"fb8c8a39e0b407150474f6ff08c4c43d0df374cf","modified":1651161720421},{"_id":"public/categories/index.html","hash":"4bbef0e5a32bcf18ba60d29c0f126c10e043b6e6","modified":1651161720421},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1651161720421},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1651161720421},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1651161720421},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1651161720421},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1651161720421},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1651161720421},{"_id":"public/img/humphrey.jpg","hash":"3500d8fbd318b9a70479a55f82c1a47c77d98ba4","modified":1651161720421},{"_id":"public/img/my-little-pony.jpeg","hash":"92aefc0ccd6d69e72ed9abadfbf333ebb239390b","modified":1651161720421},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1651161720421},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1651161720421},{"_id":"public/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1651161720421},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1651161720421},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1651161720421},{"_id":"public/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1651161720421},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1651161720421},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1651161720421},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1651161720421},{"_id":"public/css/main.css","hash":"63bc59b8ca4b03afa2b93883143c349d461b1052","modified":1651161720421},{"_id":"public/img/lengtu.jpeg","hash":"a181605cf087e48b00cf633aca0d6eb3cde66ced","modified":1651161720421},{"_id":"public/img/sheep.jpg","hash":"2f10e5756bee0bdc1f3de82c4b7a98adf42a2203","modified":1651161720421},{"_id":"public/img/rabbit.gif","hash":"5a605d911a2a266fa3040c6205b372515db64e3d","modified":1651161720421}],"Category":[{"name":"服务后端开发","_id":"cl2j6t6uy00044f61awvb6tup"},{"name":"Java","_id":"cl2j6t6v200094f61g4xy1vs9"},{"name":"面试技巧","_id":"cl2j6t6va00114f6173ub5mmf"},{"name":"面试盘点","_id":"cl2j6t6vd00184f61efvsd2u1"},{"name":"消息中间件","_id":"cl2j6t6ve001f4f6167bk49sl"},{"name":"JavaScript","_id":"cl2j6t6vh001q4f616g58a65n"},{"name":"数据库","_id":"cl2j6t6vu003m4f6186w9crx1"},{"name":"Spring","_id":"cl2j6t6vv003t4f612yv3625g"},{"name":"微服务架构学习","_id":"cl2j6t6vy00454f612xe8achz"},{"name":"分布式架构设计","_id":"cl2j6t6w2004z4f610scwcfcq"},{"name":"前端","_id":"cl2j6t6w300544f61cg8tc3ot"}],"Data":[],"Page":[{"title":"about","date":"2022-02-13T06:22:43.000Z","layout":"about","_content":"> 一句话总结：最不像程序员的程序员。\n\n一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。\n\n平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-02-13 14:22:43\nlayout: about\n---\n> 一句话总结：最不像程序员的程序员。\n\n一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。\n\n平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。\n","updated":"2022-02-14T16:19:56.886Z","path":"about/index.html","comments":1,"_id":"cl2j6t6ur00004f61giixc1wi","content":"<blockquote>\n<p>一句话总结：最不像程序员的程序员。</p>\n</blockquote>\n<p>一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。</p>\n<p>平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。</p>\n","site":{"data":{}},"wordcount":165,"excerpt":"","more":"<blockquote>\n<p>一句话总结：最不像程序员的程序员。</p>\n</blockquote>\n<p>一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。</p>\n<p>平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。</p>\n"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-02-16T06:46:17.234Z","updated":"2022-02-16T06:46:17.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6uu00014f61c2fa5hb0","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"wordcount":367,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Golang入门教程","date":"2022-03-23T14:29:25.000Z","updated":"2022-03-23T14:29:25.000Z","_content":"\n# 一、这篇文章的目的\n\n按照以前的惯例，我们会把Golang的语法贴在这里，其实网上（包括官网）都有非常详细的Go语言教程，学习过程中可以多实践使用。这里我写一些使用中在语法上比较少涉及到的点。方便在使用过程快速回忆。当然golang本身也不复杂，上手也比较简单，如果有需要可以对照网上的教程重新温习。\n\n# 二、golang基础\n\n## 2.1 类型\n\n+ 布尔值\n  + **bool**\n+ 字符串\n  + **string**\n+ 整型\n  + **int** / **int8** / **int16** / **int32** / **int64**\n  + **uint** / **uint8** / **uint16** / **uint32** / **uint64** / **uintptr**\n+ 字节类型（uint8别名）\n  + **byte**\n+ Unicode类型（int32别名）\n  + **rune**\n+ 浮点类型\n  + **float32** / **float64**\n+ 复数类型\n  + **complex64** / **complex128**\n\n## 2.2 关键字汇总\n\ngolang关键字只有25个，非常容易掌握\n\n+ 第一组\n  + **break**（退出循环） / **case**（Switch语句） / **chan**（通道） / **const**（常量） / **continue**（跳过当前循环）\n+ 第二组\n  + **default**（Switch语句） / **defer**（先定义后执行） / **else**（分支） / **fallthrough**（Switch语句） / **for**（循环）\n+ 第三组\n  + **func**（函数定义） / **go**（开启Goroutine） / **goto**（流程） / **if**（条件） / **import**（导包）\n+ 第四组\n  + **interface**（接口或者泛型定义） / **map** / **package** / **range**（基于范围的遍历） / **return**（返回）\n+ 第五组\n  + **select**（在通道使用） / **struct**（结构体） / **switch**（分支语句） / **type**（定义类型） / **var**（声明变量）\n\n## 2.3 包的导入导出\n\n与Java不同的是，Go语言是通过名字大小写来判定当前函数/变量是否导出。如果是小写开头就意味着不导出；如果是大写开头就意味着是导出包。例如：\n\n```go\n// 未导出\nmath.pi\n\n// 已导出\nmath.Pi\n```\n\n## 2.4 变量声明方式\n\n与我们常用的C，C++，Java，JavaScript不同的是，Golang的变量类型是放在变量名的后面的。这点在写习惯了Java等编程语言的人来说，早期会感到不适应。但是随着你使用上习惯了，自然而然就能接受。具体如下：\n\n```go\n// 借助var关键字声明变量\nvar i int\n\n// 自动推断类型，这里一定要注意，如果前面没有创建过变量i，必须使用\":=\"符号\ni := 34\n\n// 多个变量初始化\nconst (\n\ti int\n    j bool\n    k string\n)\n```\n\n## 2.5 类型转换\n\n表达式`T(V)`将值`v`转换为类型`T`，这里提供一些关于数值转换的例子供你参考：\n\n```go\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n\n或者使用更加简单的形式：\n\n```go\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n## 2.6 函数\n\n跟Java不同的是，Go语言中的函数可以返回多个值，例如让你写一个交换两值的函数，在Java下你会这么写：\n\n```java\npublic void swap(int x, int y) {\n    System.out.printf(\"Before Swap is: %d, %d\", x, y);\n    int tmp = x;\n    x = y;\n    y = tmp;\n    System.out.println(\"After Swap is: %d, %d\", x, y);\n}\n```\n\n但是在Go语言下，你只需要这样写就可以实现一样的效果了：\n\n> 可以发现：在golang中函数的返回值也是放在函数尾部的，这和我们Java的语法存在不同，需要注意\n\n```go\nfunc swap(x, y int) (int, int) {\n    return y, x\n}\n```\n\nGo语言的返回值可以被命名，它们会被视作定义在函数顶部的变量，简而言之就是：没有参数的`return`语句返回已命名的返回值。也就是直接返回。例如：\n\n> 直接返回语句应当仅用在短函数中，过长的函数代码反而会影响代码可读性\n\n```go\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return\n}\n```\n\n## 2.7 for循环\n\nGo语言中只有一种循环结构，就是for，它的语法跟Java、C++很像。唯一的区别就是循环两侧不需要括号。例如：\n\n```go\n// 标准的for循环\nfor i := 0; i < 10; i++ {}\n\n// Go语言中的While循环\nfor sum < 100 {}\n```\n\n除此之外，还可以使用for循环迭代切片和map\n\n```go\nvar slice []int = []int{ 10, 20, 30, 40, 50 }\n// 迭代切片\nfor index, value := range slice {\n    fmt.Printf(\"索引为：%d，数值为：%d\\n\", index, value);\n}\n\n// 如果不想获取索引，可以使用\"_\"将其屏蔽\nfor _, value := range slice {\n    fmt.Printf(\"索引为：%d，数值为：%d\\n\", index, value);\n}\n\n// 迭代map\nvar stock_map map[string]int = map[string]int{\n\t\"iPhone 13 Pro\": 345,\n\t\"One Plus\":      21,\n\t\"Realme\":        34,\n}\n\nfor k, v := range stock_map {\n\tfmt.Printf(\"Key: %v, value: %d\\n\", k, v)\n}\n```\n\n# 三、数组、切片和Map\n\n## 3.1 数组\n\n类型`[n]T`表示拥有n个T类型的值数组，语法如下：\n\n```go\nvar a [10]int\n```\n\n具体实例如下所示：\n\n```go\nvar a [2]string\na[0] = \"hello\"\na[1] = \"world\"\n\nprimes := [6]int{2, 3, 5, 7, 11}\n```\n\n## 3.2 切片\n\n由于数组的大小是固定的，所以使用切片为数组元素提供动态大小、灵活的视角。在具体的开发实践中，切片比数组更加常用。具体语法如下：\n\n```go\na[low:high]\n```\n\n它会选择一个半开区间，包括第一个元素但排除最后一个元素：\n\n```go\n// 代表a数组从下标1到3的元素（不包括4）\na[1:4]\n```\n\n切片并不存储任何数据，它仅仅是描述了底层数组中的一段，而且**更改切片中的元素会修改其底层数组**中对应的元素；除此之外，切片的下界默认为0，上界是该切片的长度。因此好好理解一下下列切片代表的含义：\n\n```go\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\n\ts = s[0:6] // 下界为0，上界为6\n\tfmt.Println(s)\n\n\ts = s[:6] // 下界默认为0，可以不写\n\tfmt.Println(s)\n\n\ts = s[0:] // 上界默认为6，可以不写\n\tfmt.Println(s)\n\n\ts = s[:] // 下界为0，上界为6\n\tfmt.Println(s)\n    \n    // 输出结果均为[ 2, 3, 5, 7, 11, 13 ]\n}\n```\n\n切片有长度和容量，长度就是其所包含的元素个数，容量是从第一个元素开始数，到其底层数组元素的末尾个数。获取长度可以用`len(s)`，获取容量使用`cap(s)`。可以通过重新切片来扩展一个切片。给它提供足够的容量。\n\n一个没有初始化的切片为nil切片，长度和容量均为0且没有底层数组（这就意味着有数据的切片存在一个底层数组，我们后面专门从底层讲讲切片）\n\n创建切片可以使用内建的`make`函数来完成，也是用于创建动态数组的方式。\n\n```go\na := make([]int, 5)\nprintSlice(\"a\", a) // [0 0 0 0 0]\n\nb := make([]int, 0, 5)\nprintSlice(\"b\", b) // []\n\nc := b[:2]\nprintSlice(\"c\", c) // [0 0]\n\nd := c[2:5]\nprintSlice(\"d\", d) // [0 0 0]\n\nfunc printSlice(s string, x []int) {\n    fmt.Printf(\"%s len=%d, cap=%d %v\\n\", s, len(s), cap(s), x)\n}\n```\n\n### 3.2.1 切片的切片\n\n切片可以包含任何类型，甚至是包括其它切片，记录一下基本的使用：\n\n```go\nfunc main() {\n    // board本身为一个切片，切片中每个元素又为一个切片\n    board := [][]string{\n        []string{\"_\", \"_\", \"_\"},\n        []string{\"_\", \"_\", \"_\"},\n        []string{\"_\", \"_\", \"_\"},\n    }\n}\n```\n\n### 3.2.2 向切片中追加元素\n\n`Go`提供了内建的`append`函数，可以对已有切片进行元素的追加操作，具体使用事例如下所示：\n\n```go\nfunc main() {\n    var s []int\n    printSlice(s)\n    \n    s = append(s, 0)\n    printSlice(s)\n    \n    s = append(s, 1)\n    printSlice(s)\n    \n    s = append(s, 2, 3, 4)\n    printSlice(s)\n}\n\nfunc printSlice(s []int) {\n    fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s);\n}\n```\n\n### 3.2.3 使用range循环切片\n\n`for`循环的`range`形式可以遍历切片或映射，需要注意的是每次循环都会出现两个值，第一个值为当前元素的下标，第二个值为下标对应元素的副本，如果想要忽略下标，可以使用`_`符号；\n\n```go\nvar pow = []int{1, 2, 4, 8, 16, 32, 64}\n\nfunc main() {\n    for i, v := range pow {\n        fmt.Printf(\"2**%d = %d\\n\", i, v)\n    }\n}\n```\n\n## 3.3 Map\n\n这种数据结构在熟悉不过了，如果你用过Java，那你应该对它很熟悉，介绍一下它的基本用法：\n\n```go\ntype Vertex struct {\n    Lat, Long float64\n}\n\nvar m map[string]Vertex // 括号内为key的类型，括号外为value的类型，前面使用map关键字修饰\n\nm = make(map[string]Vertex)\nm[\"Bell Labs\"] = Vertex{\n    40.68433, -74.39967\n}\n\n//还可以忽略顶级类型名\nvar m = map[string]Vertex{\n    \"Bell Labs\": {40.68443, -74.36883},\n    \"Google\":    {37.43323, -122.08448},\n}\n\n// 修改也很简单\nm := make(map[string]int)\nm[\"Answer\"] = 42 // 修改Key为Answer的值\ndelete(m, \"Answer\") // 删除Key为Answer的值\nv, ok := m[\"Answer\"] // 判断Answer的key是否存在\n```\n\n# 四、函数\n\n## 4.1 函数也可以成为参数或者返回值\n\n这也是Go语言面向函数式编程的核心思想，还有一个重要的概念叫闭包。例如：\n\n```go\n// compute为函数类型\n// compute的函数参数为一个名为fn的函数，其接收两个函数参数， fn函数的返回值也为float64类型\n// 返回值直接返回的也是函数类型\nfunc compute(fn func(float64, float64) float64) float64 {\n    return fn(3, 4)\n}\n\nfunc main() {\n    hypot := func(x, y float64) float64 {\n        return math.Sqrt(x*x + y*y)\n    }\n    fmt.Println(hypot(5, 12))\n    fmt.Println(compute(hypot))\n    fmt.Println(compute(math.Pow))\n}\n```\n\n## 4.2 函数的闭包\n\nGo函数可以是一个闭包，闭包是一个函数值，其引用了其函数体之外的变量，该函数也可以访问并赋予其引用的变量值。\n\n```go\nfunc adder() func(int) int {\n    sum := 0\n    return func(x int) int {\n        sum += x\n        return sum\n    }\n}\n\nfunc main() {\n    // 两个闭包都绑定在各自的sum变量上\n    pos, neg := adder(), adder()\n    for i := 0; i < 10; i++ {\n        fmt.Println(pos(i), neg(-2*i))\n    }\n}\n```\n\n使用闭包实现斐波那契数列的算法可以这样写：\n\n```go\nfunc fibonacci() func() int {\n    back1, back2 := 0, 1\n    // 闭包返回的是具体的函数，所以这里也要返回函数\n    return func() int {\n        temp := back1\n        back1, back2 = back2, (back1 + back2)\n        return temp\n    }\n}\n\nfunc main() {\n    f := fibonacci()\n    for i := 0; i < 10; i++ {\n        fmt.Println(f())\n    }\n}\n```\n\n# 五、方法\n\n## 5.1 基本概念\n\n这里我们对照面向对象的思想，Go语言中没有“类”这个概念，所以我们一般可以借助结构体来定义方法。这个概念很重要，因为后面我们的很多面向对象的特性都是基于方法这个概念进行开展的。\n\n```go\ntype Vertex struct {\n    X, Y float64\n}\n\n// Vertex有一个方法，接收者为Vertex，可以理解为这个方法是Vertex的成员方法\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n```\n\n和一般的函数区别在于，方法在`func`关键字和方法名之间有一个参数列表，我们称之为`方法接收者`\n\n## 5.2 指针接收者\n\n可以为指针接收者声明方法，意味着对于某类型`T`，接收者可以是`*T`的文法。指针接收者的方法可以修改接收者指向的值。由于方法经常需要修改接收者，指针接收者比值接收者更加常用。\n\n```go\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n```\n\n当然，你也可以使用函数来实现`Scale`方法，效果和使用指针接收器是一样的。\n\n```go\ntype Vertex struct {\n    X, Y float64\n}\n\n// 需要注意的是：如果涉及值修改，必须使用指针接收对象，否则值不会发生变化\nfunc Scale(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n```\n\n这里可以得出一个结论：（在接收者参数类型上，值和指针满足交换律）\n\n+ 以指针为接收者的方法被调用时，接收者既可以为值，又可以为指针；\n+ 以值为接收者的方法被调用时，接收者既可以为值又可以为指针；\n\n## 5.3 什么时候使用指针接收者\n\n+ 方法能够修改其接收者指向的值\n+ 避免每次调用方法调用进行大对象复制，特别是大型结构体，这样做更显得更加高效\n\n# 六、接口(interface)\n\n## 6.1 基本概念\n\n接口类型是一组方法签名定义的集合，接口类型的变量可以保存任何实现了这些方法的值。例如：\n\n```go\ntype I interface {\n    M()\n}\n\ntype T struct {\n    S string\n}\n\n// 此方法表示类型T实现了接口I，但是不需要显式声明\nfunc (t T) M() {\n    fmt.Println(t.S)\n}\n\nfunc main() {\n    var i T = T{\"Hello\"}\n    i.M()\n}\n```\n\n类型通过实现一个接口的所有方法来实现该接口，既然无需专门显式声明，也就没有`implements`关键字。\n\n隐式接口从接口的实现解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。\n\n## 6.2 接口值\n\n接口也可以像其他值一样传递，可以用作函数的参数或者返回值，接口值保存了一个具体底层类型的具体值，接口值调用方法时会执行其底层类型的同名方法。\n\n```go\ntype I interface {\n    M()\n}\n\ntype T struct {\n    S string\n}\n\nfunc (t *T) M() {\n    fmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n    fmt.Println(f)\n}\n\nfunc main() {\n    var i I\n    \n    // 类似于面向接口编程\n    i = &T{\"Hello\"}\n    i.M()\n    \n    i = F(math.Pi)\n    i.M()\n}\n```\n\nnil接口值既不保存值也不保存具体类型，空接口`interface{}`可以保存任何类型的值，因此可以用于处理未知类型的值。例如：\n\n```go\nfunc main() {\n    var i interface{}\n    describe(i)\n    \n    i = 42\n    describe(i)\n    \n    i = \"Hello\"\n    describe(i)\n}\n\nfunc describe(i interface{}) {\n    fmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n## 6.3 类型断言\n\n类型断言提供了访问接口值底层具体值的方式：\n\n```go\nt, ok := i.(T)\n```\n\n该语句断言的接口值`i`保存了具体类型`T`，并将其底层类型为`T`的值赋予变量`t`。为了判断一个接口值是否保存了一个特定类型，类型断言可以返回两个值：其底层值以及一个报告断言是否成功的布尔值。这里的语句和Map中的用法是一样的。例如：\n\n```go\nfunc main() {\n    var i interface{} = \"hello\"\n    \n    s := i.(string)\n    fmt.Println(s)\n    \n    s, ok := i.(string)\n    fmt.Println(s, ok)\n    \n    f, ok := i.(float64)\n    fmt.Println(f, ok)\n    \n    f = i.(float64)\n    fmt.Println(f)\n}\n```\n\n## 6.4 类型选择\n\n类型选择是一种按照顺序从几个类型断言中选择分支的结构，类型选择一般与switch语句相似，不过类型选择中的case为类型（而非值），它们针对给定接口值所存储的值类型进行比较。其中`type`是固定写法。\n\n```go\nswitch v := i.(type) {\n    case T:\n    \t// v的类型为T\n\tcase S:\n    \t// v的类型为S\n\tdefault:\n    \t// 没有匹配，v与i的类型相同\n}\n```\n\n# 七、异常处理\n\nGo语言使用`error`来表示错误状态（想想和Java中的有什么不同呢？），通常函数会返回一个`error`值，调用它的代码应当判断这个错误是否等于`nil`来处理错误，如果`error`为nil表示成功，否则表示失败；\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\n\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf(\"at %v, %s\", e.When, e.What)\n}\n\nfunc run() error {\n\treturn &MyError{time.Now(), \"it didn't work\"}\n}\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n```\n\n# 八、Reader\n\nio包指定了`io.Reader`接口，它表示从数据流的末尾进行读取，并且Go的标准库也包含了该接口的许多实现，包括文件、网络连接、压缩和加密。\n\n## 8.1 字符读取\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"Hello, Reader!\")\n\n\tb := make([]byte, 8)\n\tfor {\n\t\tn, err := r.Read(b)\n\t\tfmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b)\n\t\tfmt.Printf(\"b[:n] = %q\\n\", b[:n])\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n# 九、并发\n\n## 9.1 协程\n\n协程（Goroutine）是由Go运行时管理的轻量级线程，Goroutine在相同的地址空间中运行，因此在访问共享内存时必须进行同步。`sync`包提供了这种能力，不过在Goroutine中并不常见。\n\n```go\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say(\"word\")\n    say(\"hello\")\n}\n```\n\n## 9.2 channel通道\n\n通道是带有类型的管道，可以使用信道操作符`<-`来发送或者接收值（PS：“箭头”就是数据流的方向）\n\n```go\nch <- v // 将v发送至信道ch\nv := <- ch // 从ch接收值并赋予v\n```\n\n信道和切片一样，使用前必须创建，使用make函数来创建：\n\n```go\nch := make(chan int)\n```\n\n默认情况下，发送和接收操作在另一端准备好之前都会阻塞，这就意味着Goroutine可以在没有显式锁或者竞态变量的情况下进行同步；\n\n```go\nfunc sum(s []int, c chan int) {\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c <- sum\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n    c := make(chan int)\n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n    x, y := <-c, <-c\n    \n    fmt.Println(x, y, x+y)\n}\n```\n\nchannel可以带缓冲区，有了缓冲区后，仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接收方会阻塞。\n\n```go\nfunc main() {\n    ch := make(chan int, 2)\n    ch <- 1\n    ch <- 2\n    fmt.Println(<-ch)\n    fmt.Println(<-ch)\n}\n```\n\n需要注意的是：仅当信道的缓冲区填满了以后，向其发送数据时才会阻塞，当缓冲区为空的时候，接受方会阻塞\n\n发送者可以通过`close`关闭一个信道表示没有需要发送的值了，接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭；若没有值可以接收且信道已被关闭，那么执行结束后状态就会改成false。\n\n> 1. 只有发送者才能关闭信道，接收者不能\n> 2. 向一个已经关闭的信道发送数据会触发panic；\n> 3. 信道与文件不同，通常情况下不需要关闭，只有在必须告诉接收者不再有需要发送的值才有必要关闭，例如**终止range循环**\n\n例如：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n    // 当所有的值传输完后关闭通道\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n```\n\n## 9.3 select语句\n\nselect语句可以使得一个goroutine等待多个信道操作，select语句会阻塞某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci2(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci2(c, quit)\n}\n\n```\n\n当`select`中的其他分支都没准备好时，`default`分支就会执行，为了尝试发送或者接收时不发生阻塞，可使用`default`分支：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.After(500 * time.Millisecond)\n\tfor {\n\t\tselect {\n\t\tcase <-tick:\n\t\t\tfmt.Println(\"tick.\")\n\t\tcase <-boom:\n\t\t\tfmt.Println(\"BOOM!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"    .\")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}\n```\n\n","source":"_posts/golang/go-lang-basic.md","raw":"---\ntitle: Golang入门教程\ndate: 2022-03-23 22:29:25\nupdated: 2022-03-23 22:29:25\ntags: Go语言\ncategories: 服务后端开发\n---\n\n# 一、这篇文章的目的\n\n按照以前的惯例，我们会把Golang的语法贴在这里，其实网上（包括官网）都有非常详细的Go语言教程，学习过程中可以多实践使用。这里我写一些使用中在语法上比较少涉及到的点。方便在使用过程快速回忆。当然golang本身也不复杂，上手也比较简单，如果有需要可以对照网上的教程重新温习。\n\n# 二、golang基础\n\n## 2.1 类型\n\n+ 布尔值\n  + **bool**\n+ 字符串\n  + **string**\n+ 整型\n  + **int** / **int8** / **int16** / **int32** / **int64**\n  + **uint** / **uint8** / **uint16** / **uint32** / **uint64** / **uintptr**\n+ 字节类型（uint8别名）\n  + **byte**\n+ Unicode类型（int32别名）\n  + **rune**\n+ 浮点类型\n  + **float32** / **float64**\n+ 复数类型\n  + **complex64** / **complex128**\n\n## 2.2 关键字汇总\n\ngolang关键字只有25个，非常容易掌握\n\n+ 第一组\n  + **break**（退出循环） / **case**（Switch语句） / **chan**（通道） / **const**（常量） / **continue**（跳过当前循环）\n+ 第二组\n  + **default**（Switch语句） / **defer**（先定义后执行） / **else**（分支） / **fallthrough**（Switch语句） / **for**（循环）\n+ 第三组\n  + **func**（函数定义） / **go**（开启Goroutine） / **goto**（流程） / **if**（条件） / **import**（导包）\n+ 第四组\n  + **interface**（接口或者泛型定义） / **map** / **package** / **range**（基于范围的遍历） / **return**（返回）\n+ 第五组\n  + **select**（在通道使用） / **struct**（结构体） / **switch**（分支语句） / **type**（定义类型） / **var**（声明变量）\n\n## 2.3 包的导入导出\n\n与Java不同的是，Go语言是通过名字大小写来判定当前函数/变量是否导出。如果是小写开头就意味着不导出；如果是大写开头就意味着是导出包。例如：\n\n```go\n// 未导出\nmath.pi\n\n// 已导出\nmath.Pi\n```\n\n## 2.4 变量声明方式\n\n与我们常用的C，C++，Java，JavaScript不同的是，Golang的变量类型是放在变量名的后面的。这点在写习惯了Java等编程语言的人来说，早期会感到不适应。但是随着你使用上习惯了，自然而然就能接受。具体如下：\n\n```go\n// 借助var关键字声明变量\nvar i int\n\n// 自动推断类型，这里一定要注意，如果前面没有创建过变量i，必须使用\":=\"符号\ni := 34\n\n// 多个变量初始化\nconst (\n\ti int\n    j bool\n    k string\n)\n```\n\n## 2.5 类型转换\n\n表达式`T(V)`将值`v`转换为类型`T`，这里提供一些关于数值转换的例子供你参考：\n\n```go\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n\n或者使用更加简单的形式：\n\n```go\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n## 2.6 函数\n\n跟Java不同的是，Go语言中的函数可以返回多个值，例如让你写一个交换两值的函数，在Java下你会这么写：\n\n```java\npublic void swap(int x, int y) {\n    System.out.printf(\"Before Swap is: %d, %d\", x, y);\n    int tmp = x;\n    x = y;\n    y = tmp;\n    System.out.println(\"After Swap is: %d, %d\", x, y);\n}\n```\n\n但是在Go语言下，你只需要这样写就可以实现一样的效果了：\n\n> 可以发现：在golang中函数的返回值也是放在函数尾部的，这和我们Java的语法存在不同，需要注意\n\n```go\nfunc swap(x, y int) (int, int) {\n    return y, x\n}\n```\n\nGo语言的返回值可以被命名，它们会被视作定义在函数顶部的变量，简而言之就是：没有参数的`return`语句返回已命名的返回值。也就是直接返回。例如：\n\n> 直接返回语句应当仅用在短函数中，过长的函数代码反而会影响代码可读性\n\n```go\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return\n}\n```\n\n## 2.7 for循环\n\nGo语言中只有一种循环结构，就是for，它的语法跟Java、C++很像。唯一的区别就是循环两侧不需要括号。例如：\n\n```go\n// 标准的for循环\nfor i := 0; i < 10; i++ {}\n\n// Go语言中的While循环\nfor sum < 100 {}\n```\n\n除此之外，还可以使用for循环迭代切片和map\n\n```go\nvar slice []int = []int{ 10, 20, 30, 40, 50 }\n// 迭代切片\nfor index, value := range slice {\n    fmt.Printf(\"索引为：%d，数值为：%d\\n\", index, value);\n}\n\n// 如果不想获取索引，可以使用\"_\"将其屏蔽\nfor _, value := range slice {\n    fmt.Printf(\"索引为：%d，数值为：%d\\n\", index, value);\n}\n\n// 迭代map\nvar stock_map map[string]int = map[string]int{\n\t\"iPhone 13 Pro\": 345,\n\t\"One Plus\":      21,\n\t\"Realme\":        34,\n}\n\nfor k, v := range stock_map {\n\tfmt.Printf(\"Key: %v, value: %d\\n\", k, v)\n}\n```\n\n# 三、数组、切片和Map\n\n## 3.1 数组\n\n类型`[n]T`表示拥有n个T类型的值数组，语法如下：\n\n```go\nvar a [10]int\n```\n\n具体实例如下所示：\n\n```go\nvar a [2]string\na[0] = \"hello\"\na[1] = \"world\"\n\nprimes := [6]int{2, 3, 5, 7, 11}\n```\n\n## 3.2 切片\n\n由于数组的大小是固定的，所以使用切片为数组元素提供动态大小、灵活的视角。在具体的开发实践中，切片比数组更加常用。具体语法如下：\n\n```go\na[low:high]\n```\n\n它会选择一个半开区间，包括第一个元素但排除最后一个元素：\n\n```go\n// 代表a数组从下标1到3的元素（不包括4）\na[1:4]\n```\n\n切片并不存储任何数据，它仅仅是描述了底层数组中的一段，而且**更改切片中的元素会修改其底层数组**中对应的元素；除此之外，切片的下界默认为0，上界是该切片的长度。因此好好理解一下下列切片代表的含义：\n\n```go\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\n\ts = s[0:6] // 下界为0，上界为6\n\tfmt.Println(s)\n\n\ts = s[:6] // 下界默认为0，可以不写\n\tfmt.Println(s)\n\n\ts = s[0:] // 上界默认为6，可以不写\n\tfmt.Println(s)\n\n\ts = s[:] // 下界为0，上界为6\n\tfmt.Println(s)\n    \n    // 输出结果均为[ 2, 3, 5, 7, 11, 13 ]\n}\n```\n\n切片有长度和容量，长度就是其所包含的元素个数，容量是从第一个元素开始数，到其底层数组元素的末尾个数。获取长度可以用`len(s)`，获取容量使用`cap(s)`。可以通过重新切片来扩展一个切片。给它提供足够的容量。\n\n一个没有初始化的切片为nil切片，长度和容量均为0且没有底层数组（这就意味着有数据的切片存在一个底层数组，我们后面专门从底层讲讲切片）\n\n创建切片可以使用内建的`make`函数来完成，也是用于创建动态数组的方式。\n\n```go\na := make([]int, 5)\nprintSlice(\"a\", a) // [0 0 0 0 0]\n\nb := make([]int, 0, 5)\nprintSlice(\"b\", b) // []\n\nc := b[:2]\nprintSlice(\"c\", c) // [0 0]\n\nd := c[2:5]\nprintSlice(\"d\", d) // [0 0 0]\n\nfunc printSlice(s string, x []int) {\n    fmt.Printf(\"%s len=%d, cap=%d %v\\n\", s, len(s), cap(s), x)\n}\n```\n\n### 3.2.1 切片的切片\n\n切片可以包含任何类型，甚至是包括其它切片，记录一下基本的使用：\n\n```go\nfunc main() {\n    // board本身为一个切片，切片中每个元素又为一个切片\n    board := [][]string{\n        []string{\"_\", \"_\", \"_\"},\n        []string{\"_\", \"_\", \"_\"},\n        []string{\"_\", \"_\", \"_\"},\n    }\n}\n```\n\n### 3.2.2 向切片中追加元素\n\n`Go`提供了内建的`append`函数，可以对已有切片进行元素的追加操作，具体使用事例如下所示：\n\n```go\nfunc main() {\n    var s []int\n    printSlice(s)\n    \n    s = append(s, 0)\n    printSlice(s)\n    \n    s = append(s, 1)\n    printSlice(s)\n    \n    s = append(s, 2, 3, 4)\n    printSlice(s)\n}\n\nfunc printSlice(s []int) {\n    fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s);\n}\n```\n\n### 3.2.3 使用range循环切片\n\n`for`循环的`range`形式可以遍历切片或映射，需要注意的是每次循环都会出现两个值，第一个值为当前元素的下标，第二个值为下标对应元素的副本，如果想要忽略下标，可以使用`_`符号；\n\n```go\nvar pow = []int{1, 2, 4, 8, 16, 32, 64}\n\nfunc main() {\n    for i, v := range pow {\n        fmt.Printf(\"2**%d = %d\\n\", i, v)\n    }\n}\n```\n\n## 3.3 Map\n\n这种数据结构在熟悉不过了，如果你用过Java，那你应该对它很熟悉，介绍一下它的基本用法：\n\n```go\ntype Vertex struct {\n    Lat, Long float64\n}\n\nvar m map[string]Vertex // 括号内为key的类型，括号外为value的类型，前面使用map关键字修饰\n\nm = make(map[string]Vertex)\nm[\"Bell Labs\"] = Vertex{\n    40.68433, -74.39967\n}\n\n//还可以忽略顶级类型名\nvar m = map[string]Vertex{\n    \"Bell Labs\": {40.68443, -74.36883},\n    \"Google\":    {37.43323, -122.08448},\n}\n\n// 修改也很简单\nm := make(map[string]int)\nm[\"Answer\"] = 42 // 修改Key为Answer的值\ndelete(m, \"Answer\") // 删除Key为Answer的值\nv, ok := m[\"Answer\"] // 判断Answer的key是否存在\n```\n\n# 四、函数\n\n## 4.1 函数也可以成为参数或者返回值\n\n这也是Go语言面向函数式编程的核心思想，还有一个重要的概念叫闭包。例如：\n\n```go\n// compute为函数类型\n// compute的函数参数为一个名为fn的函数，其接收两个函数参数， fn函数的返回值也为float64类型\n// 返回值直接返回的也是函数类型\nfunc compute(fn func(float64, float64) float64) float64 {\n    return fn(3, 4)\n}\n\nfunc main() {\n    hypot := func(x, y float64) float64 {\n        return math.Sqrt(x*x + y*y)\n    }\n    fmt.Println(hypot(5, 12))\n    fmt.Println(compute(hypot))\n    fmt.Println(compute(math.Pow))\n}\n```\n\n## 4.2 函数的闭包\n\nGo函数可以是一个闭包，闭包是一个函数值，其引用了其函数体之外的变量，该函数也可以访问并赋予其引用的变量值。\n\n```go\nfunc adder() func(int) int {\n    sum := 0\n    return func(x int) int {\n        sum += x\n        return sum\n    }\n}\n\nfunc main() {\n    // 两个闭包都绑定在各自的sum变量上\n    pos, neg := adder(), adder()\n    for i := 0; i < 10; i++ {\n        fmt.Println(pos(i), neg(-2*i))\n    }\n}\n```\n\n使用闭包实现斐波那契数列的算法可以这样写：\n\n```go\nfunc fibonacci() func() int {\n    back1, back2 := 0, 1\n    // 闭包返回的是具体的函数，所以这里也要返回函数\n    return func() int {\n        temp := back1\n        back1, back2 = back2, (back1 + back2)\n        return temp\n    }\n}\n\nfunc main() {\n    f := fibonacci()\n    for i := 0; i < 10; i++ {\n        fmt.Println(f())\n    }\n}\n```\n\n# 五、方法\n\n## 5.1 基本概念\n\n这里我们对照面向对象的思想，Go语言中没有“类”这个概念，所以我们一般可以借助结构体来定义方法。这个概念很重要，因为后面我们的很多面向对象的特性都是基于方法这个概念进行开展的。\n\n```go\ntype Vertex struct {\n    X, Y float64\n}\n\n// Vertex有一个方法，接收者为Vertex，可以理解为这个方法是Vertex的成员方法\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n```\n\n和一般的函数区别在于，方法在`func`关键字和方法名之间有一个参数列表，我们称之为`方法接收者`\n\n## 5.2 指针接收者\n\n可以为指针接收者声明方法，意味着对于某类型`T`，接收者可以是`*T`的文法。指针接收者的方法可以修改接收者指向的值。由于方法经常需要修改接收者，指针接收者比值接收者更加常用。\n\n```go\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n```\n\n当然，你也可以使用函数来实现`Scale`方法，效果和使用指针接收器是一样的。\n\n```go\ntype Vertex struct {\n    X, Y float64\n}\n\n// 需要注意的是：如果涉及值修改，必须使用指针接收对象，否则值不会发生变化\nfunc Scale(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n```\n\n这里可以得出一个结论：（在接收者参数类型上，值和指针满足交换律）\n\n+ 以指针为接收者的方法被调用时，接收者既可以为值，又可以为指针；\n+ 以值为接收者的方法被调用时，接收者既可以为值又可以为指针；\n\n## 5.3 什么时候使用指针接收者\n\n+ 方法能够修改其接收者指向的值\n+ 避免每次调用方法调用进行大对象复制，特别是大型结构体，这样做更显得更加高效\n\n# 六、接口(interface)\n\n## 6.1 基本概念\n\n接口类型是一组方法签名定义的集合，接口类型的变量可以保存任何实现了这些方法的值。例如：\n\n```go\ntype I interface {\n    M()\n}\n\ntype T struct {\n    S string\n}\n\n// 此方法表示类型T实现了接口I，但是不需要显式声明\nfunc (t T) M() {\n    fmt.Println(t.S)\n}\n\nfunc main() {\n    var i T = T{\"Hello\"}\n    i.M()\n}\n```\n\n类型通过实现一个接口的所有方法来实现该接口，既然无需专门显式声明，也就没有`implements`关键字。\n\n隐式接口从接口的实现解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。\n\n## 6.2 接口值\n\n接口也可以像其他值一样传递，可以用作函数的参数或者返回值，接口值保存了一个具体底层类型的具体值，接口值调用方法时会执行其底层类型的同名方法。\n\n```go\ntype I interface {\n    M()\n}\n\ntype T struct {\n    S string\n}\n\nfunc (t *T) M() {\n    fmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n    fmt.Println(f)\n}\n\nfunc main() {\n    var i I\n    \n    // 类似于面向接口编程\n    i = &T{\"Hello\"}\n    i.M()\n    \n    i = F(math.Pi)\n    i.M()\n}\n```\n\nnil接口值既不保存值也不保存具体类型，空接口`interface{}`可以保存任何类型的值，因此可以用于处理未知类型的值。例如：\n\n```go\nfunc main() {\n    var i interface{}\n    describe(i)\n    \n    i = 42\n    describe(i)\n    \n    i = \"Hello\"\n    describe(i)\n}\n\nfunc describe(i interface{}) {\n    fmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n## 6.3 类型断言\n\n类型断言提供了访问接口值底层具体值的方式：\n\n```go\nt, ok := i.(T)\n```\n\n该语句断言的接口值`i`保存了具体类型`T`，并将其底层类型为`T`的值赋予变量`t`。为了判断一个接口值是否保存了一个特定类型，类型断言可以返回两个值：其底层值以及一个报告断言是否成功的布尔值。这里的语句和Map中的用法是一样的。例如：\n\n```go\nfunc main() {\n    var i interface{} = \"hello\"\n    \n    s := i.(string)\n    fmt.Println(s)\n    \n    s, ok := i.(string)\n    fmt.Println(s, ok)\n    \n    f, ok := i.(float64)\n    fmt.Println(f, ok)\n    \n    f = i.(float64)\n    fmt.Println(f)\n}\n```\n\n## 6.4 类型选择\n\n类型选择是一种按照顺序从几个类型断言中选择分支的结构，类型选择一般与switch语句相似，不过类型选择中的case为类型（而非值），它们针对给定接口值所存储的值类型进行比较。其中`type`是固定写法。\n\n```go\nswitch v := i.(type) {\n    case T:\n    \t// v的类型为T\n\tcase S:\n    \t// v的类型为S\n\tdefault:\n    \t// 没有匹配，v与i的类型相同\n}\n```\n\n# 七、异常处理\n\nGo语言使用`error`来表示错误状态（想想和Java中的有什么不同呢？），通常函数会返回一个`error`值，调用它的代码应当判断这个错误是否等于`nil`来处理错误，如果`error`为nil表示成功，否则表示失败；\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\n\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf(\"at %v, %s\", e.When, e.What)\n}\n\nfunc run() error {\n\treturn &MyError{time.Now(), \"it didn't work\"}\n}\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n```\n\n# 八、Reader\n\nio包指定了`io.Reader`接口，它表示从数据流的末尾进行读取，并且Go的标准库也包含了该接口的许多实现，包括文件、网络连接、压缩和加密。\n\n## 8.1 字符读取\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"Hello, Reader!\")\n\n\tb := make([]byte, 8)\n\tfor {\n\t\tn, err := r.Read(b)\n\t\tfmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b)\n\t\tfmt.Printf(\"b[:n] = %q\\n\", b[:n])\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n# 九、并发\n\n## 9.1 协程\n\n协程（Goroutine）是由Go运行时管理的轻量级线程，Goroutine在相同的地址空间中运行，因此在访问共享内存时必须进行同步。`sync`包提供了这种能力，不过在Goroutine中并不常见。\n\n```go\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say(\"word\")\n    say(\"hello\")\n}\n```\n\n## 9.2 channel通道\n\n通道是带有类型的管道，可以使用信道操作符`<-`来发送或者接收值（PS：“箭头”就是数据流的方向）\n\n```go\nch <- v // 将v发送至信道ch\nv := <- ch // 从ch接收值并赋予v\n```\n\n信道和切片一样，使用前必须创建，使用make函数来创建：\n\n```go\nch := make(chan int)\n```\n\n默认情况下，发送和接收操作在另一端准备好之前都会阻塞，这就意味着Goroutine可以在没有显式锁或者竞态变量的情况下进行同步；\n\n```go\nfunc sum(s []int, c chan int) {\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c <- sum\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n    c := make(chan int)\n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n    x, y := <-c, <-c\n    \n    fmt.Println(x, y, x+y)\n}\n```\n\nchannel可以带缓冲区，有了缓冲区后，仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接收方会阻塞。\n\n```go\nfunc main() {\n    ch := make(chan int, 2)\n    ch <- 1\n    ch <- 2\n    fmt.Println(<-ch)\n    fmt.Println(<-ch)\n}\n```\n\n需要注意的是：仅当信道的缓冲区填满了以后，向其发送数据时才会阻塞，当缓冲区为空的时候，接受方会阻塞\n\n发送者可以通过`close`关闭一个信道表示没有需要发送的值了，接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭；若没有值可以接收且信道已被关闭，那么执行结束后状态就会改成false。\n\n> 1. 只有发送者才能关闭信道，接收者不能\n> 2. 向一个已经关闭的信道发送数据会触发panic；\n> 3. 信道与文件不同，通常情况下不需要关闭，只有在必须告诉接收者不再有需要发送的值才有必要关闭，例如**终止range循环**\n\n例如：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n    // 当所有的值传输完后关闭通道\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n```\n\n## 9.3 select语句\n\nselect语句可以使得一个goroutine等待多个信道操作，select语句会阻塞某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci2(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci2(c, quit)\n}\n\n```\n\n当`select`中的其他分支都没准备好时，`default`分支就会执行，为了尝试发送或者接收时不发生阻塞，可使用`default`分支：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.After(500 * time.Millisecond)\n\tfor {\n\t\tselect {\n\t\tcase <-tick:\n\t\t\tfmt.Println(\"tick.\")\n\t\tcase <-boom:\n\t\t\tfmt.Println(\"BOOM!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"    .\")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}\n```\n\n","slug":"golang/go-lang-basic","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6uw00024f610jrp5w9z","content":"<h1 id=\"一、这篇文章的目的\"><a href=\"#一、这篇文章的目的\" class=\"headerlink\" title=\"一、这篇文章的目的\"></a>一、这篇文章的目的</h1><p>按照以前的惯例，我们会把Golang的语法贴在这里，其实网上（包括官网）都有非常详细的Go语言教程，学习过程中可以多实践使用。这里我写一些使用中在语法上比较少涉及到的点。方便在使用过程快速回忆。当然golang本身也不复杂，上手也比较简单，如果有需要可以对照网上的教程重新温习。</p>\n<h1 id=\"二、golang基础\"><a href=\"#二、golang基础\" class=\"headerlink\" title=\"二、golang基础\"></a>二、golang基础</h1><h2 id=\"2-1-类型\"><a href=\"#2-1-类型\" class=\"headerlink\" title=\"2.1 类型\"></a>2.1 类型</h2><ul>\n<li>布尔值<ul>\n<li><strong>bool</strong></li>\n</ul>\n</li>\n<li>字符串<ul>\n<li><strong>string</strong></li>\n</ul>\n</li>\n<li>整型<ul>\n<li><strong>int</strong> / <strong>int8</strong> / <strong>int16</strong> / <strong>int32</strong> / <strong>int64</strong></li>\n<li><strong>uint</strong> / <strong>uint8</strong> / <strong>uint16</strong> / <strong>uint32</strong> / <strong>uint64</strong> / <strong>uintptr</strong></li>\n</ul>\n</li>\n<li>字节类型（uint8别名）<ul>\n<li><strong>byte</strong></li>\n</ul>\n</li>\n<li>Unicode类型（int32别名）<ul>\n<li><strong>rune</strong></li>\n</ul>\n</li>\n<li>浮点类型<ul>\n<li><strong>float32</strong> / <strong>float64</strong></li>\n</ul>\n</li>\n<li>复数类型<ul>\n<li><strong>complex64</strong> / <strong>complex128</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-2-关键字汇总\"><a href=\"#2-2-关键字汇总\" class=\"headerlink\" title=\"2.2 关键字汇总\"></a>2.2 关键字汇总</h2><p>golang关键字只有25个，非常容易掌握</p>\n<ul>\n<li>第一组<ul>\n<li><strong>break</strong>（退出循环） / <strong>case</strong>（Switch语句） / <strong>chan</strong>（通道） / <strong>const</strong>（常量） / <strong>continue</strong>（跳过当前循环）</li>\n</ul>\n</li>\n<li>第二组<ul>\n<li><strong>default</strong>（Switch语句） / <strong>defer</strong>（先定义后执行） / <strong>else</strong>（分支） / <strong>fallthrough</strong>（Switch语句） / <strong>for</strong>（循环）</li>\n</ul>\n</li>\n<li>第三组<ul>\n<li><strong>func</strong>（函数定义） / <strong>go</strong>（开启Goroutine） / <strong>goto</strong>（流程） / <strong>if</strong>（条件） / <strong>import</strong>（导包）</li>\n</ul>\n</li>\n<li>第四组<ul>\n<li><strong>interface</strong>（接口或者泛型定义） / <strong>map</strong> / <strong>package</strong> / <strong>range</strong>（基于范围的遍历） / <strong>return</strong>（返回）</li>\n</ul>\n</li>\n<li>第五组<ul>\n<li><strong>select</strong>（在通道使用） / <strong>struct</strong>（结构体） / <strong>switch</strong>（分支语句） / <strong>type</strong>（定义类型） / <strong>var</strong>（声明变量）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-3-包的导入导出\"><a href=\"#2-3-包的导入导出\" class=\"headerlink\" title=\"2.3 包的导入导出\"></a>2.3 包的导入导出</h2><p>与Java不同的是，Go语言是通过名字大小写来判定当前函数/变量是否导出。如果是小写开头就意味着不导出；如果是大写开头就意味着是导出包。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 未导出</span><br>math.pi<br><br><span class=\"hljs-comment\">// 已导出</span><br>math.Pi<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-4-变量声明方式\"><a href=\"#2-4-变量声明方式\" class=\"headerlink\" title=\"2.4 变量声明方式\"></a>2.4 变量声明方式</h2><p>与我们常用的C，C++，Java，JavaScript不同的是，Golang的变量类型是放在变量名的后面的。这点在写习惯了Java等编程语言的人来说，早期会感到不适应。但是随着你使用上习惯了，自然而然就能接受。具体如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 借助var关键字声明变量</span><br><span class=\"hljs-keyword\">var</span> i <span class=\"hljs-type\">int</span><br><br><span class=\"hljs-comment\">// 自动推断类型，这里一定要注意，如果前面没有创建过变量i，必须使用&quot;:=&quot;符号</span><br>i := <span class=\"hljs-number\">34</span><br><br><span class=\"hljs-comment\">// 多个变量初始化</span><br><span class=\"hljs-keyword\">const</span> (<br>\ti <span class=\"hljs-type\">int</span><br>    j <span class=\"hljs-type\">bool</span><br>    k <span class=\"hljs-type\">string</span><br>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-5-类型转换\"><a href=\"#2-5-类型转换\" class=\"headerlink\" title=\"2.5 类型转换\"></a>2.5 类型转换</h2><p>表达式<code>T(V)</code>将值<code>v</code>转换为类型<code>T</code>，这里提供一些关于数值转换的例子供你参考：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> i <span class=\"hljs-type\">int</span> = <span class=\"hljs-number\">42</span><br><span class=\"hljs-keyword\">var</span> f <span class=\"hljs-type\">float64</span> = <span class=\"hljs-type\">float64</span>(i)<br><span class=\"hljs-keyword\">var</span> u <span class=\"hljs-type\">uint</span> = <span class=\"hljs-type\">uint</span>(f)<br></code></pre></td></tr></table></figure>\n<p>或者使用更加简单的形式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">i := <span class=\"hljs-number\">42</span><br>f := <span class=\"hljs-type\">float64</span>(i)<br>u := <span class=\"hljs-type\">uint</span>(f)<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-6-函数\"><a href=\"#2-6-函数\" class=\"headerlink\" title=\"2.6 函数\"></a>2.6 函数</h2><p>跟Java不同的是，Go语言中的函数可以返回多个值，例如让你写一个交换两值的函数，在Java下你会这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span> &#123;<br>    System.out.printf(<span class=\"hljs-string\">&quot;Before Swap is: %d, %d&quot;</span>, x, y);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">tmp</span> <span class=\"hljs-operator\">=</span> x;<br>    x = y;<br>    y = tmp;<br>    System.out.println(<span class=\"hljs-string\">&quot;After Swap is: %d, %d&quot;</span>, x, y);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>但是在Go语言下，你只需要这样写就可以实现一样的效果了：</p>\n<blockquote>\n<p>可以发现：在golang中函数的返回值也是放在函数尾部的，这和我们Java的语法存在不同，需要注意</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">int</span>)</span></span> (<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> y, x<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Go语言的返回值可以被命名，它们会被视作定义在函数顶部的变量，简而言之就是：没有参数的<code>return</code>语句返回已命名的返回值。也就是直接返回。例如：</p>\n<blockquote>\n<p>直接返回语句应当仅用在短函数中，过长的函数代码反而会影响代码可读性</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">split</span><span class=\"hljs-params\">(sum <span class=\"hljs-type\">int</span>)</span></span> (x, y <span class=\"hljs-type\">int</span>) &#123;<br>    x = sum * <span class=\"hljs-number\">4</span> / <span class=\"hljs-number\">9</span><br>    y = sum - x<br>    <span class=\"hljs-keyword\">return</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-7-for循环\"><a href=\"#2-7-for循环\" class=\"headerlink\" title=\"2.7 for循环\"></a>2.7 for循环</h2><p>Go语言中只有一种循环结构，就是for，它的语法跟Java、C++很像。唯一的区别就是循环两侧不需要括号。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 标准的for循环</span><br><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ &#123;&#125;<br><br><span class=\"hljs-comment\">// Go语言中的While循环</span><br><span class=\"hljs-keyword\">for</span> sum &lt; <span class=\"hljs-number\">100</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，还可以使用for循环迭代切片和map</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> slice []<span class=\"hljs-type\">int</span> = []<span class=\"hljs-type\">int</span>&#123; <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span> &#125;<br><span class=\"hljs-comment\">// 迭代切片</span><br><span class=\"hljs-keyword\">for</span> index, value := <span class=\"hljs-keyword\">range</span> slice &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;索引为：%d，数值为：%d\\n&quot;</span>, index, value);<br>&#125;<br><br><span class=\"hljs-comment\">// 如果不想获取索引，可以使用&quot;_&quot;将其屏蔽</span><br><span class=\"hljs-keyword\">for</span> _, value := <span class=\"hljs-keyword\">range</span> slice &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;索引为：%d，数值为：%d\\n&quot;</span>, index, value);<br>&#125;<br><br><span class=\"hljs-comment\">// 迭代map</span><br><span class=\"hljs-keyword\">var</span> stock_map <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">int</span> = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">int</span>&#123;<br>\t<span class=\"hljs-string\">&quot;iPhone 13 Pro&quot;</span>: <span class=\"hljs-number\">345</span>,<br>\t<span class=\"hljs-string\">&quot;One Plus&quot;</span>:      <span class=\"hljs-number\">21</span>,<br>\t<span class=\"hljs-string\">&quot;Realme&quot;</span>:        <span class=\"hljs-number\">34</span>,<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> stock_map &#123;<br>\tfmt.Printf(<span class=\"hljs-string\">&quot;Key: %v, value: %d\\n&quot;</span>, k, v)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"三、数组、切片和Map\"><a href=\"#三、数组、切片和Map\" class=\"headerlink\" title=\"三、数组、切片和Map\"></a>三、数组、切片和Map</h1><h2 id=\"3-1-数组\"><a href=\"#3-1-数组\" class=\"headerlink\" title=\"3.1 数组\"></a>3.1 数组</h2><p>类型<code>[n]T</code>表示拥有n个T类型的值数组，语法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> a [<span class=\"hljs-number\">10</span>]<span class=\"hljs-type\">int</span><br></code></pre></td></tr></table></figure>\n<p>具体实例如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> a [<span class=\"hljs-number\">2</span>]<span class=\"hljs-type\">string</span><br>a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;hello&quot;</span><br>a[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">&quot;world&quot;</span><br><br>primes := [<span class=\"hljs-number\">6</span>]<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-2-切片\"><a href=\"#3-2-切片\" class=\"headerlink\" title=\"3.2 切片\"></a>3.2 切片</h2><p>由于数组的大小是固定的，所以使用切片为数组元素提供动态大小、灵活的视角。在具体的开发实践中，切片比数组更加常用。具体语法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">a[low:high]<br></code></pre></td></tr></table></figure>\n<p>它会选择一个半开区间，包括第一个元素但排除最后一个元素：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 代表a数组从下标1到3的元素（不包括4）</span><br>a[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">4</span>]<br></code></pre></td></tr></table></figure>\n<p>切片并不存储任何数据，它仅仅是描述了底层数组中的一段，而且<strong>更改切片中的元素会修改其底层数组</strong>中对应的元素；除此之外，切片的下界默认为0，上界是该切片的长度。因此好好理解一下下列切片代表的含义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\ts := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>&#125;<br><br>\ts = s[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">6</span>] <span class=\"hljs-comment\">// 下界为0，上界为6</span><br>\tfmt.Println(s)<br><br>\ts = s[:<span class=\"hljs-number\">6</span>] <span class=\"hljs-comment\">// 下界默认为0，可以不写</span><br>\tfmt.Println(s)<br><br>\ts = s[<span class=\"hljs-number\">0</span>:] <span class=\"hljs-comment\">// 上界默认为6，可以不写</span><br>\tfmt.Println(s)<br><br>\ts = s[:] <span class=\"hljs-comment\">// 下界为0，上界为6</span><br>\tfmt.Println(s)<br>    <br>    <span class=\"hljs-comment\">// 输出结果均为[ 2, 3, 5, 7, 11, 13 ]</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>切片有长度和容量，长度就是其所包含的元素个数，容量是从第一个元素开始数，到其底层数组元素的末尾个数。获取长度可以用<code>len(s)</code>，获取容量使用<code>cap(s)</code>。可以通过重新切片来扩展一个切片。给它提供足够的容量。</p>\n<p>一个没有初始化的切片为nil切片，长度和容量均为0且没有底层数组（这就意味着有数据的切片存在一个底层数组，我们后面专门从底层讲讲切片）</p>\n<p>创建切片可以使用内建的<code>make</code>函数来完成，也是用于创建动态数组的方式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">a := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">5</span>)<br>printSlice(<span class=\"hljs-string\">&quot;a&quot;</span>, a) <span class=\"hljs-comment\">// [0 0 0 0 0]</span><br><br>b := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>)<br>printSlice(<span class=\"hljs-string\">&quot;b&quot;</span>, b) <span class=\"hljs-comment\">// []</span><br><br>c := b[:<span class=\"hljs-number\">2</span>]<br>printSlice(<span class=\"hljs-string\">&quot;c&quot;</span>, c) <span class=\"hljs-comment\">// [0 0]</span><br><br>d := c[<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">5</span>]<br>printSlice(<span class=\"hljs-string\">&quot;d&quot;</span>, d) <span class=\"hljs-comment\">// [0 0 0]</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">printSlice</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, x []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;%s len=%d, cap=%d %v\\n&quot;</span>, s, <span class=\"hljs-built_in\">len</span>(s), <span class=\"hljs-built_in\">cap</span>(s), x)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-2-1-切片的切片\"><a href=\"#3-2-1-切片的切片\" class=\"headerlink\" title=\"3.2.1 切片的切片\"></a>3.2.1 切片的切片</h3><p>切片可以包含任何类型，甚至是包括其它切片，记录一下基本的使用：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-comment\">// board本身为一个切片，切片中每个元素又为一个切片</span><br>    board := [][]<span class=\"hljs-type\">string</span>&#123;<br>        []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>&#125;,<br>        []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>&#125;,<br>        []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>&#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-2-2-向切片中追加元素\"><a href=\"#3-2-2-向切片中追加元素\" class=\"headerlink\" title=\"3.2.2 向切片中追加元素\"></a>3.2.2 向切片中追加元素</h3><p><code>Go</code>提供了内建的<code>append</code>函数，可以对已有切片进行元素的追加操作，具体使用事例如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> s []<span class=\"hljs-type\">int</span><br>    printSlice(s)<br>    <br>    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">0</span>)<br>    printSlice(s)<br>    <br>    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">1</span>)<br>    printSlice(s)<br>    <br>    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)<br>    printSlice(s)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">printSlice</span><span class=\"hljs-params\">(s []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;len=%d cap=%d %v\\n&quot;</span>, <span class=\"hljs-built_in\">len</span>(s), <span class=\"hljs-built_in\">cap</span>(s), s);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-2-3-使用range循环切片\"><a href=\"#3-2-3-使用range循环切片\" class=\"headerlink\" title=\"3.2.3 使用range循环切片\"></a>3.2.3 使用range循环切片</h3><p><code>for</code>循环的<code>range</code>形式可以遍历切片或映射，需要注意的是每次循环都会出现两个值，第一个值为当前元素的下标，第二个值为下标对应元素的副本，如果想要忽略下标，可以使用<code>_</code>符号；</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> pow = []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">64</span>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> pow &#123;<br>        fmt.Printf(<span class=\"hljs-string\">&quot;2**%d = %d\\n&quot;</span>, i, v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-3-Map\"><a href=\"#3-3-Map\" class=\"headerlink\" title=\"3.3 Map\"></a>3.3 Map</h2><p>这种数据结构在熟悉不过了，如果你用过Java，那你应该对它很熟悉，介绍一下它的基本用法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-keyword\">struct</span> &#123;<br>    Lat, Long <span class=\"hljs-type\">float64</span><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> m <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]Vertex <span class=\"hljs-comment\">// 括号内为key的类型，括号外为value的类型，前面使用map关键字修饰</span><br><br>m = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]Vertex)<br>m[<span class=\"hljs-string\">&quot;Bell Labs&quot;</span>] = Vertex&#123;<br>    <span class=\"hljs-number\">40.68433</span>, <span class=\"hljs-number\">-74.39967</span><br>&#125;<br><br><span class=\"hljs-comment\">//还可以忽略顶级类型名</span><br><span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]Vertex&#123;<br>    <span class=\"hljs-string\">&quot;Bell Labs&quot;</span>: &#123;<span class=\"hljs-number\">40.68443</span>, <span class=\"hljs-number\">-74.36883</span>&#125;,<br>    <span class=\"hljs-string\">&quot;Google&quot;</span>:    &#123;<span class=\"hljs-number\">37.43323</span>, <span class=\"hljs-number\">-122.08448</span>&#125;,<br>&#125;<br><br><span class=\"hljs-comment\">// 修改也很简单</span><br>m := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">int</span>)<br>m[<span class=\"hljs-string\">&quot;Answer&quot;</span>] = <span class=\"hljs-number\">42</span> <span class=\"hljs-comment\">// 修改Key为Answer的值</span><br><span class=\"hljs-built_in\">delete</span>(m, <span class=\"hljs-string\">&quot;Answer&quot;</span>) <span class=\"hljs-comment\">// 删除Key为Answer的值</span><br>v, ok := m[<span class=\"hljs-string\">&quot;Answer&quot;</span>] <span class=\"hljs-comment\">// 判断Answer的key是否存在</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"四、函数\"><a href=\"#四、函数\" class=\"headerlink\" title=\"四、函数\"></a>四、函数</h1><h2 id=\"4-1-函数也可以成为参数或者返回值\"><a href=\"#4-1-函数也可以成为参数或者返回值\" class=\"headerlink\" title=\"4.1 函数也可以成为参数或者返回值\"></a>4.1 函数也可以成为参数或者返回值</h2><p>这也是Go语言面向函数式编程的核心思想，还有一个重要的概念叫闭包。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// compute为函数类型</span><br><span class=\"hljs-comment\">// compute的函数参数为一个名为fn的函数，其接收两个函数参数， fn函数的返回值也为float64类型</span><br><span class=\"hljs-comment\">// 返回值直接返回的也是函数类型</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">compute</span><span class=\"hljs-params\">(fn <span class=\"hljs-keyword\">func</span>(<span class=\"hljs-type\">float64</span>, <span class=\"hljs-type\">float64</span>)</span></span> <span class=\"hljs-type\">float64</span>) <span class=\"hljs-type\">float64</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> fn(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    hypot := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">float64</span>)</span></span> <span class=\"hljs-type\">float64</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> math.Sqrt(x*x + y*y)<br>    &#125;<br>    fmt.Println(hypot(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">12</span>))<br>    fmt.Println(compute(hypot))<br>    fmt.Println(compute(math.Pow))<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"4-2-函数的闭包\"><a href=\"#4-2-函数的闭包\" class=\"headerlink\" title=\"4.2 函数的闭包\"></a>4.2 函数的闭包</h2><p>Go函数可以是一个闭包，闭包是一个函数值，其引用了其函数体之外的变量，该函数也可以访问并赋予其引用的变量值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">adder</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    sum := <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        sum += x<br>        <span class=\"hljs-keyword\">return</span> sum<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-comment\">// 两个闭包都绑定在各自的sum变量上</span><br>    pos, neg := adder(), adder()<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ &#123;<br>        fmt.Println(pos(i), neg(<span class=\"hljs-number\">-2</span>*i))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用闭包实现斐波那契数列的算法可以这样写：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fibonacci</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    back1, back2 := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-comment\">// 闭包返回的是具体的函数，所以这里也要返回函数</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        temp := back1<br>        back1, back2 = back2, (back1 + back2)<br>        <span class=\"hljs-keyword\">return</span> temp<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    f := fibonacci()<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ &#123;<br>        fmt.Println(f())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"五、方法\"><a href=\"#五、方法\" class=\"headerlink\" title=\"五、方法\"></a>五、方法</h1><h2 id=\"5-1-基本概念\"><a href=\"#5-1-基本概念\" class=\"headerlink\" title=\"5.1 基本概念\"></a>5.1 基本概念</h2><p>这里我们对照面向对象的思想，Go语言中没有“类”这个概念，所以我们一般可以借助结构体来定义方法。这个概念很重要，因为后面我们的很多面向对象的特性都是基于方法这个概念进行开展的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-keyword\">struct</span> &#123;<br>    X, Y <span class=\"hljs-type\">float64</span><br>&#125;<br><br><span class=\"hljs-comment\">// Vertex有一个方法，接收者为Vertex，可以理解为这个方法是Vertex的成员方法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(v Vertex)</span></span> Abs() <span class=\"hljs-type\">float64</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>和一般的函数区别在于，方法在<code>func</code>关键字和方法名之间有一个参数列表，我们称之为<code>方法接收者</code></p>\n<h2 id=\"5-2-指针接收者\"><a href=\"#5-2-指针接收者\" class=\"headerlink\" title=\"5.2 指针接收者\"></a>5.2 指针接收者</h2><p>可以为指针接收者声明方法，意味着对于某类型<code>T</code>，接收者可以是<code>*T</code>的文法。指针接收者的方法可以修改接收者指向的值。由于方法经常需要修改接收者，指针接收者比值接收者更加常用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-keyword\">struct</span> &#123;<br>    X, Y <span class=\"hljs-type\">float64</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(v *Vertex)</span></span> Scale(f <span class=\"hljs-type\">float64</span>) &#123;<br>    v.X = v.X * f<br>    v.Y = v.Y * f<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当然，你也可以使用函数来实现<code>Scale</code>方法，效果和使用指针接收器是一样的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-keyword\">struct</span> &#123;<br>    X, Y <span class=\"hljs-type\">float64</span><br>&#125;<br><br><span class=\"hljs-comment\">// 需要注意的是：如果涉及值修改，必须使用指针接收对象，否则值不会发生变化</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Scale</span><span class=\"hljs-params\">(v *Vertex, f <span class=\"hljs-type\">float64</span>)</span></span> &#123;<br>    v.X = v.X * f<br>    v.Y = v.Y * f<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里可以得出一个结论：（在接收者参数类型上，值和指针满足交换律）</p>\n<ul>\n<li>以指针为接收者的方法被调用时，接收者既可以为值，又可以为指针；</li>\n<li>以值为接收者的方法被调用时，接收者既可以为值又可以为指针；</li>\n</ul>\n<h2 id=\"5-3-什么时候使用指针接收者\"><a href=\"#5-3-什么时候使用指针接收者\" class=\"headerlink\" title=\"5.3 什么时候使用指针接收者\"></a>5.3 什么时候使用指针接收者</h2><ul>\n<li>方法能够修改其接收者指向的值</li>\n<li>避免每次调用方法调用进行大对象复制，特别是大型结构体，这样做更显得更加高效</li>\n</ul>\n<h1 id=\"六、接口-interface\"><a href=\"#六、接口-interface\" class=\"headerlink\" title=\"六、接口(interface)\"></a>六、接口(interface)</h1><h2 id=\"6-1-基本概念\"><a href=\"#6-1-基本概念\" class=\"headerlink\" title=\"6.1 基本概念\"></a>6.1 基本概念</h2><p>接口类型是一组方法签名定义的集合，接口类型的变量可以保存任何实现了这些方法的值。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> I <span class=\"hljs-keyword\">interface</span> &#123;<br>    M()<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> T <span class=\"hljs-keyword\">struct</span> &#123;<br>    S <span class=\"hljs-type\">string</span><br>&#125;<br><br><span class=\"hljs-comment\">// 此方法表示类型T实现了接口I，但是不需要显式声明</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(t T)</span></span> M() &#123;<br>    fmt.Println(t.S)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> i T = T&#123;<span class=\"hljs-string\">&quot;Hello&quot;</span>&#125;<br>    i.M()<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>类型通过实现一个接口的所有方法来实现该接口，既然无需专门显式声明，也就没有<code>implements</code>关键字。</p>\n<p>隐式接口从接口的实现解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>\n<h2 id=\"6-2-接口值\"><a href=\"#6-2-接口值\" class=\"headerlink\" title=\"6.2 接口值\"></a>6.2 接口值</h2><p>接口也可以像其他值一样传递，可以用作函数的参数或者返回值，接口值保存了一个具体底层类型的具体值，接口值调用方法时会执行其底层类型的同名方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> I <span class=\"hljs-keyword\">interface</span> &#123;<br>    M()<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> T <span class=\"hljs-keyword\">struct</span> &#123;<br>    S <span class=\"hljs-type\">string</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(t *T)</span></span> M() &#123;<br>    fmt.Println(t.S)<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> F <span class=\"hljs-type\">float64</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f F)</span></span> M() &#123;<br>    fmt.Println(f)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> i I<br>    <br>    <span class=\"hljs-comment\">// 类似于面向接口编程</span><br>    i = &amp;T&#123;<span class=\"hljs-string\">&quot;Hello&quot;</span>&#125;<br>    i.M()<br>    <br>    i = F(math.Pi)<br>    i.M()<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>nil接口值既不保存值也不保存具体类型，空接口<code>interface&#123;&#125;</code>可以保存任何类型的值，因此可以用于处理未知类型的值。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">interface</span>&#123;&#125;<br>    describe(i)<br>    <br>    i = <span class=\"hljs-number\">42</span><br>    describe(i)<br>    <br>    i = <span class=\"hljs-string\">&quot;Hello&quot;</span><br>    describe(i)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">describe</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;(%v, %T)\\n&quot;</span>, i, i)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"6-3-类型断言\"><a href=\"#6-3-类型断言\" class=\"headerlink\" title=\"6.3 类型断言\"></a>6.3 类型断言</h2><p>类型断言提供了访问接口值底层具体值的方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">t, ok := i.(T)<br></code></pre></td></tr></table></figure>\n<p>该语句断言的接口值<code>i</code>保存了具体类型<code>T</code>，并将其底层类型为<code>T</code>的值赋予变量<code>t</code>。为了判断一个接口值是否保存了一个特定类型，类型断言可以返回两个值：其底层值以及一个报告断言是否成功的布尔值。这里的语句和Map中的用法是一样的。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">interface</span>&#123;&#125; = <span class=\"hljs-string\">&quot;hello&quot;</span><br>    <br>    s := i.(<span class=\"hljs-type\">string</span>)<br>    fmt.Println(s)<br>    <br>    s, ok := i.(<span class=\"hljs-type\">string</span>)<br>    fmt.Println(s, ok)<br>    <br>    f, ok := i.(<span class=\"hljs-type\">float64</span>)<br>    fmt.Println(f, ok)<br>    <br>    f = i.(<span class=\"hljs-type\">float64</span>)<br>    fmt.Println(f)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"6-4-类型选择\"><a href=\"#6-4-类型选择\" class=\"headerlink\" title=\"6.4 类型选择\"></a>6.4 类型选择</h2><p>类型选择是一种按照顺序从几个类型断言中选择分支的结构，类型选择一般与switch语句相似，不过类型选择中的case为类型（而非值），它们针对给定接口值所存储的值类型进行比较。其中<code>type</code>是固定写法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">switch</span> v := i.(<span class=\"hljs-keyword\">type</span>) &#123;<br>    <span class=\"hljs-keyword\">case</span> T:<br>    \t<span class=\"hljs-comment\">// v的类型为T</span><br>\t<span class=\"hljs-keyword\">case</span> S:<br>    \t<span class=\"hljs-comment\">// v的类型为S</span><br>\t<span class=\"hljs-keyword\">default</span>:<br>    \t<span class=\"hljs-comment\">// 没有匹配，v与i的类型相同</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"七、异常处理\"><a href=\"#七、异常处理\" class=\"headerlink\" title=\"七、异常处理\"></a>七、异常处理</h1><p>Go语言使用<code>error</code>来表示错误状态（想想和Java中的有什么不同呢？），通常函数会返回一个<code>error</code>值，调用它的代码应当判断这个错误是否等于<code>nil</code>来处理错误，如果<code>error</code>为nil表示成功，否则表示失败；</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>\t<span class=\"hljs-string\">&quot;fmt&quot;</span><br>\t<span class=\"hljs-string\">&quot;time&quot;</span><br>)<br><br><span class=\"hljs-keyword\">type</span> MyError <span class=\"hljs-keyword\">struct</span> &#123;<br>\tWhen time.Time<br>\tWhat <span class=\"hljs-type\">string</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(e *MyError)</span></span> Error() <span class=\"hljs-type\">string</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">&quot;at %v, %s&quot;</span>, e.When, e.What)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">error</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> &amp;MyError&#123;time.Now(), <span class=\"hljs-string\">&quot;it didn&#x27;t work&quot;</span>&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> err := run(); err != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tfmt.Println(err)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"八、Reader\"><a href=\"#八、Reader\" class=\"headerlink\" title=\"八、Reader\"></a>八、Reader</h1><p>io包指定了<code>io.Reader</code>接口，它表示从数据流的末尾进行读取，并且Go的标准库也包含了该接口的许多实现，包括文件、网络连接、压缩和加密。</p>\n<h2 id=\"8-1-字符读取\"><a href=\"#8-1-字符读取\" class=\"headerlink\" title=\"8.1 字符读取\"></a>8.1 字符读取</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>\t<span class=\"hljs-string\">&quot;fmt&quot;</span><br>\t<span class=\"hljs-string\">&quot;io&quot;</span><br>\t<span class=\"hljs-string\">&quot;strings&quot;</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tr := strings.NewReader(<span class=\"hljs-string\">&quot;Hello, Reader!&quot;</span>)<br><br>\tb := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">byte</span>, <span class=\"hljs-number\">8</span>)<br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\tn, err := r.Read(b)<br>\t\tfmt.Printf(<span class=\"hljs-string\">&quot;n = %v err = %v b = %v\\n&quot;</span>, n, err, b)<br>\t\tfmt.Printf(<span class=\"hljs-string\">&quot;b[:n] = %q\\n&quot;</span>, b[:n])<br>\t\t<span class=\"hljs-keyword\">if</span> err == io.EOF &#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"九、并发\"><a href=\"#九、并发\" class=\"headerlink\" title=\"九、并发\"></a>九、并发</h1><h2 id=\"9-1-协程\"><a href=\"#9-1-协程\" class=\"headerlink\" title=\"9.1 协程\"></a>9.1 协程</h2><p>协程（Goroutine）是由Go运行时管理的轻量级线程，Goroutine在相同的地址空间中运行，因此在访问共享内存时必须进行同步。<code>sync</code>包提供了这种能力，不过在Goroutine中并不常见。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">say</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> &#123;<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++ &#123;<br>        time.Sleep(<span class=\"hljs-number\">100</span> * time.Millisecond)<br>        fmt.Println(s)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">go</span> say(<span class=\"hljs-string\">&quot;word&quot;</span>)<br>    say(<span class=\"hljs-string\">&quot;hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"9-2-channel通道\"><a href=\"#9-2-channel通道\" class=\"headerlink\" title=\"9.2 channel通道\"></a>9.2 channel通道</h2><p>通道是带有类型的管道，可以使用信道操作符<code>&lt;-</code>来发送或者接收值（PS：“箭头”就是数据流的方向）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">ch &lt;- v <span class=\"hljs-comment\">// 将v发送至信道ch</span><br>v := &lt;- ch <span class=\"hljs-comment\">// 从ch接收值并赋予v</span><br></code></pre></td></tr></table></figure>\n<p>信道和切片一样，使用前必须创建，使用make函数来创建：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)<br></code></pre></td></tr></table></figure>\n<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞，这就意味着Goroutine可以在没有显式锁或者竞态变量的情况下进行同步；</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(s []<span class=\"hljs-type\">int</span>, c <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    sum := <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> s &#123;<br>        sum += v<br>    &#125;<br>    c &lt;- sum<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    s := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>&#125;<br>    c := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)<br>    <span class=\"hljs-keyword\">go</span> sum(s[:<span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>], c)<br>    <span class=\"hljs-keyword\">go</span> sum(s[<span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>:], c)<br>    x, y := &lt;-c, &lt;-c<br>    <br>    fmt.Println(x, y, x+y)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>channel可以带缓冲区，有了缓冲区后，仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接收方会阻塞。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>    ch &lt;- <span class=\"hljs-number\">1</span><br>    ch &lt;- <span class=\"hljs-number\">2</span><br>    fmt.Println(&lt;-ch)<br>    fmt.Println(&lt;-ch)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：仅当信道的缓冲区填满了以后，向其发送数据时才会阻塞，当缓冲区为空的时候，接受方会阻塞</p>\n<p>发送者可以通过<code>close</code>关闭一个信道表示没有需要发送的值了，接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭；若没有值可以接收且信道已被关闭，那么执行结束后状态就会改成false。</p>\n<blockquote>\n<ol>\n<li>只有发送者才能关闭信道，接收者不能</li>\n<li>向一个已经关闭的信道发送数据会触发panic；</li>\n<li>信道与文件不同，通常情况下不需要关闭，只有在必须告诉接收者不再有需要发送的值才有必要关闭，例如<strong>终止range循环</strong></li>\n</ol>\n</blockquote>\n<p>例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fibonacci</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>, c <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\tx, y := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>\t\tc &lt;- x<br>\t\tx, y = y, x+y<br>\t&#125;<br>    <span class=\"hljs-comment\">// 当所有的值传输完后关闭通道</span><br>\t<span class=\"hljs-built_in\">close</span>(c)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tc := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">10</span>)<br>\t<span class=\"hljs-keyword\">go</span> fibonacci(<span class=\"hljs-built_in\">cap</span>(c), c)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> c &#123;<br>\t\tfmt.Println(i)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"9-3-select语句\"><a href=\"#9-3-select语句\" class=\"headerlink\" title=\"9.3 select语句\"></a>9.3 select语句</h2><p>select语句可以使得一个goroutine等待多个信道操作，select语句会阻塞某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fibonacci2</span><span class=\"hljs-params\">(c, quit <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\tx, y := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\t<span class=\"hljs-keyword\">select</span> &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> c &lt;- x:<br>\t\t\tx, y = y, x+y<br>\t\t<span class=\"hljs-keyword\">case</span> &lt;-quit:<br>\t\t\tfmt.Println(<span class=\"hljs-string\">&quot;quit&quot;</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tc := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)<br>\tquit := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)<br>\t<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ &#123;<br>\t\t\tfmt.Println(&lt;-c)<br>\t\t&#125;<br>\t\tquit &lt;- <span class=\"hljs-number\">0</span><br>\t&#125;()<br>\tfibonacci2(c, quit)<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>当<code>select</code>中的其他分支都没准备好时，<code>default</code>分支就会执行，为了尝试发送或者接收时不发生阻塞，可使用<code>default</code>分支：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>\t<span class=\"hljs-string\">&quot;fmt&quot;</span><br>\t<span class=\"hljs-string\">&quot;time&quot;</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\ttick := time.Tick(<span class=\"hljs-number\">100</span> * time.Millisecond)<br>\tboom := time.After(<span class=\"hljs-number\">500</span> * time.Millisecond)<br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\t<span class=\"hljs-keyword\">select</span> &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> &lt;-tick:<br>\t\t\tfmt.Println(<span class=\"hljs-string\">&quot;tick.&quot;</span>)<br>\t\t<span class=\"hljs-keyword\">case</span> &lt;-boom:<br>\t\t\tfmt.Println(<span class=\"hljs-string\">&quot;BOOM!&quot;</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span><br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\tfmt.Println(<span class=\"hljs-string\">&quot;    .&quot;</span>)<br>\t\t\ttime.Sleep(<span class=\"hljs-number\">50</span> * time.Millisecond)<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":11638,"excerpt":"","more":"<h1 id=\"一、这篇文章的目的\"><a href=\"#一、这篇文章的目的\" class=\"headerlink\" title=\"一、这篇文章的目的\"></a>一、这篇文章的目的</h1><p>按照以前的惯例，我们会把Golang的语法贴在这里，其实网上（包括官网）都有非常详细的Go语言教程，学习过程中可以多实践使用。这里我写一些使用中在语法上比较少涉及到的点。方便在使用过程快速回忆。当然golang本身也不复杂，上手也比较简单，如果有需要可以对照网上的教程重新温习。</p>\n<h1 id=\"二、golang基础\"><a href=\"#二、golang基础\" class=\"headerlink\" title=\"二、golang基础\"></a>二、golang基础</h1><h2 id=\"2-1-类型\"><a href=\"#2-1-类型\" class=\"headerlink\" title=\"2.1 类型\"></a>2.1 类型</h2><ul>\n<li>布尔值<ul>\n<li><strong>bool</strong></li>\n</ul>\n</li>\n<li>字符串<ul>\n<li><strong>string</strong></li>\n</ul>\n</li>\n<li>整型<ul>\n<li><strong>int</strong> / <strong>int8</strong> / <strong>int16</strong> / <strong>int32</strong> / <strong>int64</strong></li>\n<li><strong>uint</strong> / <strong>uint8</strong> / <strong>uint16</strong> / <strong>uint32</strong> / <strong>uint64</strong> / <strong>uintptr</strong></li>\n</ul>\n</li>\n<li>字节类型（uint8别名）<ul>\n<li><strong>byte</strong></li>\n</ul>\n</li>\n<li>Unicode类型（int32别名）<ul>\n<li><strong>rune</strong></li>\n</ul>\n</li>\n<li>浮点类型<ul>\n<li><strong>float32</strong> / <strong>float64</strong></li>\n</ul>\n</li>\n<li>复数类型<ul>\n<li><strong>complex64</strong> / <strong>complex128</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-2-关键字汇总\"><a href=\"#2-2-关键字汇总\" class=\"headerlink\" title=\"2.2 关键字汇总\"></a>2.2 关键字汇总</h2><p>golang关键字只有25个，非常容易掌握</p>\n<ul>\n<li>第一组<ul>\n<li><strong>break</strong>（退出循环） / <strong>case</strong>（Switch语句） / <strong>chan</strong>（通道） / <strong>const</strong>（常量） / <strong>continue</strong>（跳过当前循环）</li>\n</ul>\n</li>\n<li>第二组<ul>\n<li><strong>default</strong>（Switch语句） / <strong>defer</strong>（先定义后执行） / <strong>else</strong>（分支） / <strong>fallthrough</strong>（Switch语句） / <strong>for</strong>（循环）</li>\n</ul>\n</li>\n<li>第三组<ul>\n<li><strong>func</strong>（函数定义） / <strong>go</strong>（开启Goroutine） / <strong>goto</strong>（流程） / <strong>if</strong>（条件） / <strong>import</strong>（导包）</li>\n</ul>\n</li>\n<li>第四组<ul>\n<li><strong>interface</strong>（接口或者泛型定义） / <strong>map</strong> / <strong>package</strong> / <strong>range</strong>（基于范围的遍历） / <strong>return</strong>（返回）</li>\n</ul>\n</li>\n<li>第五组<ul>\n<li><strong>select</strong>（在通道使用） / <strong>struct</strong>（结构体） / <strong>switch</strong>（分支语句） / <strong>type</strong>（定义类型） / <strong>var</strong>（声明变量）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-3-包的导入导出\"><a href=\"#2-3-包的导入导出\" class=\"headerlink\" title=\"2.3 包的导入导出\"></a>2.3 包的导入导出</h2><p>与Java不同的是，Go语言是通过名字大小写来判定当前函数/变量是否导出。如果是小写开头就意味着不导出；如果是大写开头就意味着是导出包。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 未导出</span><br>math.pi<br><br><span class=\"hljs-comment\">// 已导出</span><br>math.Pi<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-4-变量声明方式\"><a href=\"#2-4-变量声明方式\" class=\"headerlink\" title=\"2.4 变量声明方式\"></a>2.4 变量声明方式</h2><p>与我们常用的C，C++，Java，JavaScript不同的是，Golang的变量类型是放在变量名的后面的。这点在写习惯了Java等编程语言的人来说，早期会感到不适应。但是随着你使用上习惯了，自然而然就能接受。具体如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 借助var关键字声明变量</span><br><span class=\"hljs-keyword\">var</span> i <span class=\"hljs-type\">int</span><br><br><span class=\"hljs-comment\">// 自动推断类型，这里一定要注意，如果前面没有创建过变量i，必须使用&quot;:=&quot;符号</span><br>i := <span class=\"hljs-number\">34</span><br><br><span class=\"hljs-comment\">// 多个变量初始化</span><br><span class=\"hljs-keyword\">const</span> (<br>\ti <span class=\"hljs-type\">int</span><br>    j <span class=\"hljs-type\">bool</span><br>    k <span class=\"hljs-type\">string</span><br>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-5-类型转换\"><a href=\"#2-5-类型转换\" class=\"headerlink\" title=\"2.5 类型转换\"></a>2.5 类型转换</h2><p>表达式<code>T(V)</code>将值<code>v</code>转换为类型<code>T</code>，这里提供一些关于数值转换的例子供你参考：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> i <span class=\"hljs-type\">int</span> = <span class=\"hljs-number\">42</span><br><span class=\"hljs-keyword\">var</span> f <span class=\"hljs-type\">float64</span> = <span class=\"hljs-type\">float64</span>(i)<br><span class=\"hljs-keyword\">var</span> u <span class=\"hljs-type\">uint</span> = <span class=\"hljs-type\">uint</span>(f)<br></code></pre></td></tr></table></figure>\n<p>或者使用更加简单的形式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">i := <span class=\"hljs-number\">42</span><br>f := <span class=\"hljs-type\">float64</span>(i)<br>u := <span class=\"hljs-type\">uint</span>(f)<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-6-函数\"><a href=\"#2-6-函数\" class=\"headerlink\" title=\"2.6 函数\"></a>2.6 函数</h2><p>跟Java不同的是，Go语言中的函数可以返回多个值，例如让你写一个交换两值的函数，在Java下你会这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span> &#123;<br>    System.out.printf(<span class=\"hljs-string\">&quot;Before Swap is: %d, %d&quot;</span>, x, y);<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">tmp</span> <span class=\"hljs-operator\">=</span> x;<br>    x = y;<br>    y = tmp;<br>    System.out.println(<span class=\"hljs-string\">&quot;After Swap is: %d, %d&quot;</span>, x, y);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>但是在Go语言下，你只需要这样写就可以实现一样的效果了：</p>\n<blockquote>\n<p>可以发现：在golang中函数的返回值也是放在函数尾部的，这和我们Java的语法存在不同，需要注意</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">int</span>)</span></span> (<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> y, x<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Go语言的返回值可以被命名，它们会被视作定义在函数顶部的变量，简而言之就是：没有参数的<code>return</code>语句返回已命名的返回值。也就是直接返回。例如：</p>\n<blockquote>\n<p>直接返回语句应当仅用在短函数中，过长的函数代码反而会影响代码可读性</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">split</span><span class=\"hljs-params\">(sum <span class=\"hljs-type\">int</span>)</span></span> (x, y <span class=\"hljs-type\">int</span>) &#123;<br>    x = sum * <span class=\"hljs-number\">4</span> / <span class=\"hljs-number\">9</span><br>    y = sum - x<br>    <span class=\"hljs-keyword\">return</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"2-7-for循环\"><a href=\"#2-7-for循环\" class=\"headerlink\" title=\"2.7 for循环\"></a>2.7 for循环</h2><p>Go语言中只有一种循环结构，就是for，它的语法跟Java、C++很像。唯一的区别就是循环两侧不需要括号。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 标准的for循环</span><br><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ &#123;&#125;<br><br><span class=\"hljs-comment\">// Go语言中的While循环</span><br><span class=\"hljs-keyword\">for</span> sum &lt; <span class=\"hljs-number\">100</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，还可以使用for循环迭代切片和map</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> slice []<span class=\"hljs-type\">int</span> = []<span class=\"hljs-type\">int</span>&#123; <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span> &#125;<br><span class=\"hljs-comment\">// 迭代切片</span><br><span class=\"hljs-keyword\">for</span> index, value := <span class=\"hljs-keyword\">range</span> slice &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;索引为：%d，数值为：%d\\n&quot;</span>, index, value);<br>&#125;<br><br><span class=\"hljs-comment\">// 如果不想获取索引，可以使用&quot;_&quot;将其屏蔽</span><br><span class=\"hljs-keyword\">for</span> _, value := <span class=\"hljs-keyword\">range</span> slice &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;索引为：%d，数值为：%d\\n&quot;</span>, index, value);<br>&#125;<br><br><span class=\"hljs-comment\">// 迭代map</span><br><span class=\"hljs-keyword\">var</span> stock_map <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">int</span> = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">int</span>&#123;<br>\t<span class=\"hljs-string\">&quot;iPhone 13 Pro&quot;</span>: <span class=\"hljs-number\">345</span>,<br>\t<span class=\"hljs-string\">&quot;One Plus&quot;</span>:      <span class=\"hljs-number\">21</span>,<br>\t<span class=\"hljs-string\">&quot;Realme&quot;</span>:        <span class=\"hljs-number\">34</span>,<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> stock_map &#123;<br>\tfmt.Printf(<span class=\"hljs-string\">&quot;Key: %v, value: %d\\n&quot;</span>, k, v)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"三、数组、切片和Map\"><a href=\"#三、数组、切片和Map\" class=\"headerlink\" title=\"三、数组、切片和Map\"></a>三、数组、切片和Map</h1><h2 id=\"3-1-数组\"><a href=\"#3-1-数组\" class=\"headerlink\" title=\"3.1 数组\"></a>3.1 数组</h2><p>类型<code>[n]T</code>表示拥有n个T类型的值数组，语法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> a [<span class=\"hljs-number\">10</span>]<span class=\"hljs-type\">int</span><br></code></pre></td></tr></table></figure>\n<p>具体实例如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> a [<span class=\"hljs-number\">2</span>]<span class=\"hljs-type\">string</span><br>a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;hello&quot;</span><br>a[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">&quot;world&quot;</span><br><br>primes := [<span class=\"hljs-number\">6</span>]<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-2-切片\"><a href=\"#3-2-切片\" class=\"headerlink\" title=\"3.2 切片\"></a>3.2 切片</h2><p>由于数组的大小是固定的，所以使用切片为数组元素提供动态大小、灵活的视角。在具体的开发实践中，切片比数组更加常用。具体语法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">a[low:high]<br></code></pre></td></tr></table></figure>\n<p>它会选择一个半开区间，包括第一个元素但排除最后一个元素：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 代表a数组从下标1到3的元素（不包括4）</span><br>a[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">4</span>]<br></code></pre></td></tr></table></figure>\n<p>切片并不存储任何数据，它仅仅是描述了底层数组中的一段，而且<strong>更改切片中的元素会修改其底层数组</strong>中对应的元素；除此之外，切片的下界默认为0，上界是该切片的长度。因此好好理解一下下列切片代表的含义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\ts := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>&#125;<br><br>\ts = s[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">6</span>] <span class=\"hljs-comment\">// 下界为0，上界为6</span><br>\tfmt.Println(s)<br><br>\ts = s[:<span class=\"hljs-number\">6</span>] <span class=\"hljs-comment\">// 下界默认为0，可以不写</span><br>\tfmt.Println(s)<br><br>\ts = s[<span class=\"hljs-number\">0</span>:] <span class=\"hljs-comment\">// 上界默认为6，可以不写</span><br>\tfmt.Println(s)<br><br>\ts = s[:] <span class=\"hljs-comment\">// 下界为0，上界为6</span><br>\tfmt.Println(s)<br>    <br>    <span class=\"hljs-comment\">// 输出结果均为[ 2, 3, 5, 7, 11, 13 ]</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>切片有长度和容量，长度就是其所包含的元素个数，容量是从第一个元素开始数，到其底层数组元素的末尾个数。获取长度可以用<code>len(s)</code>，获取容量使用<code>cap(s)</code>。可以通过重新切片来扩展一个切片。给它提供足够的容量。</p>\n<p>一个没有初始化的切片为nil切片，长度和容量均为0且没有底层数组（这就意味着有数据的切片存在一个底层数组，我们后面专门从底层讲讲切片）</p>\n<p>创建切片可以使用内建的<code>make</code>函数来完成，也是用于创建动态数组的方式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">a := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">5</span>)<br>printSlice(<span class=\"hljs-string\">&quot;a&quot;</span>, a) <span class=\"hljs-comment\">// [0 0 0 0 0]</span><br><br>b := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>)<br>printSlice(<span class=\"hljs-string\">&quot;b&quot;</span>, b) <span class=\"hljs-comment\">// []</span><br><br>c := b[:<span class=\"hljs-number\">2</span>]<br>printSlice(<span class=\"hljs-string\">&quot;c&quot;</span>, c) <span class=\"hljs-comment\">// [0 0]</span><br><br>d := c[<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">5</span>]<br>printSlice(<span class=\"hljs-string\">&quot;d&quot;</span>, d) <span class=\"hljs-comment\">// [0 0 0]</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">printSlice</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>, x []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;%s len=%d, cap=%d %v\\n&quot;</span>, s, <span class=\"hljs-built_in\">len</span>(s), <span class=\"hljs-built_in\">cap</span>(s), x)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-2-1-切片的切片\"><a href=\"#3-2-1-切片的切片\" class=\"headerlink\" title=\"3.2.1 切片的切片\"></a>3.2.1 切片的切片</h3><p>切片可以包含任何类型，甚至是包括其它切片，记录一下基本的使用：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-comment\">// board本身为一个切片，切片中每个元素又为一个切片</span><br>    board := [][]<span class=\"hljs-type\">string</span>&#123;<br>        []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>&#125;,<br>        []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>&#125;,<br>        []<span class=\"hljs-type\">string</span>&#123;<span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>, <span class=\"hljs-string\">&quot;_&quot;</span>&#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-2-2-向切片中追加元素\"><a href=\"#3-2-2-向切片中追加元素\" class=\"headerlink\" title=\"3.2.2 向切片中追加元素\"></a>3.2.2 向切片中追加元素</h3><p><code>Go</code>提供了内建的<code>append</code>函数，可以对已有切片进行元素的追加操作，具体使用事例如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> s []<span class=\"hljs-type\">int</span><br>    printSlice(s)<br>    <br>    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">0</span>)<br>    printSlice(s)<br>    <br>    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">1</span>)<br>    printSlice(s)<br>    <br>    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)<br>    printSlice(s)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">printSlice</span><span class=\"hljs-params\">(s []<span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;len=%d cap=%d %v\\n&quot;</span>, <span class=\"hljs-built_in\">len</span>(s), <span class=\"hljs-built_in\">cap</span>(s), s);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-2-3-使用range循环切片\"><a href=\"#3-2-3-使用range循环切片\" class=\"headerlink\" title=\"3.2.3 使用range循环切片\"></a>3.2.3 使用range循环切片</h3><p><code>for</code>循环的<code>range</code>形式可以遍历切片或映射，需要注意的是每次循环都会出现两个值，第一个值为当前元素的下标，第二个值为下标对应元素的副本，如果想要忽略下标，可以使用<code>_</code>符号；</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> pow = []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">64</span>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> pow &#123;<br>        fmt.Printf(<span class=\"hljs-string\">&quot;2**%d = %d\\n&quot;</span>, i, v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-3-Map\"><a href=\"#3-3-Map\" class=\"headerlink\" title=\"3.3 Map\"></a>3.3 Map</h2><p>这种数据结构在熟悉不过了，如果你用过Java，那你应该对它很熟悉，介绍一下它的基本用法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-keyword\">struct</span> &#123;<br>    Lat, Long <span class=\"hljs-type\">float64</span><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> m <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]Vertex <span class=\"hljs-comment\">// 括号内为key的类型，括号外为value的类型，前面使用map关键字修饰</span><br><br>m = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]Vertex)<br>m[<span class=\"hljs-string\">&quot;Bell Labs&quot;</span>] = Vertex&#123;<br>    <span class=\"hljs-number\">40.68433</span>, <span class=\"hljs-number\">-74.39967</span><br>&#125;<br><br><span class=\"hljs-comment\">//还可以忽略顶级类型名</span><br><span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]Vertex&#123;<br>    <span class=\"hljs-string\">&quot;Bell Labs&quot;</span>: &#123;<span class=\"hljs-number\">40.68443</span>, <span class=\"hljs-number\">-74.36883</span>&#125;,<br>    <span class=\"hljs-string\">&quot;Google&quot;</span>:    &#123;<span class=\"hljs-number\">37.43323</span>, <span class=\"hljs-number\">-122.08448</span>&#125;,<br>&#125;<br><br><span class=\"hljs-comment\">// 修改也很简单</span><br>m := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">int</span>)<br>m[<span class=\"hljs-string\">&quot;Answer&quot;</span>] = <span class=\"hljs-number\">42</span> <span class=\"hljs-comment\">// 修改Key为Answer的值</span><br><span class=\"hljs-built_in\">delete</span>(m, <span class=\"hljs-string\">&quot;Answer&quot;</span>) <span class=\"hljs-comment\">// 删除Key为Answer的值</span><br>v, ok := m[<span class=\"hljs-string\">&quot;Answer&quot;</span>] <span class=\"hljs-comment\">// 判断Answer的key是否存在</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"四、函数\"><a href=\"#四、函数\" class=\"headerlink\" title=\"四、函数\"></a>四、函数</h1><h2 id=\"4-1-函数也可以成为参数或者返回值\"><a href=\"#4-1-函数也可以成为参数或者返回值\" class=\"headerlink\" title=\"4.1 函数也可以成为参数或者返回值\"></a>4.1 函数也可以成为参数或者返回值</h2><p>这也是Go语言面向函数式编程的核心思想，还有一个重要的概念叫闭包。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// compute为函数类型</span><br><span class=\"hljs-comment\">// compute的函数参数为一个名为fn的函数，其接收两个函数参数， fn函数的返回值也为float64类型</span><br><span class=\"hljs-comment\">// 返回值直接返回的也是函数类型</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">compute</span><span class=\"hljs-params\">(fn <span class=\"hljs-keyword\">func</span>(<span class=\"hljs-type\">float64</span>, <span class=\"hljs-type\">float64</span>)</span></span> <span class=\"hljs-type\">float64</span>) <span class=\"hljs-type\">float64</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> fn(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    hypot := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x, y <span class=\"hljs-type\">float64</span>)</span></span> <span class=\"hljs-type\">float64</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> math.Sqrt(x*x + y*y)<br>    &#125;<br>    fmt.Println(hypot(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">12</span>))<br>    fmt.Println(compute(hypot))<br>    fmt.Println(compute(math.Pow))<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"4-2-函数的闭包\"><a href=\"#4-2-函数的闭包\" class=\"headerlink\" title=\"4.2 函数的闭包\"></a>4.2 函数的闭包</h2><p>Go函数可以是一个闭包，闭包是一个函数值，其引用了其函数体之外的变量，该函数也可以访问并赋予其引用的变量值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">adder</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    sum := <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        sum += x<br>        <span class=\"hljs-keyword\">return</span> sum<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-comment\">// 两个闭包都绑定在各自的sum变量上</span><br>    pos, neg := adder(), adder()<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ &#123;<br>        fmt.Println(pos(i), neg(<span class=\"hljs-number\">-2</span>*i))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用闭包实现斐波那契数列的算法可以这样写：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fibonacci</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">int</span> &#123;<br>    back1, back2 := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-comment\">// 闭包返回的是具体的函数，所以这里也要返回函数</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">int</span> &#123;<br>        temp := back1<br>        back1, back2 = back2, (back1 + back2)<br>        <span class=\"hljs-keyword\">return</span> temp<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    f := fibonacci()<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ &#123;<br>        fmt.Println(f())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"五、方法\"><a href=\"#五、方法\" class=\"headerlink\" title=\"五、方法\"></a>五、方法</h1><h2 id=\"5-1-基本概念\"><a href=\"#5-1-基本概念\" class=\"headerlink\" title=\"5.1 基本概念\"></a>5.1 基本概念</h2><p>这里我们对照面向对象的思想，Go语言中没有“类”这个概念，所以我们一般可以借助结构体来定义方法。这个概念很重要，因为后面我们的很多面向对象的特性都是基于方法这个概念进行开展的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-keyword\">struct</span> &#123;<br>    X, Y <span class=\"hljs-type\">float64</span><br>&#125;<br><br><span class=\"hljs-comment\">// Vertex有一个方法，接收者为Vertex，可以理解为这个方法是Vertex的成员方法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(v Vertex)</span></span> Abs() <span class=\"hljs-type\">float64</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>和一般的函数区别在于，方法在<code>func</code>关键字和方法名之间有一个参数列表，我们称之为<code>方法接收者</code></p>\n<h2 id=\"5-2-指针接收者\"><a href=\"#5-2-指针接收者\" class=\"headerlink\" title=\"5.2 指针接收者\"></a>5.2 指针接收者</h2><p>可以为指针接收者声明方法，意味着对于某类型<code>T</code>，接收者可以是<code>*T</code>的文法。指针接收者的方法可以修改接收者指向的值。由于方法经常需要修改接收者，指针接收者比值接收者更加常用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-keyword\">struct</span> &#123;<br>    X, Y <span class=\"hljs-type\">float64</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(v *Vertex)</span></span> Scale(f <span class=\"hljs-type\">float64</span>) &#123;<br>    v.X = v.X * f<br>    v.Y = v.Y * f<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>当然，你也可以使用函数来实现<code>Scale</code>方法，效果和使用指针接收器是一样的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> Vertex <span class=\"hljs-keyword\">struct</span> &#123;<br>    X, Y <span class=\"hljs-type\">float64</span><br>&#125;<br><br><span class=\"hljs-comment\">// 需要注意的是：如果涉及值修改，必须使用指针接收对象，否则值不会发生变化</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Scale</span><span class=\"hljs-params\">(v *Vertex, f <span class=\"hljs-type\">float64</span>)</span></span> &#123;<br>    v.X = v.X * f<br>    v.Y = v.Y * f<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里可以得出一个结论：（在接收者参数类型上，值和指针满足交换律）</p>\n<ul>\n<li>以指针为接收者的方法被调用时，接收者既可以为值，又可以为指针；</li>\n<li>以值为接收者的方法被调用时，接收者既可以为值又可以为指针；</li>\n</ul>\n<h2 id=\"5-3-什么时候使用指针接收者\"><a href=\"#5-3-什么时候使用指针接收者\" class=\"headerlink\" title=\"5.3 什么时候使用指针接收者\"></a>5.3 什么时候使用指针接收者</h2><ul>\n<li>方法能够修改其接收者指向的值</li>\n<li>避免每次调用方法调用进行大对象复制，特别是大型结构体，这样做更显得更加高效</li>\n</ul>\n<h1 id=\"六、接口-interface\"><a href=\"#六、接口-interface\" class=\"headerlink\" title=\"六、接口(interface)\"></a>六、接口(interface)</h1><h2 id=\"6-1-基本概念\"><a href=\"#6-1-基本概念\" class=\"headerlink\" title=\"6.1 基本概念\"></a>6.1 基本概念</h2><p>接口类型是一组方法签名定义的集合，接口类型的变量可以保存任何实现了这些方法的值。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> I <span class=\"hljs-keyword\">interface</span> &#123;<br>    M()<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> T <span class=\"hljs-keyword\">struct</span> &#123;<br>    S <span class=\"hljs-type\">string</span><br>&#125;<br><br><span class=\"hljs-comment\">// 此方法表示类型T实现了接口I，但是不需要显式声明</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(t T)</span></span> M() &#123;<br>    fmt.Println(t.S)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> i T = T&#123;<span class=\"hljs-string\">&quot;Hello&quot;</span>&#125;<br>    i.M()<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>类型通过实现一个接口的所有方法来实现该接口，既然无需专门显式声明，也就没有<code>implements</code>关键字。</p>\n<p>隐式接口从接口的实现解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>\n<h2 id=\"6-2-接口值\"><a href=\"#6-2-接口值\" class=\"headerlink\" title=\"6.2 接口值\"></a>6.2 接口值</h2><p>接口也可以像其他值一样传递，可以用作函数的参数或者返回值，接口值保存了一个具体底层类型的具体值，接口值调用方法时会执行其底层类型的同名方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> I <span class=\"hljs-keyword\">interface</span> &#123;<br>    M()<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> T <span class=\"hljs-keyword\">struct</span> &#123;<br>    S <span class=\"hljs-type\">string</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(t *T)</span></span> M() &#123;<br>    fmt.Println(t.S)<br>&#125;<br><br><span class=\"hljs-keyword\">type</span> F <span class=\"hljs-type\">float64</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f F)</span></span> M() &#123;<br>    fmt.Println(f)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> i I<br>    <br>    <span class=\"hljs-comment\">// 类似于面向接口编程</span><br>    i = &amp;T&#123;<span class=\"hljs-string\">&quot;Hello&quot;</span>&#125;<br>    i.M()<br>    <br>    i = F(math.Pi)<br>    i.M()<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>nil接口值既不保存值也不保存具体类型，空接口<code>interface&#123;&#125;</code>可以保存任何类型的值，因此可以用于处理未知类型的值。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">interface</span>&#123;&#125;<br>    describe(i)<br>    <br>    i = <span class=\"hljs-number\">42</span><br>    describe(i)<br>    <br>    i = <span class=\"hljs-string\">&quot;Hello&quot;</span><br>    describe(i)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">describe</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">interface</span>&#123;&#125;)</span></span> &#123;<br>    fmt.Printf(<span class=\"hljs-string\">&quot;(%v, %T)\\n&quot;</span>, i, i)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"6-3-类型断言\"><a href=\"#6-3-类型断言\" class=\"headerlink\" title=\"6.3 类型断言\"></a>6.3 类型断言</h2><p>类型断言提供了访问接口值底层具体值的方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">t, ok := i.(T)<br></code></pre></td></tr></table></figure>\n<p>该语句断言的接口值<code>i</code>保存了具体类型<code>T</code>，并将其底层类型为<code>T</code>的值赋予变量<code>t</code>。为了判断一个接口值是否保存了一个特定类型，类型断言可以返回两个值：其底层值以及一个报告断言是否成功的布尔值。这里的语句和Map中的用法是一样的。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">interface</span>&#123;&#125; = <span class=\"hljs-string\">&quot;hello&quot;</span><br>    <br>    s := i.(<span class=\"hljs-type\">string</span>)<br>    fmt.Println(s)<br>    <br>    s, ok := i.(<span class=\"hljs-type\">string</span>)<br>    fmt.Println(s, ok)<br>    <br>    f, ok := i.(<span class=\"hljs-type\">float64</span>)<br>    fmt.Println(f, ok)<br>    <br>    f = i.(<span class=\"hljs-type\">float64</span>)<br>    fmt.Println(f)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"6-4-类型选择\"><a href=\"#6-4-类型选择\" class=\"headerlink\" title=\"6.4 类型选择\"></a>6.4 类型选择</h2><p>类型选择是一种按照顺序从几个类型断言中选择分支的结构，类型选择一般与switch语句相似，不过类型选择中的case为类型（而非值），它们针对给定接口值所存储的值类型进行比较。其中<code>type</code>是固定写法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">switch</span> v := i.(<span class=\"hljs-keyword\">type</span>) &#123;<br>    <span class=\"hljs-keyword\">case</span> T:<br>    \t<span class=\"hljs-comment\">// v的类型为T</span><br>\t<span class=\"hljs-keyword\">case</span> S:<br>    \t<span class=\"hljs-comment\">// v的类型为S</span><br>\t<span class=\"hljs-keyword\">default</span>:<br>    \t<span class=\"hljs-comment\">// 没有匹配，v与i的类型相同</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"七、异常处理\"><a href=\"#七、异常处理\" class=\"headerlink\" title=\"七、异常处理\"></a>七、异常处理</h1><p>Go语言使用<code>error</code>来表示错误状态（想想和Java中的有什么不同呢？），通常函数会返回一个<code>error</code>值，调用它的代码应当判断这个错误是否等于<code>nil</code>来处理错误，如果<code>error</code>为nil表示成功，否则表示失败；</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>\t<span class=\"hljs-string\">&quot;fmt&quot;</span><br>\t<span class=\"hljs-string\">&quot;time&quot;</span><br>)<br><br><span class=\"hljs-keyword\">type</span> MyError <span class=\"hljs-keyword\">struct</span> &#123;<br>\tWhen time.Time<br>\tWhat <span class=\"hljs-type\">string</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(e *MyError)</span></span> Error() <span class=\"hljs-type\">string</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">&quot;at %v, %s&quot;</span>, e.When, e.What)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">error</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> &amp;MyError&#123;time.Now(), <span class=\"hljs-string\">&quot;it didn&#x27;t work&quot;</span>&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> err := run(); err != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tfmt.Println(err)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"八、Reader\"><a href=\"#八、Reader\" class=\"headerlink\" title=\"八、Reader\"></a>八、Reader</h1><p>io包指定了<code>io.Reader</code>接口，它表示从数据流的末尾进行读取，并且Go的标准库也包含了该接口的许多实现，包括文件、网络连接、压缩和加密。</p>\n<h2 id=\"8-1-字符读取\"><a href=\"#8-1-字符读取\" class=\"headerlink\" title=\"8.1 字符读取\"></a>8.1 字符读取</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>\t<span class=\"hljs-string\">&quot;fmt&quot;</span><br>\t<span class=\"hljs-string\">&quot;io&quot;</span><br>\t<span class=\"hljs-string\">&quot;strings&quot;</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tr := strings.NewReader(<span class=\"hljs-string\">&quot;Hello, Reader!&quot;</span>)<br><br>\tb := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">byte</span>, <span class=\"hljs-number\">8</span>)<br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\tn, err := r.Read(b)<br>\t\tfmt.Printf(<span class=\"hljs-string\">&quot;n = %v err = %v b = %v\\n&quot;</span>, n, err, b)<br>\t\tfmt.Printf(<span class=\"hljs-string\">&quot;b[:n] = %q\\n&quot;</span>, b[:n])<br>\t\t<span class=\"hljs-keyword\">if</span> err == io.EOF &#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"九、并发\"><a href=\"#九、并发\" class=\"headerlink\" title=\"九、并发\"></a>九、并发</h1><h2 id=\"9-1-协程\"><a href=\"#9-1-协程\" class=\"headerlink\" title=\"9.1 协程\"></a>9.1 协程</h2><p>协程（Goroutine）是由Go运行时管理的轻量级线程，Goroutine在相同的地址空间中运行，因此在访问共享内存时必须进行同步。<code>sync</code>包提供了这种能力，不过在Goroutine中并不常见。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">say</span><span class=\"hljs-params\">(s <span class=\"hljs-type\">string</span>)</span></span> &#123;<br>    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++ &#123;<br>        time.Sleep(<span class=\"hljs-number\">100</span> * time.Millisecond)<br>        fmt.Println(s)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-keyword\">go</span> say(<span class=\"hljs-string\">&quot;word&quot;</span>)<br>    say(<span class=\"hljs-string\">&quot;hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"9-2-channel通道\"><a href=\"#9-2-channel通道\" class=\"headerlink\" title=\"9.2 channel通道\"></a>9.2 channel通道</h2><p>通道是带有类型的管道，可以使用信道操作符<code>&lt;-</code>来发送或者接收值（PS：“箭头”就是数据流的方向）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">ch &lt;- v <span class=\"hljs-comment\">// 将v发送至信道ch</span><br>v := &lt;- ch <span class=\"hljs-comment\">// 从ch接收值并赋予v</span><br></code></pre></td></tr></table></figure>\n<p>信道和切片一样，使用前必须创建，使用make函数来创建：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)<br></code></pre></td></tr></table></figure>\n<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞，这就意味着Goroutine可以在没有显式锁或者竞态变量的情况下进行同步；</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(s []<span class=\"hljs-type\">int</span>, c <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>    sum := <span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> s &#123;<br>        sum += v<br>    &#125;<br>    c &lt;- sum<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    s := []<span class=\"hljs-type\">int</span>&#123;<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>&#125;<br>    c := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)<br>    <span class=\"hljs-keyword\">go</span> sum(s[:<span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>], c)<br>    <span class=\"hljs-keyword\">go</span> sum(s[<span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>:], c)<br>    x, y := &lt;-c, &lt;-c<br>    <br>    fmt.Println(x, y, x+y)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>channel可以带缓冲区，有了缓冲区后，仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接收方会阻塞。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">2</span>)<br>    ch &lt;- <span class=\"hljs-number\">1</span><br>    ch &lt;- <span class=\"hljs-number\">2</span><br>    fmt.Println(&lt;-ch)<br>    fmt.Println(&lt;-ch)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：仅当信道的缓冲区填满了以后，向其发送数据时才会阻塞，当缓冲区为空的时候，接受方会阻塞</p>\n<p>发送者可以通过<code>close</code>关闭一个信道表示没有需要发送的值了，接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭；若没有值可以接收且信道已被关闭，那么执行结束后状态就会改成false。</p>\n<blockquote>\n<ol>\n<li>只有发送者才能关闭信道，接收者不能</li>\n<li>向一个已经关闭的信道发送数据会触发panic；</li>\n<li>信道与文件不同，通常情况下不需要关闭，只有在必须告诉接收者不再有需要发送的值才有必要关闭，例如<strong>终止range循环</strong></li>\n</ol>\n</blockquote>\n<p>例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fibonacci</span><span class=\"hljs-params\">(n <span class=\"hljs-type\">int</span>, c <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\tx, y := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n; i++ &#123;<br>\t\tc &lt;- x<br>\t\tx, y = y, x+y<br>\t&#125;<br>    <span class=\"hljs-comment\">// 当所有的值传输完后关闭通道</span><br>\t<span class=\"hljs-built_in\">close</span>(c)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tc := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">10</span>)<br>\t<span class=\"hljs-keyword\">go</span> fibonacci(<span class=\"hljs-built_in\">cap</span>(c), c)<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> c &#123;<br>\t\tfmt.Println(i)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"9-3-select语句\"><a href=\"#9-3-select语句\" class=\"headerlink\" title=\"9.3 select语句\"></a>9.3 select语句</h2><p>select语句可以使得一个goroutine等待多个信道操作，select语句会阻塞某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fibonacci2</span><span class=\"hljs-params\">(c, quit <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)</span></span> &#123;<br>\tx, y := <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span><br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\t<span class=\"hljs-keyword\">select</span> &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> c &lt;- x:<br>\t\t\tx, y = y, x+y<br>\t\t<span class=\"hljs-keyword\">case</span> &lt;-quit:<br>\t\t\tfmt.Println(<span class=\"hljs-string\">&quot;quit&quot;</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\tc := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)<br>\tquit := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)<br>\t<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++ &#123;<br>\t\t\tfmt.Println(&lt;-c)<br>\t\t&#125;<br>\t\tquit &lt;- <span class=\"hljs-number\">0</span><br>\t&#125;()<br>\tfibonacci2(c, quit)<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>当<code>select</code>中的其他分支都没准备好时，<code>default</code>分支就会执行，为了尝试发送或者接收时不发生阻塞，可使用<code>default</code>分支：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>\t<span class=\"hljs-string\">&quot;fmt&quot;</span><br>\t<span class=\"hljs-string\">&quot;time&quot;</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\ttick := time.Tick(<span class=\"hljs-number\">100</span> * time.Millisecond)<br>\tboom := time.After(<span class=\"hljs-number\">500</span> * time.Millisecond)<br>\t<span class=\"hljs-keyword\">for</span> &#123;<br>\t\t<span class=\"hljs-keyword\">select</span> &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> &lt;-tick:<br>\t\t\tfmt.Println(<span class=\"hljs-string\">&quot;tick.&quot;</span>)<br>\t\t<span class=\"hljs-keyword\">case</span> &lt;-boom:<br>\t\t\tfmt.Println(<span class=\"hljs-string\">&quot;BOOM!&quot;</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span><br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\tfmt.Println(<span class=\"hljs-string\">&quot;    .&quot;</span>)<br>\t\t\ttime.Sleep(<span class=\"hljs-number\">50</span> * time.Millisecond)<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"Java编程原理——编程基础","date":"2022-02-13T05:58:16.000Z","_content":"\n# 1. Java基本数据类型\n##### 1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\n\n类型名 | 取值范围\n---|---\nbyte | -2^7 ~ 2^(7-1)\nshort | -2^15 ~ 2^(15-1)\nint | -2^31 ~ 2^(31-1)\nlong | -2^63 ~ 2^(63-1)\n\n##### 1.2 小数类型：有float和double，分别占用4和8个字节\n\n类型名 | 取值范围\n---|---\nfloat | 1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45\ndouble | 4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324\n\n# 2. Java特殊数据类型\n##### 2.1 数组类型\n数组类型在内存中有两块：一块是用于**存储数组本身**，另一块是用于**存储数组内容的位置。** 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。\n\n# 3. Java运算符\n##### 3.1 \"+\", \"-\", \"*\", \"/\", \"%\"\n运算符的使用需要注意：\n1. 整数相除不是四舍五入，而是直接舍去小数位；\n2. a++表示先使用原值a后再进行自增；a--同理；\n3. ++a表示先对原始值a进行自增再进行使用；--a同理；\n4. a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；\n\n# 4. Java逻辑运算\n1. 与运算符(&)：两个都为true才是true，有一个为false就是false;\n2. 或运算符(|)：只要有一个为true就是true，只有都为false才是false;\n3. 非运算符(!)：true的非运算就是false，反之同理;\n4. 异或运算符(^)：相同为false，不相同就是true;\n5. 短路与(&&)：作用跟&类似，boolean flag = a || b++ > 0, 当a为true忽略后面的运算；\n6. 短路或(||)：作用于|类似，boolean flag = a && b++ > 0，当a为true时，忽略后面的运算；\n\n# 5. Java条件语法\n- 选择结构：if/else相当于三元运算符--> operator ? a : b;\n- 多重if/else if/else if/else相当于switch--> switch-case语法：\n```\nif (cond1) {\n    // op1\n} else if (cond2) {\n    // op2\n} else if (cond3) {\n    // op3\n} else {\n    // op4\n}\n\nswitch(cond) {\n    case cond1:\n        // op1\n        break;\n    case cond2:\n        // op2\n        break;\n    case cond3:\n        // op3\n        break;\n}\n```\n\n系统层面下：if/eise使用的操作系统中的**跳转指令**实现的，而switch使用的是**跳转表（跳转表使用二分查找实现，效率较高）** 实现的。在switch分支少的情况下会使用跳转指令实现。\n\n# 6. Java循环语法\n##### 1. while循环\n\n```\nwhile (cond) {\n    loop body\n}\n```\n只要循环条件为true，就一直执行循环体内，否则就中止执行；\n##### 2. do-while循环\n\n```\ndo {\n    loop body\n} while (cond)\n```\n不管循环条件是什么，循环体至少会执行一次；\n##### 3. for循环\n\n```\nfor (init; cond; step) {\n    loop body\n}\n```\n- 1.执行初始化命令；\n- 2.检查循环条件是否为true，如果为false执行步骤6\n- 3.循环条件为true，执行循环体；\n- 4.执行步进操作；\n- 5.步进操作执行结束后，跳转至步骤2\n- 6.for循环后续的语句；\n\n##### 4. foreach语法\n\n```\nfor (DataType element : DataTypeArr) {\n    loop body\n}\n```\n每次迭代循环element时，指针会自动更新；\n\n##### 5. 循环控制\n- break：提前结束循环，不再执行循环体内的剩余代码；\n- continue:跳过循环体内剩余的代码，然后执行步进操作；\n\n# 7. Java函数\n函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。\n1. 函数参数支持可变长度参数，语法为在数据类型的后面加上(...)，在函数内可变长度参数可以看做是数组。**可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数**。\n2. return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。\n3. 返回值可以是数组或者是对象，根据具体需求来选择；\n4. 函数重名但是参数列表不同的现象称之为函数的重载；\n5. 函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；\n6. 函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。\n7. 函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。\n8. 总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。\n\n","source":"_posts/java-core/ch01.md","raw":"---\ntitle: Java编程原理——编程基础\ndate: 2022-02-13 13:58:16\ntags: Java基础\ncategories: Java\n---\n\n# 1. Java基本数据类型\n##### 1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\n\n类型名 | 取值范围\n---|---\nbyte | -2^7 ~ 2^(7-1)\nshort | -2^15 ~ 2^(15-1)\nint | -2^31 ~ 2^(31-1)\nlong | -2^63 ~ 2^(63-1)\n\n##### 1.2 小数类型：有float和double，分别占用4和8个字节\n\n类型名 | 取值范围\n---|---\nfloat | 1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45\ndouble | 4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324\n\n# 2. Java特殊数据类型\n##### 2.1 数组类型\n数组类型在内存中有两块：一块是用于**存储数组本身**，另一块是用于**存储数组内容的位置。** 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。\n\n# 3. Java运算符\n##### 3.1 \"+\", \"-\", \"*\", \"/\", \"%\"\n运算符的使用需要注意：\n1. 整数相除不是四舍五入，而是直接舍去小数位；\n2. a++表示先使用原值a后再进行自增；a--同理；\n3. ++a表示先对原始值a进行自增再进行使用；--a同理；\n4. a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；\n\n# 4. Java逻辑运算\n1. 与运算符(&)：两个都为true才是true，有一个为false就是false;\n2. 或运算符(|)：只要有一个为true就是true，只有都为false才是false;\n3. 非运算符(!)：true的非运算就是false，反之同理;\n4. 异或运算符(^)：相同为false，不相同就是true;\n5. 短路与(&&)：作用跟&类似，boolean flag = a || b++ > 0, 当a为true忽略后面的运算；\n6. 短路或(||)：作用于|类似，boolean flag = a && b++ > 0，当a为true时，忽略后面的运算；\n\n# 5. Java条件语法\n- 选择结构：if/else相当于三元运算符--> operator ? a : b;\n- 多重if/else if/else if/else相当于switch--> switch-case语法：\n```\nif (cond1) {\n    // op1\n} else if (cond2) {\n    // op2\n} else if (cond3) {\n    // op3\n} else {\n    // op4\n}\n\nswitch(cond) {\n    case cond1:\n        // op1\n        break;\n    case cond2:\n        // op2\n        break;\n    case cond3:\n        // op3\n        break;\n}\n```\n\n系统层面下：if/eise使用的操作系统中的**跳转指令**实现的，而switch使用的是**跳转表（跳转表使用二分查找实现，效率较高）** 实现的。在switch分支少的情况下会使用跳转指令实现。\n\n# 6. Java循环语法\n##### 1. while循环\n\n```\nwhile (cond) {\n    loop body\n}\n```\n只要循环条件为true，就一直执行循环体内，否则就中止执行；\n##### 2. do-while循环\n\n```\ndo {\n    loop body\n} while (cond)\n```\n不管循环条件是什么，循环体至少会执行一次；\n##### 3. for循环\n\n```\nfor (init; cond; step) {\n    loop body\n}\n```\n- 1.执行初始化命令；\n- 2.检查循环条件是否为true，如果为false执行步骤6\n- 3.循环条件为true，执行循环体；\n- 4.执行步进操作；\n- 5.步进操作执行结束后，跳转至步骤2\n- 6.for循环后续的语句；\n\n##### 4. foreach语法\n\n```\nfor (DataType element : DataTypeArr) {\n    loop body\n}\n```\n每次迭代循环element时，指针会自动更新；\n\n##### 5. 循环控制\n- break：提前结束循环，不再执行循环体内的剩余代码；\n- continue:跳过循环体内剩余的代码，然后执行步进操作；\n\n# 7. Java函数\n函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。\n1. 函数参数支持可变长度参数，语法为在数据类型的后面加上(...)，在函数内可变长度参数可以看做是数组。**可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数**。\n2. return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。\n3. 返回值可以是数组或者是对象，根据具体需求来选择；\n4. 函数重名但是参数列表不同的现象称之为函数的重载；\n5. 函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；\n6. 函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。\n7. 函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。\n8. 总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。\n\n","slug":"java-core/ch01","published":1,"updated":"2022-02-16T11:42:59.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6ux00034f618idzf8cu","content":"<h1 id=\"1-Java基本数据类型\"><a href=\"#1-Java基本数据类型\" class=\"headerlink\" title=\"1. Java基本数据类型\"></a>1. Java基本数据类型</h1><h5 id=\"1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\"><a href=\"#1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\" class=\"headerlink\" title=\"1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\"></a>1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>-2^7 ~ 2^(7-1)</td>\n</tr>\n<tr>\n<td>short</td>\n<td>-2^15 ~ 2^(15-1)</td>\n</tr>\n<tr>\n<td>int</td>\n<td>-2^31 ~ 2^(31-1)</td>\n</tr>\n<tr>\n<td>long</td>\n<td>-2^63 ~ 2^(63-1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-2-小数类型：有float和double，分别占用4和8个字节\"><a href=\"#1-2-小数类型：有float和double，分别占用4和8个字节\" class=\"headerlink\" title=\"1.2 小数类型：有float和double，分别占用4和8个字节\"></a>1.2 小数类型：有float和double，分别占用4和8个字节</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45</td>\n</tr>\n<tr>\n<td>double</td>\n<td>4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"2-Java特殊数据类型\"><a href=\"#2-Java特殊数据类型\" class=\"headerlink\" title=\"2. Java特殊数据类型\"></a>2. Java特殊数据类型</h1><h5 id=\"2-1-数组类型\"><a href=\"#2-1-数组类型\" class=\"headerlink\" title=\"2.1 数组类型\"></a>2.1 数组类型</h5><p>数组类型在内存中有两块：一块是用于<strong>存储数组本身</strong>，另一块是用于<strong>存储数组内容的位置。</strong> 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。</p>\n<h1 id=\"3-Java运算符\"><a href=\"#3-Java运算符\" class=\"headerlink\" title=\"3. Java运算符\"></a>3. Java运算符</h1><h5 id=\"3-1-“-”-“-“-“-”-“-“-“-”\"><a href=\"#3-1-“-”-“-“-“-”-“-“-“-”\" class=\"headerlink\" title=\"3.1 “+”, “-“, “*”, “/“, “%”\"></a>3.1 “+”, “-“, “*”, “/“, “%”</h5><p>运算符的使用需要注意：</p>\n<ol>\n<li>整数相除不是四舍五入，而是直接舍去小数位；</li>\n<li>a++表示先使用原值a后再进行自增；a—同理；</li>\n<li>++a表示先对原始值a进行自增再进行使用；—a同理；</li>\n<li>a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；</li>\n</ol>\n<h1 id=\"4-Java逻辑运算\"><a href=\"#4-Java逻辑运算\" class=\"headerlink\" title=\"4. Java逻辑运算\"></a>4. Java逻辑运算</h1><ol>\n<li>与运算符(&amp;)：两个都为true才是true，有一个为false就是false;</li>\n<li>或运算符(|)：只要有一个为true就是true，只有都为false才是false;</li>\n<li>非运算符(!)：true的非运算就是false，反之同理;</li>\n<li>异或运算符(^)：相同为false，不相同就是true;</li>\n<li>短路与(&amp;&amp;)：作用跟&amp;类似，boolean flag = a || b++ &gt; 0, 当a为true忽略后面的运算；</li>\n<li>短路或(||)：作用于|类似，boolean flag = a &amp;&amp; b++ &gt; 0，当a为true时，忽略后面的运算；</li>\n</ol>\n<h1 id=\"5-Java条件语法\"><a href=\"#5-Java条件语法\" class=\"headerlink\" title=\"5. Java条件语法\"></a>5. Java条件语法</h1><ul>\n<li>选择结构：if/else相当于三元运算符—&gt; operator ? a : b;</li>\n<li>多重if/else if/else if/else相当于switch—&gt; switch-case语法：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-keyword\">if</span> (cond1) &#123;<br>    <span class=\"hljs-regexp\">//</span> op1<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond2) &#123;<br>    <span class=\"hljs-regexp\">//</span> op2<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond3) &#123;<br>    <span class=\"hljs-regexp\">//</span> op3<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-regexp\">//</span> op4<br>&#125;<br><br>switch(cond) &#123;<br>    case cond1:<br>        <span class=\"hljs-regexp\">//</span> op1<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond2:<br>        <span class=\"hljs-regexp\">//</span> op2<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond3:<br>        <span class=\"hljs-regexp\">//</span> op3<br>        <span class=\"hljs-keyword\">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>系统层面下：if/eise使用的操作系统中的<strong>跳转指令</strong>实现的，而switch使用的是<strong>跳转表（跳转表使用二分查找实现，效率较高）</strong> 实现的。在switch分支少的情况下会使用跳转指令实现。</p>\n<h1 id=\"6-Java循环语法\"><a href=\"#6-Java循环语法\" class=\"headerlink\" title=\"6. Java循环语法\"></a>6. Java循环语法</h1><h5 id=\"1-while循环\"><a href=\"#1-while循环\" class=\"headerlink\" title=\"1. while循环\"></a>1. while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">while</span> (cond) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>只要循环条件为true，就一直执行循环体内，否则就中止执行；</p>\n<h5 id=\"2-do-while循环\"><a href=\"#2-do-while循环\" class=\"headerlink\" title=\"2. do-while循环\"></a>2. do-while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125; <span class=\"hljs-keyword\">while</span> (cond)<br></code></pre></td></tr></table></figure>\n<p>不管循环条件是什么，循环体至少会执行一次；</p>\n<h5 id=\"3-for循环\"><a href=\"#3-for循环\" class=\"headerlink\" title=\"3. for循环\"></a>3. for循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (init; cond; step) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>1.执行初始化命令；</li>\n<li>2.检查循环条件是否为true，如果为false执行步骤6</li>\n<li>3.循环条件为true，执行循环体；</li>\n<li>4.执行步进操作；</li>\n<li>5.步进操作执行结束后，跳转至步骤2</li>\n<li>6.for循环后续的语句；</li>\n</ul>\n<h5 id=\"4-foreach语法\"><a href=\"#4-foreach语法\" class=\"headerlink\" title=\"4. foreach语法\"></a>4. foreach语法</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (DataType element : <span class=\"hljs-type\">DataTypeArr</span>) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每次迭代循环element时，指针会自动更新；</p>\n<h5 id=\"5-循环控制\"><a href=\"#5-循环控制\" class=\"headerlink\" title=\"5. 循环控制\"></a>5. 循环控制</h5><ul>\n<li>break：提前结束循环，不再执行循环体内的剩余代码；</li>\n<li>continue:跳过循环体内剩余的代码，然后执行步进操作；</li>\n</ul>\n<h1 id=\"7-Java函数\"><a href=\"#7-Java函数\" class=\"headerlink\" title=\"7. Java函数\"></a>7. Java函数</h1><p>函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。</p>\n<ol>\n<li>函数参数支持可变长度参数，语法为在数据类型的后面加上(…)，在函数内可变长度参数可以看做是数组。<strong>可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数</strong>。</li>\n<li>return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。</li>\n<li>返回值可以是数组或者是对象，根据具体需求来选择；</li>\n<li>函数重名但是参数列表不同的现象称之为函数的重载；</li>\n<li>函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；</li>\n<li>函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。</li>\n<li>函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。</li>\n<li>总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。</li>\n</ol>\n","site":{"data":{}},"wordcount":2120,"excerpt":"","more":"<h1 id=\"1-Java基本数据类型\"><a href=\"#1-Java基本数据类型\" class=\"headerlink\" title=\"1. Java基本数据类型\"></a>1. Java基本数据类型</h1><h5 id=\"1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\"><a href=\"#1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\" class=\"headerlink\" title=\"1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\"></a>1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>-2^7 ~ 2^(7-1)</td>\n</tr>\n<tr>\n<td>short</td>\n<td>-2^15 ~ 2^(15-1)</td>\n</tr>\n<tr>\n<td>int</td>\n<td>-2^31 ~ 2^(31-1)</td>\n</tr>\n<tr>\n<td>long</td>\n<td>-2^63 ~ 2^(63-1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-2-小数类型：有float和double，分别占用4和8个字节\"><a href=\"#1-2-小数类型：有float和double，分别占用4和8个字节\" class=\"headerlink\" title=\"1.2 小数类型：有float和double，分别占用4和8个字节\"></a>1.2 小数类型：有float和double，分别占用4和8个字节</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45</td>\n</tr>\n<tr>\n<td>double</td>\n<td>4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"2-Java特殊数据类型\"><a href=\"#2-Java特殊数据类型\" class=\"headerlink\" title=\"2. Java特殊数据类型\"></a>2. Java特殊数据类型</h1><h5 id=\"2-1-数组类型\"><a href=\"#2-1-数组类型\" class=\"headerlink\" title=\"2.1 数组类型\"></a>2.1 数组类型</h5><p>数组类型在内存中有两块：一块是用于<strong>存储数组本身</strong>，另一块是用于<strong>存储数组内容的位置。</strong> 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。</p>\n<h1 id=\"3-Java运算符\"><a href=\"#3-Java运算符\" class=\"headerlink\" title=\"3. Java运算符\"></a>3. Java运算符</h1><h5 id=\"3-1-“-”-“-“-“-”-“-“-“-”\"><a href=\"#3-1-“-”-“-“-“-”-“-“-“-”\" class=\"headerlink\" title=\"3.1 “+”, “-“, “*”, “/“, “%”\"></a>3.1 “+”, “-“, “*”, “/“, “%”</h5><p>运算符的使用需要注意：</p>\n<ol>\n<li>整数相除不是四舍五入，而是直接舍去小数位；</li>\n<li>a++表示先使用原值a后再进行自增；a—同理；</li>\n<li>++a表示先对原始值a进行自增再进行使用；—a同理；</li>\n<li>a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；</li>\n</ol>\n<h1 id=\"4-Java逻辑运算\"><a href=\"#4-Java逻辑运算\" class=\"headerlink\" title=\"4. Java逻辑运算\"></a>4. Java逻辑运算</h1><ol>\n<li>与运算符(&amp;)：两个都为true才是true，有一个为false就是false;</li>\n<li>或运算符(|)：只要有一个为true就是true，只有都为false才是false;</li>\n<li>非运算符(!)：true的非运算就是false，反之同理;</li>\n<li>异或运算符(^)：相同为false，不相同就是true;</li>\n<li>短路与(&amp;&amp;)：作用跟&amp;类似，boolean flag = a || b++ &gt; 0, 当a为true忽略后面的运算；</li>\n<li>短路或(||)：作用于|类似，boolean flag = a &amp;&amp; b++ &gt; 0，当a为true时，忽略后面的运算；</li>\n</ol>\n<h1 id=\"5-Java条件语法\"><a href=\"#5-Java条件语法\" class=\"headerlink\" title=\"5. Java条件语法\"></a>5. Java条件语法</h1><ul>\n<li>选择结构：if/else相当于三元运算符—&gt; operator ? a : b;</li>\n<li>多重if/else if/else if/else相当于switch—&gt; switch-case语法：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-keyword\">if</span> (cond1) &#123;<br>    <span class=\"hljs-regexp\">//</span> op1<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond2) &#123;<br>    <span class=\"hljs-regexp\">//</span> op2<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond3) &#123;<br>    <span class=\"hljs-regexp\">//</span> op3<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-regexp\">//</span> op4<br>&#125;<br><br>switch(cond) &#123;<br>    case cond1:<br>        <span class=\"hljs-regexp\">//</span> op1<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond2:<br>        <span class=\"hljs-regexp\">//</span> op2<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond3:<br>        <span class=\"hljs-regexp\">//</span> op3<br>        <span class=\"hljs-keyword\">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>系统层面下：if/eise使用的操作系统中的<strong>跳转指令</strong>实现的，而switch使用的是<strong>跳转表（跳转表使用二分查找实现，效率较高）</strong> 实现的。在switch分支少的情况下会使用跳转指令实现。</p>\n<h1 id=\"6-Java循环语法\"><a href=\"#6-Java循环语法\" class=\"headerlink\" title=\"6. Java循环语法\"></a>6. Java循环语法</h1><h5 id=\"1-while循环\"><a href=\"#1-while循环\" class=\"headerlink\" title=\"1. while循环\"></a>1. while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">while</span> (cond) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>只要循环条件为true，就一直执行循环体内，否则就中止执行；</p>\n<h5 id=\"2-do-while循环\"><a href=\"#2-do-while循环\" class=\"headerlink\" title=\"2. do-while循环\"></a>2. do-while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125; <span class=\"hljs-keyword\">while</span> (cond)<br></code></pre></td></tr></table></figure>\n<p>不管循环条件是什么，循环体至少会执行一次；</p>\n<h5 id=\"3-for循环\"><a href=\"#3-for循环\" class=\"headerlink\" title=\"3. for循环\"></a>3. for循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (init; cond; step) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>1.执行初始化命令；</li>\n<li>2.检查循环条件是否为true，如果为false执行步骤6</li>\n<li>3.循环条件为true，执行循环体；</li>\n<li>4.执行步进操作；</li>\n<li>5.步进操作执行结束后，跳转至步骤2</li>\n<li>6.for循环后续的语句；</li>\n</ul>\n<h5 id=\"4-foreach语法\"><a href=\"#4-foreach语法\" class=\"headerlink\" title=\"4. foreach语法\"></a>4. foreach语法</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (DataType element : <span class=\"hljs-type\">DataTypeArr</span>) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每次迭代循环element时，指针会自动更新；</p>\n<h5 id=\"5-循环控制\"><a href=\"#5-循环控制\" class=\"headerlink\" title=\"5. 循环控制\"></a>5. 循环控制</h5><ul>\n<li>break：提前结束循环，不再执行循环体内的剩余代码；</li>\n<li>continue:跳过循环体内剩余的代码，然后执行步进操作；</li>\n</ul>\n<h1 id=\"7-Java函数\"><a href=\"#7-Java函数\" class=\"headerlink\" title=\"7. Java函数\"></a>7. Java函数</h1><p>函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。</p>\n<ol>\n<li>函数参数支持可变长度参数，语法为在数据类型的后面加上(…)，在函数内可变长度参数可以看做是数组。<strong>可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数</strong>。</li>\n<li>return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。</li>\n<li>返回值可以是数组或者是对象，根据具体需求来选择；</li>\n<li>函数重名但是参数列表不同的现象称之为函数的重载；</li>\n<li>函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；</li>\n<li>函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。</li>\n<li>函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。</li>\n<li>总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。</li>\n</ol>\n"},{"title":"Java编程原理——计算机执行的二进制逻辑","date":"2022-02-16T06:51:30.000Z","updated":"2022-02-16T06:51:30.000Z","math":true,"mermaid":true,"_content":"# 1. 二进制--计算机表示数据的方式\n### 1.1 十进制表示数的方式\n1. 以123来说，使用十进制表示可以写为:<br/>\n\n$$\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0\n$$\n\n2. 按照类比规则推算，N进制数字abc有如下表示，其中k为位权：\n\n$$\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...\n$$\n\n### 1.2 二进制的数字表示\n二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:\n\n$$\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}\n$$\n十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：\n1. -1的8位二进制按概念应是10000001，实际上为11111111\n2. -127的8位二进制按概念应是11111111，实际上为10000001<br/>\n因此我们需要注意下列计算机表示二进制的机器码。\n- 原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;\n- 反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;\n- 补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;\n\n使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。\n\n### 1.3 十六进制--二进制的简化\n由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])\n\n二进制 | 十进制 | 十六进制 | 二进制 | 十进制 | 十六进制\n:---:|:---:|:---:|:---:|:---:|:---:\n1010 | 10 | A | 1011 | 11 | B\n1100 | 12 | C| 1101 | 13 | D\n1110 | 14 | E | 1111 | 15 | F\n\n##### 1.4 位运算\n1. 左移(<<)：左移一位表示乘以2（高位舍去，右侧补0）；\n2. 右移(>>)：右移一位表示除以2（低位舍去，高位按原先补充）；\n\n##### 1.5 查看浮点数的具体二进制形式\n\n```java\nInteger.toBinaryString(Float.floatToIntBits(value));\nLong.toBinaryString(Double.doubleToLongBits(value));\n```\n# 2. 字符集与编码\n##### 2.1 非Unicode编码\n1. **ASCII：**覆盖键盘上的绝大多数的字符，对美国等英语国家够用；\n2. **ISO 8859-1：** 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；\n3. **Windows-1252：**在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；\n4. **GB2312：**简体中文编码规范，使用两个字节表示汉字；\n5. **GBK：**GB2312的扩充，支持更多的汉字编码；\n6. **GB18030：**在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；\n7. **Big5：**针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；\n\n##### 2.2 Unicode编码\n为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：\n1. UTF-32：字符编号的整数二进制形式，4字节\n2. UTF-16：变长字节表示，编号在U+0000\\~U+FFFF使用两字节；编号在U+10000\\~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；\n3. UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；\n\n##### 2.3 编码转换\n1. 假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。\n```mermaid\ngraph LR;\n\t字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B\n```\n\n编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。\n\n2. 乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。\n3. 乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。\n4. 使用Java恢复乱码：\n\n```java\nString str = \"value to encdoe\";\nString newStr = new String(str.getBytes(\"Windows-1252\"), \"GB18030\");\nSystem.out.println(newStr);\n```","source":"_posts/java-core/ch02.md","raw":"---\ntitle: Java编程原理——计算机执行的二进制逻辑\ndate: 2022-02-16 14:51:30\nupdated: 2022-02-16 14:51:30\ntags: Java基础\ncategories: Java\nmath: true\nmermaid: true\n---\n# 1. 二进制--计算机表示数据的方式\n### 1.1 十进制表示数的方式\n1. 以123来说，使用十进制表示可以写为:<br/>\n\n$$\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0\n$$\n\n2. 按照类比规则推算，N进制数字abc有如下表示，其中k为位权：\n\n$$\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...\n$$\n\n### 1.2 二进制的数字表示\n二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:\n\n$$\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}\n$$\n十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：\n1. -1的8位二进制按概念应是10000001，实际上为11111111\n2. -127的8位二进制按概念应是11111111，实际上为10000001<br/>\n因此我们需要注意下列计算机表示二进制的机器码。\n- 原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;\n- 反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;\n- 补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;\n\n使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。\n\n### 1.3 十六进制--二进制的简化\n由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])\n\n二进制 | 十进制 | 十六进制 | 二进制 | 十进制 | 十六进制\n:---:|:---:|:---:|:---:|:---:|:---:\n1010 | 10 | A | 1011 | 11 | B\n1100 | 12 | C| 1101 | 13 | D\n1110 | 14 | E | 1111 | 15 | F\n\n##### 1.4 位运算\n1. 左移(<<)：左移一位表示乘以2（高位舍去，右侧补0）；\n2. 右移(>>)：右移一位表示除以2（低位舍去，高位按原先补充）；\n\n##### 1.5 查看浮点数的具体二进制形式\n\n```java\nInteger.toBinaryString(Float.floatToIntBits(value));\nLong.toBinaryString(Double.doubleToLongBits(value));\n```\n# 2. 字符集与编码\n##### 2.1 非Unicode编码\n1. **ASCII：**覆盖键盘上的绝大多数的字符，对美国等英语国家够用；\n2. **ISO 8859-1：** 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；\n3. **Windows-1252：**在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；\n4. **GB2312：**简体中文编码规范，使用两个字节表示汉字；\n5. **GBK：**GB2312的扩充，支持更多的汉字编码；\n6. **GB18030：**在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；\n7. **Big5：**针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；\n\n##### 2.2 Unicode编码\n为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：\n1. UTF-32：字符编号的整数二进制形式，4字节\n2. UTF-16：变长字节表示，编号在U+0000\\~U+FFFF使用两字节；编号在U+10000\\~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；\n3. UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；\n\n##### 2.3 编码转换\n1. 假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。\n```mermaid\ngraph LR;\n\t字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B\n```\n\n编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。\n\n2. 乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。\n3. 乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。\n4. 使用Java恢复乱码：\n\n```java\nString str = \"value to encdoe\";\nString newStr = new String(str.getBytes(\"Windows-1252\"), \"GB18030\");\nSystem.out.println(newStr);\n```","slug":"java-core/ch02","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v000064f611813aw86","content":"<h1 id=\"1-二进制—计算机表示数据的方式\"><a href=\"#1-二进制—计算机表示数据的方式\" class=\"headerlink\" title=\"1. 二进制—计算机表示数据的方式\"></a>1. 二进制—计算机表示数据的方式</h1><h3 id=\"1-1-十进制表示数的方式\"><a href=\"#1-1-十进制表示数的方式\" class=\"headerlink\" title=\"1.1 十进制表示数的方式\"></a>1.1 十进制表示数的方式</h3><ol>\n<li>以123来说，使用十进制表示可以写为:<br/></li>\n</ol>\n<script type=\"math/tex; mode=display\">\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0</script><ol>\n<li>按照类比规则推算，N进制数字abc有如下表示，其中k为位权：</li>\n</ol>\n<script type=\"math/tex; mode=display\">\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...</script><h3 id=\"1-2-二进制的数字表示\"><a href=\"#1-2-二进制的数字表示\" class=\"headerlink\" title=\"1.2 二进制的数字表示\"></a>1.2 二进制的数字表示</h3><p>二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:</p>\n<script type=\"math/tex; mode=display\">\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}</script><p>十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：</p>\n<ol>\n<li>-1的8位二进制按概念应是10000001，实际上为11111111</li>\n<li>-127的8位二进制按概念应是11111111，实际上为10000001<br/><br>因此我们需要注意下列计算机表示二进制的机器码。</li>\n</ol>\n<ul>\n<li>原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;</li>\n<li>反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;</li>\n<li>补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;</li>\n</ul>\n<p>使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。</p>\n<h3 id=\"1-3-十六进制—二进制的简化\"><a href=\"#1-3-十六进制—二进制的简化\" class=\"headerlink\" title=\"1.3 十六进制—二进制的简化\"></a>1.3 十六进制—二进制的简化</h3><p>由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1010</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">1011</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">B</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1100</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1101</td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1110</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">1111</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">F</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-4-位运算\"><a href=\"#1-4-位运算\" class=\"headerlink\" title=\"1.4 位运算\"></a>1.4 位运算</h5><ol>\n<li>左移(&lt;&lt;)：左移一位表示乘以2（高位舍去，右侧补0）；</li>\n<li>右移(&gt;&gt;)：右移一位表示除以2（低位舍去，高位按原先补充）；</li>\n</ol>\n<h5 id=\"1-5-查看浮点数的具体二进制形式\"><a href=\"#1-5-查看浮点数的具体二进制形式\" class=\"headerlink\" title=\"1.5 查看浮点数的具体二进制形式\"></a>1.5 查看浮点数的具体二进制形式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\">Integer.toBinaryString(Float.floatToIntBits(value));<br>Long.toBinaryString(Double.doubleToLongBits(value));<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-字符集与编码\"><a href=\"#2-字符集与编码\" class=\"headerlink\" title=\"2. 字符集与编码\"></a>2. 字符集与编码</h1><h5 id=\"2-1-非Unicode编码\"><a href=\"#2-1-非Unicode编码\" class=\"headerlink\" title=\"2.1 非Unicode编码\"></a>2.1 非Unicode编码</h5><ol>\n<li><strong>ASCII：</strong>覆盖键盘上的绝大多数的字符，对美国等英语国家够用；</li>\n<li><strong>ISO 8859-1：</strong> 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；</li>\n<li><strong>Windows-1252：</strong>在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；</li>\n<li><strong>GB2312：</strong>简体中文编码规范，使用两个字节表示汉字；</li>\n<li><strong>GBK：</strong>GB2312的扩充，支持更多的汉字编码；</li>\n<li><strong>GB18030：</strong>在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；</li>\n<li><strong>Big5：</strong>针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；</li>\n</ol>\n<h5 id=\"2-2-Unicode编码\"><a href=\"#2-2-Unicode编码\" class=\"headerlink\" title=\"2.2 Unicode编码\"></a>2.2 Unicode编码</h5><p>为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：</p>\n<ol>\n<li>UTF-32：字符编号的整数二进制形式，4字节</li>\n<li>UTF-16：变长字节表示，编号在U+0000~U+FFFF使用两字节；编号在U+10000~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；</li>\n<li>UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；</li>\n</ol>\n<h5 id=\"2-3-编码转换\"><a href=\"#2-3-编码转换\" class=\"headerlink\" title=\"2.3 编码转换\"></a>2.3 编码转换</h5><ol>\n<li>假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。<div class=\"code-wrapper\"><pre class=\"mermaid\">graph LR;\n 字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B</pre></div>\n\n</li>\n</ol>\n<p>编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。</p>\n<ol>\n<li>乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。</li>\n<li>乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。</li>\n<li>使用Java恢复乱码：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value to encdoe&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">newStr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(str.getBytes(<span class=\"hljs-string\">&quot;Windows-1252&quot;</span>), <span class=\"hljs-string\">&quot;GB18030&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":1956,"excerpt":"","more":"<h1 id=\"1-二进制—计算机表示数据的方式\"><a href=\"#1-二进制—计算机表示数据的方式\" class=\"headerlink\" title=\"1. 二进制—计算机表示数据的方式\"></a>1. 二进制—计算机表示数据的方式</h1><h3 id=\"1-1-十进制表示数的方式\"><a href=\"#1-1-十进制表示数的方式\" class=\"headerlink\" title=\"1.1 十进制表示数的方式\"></a>1.1 十进制表示数的方式</h3><ol>\n<li>以123来说，使用十进制表示可以写为:<br/></li>\n</ol>\n<script type=\"math/tex; mode=display\">\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0</script><ol>\n<li>按照类比规则推算，N进制数字abc有如下表示，其中k为位权：</li>\n</ol>\n<script type=\"math/tex; mode=display\">\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...</script><h3 id=\"1-2-二进制的数字表示\"><a href=\"#1-2-二进制的数字表示\" class=\"headerlink\" title=\"1.2 二进制的数字表示\"></a>1.2 二进制的数字表示</h3><p>二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:</p>\n<script type=\"math/tex; mode=display\">\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}</script><p>十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：</p>\n<ol>\n<li>-1的8位二进制按概念应是10000001，实际上为11111111</li>\n<li>-127的8位二进制按概念应是11111111，实际上为10000001<br/><br>因此我们需要注意下列计算机表示二进制的机器码。</li>\n</ol>\n<ul>\n<li>原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;</li>\n<li>反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;</li>\n<li>补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;</li>\n</ul>\n<p>使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。</p>\n<h3 id=\"1-3-十六进制—二进制的简化\"><a href=\"#1-3-十六进制—二进制的简化\" class=\"headerlink\" title=\"1.3 十六进制—二进制的简化\"></a>1.3 十六进制—二进制的简化</h3><p>由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1010</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">1011</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">B</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1100</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1101</td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1110</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">1111</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">F</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-4-位运算\"><a href=\"#1-4-位运算\" class=\"headerlink\" title=\"1.4 位运算\"></a>1.4 位运算</h5><ol>\n<li>左移(&lt;&lt;)：左移一位表示乘以2（高位舍去，右侧补0）；</li>\n<li>右移(&gt;&gt;)：右移一位表示除以2（低位舍去，高位按原先补充）；</li>\n</ol>\n<h5 id=\"1-5-查看浮点数的具体二进制形式\"><a href=\"#1-5-查看浮点数的具体二进制形式\" class=\"headerlink\" title=\"1.5 查看浮点数的具体二进制形式\"></a>1.5 查看浮点数的具体二进制形式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Integer.toBinaryString(Float.floatToIntBits(value));<br>Long.toBinaryString(Double.doubleToLongBits(value));<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-字符集与编码\"><a href=\"#2-字符集与编码\" class=\"headerlink\" title=\"2. 字符集与编码\"></a>2. 字符集与编码</h1><h5 id=\"2-1-非Unicode编码\"><a href=\"#2-1-非Unicode编码\" class=\"headerlink\" title=\"2.1 非Unicode编码\"></a>2.1 非Unicode编码</h5><ol>\n<li><strong>ASCII：</strong>覆盖键盘上的绝大多数的字符，对美国等英语国家够用；</li>\n<li><strong>ISO 8859-1：</strong> 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；</li>\n<li><strong>Windows-1252：</strong>在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；</li>\n<li><strong>GB2312：</strong>简体中文编码规范，使用两个字节表示汉字；</li>\n<li><strong>GBK：</strong>GB2312的扩充，支持更多的汉字编码；</li>\n<li><strong>GB18030：</strong>在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；</li>\n<li><strong>Big5：</strong>针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；</li>\n</ol>\n<h5 id=\"2-2-Unicode编码\"><a href=\"#2-2-Unicode编码\" class=\"headerlink\" title=\"2.2 Unicode编码\"></a>2.2 Unicode编码</h5><p>为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：</p>\n<ol>\n<li>UTF-32：字符编号的整数二进制形式，4字节</li>\n<li>UTF-16：变长字节表示，编号在U+0000~U+FFFF使用两字节；编号在U+10000~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；</li>\n<li>UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；</li>\n</ol>\n<h5 id=\"2-3-编码转换\"><a href=\"#2-3-编码转换\" class=\"headerlink\" title=\"2.3 编码转换\"></a>2.3 编码转换</h5><ol>\n<li>假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。<pre class=\"mermaid\">graph LR;\n 字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B</pre>\n\n</li>\n</ol>\n<p>编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。</p>\n<ol>\n<li>乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。</li>\n<li>乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。</li>\n<li>使用Java恢复乱码：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value to encdoe&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">newStr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(str.getBytes(<span class=\"hljs-string\">&quot;Windows-1252&quot;</span>), <span class=\"hljs-string\">&quot;GB18030&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure>"},{"title":"Java编程原理——面向对象基础","date":"2022-02-16T07:17:46.000Z","updated":"2022-02-16T07:17:46.000Z","_content":"\n# 1. 类的定义与理解\n## 1.1 容器的视角\n1. 函数是代码的容器，而类是函数的容器；\n2. 既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；\n3. 通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；\n\n## 1.2 数据类型的视角\n1. 类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；\n2. 一个表示数据类型的类可以由以下4部分构成\n- 以**类变量**体现出的类型本身具有的属性；\n- 以**类方法**体现出的类型本身具有的操作；\n- 以**实例变量**体现出的类型实例具有的属性；\n- 以**实例方法**体现出的类型实例具有的操作；\n\n```java\npublic class Point {\n    private int x; // 实例变量\n    private int y; // 实例变量\n    /* 实例方法 */\n    public double distance(){\n        return Math.sqrt(x * x + y * y);\n    }\n}\n```\n3. 通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；\n4. 一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；\n5. 静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；\n6. 构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；\n7. 一旦自定义构造函数，编译器将不再生成默认构造函数；\n\n## 1.3 私有构造函数\n使用私有构造函数存在于以下几个场景：\n1. 不能创建类的实例，类只能被静态访问；\n2. 能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；\n3. 只是用来被其他多个构造方法调用，用于减少重复代码；\n\n## 1.4 总结\n通过**类实现自定义数据类型**，封装该类型的数据所具有的属性和操作，**隐藏实现细节**，从而在更高层次（**类和对象层次**，而非基本数据类型和函数层次）上**考虑和操作数据**，是计算机程序解决复杂问题的一种重要的思维方式。\n\n## 1.5 将现实问题转化为面向对象的层次\n&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。\n\n# 2. 类的继承\n## 2.1 基本概念\n1. 使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；\n2. 不同子类的对象注重于实现自己的行为。\n\n## 2.2 有关继承的更多的细节\n1. 构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；\n2. 静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定\n3. 实例变量、静态变量、静态方法和private方法都是静态绑定的。\n4. 重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；\n\n## 2.3 类型转换与protected关键字\n1. 向上转型：子类型的对象赋值给父类型的引用变量；\n2. 向下转型：父类型的对象赋值给子类型的引用变量；\n3. protected关键字广泛用于模板方法模式中；\n4. 可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；\n5. 继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；\n\n# 3. 类加载的过程\n## 3.1 总览\n(1) 一个Java类所包含下列信息：\n- 静态变量\n- 类初始化代码\n- 静态方法\n- 实例变量\n- 实例初始化代码\n- 父类信息引用\n\n(2)类初始化代码包括\n- 定义静态变量时的赋值语句\n- 实例初始化代码块\n- 构造函数\n\n(3)类加载的过程\n- 分配内存以及保存类的信息\n- 给类变量赋默认值\n- 加载父类\n- 设置父子关系\n- 执行类初始化代码（先执行父类，再执行子类）\n\n## 3.2 对象创建的过程\n1. 每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；\n2. 寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；\n3. 动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；\n\n## 3.3 继承的破坏性——破坏封装\n1. 继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。\n2. 父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；\n3. 对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。\n\n## 3.4 继承的破坏性——没有反映\"is-a\"关系\n&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。\n\n## 3.5 最佳实践\n1. 避免使用继承——使用final关键字关闭继承；\n- 给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；\n2. 优先使用组合模式代替继承；\n- 组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；\n3. 使用接口；\n\n# 4. 接口\n## 4.1 本质\n1. 接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；\n2. 接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；\n3. 接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；\n\n## 4.2 Java 8和Java 9新增的接口函数：\n1. 新增静态方法，便于直接将函数定义在接口中；\n2. 默认方法，使用**default**关键字表示，有具体实现，引入默认方法主要是**函数式的数据处理请求**，为了给接口增加新功能；\n\n## 4.3 总结\n针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。\n\n# 5. 抽象类\n1. 相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。\n2. 抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)\n\n# 6. 内部类\n## 6.1 定义\n顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。\n\n## 6.2 内部类分类\n- 静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；\n1. Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；\n2. LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；\n3. Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；\n- 成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；\n1. Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。\n- 方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。\n\n```java\npublic class Outer {\n    public void test() {\n        final String[] str = new String[]{\"hello\"};\n        /* 方法内部类实例 */\n        class Inner {\n            public void innerMethod() {\n                str[0] = \"hello world\";\n            }\n        }\n        Inner inner = new Inner();\n        inner.innerMethod();\n        System.out.println(str[0]);\n    }\n}\n```\n- 匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。\n\n```java\npublic class Outer {\n    public void test(final int x, final int y) {\n        /* 匿名内部类示例 */\n        Point p = new Point(2, 3) {\n            @Override\n            public double distance() {\n                return distance(new Point(x, y));\n            }\n        };\n        System.out.println(p.distance());\n    }\n}\n```\nJava API使用中参见Arrays.sort函数。\n## 6.3 总结\n将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。\n\n# 7. 枚举\n## 7.1 使用枚举的好处\n1. 枚举使得语法更简洁；\n2. 枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；\n3. 枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；\n\n# 8. 异常\n## 8.1 基本概念\n1. throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；\n2. 异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。\n3. try-with-resource语法：\n\n```java\npublic static void useResource() throws Exception {\n    try(AutoClosable r = new FileInputStream(\"hello\")) { // 创建资源\n        // 使用资源\n    }\n}\n```\n4. 未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。\n\n## 8.2 异常的使用\n1. 真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；\n2. 异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；\n\n## 8.3 异常的处理逻辑\n1. 自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；\n2. 自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；\n3. 总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；\n\n## 8.4 总结\n通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。\n\n# 9. 基本类型的包装类以及String类型\n## 9.1 共性\n1. 均重写了Object类中的(equals，hashCode以及toString)方法；\n- equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；\n- hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；\n2. Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；\n3. 包装类和String\n4. 常用常量：包装类中包含一些常用的常量，例如布尔的**TRUE/FALSE**，整形中的**MIN_VALUE**和**MAX_VALUE**以及浮点中的**POSITIVE_INFINITY（正无穷）** 以及 **NEGATIVE_INFINITY（负无穷）**；\n5. 包装类中带有一个Number类型，可以返回任意基本数据类型；\n6. 不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；\n使用Immutable是因为可以使得程序更为简单和安全，在**多线程环境下不用担心数据会被篡改**；\n7. 包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；\n\n# 10. 单说String\n## 10.1 String类的一些特性\n1. String内部使用的是UTF-16BE模式编码；\n2. 同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。\n\n## 10.2 字符串常量\n1. 如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；\n2. 如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；\n\n## 10.3 StringBuilder与StringBuffer\n1. StringBuffer类是线程安全的，而StringBuilder是线程不安全的；\n2. append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。\n3. String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；\n\n# 11 Arrays类\n## 11.1 基本\n1. sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；\n2. Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；\n3. 总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。\n\n## 11.2 查找\n1. Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：\n```java\n// 针对基本类型\npublic static int binarySearch(int[] a, int key);\npublic static int binarySearch(int[] a, int fromIndex, int toIndex, int key);\n\n// 针对对象数组\npublic int static int binarySearch(Object[] a, Object key);\n\n// 自定义比较器\npublic static <T> int binarySearch(T[] a, T key, Comparator<? super T> c);\n```\n2. 需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；\n```java\n// 索引列表为数组下标：0, 1, 2, 3, 4\n// 插入点列表为：0, 1, 2, 3, 4\nint[] arr = {3, 5, 7, 13, 21};\nSystem.out.println(Arrays.binarySearch(arr, 3); // 0\nSystem.out.println(Arrays.binarySearch(arr, 5); // 1\nSystem.out.println(Arrays.binarySearch(arr, 7); // 2\nSystem.out.println(Arrays.binarySearch(arr, 13); // 3\nSystem.out.println(Arrays.binarySearch(arr, 21); // 4\nSystem.out.println(Arrays.binarySearch(arr, 22); // -6 (由21的插入点为5加1得到，再取负数)\nSystem.out.println(Arrays.binarySearch(arr, 2); // -1 (插在3的前面数插入点为0，再加1取负数得到)\n```\n\n3. 理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；\n\n4. 排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。\n\n# 12 时间处理\n## 12.1 基本概念：\n- 时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;\n- 时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；\n- 年历：例如中国的公历和年历、日本的农历等等；\n\n## 12.2 Java8之前的API支持\n- Date：时刻，绝对时间，与年月日无关；\n- Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；\n- TimeZone：表示时区\n- Locale：表示国家（或者地区）和语言；\n\n## 12.3 Java8之前的API局限性\n- Date中的过时方法有悖常识，因此容易被误用；\n- Calendar类操作繁琐，设计臃肿；\n- DateFormat不是线程安全的，在多线程环境中会存在问题；\n\n# 13 随机\n1. 种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；\n2. 指定种子是为了实现可重复的随机；\n","source":"_posts/java-core/ch03.md","raw":"---\ntitle: Java编程原理——面向对象基础\ndate: 2022-02-16 15:17:46\nupdated: 2022-02-16 15:17:46\ntags: Java基础\ncategories: Java\n---\n\n# 1. 类的定义与理解\n## 1.1 容器的视角\n1. 函数是代码的容器，而类是函数的容器；\n2. 既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；\n3. 通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；\n\n## 1.2 数据类型的视角\n1. 类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；\n2. 一个表示数据类型的类可以由以下4部分构成\n- 以**类变量**体现出的类型本身具有的属性；\n- 以**类方法**体现出的类型本身具有的操作；\n- 以**实例变量**体现出的类型实例具有的属性；\n- 以**实例方法**体现出的类型实例具有的操作；\n\n```java\npublic class Point {\n    private int x; // 实例变量\n    private int y; // 实例变量\n    /* 实例方法 */\n    public double distance(){\n        return Math.sqrt(x * x + y * y);\n    }\n}\n```\n3. 通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；\n4. 一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；\n5. 静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；\n6. 构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；\n7. 一旦自定义构造函数，编译器将不再生成默认构造函数；\n\n## 1.3 私有构造函数\n使用私有构造函数存在于以下几个场景：\n1. 不能创建类的实例，类只能被静态访问；\n2. 能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；\n3. 只是用来被其他多个构造方法调用，用于减少重复代码；\n\n## 1.4 总结\n通过**类实现自定义数据类型**，封装该类型的数据所具有的属性和操作，**隐藏实现细节**，从而在更高层次（**类和对象层次**，而非基本数据类型和函数层次）上**考虑和操作数据**，是计算机程序解决复杂问题的一种重要的思维方式。\n\n## 1.5 将现实问题转化为面向对象的层次\n&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。\n\n# 2. 类的继承\n## 2.1 基本概念\n1. 使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；\n2. 不同子类的对象注重于实现自己的行为。\n\n## 2.2 有关继承的更多的细节\n1. 构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；\n2. 静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定\n3. 实例变量、静态变量、静态方法和private方法都是静态绑定的。\n4. 重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；\n\n## 2.3 类型转换与protected关键字\n1. 向上转型：子类型的对象赋值给父类型的引用变量；\n2. 向下转型：父类型的对象赋值给子类型的引用变量；\n3. protected关键字广泛用于模板方法模式中；\n4. 可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；\n5. 继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；\n\n# 3. 类加载的过程\n## 3.1 总览\n(1) 一个Java类所包含下列信息：\n- 静态变量\n- 类初始化代码\n- 静态方法\n- 实例变量\n- 实例初始化代码\n- 父类信息引用\n\n(2)类初始化代码包括\n- 定义静态变量时的赋值语句\n- 实例初始化代码块\n- 构造函数\n\n(3)类加载的过程\n- 分配内存以及保存类的信息\n- 给类变量赋默认值\n- 加载父类\n- 设置父子关系\n- 执行类初始化代码（先执行父类，再执行子类）\n\n## 3.2 对象创建的过程\n1. 每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；\n2. 寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；\n3. 动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；\n\n## 3.3 继承的破坏性——破坏封装\n1. 继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。\n2. 父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；\n3. 对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。\n\n## 3.4 继承的破坏性——没有反映\"is-a\"关系\n&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。\n\n## 3.5 最佳实践\n1. 避免使用继承——使用final关键字关闭继承；\n- 给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；\n2. 优先使用组合模式代替继承；\n- 组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；\n3. 使用接口；\n\n# 4. 接口\n## 4.1 本质\n1. 接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；\n2. 接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；\n3. 接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；\n\n## 4.2 Java 8和Java 9新增的接口函数：\n1. 新增静态方法，便于直接将函数定义在接口中；\n2. 默认方法，使用**default**关键字表示，有具体实现，引入默认方法主要是**函数式的数据处理请求**，为了给接口增加新功能；\n\n## 4.3 总结\n针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。\n\n# 5. 抽象类\n1. 相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。\n2. 抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)\n\n# 6. 内部类\n## 6.1 定义\n顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。\n\n## 6.2 内部类分类\n- 静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；\n1. Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；\n2. LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；\n3. Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；\n- 成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；\n1. Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。\n- 方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。\n\n```java\npublic class Outer {\n    public void test() {\n        final String[] str = new String[]{\"hello\"};\n        /* 方法内部类实例 */\n        class Inner {\n            public void innerMethod() {\n                str[0] = \"hello world\";\n            }\n        }\n        Inner inner = new Inner();\n        inner.innerMethod();\n        System.out.println(str[0]);\n    }\n}\n```\n- 匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。\n\n```java\npublic class Outer {\n    public void test(final int x, final int y) {\n        /* 匿名内部类示例 */\n        Point p = new Point(2, 3) {\n            @Override\n            public double distance() {\n                return distance(new Point(x, y));\n            }\n        };\n        System.out.println(p.distance());\n    }\n}\n```\nJava API使用中参见Arrays.sort函数。\n## 6.3 总结\n将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。\n\n# 7. 枚举\n## 7.1 使用枚举的好处\n1. 枚举使得语法更简洁；\n2. 枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；\n3. 枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；\n\n# 8. 异常\n## 8.1 基本概念\n1. throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；\n2. 异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。\n3. try-with-resource语法：\n\n```java\npublic static void useResource() throws Exception {\n    try(AutoClosable r = new FileInputStream(\"hello\")) { // 创建资源\n        // 使用资源\n    }\n}\n```\n4. 未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。\n\n## 8.2 异常的使用\n1. 真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；\n2. 异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；\n\n## 8.3 异常的处理逻辑\n1. 自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；\n2. 自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；\n3. 总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；\n\n## 8.4 总结\n通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。\n\n# 9. 基本类型的包装类以及String类型\n## 9.1 共性\n1. 均重写了Object类中的(equals，hashCode以及toString)方法；\n- equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；\n- hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；\n2. Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；\n3. 包装类和String\n4. 常用常量：包装类中包含一些常用的常量，例如布尔的**TRUE/FALSE**，整形中的**MIN_VALUE**和**MAX_VALUE**以及浮点中的**POSITIVE_INFINITY（正无穷）** 以及 **NEGATIVE_INFINITY（负无穷）**；\n5. 包装类中带有一个Number类型，可以返回任意基本数据类型；\n6. 不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；\n使用Immutable是因为可以使得程序更为简单和安全，在**多线程环境下不用担心数据会被篡改**；\n7. 包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；\n\n# 10. 单说String\n## 10.1 String类的一些特性\n1. String内部使用的是UTF-16BE模式编码；\n2. 同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。\n\n## 10.2 字符串常量\n1. 如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；\n2. 如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；\n\n## 10.3 StringBuilder与StringBuffer\n1. StringBuffer类是线程安全的，而StringBuilder是线程不安全的；\n2. append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。\n3. String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；\n\n# 11 Arrays类\n## 11.1 基本\n1. sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；\n2. Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；\n3. 总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。\n\n## 11.2 查找\n1. Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：\n```java\n// 针对基本类型\npublic static int binarySearch(int[] a, int key);\npublic static int binarySearch(int[] a, int fromIndex, int toIndex, int key);\n\n// 针对对象数组\npublic int static int binarySearch(Object[] a, Object key);\n\n// 自定义比较器\npublic static <T> int binarySearch(T[] a, T key, Comparator<? super T> c);\n```\n2. 需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；\n```java\n// 索引列表为数组下标：0, 1, 2, 3, 4\n// 插入点列表为：0, 1, 2, 3, 4\nint[] arr = {3, 5, 7, 13, 21};\nSystem.out.println(Arrays.binarySearch(arr, 3); // 0\nSystem.out.println(Arrays.binarySearch(arr, 5); // 1\nSystem.out.println(Arrays.binarySearch(arr, 7); // 2\nSystem.out.println(Arrays.binarySearch(arr, 13); // 3\nSystem.out.println(Arrays.binarySearch(arr, 21); // 4\nSystem.out.println(Arrays.binarySearch(arr, 22); // -6 (由21的插入点为5加1得到，再取负数)\nSystem.out.println(Arrays.binarySearch(arr, 2); // -1 (插在3的前面数插入点为0，再加1取负数得到)\n```\n\n3. 理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；\n\n4. 排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。\n\n# 12 时间处理\n## 12.1 基本概念：\n- 时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;\n- 时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；\n- 年历：例如中国的公历和年历、日本的农历等等；\n\n## 12.2 Java8之前的API支持\n- Date：时刻，绝对时间，与年月日无关；\n- Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；\n- TimeZone：表示时区\n- Locale：表示国家（或者地区）和语言；\n\n## 12.3 Java8之前的API局限性\n- Date中的过时方法有悖常识，因此容易被误用；\n- Calendar类操作繁琐，设计臃肿；\n- DateFormat不是线程安全的，在多线程环境中会存在问题；\n\n# 13 随机\n1. 种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；\n2. 指定种子是为了实现可重复的随机；\n","slug":"java-core/ch03","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v100074f616emlh7zp","content":"<h1 id=\"1-类的定义与理解\"><a href=\"#1-类的定义与理解\" class=\"headerlink\" title=\"1. 类的定义与理解\"></a>1. 类的定义与理解</h1><h2 id=\"1-1-容器的视角\"><a href=\"#1-1-容器的视角\" class=\"headerlink\" title=\"1.1 容器的视角\"></a>1.1 容器的视角</h2><ol>\n<li>函数是代码的容器，而类是函数的容器；</li>\n<li>既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；</li>\n<li>通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；</li>\n</ol>\n<h2 id=\"1-2-数据类型的视角\"><a href=\"#1-2-数据类型的视角\" class=\"headerlink\" title=\"1.2 数据类型的视角\"></a>1.2 数据类型的视角</h2><ol>\n<li>类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；</li>\n<li>一个表示数据类型的类可以由以下4部分构成</li>\n</ol>\n<ul>\n<li>以<strong>类变量</strong>体现出的类型本身具有的属性；</li>\n<li>以<strong>类方法</strong>体现出的类型本身具有的操作；</li>\n<li>以<strong>实例变量</strong>体现出的类型实例具有的属性；</li>\n<li>以<strong>实例方法</strong>体现出的类型实例具有的操作；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> y; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-comment\">/* 实例方法 */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> Math.sqrt(x * x + y * y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；</li>\n<li>一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；</li>\n<li>静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；</li>\n<li>构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；</li>\n<li>一旦自定义构造函数，编译器将不再生成默认构造函数；</li>\n</ol>\n<h2 id=\"1-3-私有构造函数\"><a href=\"#1-3-私有构造函数\" class=\"headerlink\" title=\"1.3 私有构造函数\"></a>1.3 私有构造函数</h2><p>使用私有构造函数存在于以下几个场景：</p>\n<ol>\n<li>不能创建类的实例，类只能被静态访问；</li>\n<li>能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；</li>\n<li>只是用来被其他多个构造方法调用，用于减少重复代码；</li>\n</ol>\n<h2 id=\"1-4-总结\"><a href=\"#1-4-总结\" class=\"headerlink\" title=\"1.4 总结\"></a>1.4 总结</h2><p>通过<strong>类实现自定义数据类型</strong>，封装该类型的数据所具有的属性和操作，<strong>隐藏实现细节</strong>，从而在更高层次（<strong>类和对象层次</strong>，而非基本数据类型和函数层次）上<strong>考虑和操作数据</strong>，是计算机程序解决复杂问题的一种重要的思维方式。</p>\n<h2 id=\"1-5-将现实问题转化为面向对象的层次\"><a href=\"#1-5-将现实问题转化为面向对象的层次\" class=\"headerlink\" title=\"1.5 将现实问题转化为面向对象的层次\"></a>1.5 将现实问题转化为面向对象的层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。</p>\n<h1 id=\"2-类的继承\"><a href=\"#2-类的继承\" class=\"headerlink\" title=\"2. 类的继承\"></a>2. 类的继承</h1><h2 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h2><ol>\n<li>使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；</li>\n<li>不同子类的对象注重于实现自己的行为。</li>\n</ol>\n<h2 id=\"2-2-有关继承的更多的细节\"><a href=\"#2-2-有关继承的更多的细节\" class=\"headerlink\" title=\"2.2 有关继承的更多的细节\"></a>2.2 有关继承的更多的细节</h2><ol>\n<li>构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；</li>\n<li>静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定</li>\n<li>实例变量、静态变量、静态方法和private方法都是静态绑定的。</li>\n<li>重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；</li>\n</ol>\n<h2 id=\"2-3-类型转换与protected关键字\"><a href=\"#2-3-类型转换与protected关键字\" class=\"headerlink\" title=\"2.3 类型转换与protected关键字\"></a>2.3 类型转换与protected关键字</h2><ol>\n<li>向上转型：子类型的对象赋值给父类型的引用变量；</li>\n<li>向下转型：父类型的对象赋值给子类型的引用变量；</li>\n<li>protected关键字广泛用于模板方法模式中；</li>\n<li>可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；</li>\n<li>继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；</li>\n</ol>\n<h1 id=\"3-类加载的过程\"><a href=\"#3-类加载的过程\" class=\"headerlink\" title=\"3. 类加载的过程\"></a>3. 类加载的过程</h1><h2 id=\"3-1-总览\"><a href=\"#3-1-总览\" class=\"headerlink\" title=\"3.1 总览\"></a>3.1 总览</h2><p>(1) 一个Java类所包含下列信息：</p>\n<ul>\n<li>静态变量</li>\n<li>类初始化代码</li>\n<li>静态方法</li>\n<li>实例变量</li>\n<li>实例初始化代码</li>\n<li>父类信息引用</li>\n</ul>\n<p>(2)类初始化代码包括</p>\n<ul>\n<li>定义静态变量时的赋值语句</li>\n<li>实例初始化代码块</li>\n<li>构造函数</li>\n</ul>\n<p>(3)类加载的过程</p>\n<ul>\n<li>分配内存以及保存类的信息</li>\n<li>给类变量赋默认值</li>\n<li>加载父类</li>\n<li>设置父子关系</li>\n<li>执行类初始化代码（先执行父类，再执行子类）</li>\n</ul>\n<h2 id=\"3-2-对象创建的过程\"><a href=\"#3-2-对象创建的过程\" class=\"headerlink\" title=\"3.2 对象创建的过程\"></a>3.2 对象创建的过程</h2><ol>\n<li>每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；</li>\n<li>寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；</li>\n<li>动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；</li>\n</ol>\n<h2 id=\"3-3-继承的破坏性——破坏封装\"><a href=\"#3-3-继承的破坏性——破坏封装\" class=\"headerlink\" title=\"3.3 继承的破坏性——破坏封装\"></a>3.3 继承的破坏性——破坏封装</h2><ol>\n<li>继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。</li>\n<li>父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；</li>\n<li>对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</li>\n</ol>\n<h2 id=\"3-4-继承的破坏性——没有反映”is-a”关系\"><a href=\"#3-4-继承的破坏性——没有反映”is-a”关系\" class=\"headerlink\" title=\"3.4 继承的破坏性——没有反映”is-a”关系\"></a>3.4 继承的破坏性——没有反映”is-a”关系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。</p>\n<h2 id=\"3-5-最佳实践\"><a href=\"#3-5-最佳实践\" class=\"headerlink\" title=\"3.5 最佳实践\"></a>3.5 最佳实践</h2><ol>\n<li>避免使用继承——使用final关键字关闭继承；</li>\n</ol>\n<ul>\n<li>给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；</li>\n</ul>\n<ol>\n<li>优先使用组合模式代替继承；</li>\n</ol>\n<ul>\n<li>组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；</li>\n</ul>\n<ol>\n<li>使用接口；</li>\n</ol>\n<h1 id=\"4-接口\"><a href=\"#4-接口\" class=\"headerlink\" title=\"4. 接口\"></a>4. 接口</h1><h2 id=\"4-1-本质\"><a href=\"#4-1-本质\" class=\"headerlink\" title=\"4.1 本质\"></a>4.1 本质</h2><ol>\n<li>接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；</li>\n<li>接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；</li>\n<li>接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；</li>\n</ol>\n<h2 id=\"4-2-Java-8和Java-9新增的接口函数：\"><a href=\"#4-2-Java-8和Java-9新增的接口函数：\" class=\"headerlink\" title=\"4.2 Java 8和Java 9新增的接口函数：\"></a>4.2 Java 8和Java 9新增的接口函数：</h2><ol>\n<li>新增静态方法，便于直接将函数定义在接口中；</li>\n<li>默认方法，使用<strong>default</strong>关键字表示，有具体实现，引入默认方法主要是<strong>函数式的数据处理请求</strong>，为了给接口增加新功能；</li>\n</ol>\n<h2 id=\"4-3-总结\"><a href=\"#4-3-总结\" class=\"headerlink\" title=\"4.3 总结\"></a>4.3 总结</h2><p>针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。</p>\n<h1 id=\"5-抽象类\"><a href=\"#5-抽象类\" class=\"headerlink\" title=\"5. 抽象类\"></a>5. 抽象类</h1><ol>\n<li>相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。</li>\n<li>抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)</li>\n</ol>\n<h1 id=\"6-内部类\"><a href=\"#6-内部类\" class=\"headerlink\" title=\"6. 内部类\"></a>6. 内部类</h1><h2 id=\"6-1-定义\"><a href=\"#6-1-定义\" class=\"headerlink\" title=\"6.1 定义\"></a>6.1 定义</h2><p>顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。</p>\n<h2 id=\"6-2-内部类分类\"><a href=\"#6-2-内部类分类\" class=\"headerlink\" title=\"6.2 内部类分类\"></a>6.2 内部类分类</h2><ul>\n<li>静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；</li>\n</ul>\n<ol>\n<li>Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；</li>\n<li>LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；</li>\n<li>Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；</li>\n</ol>\n<ul>\n<li>成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；</li>\n</ul>\n<ol>\n<li>Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。</li>\n</ol>\n<ul>\n<li>方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> String[] str = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello&quot;</span>&#125;;<br>        <span class=\"hljs-comment\">/* 方法内部类实例 */</span><br>        <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Inner</span> &#123;<br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">innerMethod</span><span class=\"hljs-params\">()</span> &#123;<br>                str[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">Inner</span> <span class=\"hljs-variable\">inner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Inner</span>();<br>        inner.innerMethod();<br>        System.out.println(str[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> x, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> y)</span> &#123;<br>        <span class=\"hljs-comment\">/* 匿名内部类示例 */</span><br>        <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> distance(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(x, y));<br>            &#125;<br>        &#125;;<br>        System.out.println(p.distance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Java API使用中参见Arrays.sort函数。</p>\n<h2 id=\"6-3-总结\"><a href=\"#6-3-总结\" class=\"headerlink\" title=\"6.3 总结\"></a>6.3 总结</h2><p>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。</p>\n<h1 id=\"7-枚举\"><a href=\"#7-枚举\" class=\"headerlink\" title=\"7. 枚举\"></a>7. 枚举</h1><h2 id=\"7-1-使用枚举的好处\"><a href=\"#7-1-使用枚举的好处\" class=\"headerlink\" title=\"7.1 使用枚举的好处\"></a>7.1 使用枚举的好处</h2><ol>\n<li>枚举使得语法更简洁；</li>\n<li>枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；</li>\n<li>枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；</li>\n</ol>\n<h1 id=\"8-异常\"><a href=\"#8-异常\" class=\"headerlink\" title=\"8. 异常\"></a>8. 异常</h1><h2 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h2><ol>\n<li>throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；</li>\n<li>异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。</li>\n<li>try-with-resource语法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useResource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>    <span class=\"hljs-keyword\">try</span>(<span class=\"hljs-type\">AutoClosable</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>)) &#123; <span class=\"hljs-comment\">// 创建资源</span><br>        <span class=\"hljs-comment\">// 使用资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。</li>\n</ol>\n<h2 id=\"8-2-异常的使用\"><a href=\"#8-2-异常的使用\" class=\"headerlink\" title=\"8.2 异常的使用\"></a>8.2 异常的使用</h2><ol>\n<li>真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；</li>\n<li>异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；</li>\n</ol>\n<h2 id=\"8-3-异常的处理逻辑\"><a href=\"#8-3-异常的处理逻辑\" class=\"headerlink\" title=\"8.3 异常的处理逻辑\"></a>8.3 异常的处理逻辑</h2><ol>\n<li>自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；</li>\n<li>自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；</li>\n<li>总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；</li>\n</ol>\n<h2 id=\"8-4-总结\"><a href=\"#8-4-总结\" class=\"headerlink\" title=\"8.4 总结\"></a>8.4 总结</h2><p>通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。</p>\n<h1 id=\"9-基本类型的包装类以及String类型\"><a href=\"#9-基本类型的包装类以及String类型\" class=\"headerlink\" title=\"9. 基本类型的包装类以及String类型\"></a>9. 基本类型的包装类以及String类型</h1><h2 id=\"9-1-共性\"><a href=\"#9-1-共性\" class=\"headerlink\" title=\"9.1 共性\"></a>9.1 共性</h2><ol>\n<li>均重写了Object类中的(equals，hashCode以及toString)方法；</li>\n</ol>\n<ul>\n<li>equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；</li>\n<li>hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；</li>\n</ul>\n<ol>\n<li>Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；</li>\n<li>包装类和String</li>\n<li>常用常量：包装类中包含一些常用的常量，例如布尔的<strong>TRUE/FALSE</strong>，整形中的<strong>MIN_VALUE</strong>和<strong>MAX_VALUE</strong>以及浮点中的<strong>POSITIVE_INFINITY（正无穷）</strong> 以及 <strong>NEGATIVE_INFINITY（负无穷）</strong>；</li>\n<li>包装类中带有一个Number类型，可以返回任意基本数据类型；</li>\n<li>不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；<br>使用Immutable是因为可以使得程序更为简单和安全，在<strong>多线程环境下不用担心数据会被篡改</strong>；</li>\n<li>包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；</li>\n</ol>\n<h1 id=\"10-单说String\"><a href=\"#10-单说String\" class=\"headerlink\" title=\"10. 单说String\"></a>10. 单说String</h1><h2 id=\"10-1-String类的一些特性\"><a href=\"#10-1-String类的一些特性\" class=\"headerlink\" title=\"10.1 String类的一些特性\"></a>10.1 String类的一些特性</h2><ol>\n<li>String内部使用的是UTF-16BE模式编码；</li>\n<li>同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。</li>\n</ol>\n<h2 id=\"10-2-字符串常量\"><a href=\"#10-2-字符串常量\" class=\"headerlink\" title=\"10.2 字符串常量\"></a>10.2 字符串常量</h2><ol>\n<li>如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；</li>\n<li>如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；</li>\n</ol>\n<h2 id=\"10-3-StringBuilder与StringBuffer\"><a href=\"#10-3-StringBuilder与StringBuffer\" class=\"headerlink\" title=\"10.3 StringBuilder与StringBuffer\"></a>10.3 StringBuilder与StringBuffer</h2><ol>\n<li>StringBuffer类是线程安全的，而StringBuilder是线程不安全的；</li>\n<li>append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。</li>\n<li>String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；</li>\n</ol>\n<h1 id=\"11-Arrays类\"><a href=\"#11-Arrays类\" class=\"headerlink\" title=\"11 Arrays类\"></a>11 Arrays类</h1><h2 id=\"11-1-基本\"><a href=\"#11-1-基本\" class=\"headerlink\" title=\"11.1 基本\"></a>11.1 基本</h2><ol>\n<li>sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；</li>\n<li>Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；</li>\n<li>总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。</li>\n</ol>\n<h2 id=\"11-2-查找\"><a href=\"#11-2-查找\" class=\"headerlink\" title=\"11.2 查找\"></a>11.2 查找</h2><ol>\n<li>Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 针对基本类型</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> key)</span>;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> fromIndex, <span class=\"hljs-type\">int</span> toIndex, <span class=\"hljs-type\">int</span> key)</span>;<br><br><span class=\"hljs-comment\">// 针对对象数组</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(Object[] a, Object key)</span>;<br><br><span class=\"hljs-comment\">// 自定义比较器</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(T[] a, T key, Comparator&lt;? <span class=\"hljs-built_in\">super</span> T&gt; c)</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 索引列表为数组下标：0, 1, 2, 3, 4</span><br><span class=\"hljs-comment\">// 插入点列表为：0, 1, 2, 3, 4</span><br><span class=\"hljs-type\">int</span>[] arr = &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">21</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 0</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 1</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 2</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">13</span>); <span class=\"hljs-comment\">// 3</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">21</span>); <span class=\"hljs-comment\">// 4</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">22</span>); <span class=\"hljs-comment\">// -6 (由21的插入点为5加1得到，再取负数)</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// -1 (插在3的前面数插入点为0，再加1取负数得到)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；</p>\n</li>\n<li><p>排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。</p>\n</li>\n</ol>\n<h1 id=\"12-时间处理\"><a href=\"#12-时间处理\" class=\"headerlink\" title=\"12 时间处理\"></a>12 时间处理</h1><h2 id=\"12-1-基本概念：\"><a href=\"#12-1-基本概念：\" class=\"headerlink\" title=\"12.1 基本概念：\"></a>12.1 基本概念：</h2><ul>\n<li>时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;</li>\n<li>时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；</li>\n<li>年历：例如中国的公历和年历、日本的农历等等；</li>\n</ul>\n<h2 id=\"12-2-Java8之前的API支持\"><a href=\"#12-2-Java8之前的API支持\" class=\"headerlink\" title=\"12.2 Java8之前的API支持\"></a>12.2 Java8之前的API支持</h2><ul>\n<li>Date：时刻，绝对时间，与年月日无关；</li>\n<li>Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；</li>\n<li>TimeZone：表示时区</li>\n<li>Locale：表示国家（或者地区）和语言；</li>\n</ul>\n<h2 id=\"12-3-Java8之前的API局限性\"><a href=\"#12-3-Java8之前的API局限性\" class=\"headerlink\" title=\"12.3 Java8之前的API局限性\"></a>12.3 Java8之前的API局限性</h2><ul>\n<li>Date中的过时方法有悖常识，因此容易被误用；</li>\n<li>Calendar类操作繁琐，设计臃肿；</li>\n<li>DateFormat不是线程安全的，在多线程环境中会存在问题；</li>\n</ul>\n<h1 id=\"13-随机\"><a href=\"#13-随机\" class=\"headerlink\" title=\"13 随机\"></a>13 随机</h1><ol>\n<li>种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；</li>\n<li>指定种子是为了实现可重复的随机；</li>\n</ol>\n","site":{"data":{}},"wordcount":7748,"excerpt":"","more":"<h1 id=\"1-类的定义与理解\"><a href=\"#1-类的定义与理解\" class=\"headerlink\" title=\"1. 类的定义与理解\"></a>1. 类的定义与理解</h1><h2 id=\"1-1-容器的视角\"><a href=\"#1-1-容器的视角\" class=\"headerlink\" title=\"1.1 容器的视角\"></a>1.1 容器的视角</h2><ol>\n<li>函数是代码的容器，而类是函数的容器；</li>\n<li>既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；</li>\n<li>通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；</li>\n</ol>\n<h2 id=\"1-2-数据类型的视角\"><a href=\"#1-2-数据类型的视角\" class=\"headerlink\" title=\"1.2 数据类型的视角\"></a>1.2 数据类型的视角</h2><ol>\n<li>类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；</li>\n<li>一个表示数据类型的类可以由以下4部分构成</li>\n</ol>\n<ul>\n<li>以<strong>类变量</strong>体现出的类型本身具有的属性；</li>\n<li>以<strong>类方法</strong>体现出的类型本身具有的操作；</li>\n<li>以<strong>实例变量</strong>体现出的类型实例具有的属性；</li>\n<li>以<strong>实例方法</strong>体现出的类型实例具有的操作；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> y; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-comment\">/* 实例方法 */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> Math.sqrt(x * x + y * y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；</li>\n<li>一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；</li>\n<li>静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；</li>\n<li>构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；</li>\n<li>一旦自定义构造函数，编译器将不再生成默认构造函数；</li>\n</ol>\n<h2 id=\"1-3-私有构造函数\"><a href=\"#1-3-私有构造函数\" class=\"headerlink\" title=\"1.3 私有构造函数\"></a>1.3 私有构造函数</h2><p>使用私有构造函数存在于以下几个场景：</p>\n<ol>\n<li>不能创建类的实例，类只能被静态访问；</li>\n<li>能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；</li>\n<li>只是用来被其他多个构造方法调用，用于减少重复代码；</li>\n</ol>\n<h2 id=\"1-4-总结\"><a href=\"#1-4-总结\" class=\"headerlink\" title=\"1.4 总结\"></a>1.4 总结</h2><p>通过<strong>类实现自定义数据类型</strong>，封装该类型的数据所具有的属性和操作，<strong>隐藏实现细节</strong>，从而在更高层次（<strong>类和对象层次</strong>，而非基本数据类型和函数层次）上<strong>考虑和操作数据</strong>，是计算机程序解决复杂问题的一种重要的思维方式。</p>\n<h2 id=\"1-5-将现实问题转化为面向对象的层次\"><a href=\"#1-5-将现实问题转化为面向对象的层次\" class=\"headerlink\" title=\"1.5 将现实问题转化为面向对象的层次\"></a>1.5 将现实问题转化为面向对象的层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。</p>\n<h1 id=\"2-类的继承\"><a href=\"#2-类的继承\" class=\"headerlink\" title=\"2. 类的继承\"></a>2. 类的继承</h1><h2 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h2><ol>\n<li>使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；</li>\n<li>不同子类的对象注重于实现自己的行为。</li>\n</ol>\n<h2 id=\"2-2-有关继承的更多的细节\"><a href=\"#2-2-有关继承的更多的细节\" class=\"headerlink\" title=\"2.2 有关继承的更多的细节\"></a>2.2 有关继承的更多的细节</h2><ol>\n<li>构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；</li>\n<li>静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定</li>\n<li>实例变量、静态变量、静态方法和private方法都是静态绑定的。</li>\n<li>重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；</li>\n</ol>\n<h2 id=\"2-3-类型转换与protected关键字\"><a href=\"#2-3-类型转换与protected关键字\" class=\"headerlink\" title=\"2.3 类型转换与protected关键字\"></a>2.3 类型转换与protected关键字</h2><ol>\n<li>向上转型：子类型的对象赋值给父类型的引用变量；</li>\n<li>向下转型：父类型的对象赋值给子类型的引用变量；</li>\n<li>protected关键字广泛用于模板方法模式中；</li>\n<li>可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；</li>\n<li>继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；</li>\n</ol>\n<h1 id=\"3-类加载的过程\"><a href=\"#3-类加载的过程\" class=\"headerlink\" title=\"3. 类加载的过程\"></a>3. 类加载的过程</h1><h2 id=\"3-1-总览\"><a href=\"#3-1-总览\" class=\"headerlink\" title=\"3.1 总览\"></a>3.1 总览</h2><p>(1) 一个Java类所包含下列信息：</p>\n<ul>\n<li>静态变量</li>\n<li>类初始化代码</li>\n<li>静态方法</li>\n<li>实例变量</li>\n<li>实例初始化代码</li>\n<li>父类信息引用</li>\n</ul>\n<p>(2)类初始化代码包括</p>\n<ul>\n<li>定义静态变量时的赋值语句</li>\n<li>实例初始化代码块</li>\n<li>构造函数</li>\n</ul>\n<p>(3)类加载的过程</p>\n<ul>\n<li>分配内存以及保存类的信息</li>\n<li>给类变量赋默认值</li>\n<li>加载父类</li>\n<li>设置父子关系</li>\n<li>执行类初始化代码（先执行父类，再执行子类）</li>\n</ul>\n<h2 id=\"3-2-对象创建的过程\"><a href=\"#3-2-对象创建的过程\" class=\"headerlink\" title=\"3.2 对象创建的过程\"></a>3.2 对象创建的过程</h2><ol>\n<li>每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；</li>\n<li>寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；</li>\n<li>动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；</li>\n</ol>\n<h2 id=\"3-3-继承的破坏性——破坏封装\"><a href=\"#3-3-继承的破坏性——破坏封装\" class=\"headerlink\" title=\"3.3 继承的破坏性——破坏封装\"></a>3.3 继承的破坏性——破坏封装</h2><ol>\n<li>继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。</li>\n<li>父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；</li>\n<li>对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</li>\n</ol>\n<h2 id=\"3-4-继承的破坏性——没有反映”is-a”关系\"><a href=\"#3-4-继承的破坏性——没有反映”is-a”关系\" class=\"headerlink\" title=\"3.4 继承的破坏性——没有反映”is-a”关系\"></a>3.4 继承的破坏性——没有反映”is-a”关系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。</p>\n<h2 id=\"3-5-最佳实践\"><a href=\"#3-5-最佳实践\" class=\"headerlink\" title=\"3.5 最佳实践\"></a>3.5 最佳实践</h2><ol>\n<li>避免使用继承——使用final关键字关闭继承；</li>\n</ol>\n<ul>\n<li>给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；</li>\n</ul>\n<ol>\n<li>优先使用组合模式代替继承；</li>\n</ol>\n<ul>\n<li>组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；</li>\n</ul>\n<ol>\n<li>使用接口；</li>\n</ol>\n<h1 id=\"4-接口\"><a href=\"#4-接口\" class=\"headerlink\" title=\"4. 接口\"></a>4. 接口</h1><h2 id=\"4-1-本质\"><a href=\"#4-1-本质\" class=\"headerlink\" title=\"4.1 本质\"></a>4.1 本质</h2><ol>\n<li>接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；</li>\n<li>接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；</li>\n<li>接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；</li>\n</ol>\n<h2 id=\"4-2-Java-8和Java-9新增的接口函数：\"><a href=\"#4-2-Java-8和Java-9新增的接口函数：\" class=\"headerlink\" title=\"4.2 Java 8和Java 9新增的接口函数：\"></a>4.2 Java 8和Java 9新增的接口函数：</h2><ol>\n<li>新增静态方法，便于直接将函数定义在接口中；</li>\n<li>默认方法，使用<strong>default</strong>关键字表示，有具体实现，引入默认方法主要是<strong>函数式的数据处理请求</strong>，为了给接口增加新功能；</li>\n</ol>\n<h2 id=\"4-3-总结\"><a href=\"#4-3-总结\" class=\"headerlink\" title=\"4.3 总结\"></a>4.3 总结</h2><p>针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。</p>\n<h1 id=\"5-抽象类\"><a href=\"#5-抽象类\" class=\"headerlink\" title=\"5. 抽象类\"></a>5. 抽象类</h1><ol>\n<li>相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。</li>\n<li>抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)</li>\n</ol>\n<h1 id=\"6-内部类\"><a href=\"#6-内部类\" class=\"headerlink\" title=\"6. 内部类\"></a>6. 内部类</h1><h2 id=\"6-1-定义\"><a href=\"#6-1-定义\" class=\"headerlink\" title=\"6.1 定义\"></a>6.1 定义</h2><p>顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。</p>\n<h2 id=\"6-2-内部类分类\"><a href=\"#6-2-内部类分类\" class=\"headerlink\" title=\"6.2 内部类分类\"></a>6.2 内部类分类</h2><ul>\n<li>静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；</li>\n</ul>\n<ol>\n<li>Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；</li>\n<li>LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；</li>\n<li>Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；</li>\n</ol>\n<ul>\n<li>成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；</li>\n</ul>\n<ol>\n<li>Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。</li>\n</ol>\n<ul>\n<li>方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> String[] str = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello&quot;</span>&#125;;<br>        <span class=\"hljs-comment\">/* 方法内部类实例 */</span><br>        <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Inner</span> &#123;<br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">innerMethod</span><span class=\"hljs-params\">()</span> &#123;<br>                str[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">Inner</span> <span class=\"hljs-variable\">inner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Inner</span>();<br>        inner.innerMethod();<br>        System.out.println(str[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> x, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> y)</span> &#123;<br>        <span class=\"hljs-comment\">/* 匿名内部类示例 */</span><br>        <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> distance(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(x, y));<br>            &#125;<br>        &#125;;<br>        System.out.println(p.distance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Java API使用中参见Arrays.sort函数。</p>\n<h2 id=\"6-3-总结\"><a href=\"#6-3-总结\" class=\"headerlink\" title=\"6.3 总结\"></a>6.3 总结</h2><p>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。</p>\n<h1 id=\"7-枚举\"><a href=\"#7-枚举\" class=\"headerlink\" title=\"7. 枚举\"></a>7. 枚举</h1><h2 id=\"7-1-使用枚举的好处\"><a href=\"#7-1-使用枚举的好处\" class=\"headerlink\" title=\"7.1 使用枚举的好处\"></a>7.1 使用枚举的好处</h2><ol>\n<li>枚举使得语法更简洁；</li>\n<li>枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；</li>\n<li>枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；</li>\n</ol>\n<h1 id=\"8-异常\"><a href=\"#8-异常\" class=\"headerlink\" title=\"8. 异常\"></a>8. 异常</h1><h2 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h2><ol>\n<li>throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；</li>\n<li>异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。</li>\n<li>try-with-resource语法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useResource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>    <span class=\"hljs-keyword\">try</span>(<span class=\"hljs-type\">AutoClosable</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>)) &#123; <span class=\"hljs-comment\">// 创建资源</span><br>        <span class=\"hljs-comment\">// 使用资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。</li>\n</ol>\n<h2 id=\"8-2-异常的使用\"><a href=\"#8-2-异常的使用\" class=\"headerlink\" title=\"8.2 异常的使用\"></a>8.2 异常的使用</h2><ol>\n<li>真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；</li>\n<li>异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；</li>\n</ol>\n<h2 id=\"8-3-异常的处理逻辑\"><a href=\"#8-3-异常的处理逻辑\" class=\"headerlink\" title=\"8.3 异常的处理逻辑\"></a>8.3 异常的处理逻辑</h2><ol>\n<li>自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；</li>\n<li>自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；</li>\n<li>总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；</li>\n</ol>\n<h2 id=\"8-4-总结\"><a href=\"#8-4-总结\" class=\"headerlink\" title=\"8.4 总结\"></a>8.4 总结</h2><p>通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。</p>\n<h1 id=\"9-基本类型的包装类以及String类型\"><a href=\"#9-基本类型的包装类以及String类型\" class=\"headerlink\" title=\"9. 基本类型的包装类以及String类型\"></a>9. 基本类型的包装类以及String类型</h1><h2 id=\"9-1-共性\"><a href=\"#9-1-共性\" class=\"headerlink\" title=\"9.1 共性\"></a>9.1 共性</h2><ol>\n<li>均重写了Object类中的(equals，hashCode以及toString)方法；</li>\n</ol>\n<ul>\n<li>equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；</li>\n<li>hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；</li>\n</ul>\n<ol>\n<li>Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；</li>\n<li>包装类和String</li>\n<li>常用常量：包装类中包含一些常用的常量，例如布尔的<strong>TRUE/FALSE</strong>，整形中的<strong>MIN_VALUE</strong>和<strong>MAX_VALUE</strong>以及浮点中的<strong>POSITIVE_INFINITY（正无穷）</strong> 以及 <strong>NEGATIVE_INFINITY（负无穷）</strong>；</li>\n<li>包装类中带有一个Number类型，可以返回任意基本数据类型；</li>\n<li>不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；<br>使用Immutable是因为可以使得程序更为简单和安全，在<strong>多线程环境下不用担心数据会被篡改</strong>；</li>\n<li>包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；</li>\n</ol>\n<h1 id=\"10-单说String\"><a href=\"#10-单说String\" class=\"headerlink\" title=\"10. 单说String\"></a>10. 单说String</h1><h2 id=\"10-1-String类的一些特性\"><a href=\"#10-1-String类的一些特性\" class=\"headerlink\" title=\"10.1 String类的一些特性\"></a>10.1 String类的一些特性</h2><ol>\n<li>String内部使用的是UTF-16BE模式编码；</li>\n<li>同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。</li>\n</ol>\n<h2 id=\"10-2-字符串常量\"><a href=\"#10-2-字符串常量\" class=\"headerlink\" title=\"10.2 字符串常量\"></a>10.2 字符串常量</h2><ol>\n<li>如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；</li>\n<li>如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；</li>\n</ol>\n<h2 id=\"10-3-StringBuilder与StringBuffer\"><a href=\"#10-3-StringBuilder与StringBuffer\" class=\"headerlink\" title=\"10.3 StringBuilder与StringBuffer\"></a>10.3 StringBuilder与StringBuffer</h2><ol>\n<li>StringBuffer类是线程安全的，而StringBuilder是线程不安全的；</li>\n<li>append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。</li>\n<li>String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；</li>\n</ol>\n<h1 id=\"11-Arrays类\"><a href=\"#11-Arrays类\" class=\"headerlink\" title=\"11 Arrays类\"></a>11 Arrays类</h1><h2 id=\"11-1-基本\"><a href=\"#11-1-基本\" class=\"headerlink\" title=\"11.1 基本\"></a>11.1 基本</h2><ol>\n<li>sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；</li>\n<li>Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；</li>\n<li>总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。</li>\n</ol>\n<h2 id=\"11-2-查找\"><a href=\"#11-2-查找\" class=\"headerlink\" title=\"11.2 查找\"></a>11.2 查找</h2><ol>\n<li>Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 针对基本类型</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> key)</span>;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> fromIndex, <span class=\"hljs-type\">int</span> toIndex, <span class=\"hljs-type\">int</span> key)</span>;<br><br><span class=\"hljs-comment\">// 针对对象数组</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(Object[] a, Object key)</span>;<br><br><span class=\"hljs-comment\">// 自定义比较器</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(T[] a, T key, Comparator&lt;? <span class=\"hljs-built_in\">super</span> T&gt; c)</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 索引列表为数组下标：0, 1, 2, 3, 4</span><br><span class=\"hljs-comment\">// 插入点列表为：0, 1, 2, 3, 4</span><br><span class=\"hljs-type\">int</span>[] arr = &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">21</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 0</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 1</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 2</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">13</span>); <span class=\"hljs-comment\">// 3</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">21</span>); <span class=\"hljs-comment\">// 4</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">22</span>); <span class=\"hljs-comment\">// -6 (由21的插入点为5加1得到，再取负数)</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// -1 (插在3的前面数插入点为0，再加1取负数得到)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；</p>\n</li>\n<li><p>排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。</p>\n</li>\n</ol>\n<h1 id=\"12-时间处理\"><a href=\"#12-时间处理\" class=\"headerlink\" title=\"12 时间处理\"></a>12 时间处理</h1><h2 id=\"12-1-基本概念：\"><a href=\"#12-1-基本概念：\" class=\"headerlink\" title=\"12.1 基本概念：\"></a>12.1 基本概念：</h2><ul>\n<li>时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;</li>\n<li>时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；</li>\n<li>年历：例如中国的公历和年历、日本的农历等等；</li>\n</ul>\n<h2 id=\"12-2-Java8之前的API支持\"><a href=\"#12-2-Java8之前的API支持\" class=\"headerlink\" title=\"12.2 Java8之前的API支持\"></a>12.2 Java8之前的API支持</h2><ul>\n<li>Date：时刻，绝对时间，与年月日无关；</li>\n<li>Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；</li>\n<li>TimeZone：表示时区</li>\n<li>Locale：表示国家（或者地区）和语言；</li>\n</ul>\n<h2 id=\"12-3-Java8之前的API局限性\"><a href=\"#12-3-Java8之前的API局限性\" class=\"headerlink\" title=\"12.3 Java8之前的API局限性\"></a>12.3 Java8之前的API局限性</h2><ul>\n<li>Date中的过时方法有悖常识，因此容易被误用；</li>\n<li>Calendar类操作繁琐，设计臃肿；</li>\n<li>DateFormat不是线程安全的，在多线程环境中会存在问题；</li>\n</ul>\n<h1 id=\"13-随机\"><a href=\"#13-随机\" class=\"headerlink\" title=\"13 随机\"></a>13 随机</h1><ol>\n<li>种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；</li>\n<li>指定种子是为了实现可重复的随机；</li>\n</ol>\n"},{"title":"Java编程原理——泛型和容器","date":"2022-02-16T11:52:26.000Z","updated":"2022-02-16T11:52:26.000Z","_content":"\n# 1 泛型\n\n## 1.1 基本概念\n\n1. 泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；\n2. Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；\n3. 泛型可以指定上限为某个具体类，例如：\n\n```java\npublic class NumberPair<U extends Number, V extends Number> extends Pair<U, V>{\n    public NumberPair(U first, V second) {\n        super(first, second);\n    }\n}\n```\n\n1. 除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；\n2. 总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。\n\n\n\n## 1.2 通配符解析\n\n1. 参数类型限定通配符写法。例如：public void addAll(DynamicArray<? extends E> c), **<? exntends E>也称为有限定通配符**；\n2. 与之相对应的就为无限定通配符，具体为：Dynamic<?>，更简洁的写法就为<T>\n3. 但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；\n4. 通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；\n5. 通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；\n6. 如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；\n7. 通配符形式和类型参数往往配合使用；\n\n\n\n## 1.3 超类型通配符\n\n1. 形式：<? super E>，用于表示E的某个父类类型；\n2. 使用场景：对于有限通配符形式<? extends E>在无法满足工作需要时，可以使用<? super E>代替；\n3. <? super E>用于灵活写入或比较，<?>或<? exntends E>用于灵活读取；\n\n\n\n## 1.4 局限性\n\n1. 基本类型不能用于实例化类型参数；\n2. 运行时类型信息不适用泛型；\n3. 类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；\n4. 不能通过类型参数创建对象；\n5. 泛型类类型参数不能用于创建静态变量和方法；\n6. 不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；\n7. 如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；\n8. 泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；\n\n\n\n# 2 列表和队列\n\n## 2.1 ArrayList\n\n1. ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；\n2. ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；\n3. 迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。\n\n```java\n/* 错误写法 */\npublic void remove(ArrayList<Integer> list) {\n    for (Integer a : list) {\n        if (a < 100) {\n            list.remove(a); // 恐抛出ConcurrentModificationException\n        }\n    }\n}\n\n/* 正确写法 */\npublic void remove(ArrayList<Integer> list) {\n    Iterator<Integer> it = list.iterator();\n    while(it.hasNext()) {\n        if (it.next() < 100) {\n            it.remove();\n        }\n    }\n}\n```\n\n1. 使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。\n2. ArrayList的特点\n\n+ 随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；\n+ 除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；\n+ 添加数组元素的效率为O(N)；\n+ 插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；\n+ 需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；\n\n\n\n## 2.2 LinkedList\n\n1. LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；\n2. LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"a\");\nqueue.offer(\"b\");\nqueue.offer(\"c\");\nwhile(queue.peek() != null) {\n    System.out.println(queue.poll());\n}\n```\n\n1. LinkedList也可以当作栈使用，示例如下：\n\n```java\nDeque<String> stack = new LinkedList<>();\nstack.push(\"a\");\nstack.push(\"b\");\nstack.push(\"c\");\nwhile(stack.peek() != null) {\n    System.out.println(stack.pop());\n}\n```\n\n1. LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；\n2. LinkedList的特点如下：\n\n+ 按需分配空间，不需要预先分配很多空间；\n+ 不可随机访问，按照索引位置访问效率较低；\n+ 无论列表是否有序，按内容查找都需要逐个查找；\n+ 在两端进行添加、删除操作效率很高；\n\n\n\n## 2.3 ArrayDeque\n\n1. ArrayDeque是基于数组实现的双端队列\n2. ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。\n3. 由于是双端队列因此具备下列特点：\n\n+ 在两端添加和删除的效率很高；\n+ 根据元素的内容查找和删除的效率很低；\n+ 与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。\n\n\n\n# 3 Map和Set\n\n## 3.1 HashMap\n\n1. 创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12\n2. 创建Map保存数据的几个步骤分别为：\n\n+ (1) 计算键的哈希值；\n+ (2) 根据哈希值得到保存位置（取模）；\n+ (3) 插到对应位置的链表表头或者更新已有值；\n+ (4) 根据扩展table大小，注意这里的table是Entry类型；\n\n1. 总结HashMap的实现原理\n\n+ HashMap内部有一个哈希表，每个元素指向一个单链表；\n+ 根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；\n+ 存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较\n+ HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；\n+ HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；\n\n\n\n## 3.2 HashSet\n\n1. Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；\n2. HashSet有下列应用场景\n\n+ 排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；\n+ 保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；\n+ 集合运算：方便进行数学中的交集以及并集的集合运算；\n\n1. HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；\n2. 总结HashSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效的添加、删除元素、判断元素是否存在；\n+ 没有顺序；\n\n\n\n## 3.3 TreeMap或TreeSet\n\n1. 与HashMap无序相对比，TreeMap是有序的。\n2. TreeMap内部使用的是[红黑树](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin)实现的；\n3. TreeMap的特点如下\n\n+ 按键有序：可以很方便地根据键的顺序进行查找\n+ 为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；\n+ 根据键值保存、查找、删除的效率比较高；\n\n1. 总结TreeSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效地添加、删除元素、判断元素是否存在；\n+ 有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；\n\n\n\n## 3.4 LinkedHashMap\n\n1. LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；\n2. LinkedHashMap是有序的，例子如下(插入顺序)：\n\n```java\nMap<String, Integer> seqMap = new LinkedHashMap<>();\nseqMap.put(\"c\", 100);\nseqMap.put(\"d\", 200);\nseqMap.put(\"a\", 500);\nseqMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : seqMap.entrySet()) {\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is :\nc 100\nd 300\na 500\n*/\n```\n\n1. LinkedHashMap的访问顺序：\n\n```java\nMap<String, Integer> accessMap = new LinkedHashMap<>(16, 0.75, true);\naccessMap.put(\"c\", 100);\naccessMap.put(\"d\", 200);\naccessMap.put(\"a\", 500);\naccessMap.get(\"c\");\naccessMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : accessMap.getEntrySet()){\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is : \na 500\nc 100\nd 300\n*/\n```\n\n1. LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：\n\n```java\n// 实现代码\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private int maxEntries;\n    public LRUCache(int maxEntries) {\n        super(16, 0.75f, true);\n        this.maxEntries = maxEntries;\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Entry<K, V> eldest) {\n        return size() > maxEntries;\n    }\n}\n// 使用示例\nLRUCache<String, Object> cache = new LRUCache<>(3);\ncache.put(\"a\", \"abstract\");\ncache.put(\"b\", \"basic\");\ncache.put(\"c\", \"call\");\ncache.get(\"a\");\ncache.put(\"d\", \"call\");\nSystem.out.println(cache);\n\n// 输出结果\n{c=call, a=abstract, d=call}\n```\n\n\n\n## 3.5 EnumMap\n\n1. 键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；\n2. EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：\n\n```java\npublic enum Size {\n    SMALL, MEDIUM, LARGE\n}\n\npublic class Clothes {\n    String id;\n    Size size;\n}\n\npublic static Map<Size, Integer> countBySize(List<Clothes> clothes) {\n    Map<Size, Integer> map = new EnumMap<>(Size.class);\n    for (Clothes c : clothes) {\n        Size size = c.getSize();\n        Integer count = map.get(size);\n        if (count != null) {\n            map.put(size, count + 1);\n        } else {\n            map.put(size, 1);\n        }\n    }\n    return map;\n}\n```\n\n1. EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。\n2. EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；\n3. 位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。\n4. 对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。\n\n\n\n# 4 堆与优先级队列\n\n## 4.1 完全二叉树\n\n1. 完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其**父节点**和**孩子节点**的编号。**例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 \\* i，右孩子节点编号为2 \\* i + 1;**\n2. 基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；\n\n\n\n## 4.2 PriorityQueue\n\n1. PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：\n\n```java\nstatic class Task {\n    int priority; // 数值越大，优先级越高\n    String name; // 表示任务的名称\n    \n    private static Comparator<Task> taskComparator = new Comparator() {\n        @Override\n        public int compare(Task o1, Task o2) {\n            if (o1.getPriority() > o2.getPriority()) {\n                return -1;\n            } else if (o1.getPriority() < o2.getPriority()){\n                return 1;\n            }\n            return 0;\n        }\n    }\n}\n\nQueue<Task> tasks = new Priority<>(11, taskComparator);\ntasks.offer(new Task(20, \"写日记\"));\ntasks.offer(new Task(10, \"看电视\"));\ntasks.offer(new Task(100, \"写代码\"));\nTask task = tasks.poll();\nwhile (task != null) {\n    System.out.print(\"处理任务：\" + task.getName() + \", 优先级：\" + task.getPriority());\n    task = tasks.poll();\n}\n// 结果如下：\n处理任务：写代码，优先级：100\n处理任务：写日记，优先级：20\n处理任务：看电视，优先级：10\n```\n\n1. PriorityQueue有如下特点：\n\n+ 实现了优先级队列，最先出队的总是优先级最高的；\n+ 优先级相同时，内部元素不完全有序；\n+ 查询头部元素效率很高，入队、出队效率很高；\n+ 根据值查找和删除元素效率很低\n+ 具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；\n\n\n\n# 5 通用容器类\n\n1. Collections提供了很多针对容器接口的通用算法和功能；\n2. 容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；\n3. 容器类中运用了大量的适配器模式\n\n+ 空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）\n+ 单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）\n+ 其他适配方法，例如将Map转换为Set等。\n\n1. 基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；\n","source":"_posts/java-core/ch04.md","raw":"---\ntitle: Java编程原理——泛型和容器\ndate: 2022-02-16 19:52:26\nupdated: 2022-02-16 19:52:26\ntags: Java基础\ncategories: Java\n---\n\n# 1 泛型\n\n## 1.1 基本概念\n\n1. 泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；\n2. Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；\n3. 泛型可以指定上限为某个具体类，例如：\n\n```java\npublic class NumberPair<U extends Number, V extends Number> extends Pair<U, V>{\n    public NumberPair(U first, V second) {\n        super(first, second);\n    }\n}\n```\n\n1. 除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；\n2. 总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。\n\n\n\n## 1.2 通配符解析\n\n1. 参数类型限定通配符写法。例如：public void addAll(DynamicArray<? extends E> c), **<? exntends E>也称为有限定通配符**；\n2. 与之相对应的就为无限定通配符，具体为：Dynamic<?>，更简洁的写法就为<T>\n3. 但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；\n4. 通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；\n5. 通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；\n6. 如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；\n7. 通配符形式和类型参数往往配合使用；\n\n\n\n## 1.3 超类型通配符\n\n1. 形式：<? super E>，用于表示E的某个父类类型；\n2. 使用场景：对于有限通配符形式<? extends E>在无法满足工作需要时，可以使用<? super E>代替；\n3. <? super E>用于灵活写入或比较，<?>或<? exntends E>用于灵活读取；\n\n\n\n## 1.4 局限性\n\n1. 基本类型不能用于实例化类型参数；\n2. 运行时类型信息不适用泛型；\n3. 类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；\n4. 不能通过类型参数创建对象；\n5. 泛型类类型参数不能用于创建静态变量和方法；\n6. 不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；\n7. 如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；\n8. 泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；\n\n\n\n# 2 列表和队列\n\n## 2.1 ArrayList\n\n1. ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；\n2. ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；\n3. 迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。\n\n```java\n/* 错误写法 */\npublic void remove(ArrayList<Integer> list) {\n    for (Integer a : list) {\n        if (a < 100) {\n            list.remove(a); // 恐抛出ConcurrentModificationException\n        }\n    }\n}\n\n/* 正确写法 */\npublic void remove(ArrayList<Integer> list) {\n    Iterator<Integer> it = list.iterator();\n    while(it.hasNext()) {\n        if (it.next() < 100) {\n            it.remove();\n        }\n    }\n}\n```\n\n1. 使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。\n2. ArrayList的特点\n\n+ 随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；\n+ 除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；\n+ 添加数组元素的效率为O(N)；\n+ 插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；\n+ 需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；\n\n\n\n## 2.2 LinkedList\n\n1. LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；\n2. LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"a\");\nqueue.offer(\"b\");\nqueue.offer(\"c\");\nwhile(queue.peek() != null) {\n    System.out.println(queue.poll());\n}\n```\n\n1. LinkedList也可以当作栈使用，示例如下：\n\n```java\nDeque<String> stack = new LinkedList<>();\nstack.push(\"a\");\nstack.push(\"b\");\nstack.push(\"c\");\nwhile(stack.peek() != null) {\n    System.out.println(stack.pop());\n}\n```\n\n1. LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；\n2. LinkedList的特点如下：\n\n+ 按需分配空间，不需要预先分配很多空间；\n+ 不可随机访问，按照索引位置访问效率较低；\n+ 无论列表是否有序，按内容查找都需要逐个查找；\n+ 在两端进行添加、删除操作效率很高；\n\n\n\n## 2.3 ArrayDeque\n\n1. ArrayDeque是基于数组实现的双端队列\n2. ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。\n3. 由于是双端队列因此具备下列特点：\n\n+ 在两端添加和删除的效率很高；\n+ 根据元素的内容查找和删除的效率很低；\n+ 与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。\n\n\n\n# 3 Map和Set\n\n## 3.1 HashMap\n\n1. 创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12\n2. 创建Map保存数据的几个步骤分别为：\n\n+ (1) 计算键的哈希值；\n+ (2) 根据哈希值得到保存位置（取模）；\n+ (3) 插到对应位置的链表表头或者更新已有值；\n+ (4) 根据扩展table大小，注意这里的table是Entry类型；\n\n1. 总结HashMap的实现原理\n\n+ HashMap内部有一个哈希表，每个元素指向一个单链表；\n+ 根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；\n+ 存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较\n+ HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；\n+ HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；\n\n\n\n## 3.2 HashSet\n\n1. Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；\n2. HashSet有下列应用场景\n\n+ 排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；\n+ 保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；\n+ 集合运算：方便进行数学中的交集以及并集的集合运算；\n\n1. HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；\n2. 总结HashSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效的添加、删除元素、判断元素是否存在；\n+ 没有顺序；\n\n\n\n## 3.3 TreeMap或TreeSet\n\n1. 与HashMap无序相对比，TreeMap是有序的。\n2. TreeMap内部使用的是[红黑树](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin)实现的；\n3. TreeMap的特点如下\n\n+ 按键有序：可以很方便地根据键的顺序进行查找\n+ 为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；\n+ 根据键值保存、查找、删除的效率比较高；\n\n1. 总结TreeSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效地添加、删除元素、判断元素是否存在；\n+ 有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；\n\n\n\n## 3.4 LinkedHashMap\n\n1. LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；\n2. LinkedHashMap是有序的，例子如下(插入顺序)：\n\n```java\nMap<String, Integer> seqMap = new LinkedHashMap<>();\nseqMap.put(\"c\", 100);\nseqMap.put(\"d\", 200);\nseqMap.put(\"a\", 500);\nseqMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : seqMap.entrySet()) {\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is :\nc 100\nd 300\na 500\n*/\n```\n\n1. LinkedHashMap的访问顺序：\n\n```java\nMap<String, Integer> accessMap = new LinkedHashMap<>(16, 0.75, true);\naccessMap.put(\"c\", 100);\naccessMap.put(\"d\", 200);\naccessMap.put(\"a\", 500);\naccessMap.get(\"c\");\naccessMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : accessMap.getEntrySet()){\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is : \na 500\nc 100\nd 300\n*/\n```\n\n1. LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：\n\n```java\n// 实现代码\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private int maxEntries;\n    public LRUCache(int maxEntries) {\n        super(16, 0.75f, true);\n        this.maxEntries = maxEntries;\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Entry<K, V> eldest) {\n        return size() > maxEntries;\n    }\n}\n// 使用示例\nLRUCache<String, Object> cache = new LRUCache<>(3);\ncache.put(\"a\", \"abstract\");\ncache.put(\"b\", \"basic\");\ncache.put(\"c\", \"call\");\ncache.get(\"a\");\ncache.put(\"d\", \"call\");\nSystem.out.println(cache);\n\n// 输出结果\n{c=call, a=abstract, d=call}\n```\n\n\n\n## 3.5 EnumMap\n\n1. 键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；\n2. EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：\n\n```java\npublic enum Size {\n    SMALL, MEDIUM, LARGE\n}\n\npublic class Clothes {\n    String id;\n    Size size;\n}\n\npublic static Map<Size, Integer> countBySize(List<Clothes> clothes) {\n    Map<Size, Integer> map = new EnumMap<>(Size.class);\n    for (Clothes c : clothes) {\n        Size size = c.getSize();\n        Integer count = map.get(size);\n        if (count != null) {\n            map.put(size, count + 1);\n        } else {\n            map.put(size, 1);\n        }\n    }\n    return map;\n}\n```\n\n1. EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。\n2. EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；\n3. 位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。\n4. 对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。\n\n\n\n# 4 堆与优先级队列\n\n## 4.1 完全二叉树\n\n1. 完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其**父节点**和**孩子节点**的编号。**例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 \\* i，右孩子节点编号为2 \\* i + 1;**\n2. 基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；\n\n\n\n## 4.2 PriorityQueue\n\n1. PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：\n\n```java\nstatic class Task {\n    int priority; // 数值越大，优先级越高\n    String name; // 表示任务的名称\n    \n    private static Comparator<Task> taskComparator = new Comparator() {\n        @Override\n        public int compare(Task o1, Task o2) {\n            if (o1.getPriority() > o2.getPriority()) {\n                return -1;\n            } else if (o1.getPriority() < o2.getPriority()){\n                return 1;\n            }\n            return 0;\n        }\n    }\n}\n\nQueue<Task> tasks = new Priority<>(11, taskComparator);\ntasks.offer(new Task(20, \"写日记\"));\ntasks.offer(new Task(10, \"看电视\"));\ntasks.offer(new Task(100, \"写代码\"));\nTask task = tasks.poll();\nwhile (task != null) {\n    System.out.print(\"处理任务：\" + task.getName() + \", 优先级：\" + task.getPriority());\n    task = tasks.poll();\n}\n// 结果如下：\n处理任务：写代码，优先级：100\n处理任务：写日记，优先级：20\n处理任务：看电视，优先级：10\n```\n\n1. PriorityQueue有如下特点：\n\n+ 实现了优先级队列，最先出队的总是优先级最高的；\n+ 优先级相同时，内部元素不完全有序；\n+ 查询头部元素效率很高，入队、出队效率很高；\n+ 根据值查找和删除元素效率很低\n+ 具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；\n\n\n\n# 5 通用容器类\n\n1. Collections提供了很多针对容器接口的通用算法和功能；\n2. 容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；\n3. 容器类中运用了大量的适配器模式\n\n+ 空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）\n+ 单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）\n+ 其他适配方法，例如将Map转换为Set等。\n\n1. 基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；\n","slug":"java-core/ch04","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v100084f614a7y9f4o","content":"<h1 id=\"1-泛型\"><a href=\"#1-泛型\" class=\"headerlink\" title=\"1 泛型\"></a>1 泛型</h1><h2 id=\"1-1-基本概念\"><a href=\"#1-1-基本概念\" class=\"headerlink\" title=\"1.1 基本概念\"></a>1.1 基本概念</h2><ol>\n<li>泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；</li>\n<li>Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；</li>\n<li>泛型可以指定上限为某个具体类，例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NumberPair</span>&lt;U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>, V <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Pair</span>&lt;U, V&gt;&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">NumberPair</span><span class=\"hljs-params\">(U first, V second)</span> &#123;<br>        <span class=\"hljs-built_in\">super</span>(first, second);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；</li>\n<li>总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。</li>\n</ol>\n<h2 id=\"1-2-通配符解析\"><a href=\"#1-2-通配符解析\" class=\"headerlink\" title=\"1.2 通配符解析\"></a>1.2 通配符解析</h2><ol>\n<li>参数类型限定通配符写法。例如：public void addAll(DynamicArray&lt;? extends E&gt; c), <strong>&lt;? exntends E&gt;也称为有限定通配符</strong>；</li>\n<li>与之相对应的就为无限定通配符，具体为：Dynamic&lt;?&gt;，更简洁的写法就为<T></li>\n<li>但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；</li>\n<li>通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；</li>\n<li>通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；</li>\n<li>如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；</li>\n<li>通配符形式和类型参数往往配合使用；</li>\n</ol>\n<h2 id=\"1-3-超类型通配符\"><a href=\"#1-3-超类型通配符\" class=\"headerlink\" title=\"1.3 超类型通配符\"></a>1.3 超类型通配符</h2><ol>\n<li>形式：&lt;? super E&gt;，用于表示E的某个父类类型；</li>\n<li>使用场景：对于有限通配符形式&lt;? extends E&gt;在无法满足工作需要时，可以使用&lt;? super E&gt;代替；</li>\n<li>&lt;? super E&gt;用于灵活写入或比较，&lt;?&gt;或&lt;? exntends E&gt;用于灵活读取；</li>\n</ol>\n<h2 id=\"1-4-局限性\"><a href=\"#1-4-局限性\" class=\"headerlink\" title=\"1.4 局限性\"></a>1.4 局限性</h2><ol>\n<li>基本类型不能用于实例化类型参数；</li>\n<li>运行时类型信息不适用泛型；</li>\n<li>类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；</li>\n<li>不能通过类型参数创建对象；</li>\n<li>泛型类类型参数不能用于创建静态变量和方法；</li>\n<li>不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；</li>\n<li>如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；</li>\n<li>泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；</li>\n</ol>\n<h1 id=\"2-列表和队列\"><a href=\"#2-列表和队列\" class=\"headerlink\" title=\"2 列表和队列\"></a>2 列表和队列</h1><h2 id=\"2-1-ArrayList\"><a href=\"#2-1-ArrayList\" class=\"headerlink\" title=\"2.1 ArrayList\"></a>2.1 ArrayList</h2><ol>\n<li>ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；</li>\n<li>ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；</li>\n<li>迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/* 错误写法 */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>    <span class=\"hljs-keyword\">for</span> (Integer a : list) &#123;<br>        <span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            list.remove(a); <span class=\"hljs-comment\">// 恐抛出ConcurrentModificationException</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 正确写法 */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>    Iterator&lt;Integer&gt; it = list.iterator();<br>    <span class=\"hljs-keyword\">while</span>(it.hasNext()) &#123;<br>        <span class=\"hljs-keyword\">if</span> (it.next() &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。</li>\n<li>ArrayList的特点</li>\n</ol>\n<ul>\n<li>随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；</li>\n<li>除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；</li>\n<li>添加数组元素的效率为O(N)；</li>\n<li>插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；</li>\n<li>需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；</li>\n</ul>\n<h2 id=\"2-2-LinkedList\"><a href=\"#2-2-LinkedList\" class=\"headerlink\" title=\"2.2 LinkedList\"></a>2.2 LinkedList</h2><ol>\n<li>LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；</li>\n<li>LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Queue&lt;String&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>queue.offer(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>queue.offer(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>queue.offer(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(queue.peek() != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList也可以当作栈使用，示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Deque&lt;String&gt; stack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>stack.push(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>stack.push(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>stack.push(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(stack.peek() != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.println(stack.pop());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；</li>\n<li>LinkedList的特点如下：</li>\n</ol>\n<ul>\n<li>按需分配空间，不需要预先分配很多空间；</li>\n<li>不可随机访问，按照索引位置访问效率较低；</li>\n<li>无论列表是否有序，按内容查找都需要逐个查找；</li>\n<li>在两端进行添加、删除操作效率很高；</li>\n</ul>\n<h2 id=\"2-3-ArrayDeque\"><a href=\"#2-3-ArrayDeque\" class=\"headerlink\" title=\"2.3 ArrayDeque\"></a>2.3 ArrayDeque</h2><ol>\n<li>ArrayDeque是基于数组实现的双端队列</li>\n<li>ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。</li>\n<li>由于是双端队列因此具备下列特点：</li>\n</ol>\n<ul>\n<li>在两端添加和删除的效率很高；</li>\n<li>根据元素的内容查找和删除的效率很低；</li>\n<li>与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。</li>\n</ul>\n<h1 id=\"3-Map和Set\"><a href=\"#3-Map和Set\" class=\"headerlink\" title=\"3 Map和Set\"></a>3 Map和Set</h1><h2 id=\"3-1-HashMap\"><a href=\"#3-1-HashMap\" class=\"headerlink\" title=\"3.1 HashMap\"></a>3.1 HashMap</h2><ol>\n<li>创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12</li>\n<li>创建Map保存数据的几个步骤分别为：</li>\n</ol>\n<ul>\n<li>(1) 计算键的哈希值；</li>\n<li>(2) 根据哈希值得到保存位置（取模）；</li>\n<li>(3) 插到对应位置的链表表头或者更新已有值；</li>\n<li>(4) 根据扩展table大小，注意这里的table是Entry类型；</li>\n</ul>\n<ol>\n<li>总结HashMap的实现原理</li>\n</ol>\n<ul>\n<li>HashMap内部有一个哈希表，每个元素指向一个单链表；</li>\n<li>根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；</li>\n<li>存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较</li>\n<li>HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；</li>\n<li>HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ol>\n<li>Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；</li>\n<li>HashSet有下列应用场景</li>\n</ol>\n<ul>\n<li>排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；</li>\n<li>保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；</li>\n<li>集合运算：方便进行数学中的交集以及并集的集合运算；</li>\n</ul>\n<ol>\n<li>HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；</li>\n<li>总结HashSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效的添加、删除元素、判断元素是否存在；</li>\n<li>没有顺序；</li>\n</ul>\n<h2 id=\"3-3-TreeMap或TreeSet\"><a href=\"#3-3-TreeMap或TreeSet\" class=\"headerlink\" title=\"3.3 TreeMap或TreeSet\"></a>3.3 TreeMap或TreeSet</h2><ol>\n<li>与HashMap无序相对比，TreeMap是有序的。</li>\n<li>TreeMap内部使用的是<a href=\"https://baike.baidu.com/item/红黑树/2413209?fr=aladdin\">红黑树</a>实现的；</li>\n<li>TreeMap的特点如下</li>\n</ol>\n<ul>\n<li>按键有序：可以很方便地根据键的顺序进行查找</li>\n<li>为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；</li>\n<li>根据键值保存、查找、删除的效率比较高；</li>\n</ul>\n<ol>\n<li>总结TreeSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效地添加、删除元素、判断元素是否存在；</li>\n<li>有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；</li>\n</ul>\n<h2 id=\"3-4-LinkedHashMap\"><a href=\"#3-4-LinkedHashMap\" class=\"headerlink\" title=\"3.4 LinkedHashMap\"></a>3.4 LinkedHashMap</h2><ol>\n<li>LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；</li>\n<li>LinkedHashMap是有序的，例子如下(插入顺序)：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Integer&gt; seqMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;();<br>seqMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (Entry&lt;String, Integer&gt; entry : seqMap.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + entry.getValue());<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Result is :</span><br><span class=\"hljs-comment\">c 100</span><br><span class=\"hljs-comment\">d 300</span><br><span class=\"hljs-comment\">a 500</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap的访问顺序：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Integer&gt; accessMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75</span>, <span class=\"hljs-literal\">true</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>accessMap.get(<span class=\"hljs-string\">&quot;c&quot;</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (Entry&lt;String, Integer&gt; entry : accessMap.getEntrySet())&#123;<br>    System.out.println(entry.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + entry.getValue());<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Result is : </span><br><span class=\"hljs-comment\">a 500</span><br><span class=\"hljs-comment\">c 100</span><br><span class=\"hljs-comment\">d 300</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 实现代码</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> maxEntries;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">LRUCache</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> maxEntries)</span> &#123;<br>        <span class=\"hljs-built_in\">super</span>(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75f</span>, <span class=\"hljs-literal\">true</span>);<br>        <span class=\"hljs-built_in\">this</span>.maxEntries = maxEntries;<br>    &#125;<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">removeEldestEntry</span><span class=\"hljs-params\">(Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> size() &gt; maxEntries;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 使用示例</span><br>LRUCache&lt;String, Object&gt; cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LRUCache</span>&lt;&gt;(<span class=\"hljs-number\">3</span>);<br>cache.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>cache.get(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>System.out.println(cache);<br><br><span class=\"hljs-comment\">// 输出结果</span><br>&#123;c=call, a=<span class=\"hljs-keyword\">abstract</span>, d=call&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-5-EnumMap\"><a href=\"#3-5-EnumMap\" class=\"headerlink\" title=\"3.5 EnumMap\"></a>3.5 EnumMap</h2><ol>\n<li>键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；</li>\n<li>EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Size</span> &#123;<br>    SMALL, MEDIUM, LARGE<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clothes</span> &#123;<br>    String id;<br>    Size size;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Map&lt;Size, Integer&gt; <span class=\"hljs-title function_\">countBySize</span><span class=\"hljs-params\">(List&lt;Clothes&gt; clothes)</span> &#123;<br>    Map&lt;Size, Integer&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumMap</span>&lt;&gt;(Size.class);<br>    <span class=\"hljs-keyword\">for</span> (Clothes c : clothes) &#123;<br>        <span class=\"hljs-type\">Size</span> <span class=\"hljs-variable\">size</span> <span class=\"hljs-operator\">=</span> c.getSize();<br>        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> map.get(size);<br>        <span class=\"hljs-keyword\">if</span> (count != <span class=\"hljs-literal\">null</span>) &#123;<br>            map.put(size, count + <span class=\"hljs-number\">1</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            map.put(size, <span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。</li>\n<li>EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；</li>\n<li>位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。</li>\n<li>对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。</li>\n</ol>\n<h1 id=\"4-堆与优先级队列\"><a href=\"#4-堆与优先级队列\" class=\"headerlink\" title=\"4 堆与优先级队列\"></a>4 堆与优先级队列</h1><h2 id=\"4-1-完全二叉树\"><a href=\"#4-1-完全二叉树\" class=\"headerlink\" title=\"4.1 完全二叉树\"></a>4.1 完全二叉树</h2><ol>\n<li>完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其<strong>父节点</strong>和<strong>孩子节点</strong>的编号。<strong>例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 * i，右孩子节点编号为2 * i + 1;</strong></li>\n<li>基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；</li>\n</ol>\n<h2 id=\"4-2-PriorityQueue\"><a href=\"#4-2-PriorityQueue\" class=\"headerlink\" title=\"4.2 PriorityQueue\"></a>4.2 PriorityQueue</h2><ol>\n<li>PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Task</span> &#123;<br>    <span class=\"hljs-type\">int</span> priority; <span class=\"hljs-comment\">// 数值越大，优先级越高</span><br>    String name; <span class=\"hljs-comment\">// 表示任务的名称</span><br>    <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Comparator&lt;Task&gt; taskComparator = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Comparator</span>() &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">compare</span><span class=\"hljs-params\">(Task o1, Task o2)</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> (o1.getPriority() &gt; o2.getPriority()) &#123;<br>                <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (o1.getPriority() &lt; o2.getPriority())&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Queue&lt;Task&gt; tasks = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Priority</span>&lt;&gt;(<span class=\"hljs-number\">11</span>, taskComparator);<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">&quot;写日记&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&quot;看电视&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">&quot;写代码&quot;</span>));<br><span class=\"hljs-type\">Task</span> <span class=\"hljs-variable\">task</span> <span class=\"hljs-operator\">=</span> tasks.poll();<br><span class=\"hljs-keyword\">while</span> (task != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.print(<span class=\"hljs-string\">&quot;处理任务：&quot;</span> + task.getName() + <span class=\"hljs-string\">&quot;, 优先级：&quot;</span> + task.getPriority());<br>    task = tasks.poll();<br>&#125;<br><span class=\"hljs-comment\">// 结果如下：</span><br>处理任务：写代码，优先级：<span class=\"hljs-number\">100</span><br>处理任务：写日记，优先级：<span class=\"hljs-number\">20</span><br>处理任务：看电视，优先级：<span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>PriorityQueue有如下特点：</li>\n</ol>\n<ul>\n<li>实现了优先级队列，最先出队的总是优先级最高的；</li>\n<li>优先级相同时，内部元素不完全有序；</li>\n<li>查询头部元素效率很高，入队、出队效率很高；</li>\n<li>根据值查找和删除元素效率很低</li>\n<li>具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；</li>\n</ul>\n<h1 id=\"5-通用容器类\"><a href=\"#5-通用容器类\" class=\"headerlink\" title=\"5 通用容器类\"></a>5 通用容器类</h1><ol>\n<li>Collections提供了很多针对容器接口的通用算法和功能；</li>\n<li>容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；</li>\n<li>容器类中运用了大量的适配器模式</li>\n</ol>\n<ul>\n<li>空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）</li>\n<li>单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）</li>\n<li>其他适配方法，例如将Map转换为Set等。</li>\n</ul>\n<ol>\n<li>基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；</li>\n</ol>\n","site":{"data":{}},"wordcount":7864,"excerpt":"","more":"<h1 id=\"1-泛型\"><a href=\"#1-泛型\" class=\"headerlink\" title=\"1 泛型\"></a>1 泛型</h1><h2 id=\"1-1-基本概念\"><a href=\"#1-1-基本概念\" class=\"headerlink\" title=\"1.1 基本概念\"></a>1.1 基本概念</h2><ol>\n<li>泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；</li>\n<li>Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；</li>\n<li>泛型可以指定上限为某个具体类，例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NumberPair</span>&lt;U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>, V <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Pair</span>&lt;U, V&gt;&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">NumberPair</span><span class=\"hljs-params\">(U first, V second)</span> &#123;<br>        <span class=\"hljs-built_in\">super</span>(first, second);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；</li>\n<li>总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。</li>\n</ol>\n<h2 id=\"1-2-通配符解析\"><a href=\"#1-2-通配符解析\" class=\"headerlink\" title=\"1.2 通配符解析\"></a>1.2 通配符解析</h2><ol>\n<li>参数类型限定通配符写法。例如：public void addAll(DynamicArray&lt;? extends E&gt; c), <strong>&lt;? exntends E&gt;也称为有限定通配符</strong>；</li>\n<li>与之相对应的就为无限定通配符，具体为：Dynamic&lt;?&gt;，更简洁的写法就为<T></li>\n<li>但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；</li>\n<li>通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；</li>\n<li>通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；</li>\n<li>如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；</li>\n<li>通配符形式和类型参数往往配合使用；</li>\n</ol>\n<h2 id=\"1-3-超类型通配符\"><a href=\"#1-3-超类型通配符\" class=\"headerlink\" title=\"1.3 超类型通配符\"></a>1.3 超类型通配符</h2><ol>\n<li>形式：&lt;? super E&gt;，用于表示E的某个父类类型；</li>\n<li>使用场景：对于有限通配符形式&lt;? extends E&gt;在无法满足工作需要时，可以使用&lt;? super E&gt;代替；</li>\n<li>&lt;? super E&gt;用于灵活写入或比较，&lt;?&gt;或&lt;? exntends E&gt;用于灵活读取；</li>\n</ol>\n<h2 id=\"1-4-局限性\"><a href=\"#1-4-局限性\" class=\"headerlink\" title=\"1.4 局限性\"></a>1.4 局限性</h2><ol>\n<li>基本类型不能用于实例化类型参数；</li>\n<li>运行时类型信息不适用泛型；</li>\n<li>类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；</li>\n<li>不能通过类型参数创建对象；</li>\n<li>泛型类类型参数不能用于创建静态变量和方法；</li>\n<li>不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；</li>\n<li>如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；</li>\n<li>泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；</li>\n</ol>\n<h1 id=\"2-列表和队列\"><a href=\"#2-列表和队列\" class=\"headerlink\" title=\"2 列表和队列\"></a>2 列表和队列</h1><h2 id=\"2-1-ArrayList\"><a href=\"#2-1-ArrayList\" class=\"headerlink\" title=\"2.1 ArrayList\"></a>2.1 ArrayList</h2><ol>\n<li>ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；</li>\n<li>ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；</li>\n<li>迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/* 错误写法 */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>    <span class=\"hljs-keyword\">for</span> (Integer a : list) &#123;<br>        <span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            list.remove(a); <span class=\"hljs-comment\">// 恐抛出ConcurrentModificationException</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 正确写法 */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>    Iterator&lt;Integer&gt; it = list.iterator();<br>    <span class=\"hljs-keyword\">while</span>(it.hasNext()) &#123;<br>        <span class=\"hljs-keyword\">if</span> (it.next() &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。</li>\n<li>ArrayList的特点</li>\n</ol>\n<ul>\n<li>随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；</li>\n<li>除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；</li>\n<li>添加数组元素的效率为O(N)；</li>\n<li>插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；</li>\n<li>需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；</li>\n</ul>\n<h2 id=\"2-2-LinkedList\"><a href=\"#2-2-LinkedList\" class=\"headerlink\" title=\"2.2 LinkedList\"></a>2.2 LinkedList</h2><ol>\n<li>LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；</li>\n<li>LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Queue&lt;String&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>queue.offer(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>queue.offer(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>queue.offer(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(queue.peek() != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList也可以当作栈使用，示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Deque&lt;String&gt; stack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>stack.push(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>stack.push(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>stack.push(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(stack.peek() != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.println(stack.pop());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；</li>\n<li>LinkedList的特点如下：</li>\n</ol>\n<ul>\n<li>按需分配空间，不需要预先分配很多空间；</li>\n<li>不可随机访问，按照索引位置访问效率较低；</li>\n<li>无论列表是否有序，按内容查找都需要逐个查找；</li>\n<li>在两端进行添加、删除操作效率很高；</li>\n</ul>\n<h2 id=\"2-3-ArrayDeque\"><a href=\"#2-3-ArrayDeque\" class=\"headerlink\" title=\"2.3 ArrayDeque\"></a>2.3 ArrayDeque</h2><ol>\n<li>ArrayDeque是基于数组实现的双端队列</li>\n<li>ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。</li>\n<li>由于是双端队列因此具备下列特点：</li>\n</ol>\n<ul>\n<li>在两端添加和删除的效率很高；</li>\n<li>根据元素的内容查找和删除的效率很低；</li>\n<li>与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。</li>\n</ul>\n<h1 id=\"3-Map和Set\"><a href=\"#3-Map和Set\" class=\"headerlink\" title=\"3 Map和Set\"></a>3 Map和Set</h1><h2 id=\"3-1-HashMap\"><a href=\"#3-1-HashMap\" class=\"headerlink\" title=\"3.1 HashMap\"></a>3.1 HashMap</h2><ol>\n<li>创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12</li>\n<li>创建Map保存数据的几个步骤分别为：</li>\n</ol>\n<ul>\n<li>(1) 计算键的哈希值；</li>\n<li>(2) 根据哈希值得到保存位置（取模）；</li>\n<li>(3) 插到对应位置的链表表头或者更新已有值；</li>\n<li>(4) 根据扩展table大小，注意这里的table是Entry类型；</li>\n</ul>\n<ol>\n<li>总结HashMap的实现原理</li>\n</ol>\n<ul>\n<li>HashMap内部有一个哈希表，每个元素指向一个单链表；</li>\n<li>根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；</li>\n<li>存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较</li>\n<li>HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；</li>\n<li>HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ol>\n<li>Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；</li>\n<li>HashSet有下列应用场景</li>\n</ol>\n<ul>\n<li>排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；</li>\n<li>保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；</li>\n<li>集合运算：方便进行数学中的交集以及并集的集合运算；</li>\n</ul>\n<ol>\n<li>HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；</li>\n<li>总结HashSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效的添加、删除元素、判断元素是否存在；</li>\n<li>没有顺序；</li>\n</ul>\n<h2 id=\"3-3-TreeMap或TreeSet\"><a href=\"#3-3-TreeMap或TreeSet\" class=\"headerlink\" title=\"3.3 TreeMap或TreeSet\"></a>3.3 TreeMap或TreeSet</h2><ol>\n<li>与HashMap无序相对比，TreeMap是有序的。</li>\n<li>TreeMap内部使用的是<a href=\"https://baike.baidu.com/item/红黑树/2413209?fr=aladdin\">红黑树</a>实现的；</li>\n<li>TreeMap的特点如下</li>\n</ol>\n<ul>\n<li>按键有序：可以很方便地根据键的顺序进行查找</li>\n<li>为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；</li>\n<li>根据键值保存、查找、删除的效率比较高；</li>\n</ul>\n<ol>\n<li>总结TreeSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效地添加、删除元素、判断元素是否存在；</li>\n<li>有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；</li>\n</ul>\n<h2 id=\"3-4-LinkedHashMap\"><a href=\"#3-4-LinkedHashMap\" class=\"headerlink\" title=\"3.4 LinkedHashMap\"></a>3.4 LinkedHashMap</h2><ol>\n<li>LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；</li>\n<li>LinkedHashMap是有序的，例子如下(插入顺序)：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Integer&gt; seqMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;();<br>seqMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (Entry&lt;String, Integer&gt; entry : seqMap.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + entry.getValue());<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Result is :</span><br><span class=\"hljs-comment\">c 100</span><br><span class=\"hljs-comment\">d 300</span><br><span class=\"hljs-comment\">a 500</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap的访问顺序：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Integer&gt; accessMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75</span>, <span class=\"hljs-literal\">true</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>accessMap.get(<span class=\"hljs-string\">&quot;c&quot;</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (Entry&lt;String, Integer&gt; entry : accessMap.getEntrySet())&#123;<br>    System.out.println(entry.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + entry.getValue());<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Result is : </span><br><span class=\"hljs-comment\">a 500</span><br><span class=\"hljs-comment\">c 100</span><br><span class=\"hljs-comment\">d 300</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 实现代码</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> maxEntries;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">LRUCache</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> maxEntries)</span> &#123;<br>        <span class=\"hljs-built_in\">super</span>(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75f</span>, <span class=\"hljs-literal\">true</span>);<br>        <span class=\"hljs-built_in\">this</span>.maxEntries = maxEntries;<br>    &#125;<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">removeEldestEntry</span><span class=\"hljs-params\">(Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> size() &gt; maxEntries;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 使用示例</span><br>LRUCache&lt;String, Object&gt; cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LRUCache</span>&lt;&gt;(<span class=\"hljs-number\">3</span>);<br>cache.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>cache.get(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>System.out.println(cache);<br><br><span class=\"hljs-comment\">// 输出结果</span><br>&#123;c=call, a=<span class=\"hljs-keyword\">abstract</span>, d=call&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-5-EnumMap\"><a href=\"#3-5-EnumMap\" class=\"headerlink\" title=\"3.5 EnumMap\"></a>3.5 EnumMap</h2><ol>\n<li>键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；</li>\n<li>EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Size</span> &#123;<br>    SMALL, MEDIUM, LARGE<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clothes</span> &#123;<br>    String id;<br>    Size size;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Map&lt;Size, Integer&gt; <span class=\"hljs-title function_\">countBySize</span><span class=\"hljs-params\">(List&lt;Clothes&gt; clothes)</span> &#123;<br>    Map&lt;Size, Integer&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumMap</span>&lt;&gt;(Size.class);<br>    <span class=\"hljs-keyword\">for</span> (Clothes c : clothes) &#123;<br>        <span class=\"hljs-type\">Size</span> <span class=\"hljs-variable\">size</span> <span class=\"hljs-operator\">=</span> c.getSize();<br>        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> map.get(size);<br>        <span class=\"hljs-keyword\">if</span> (count != <span class=\"hljs-literal\">null</span>) &#123;<br>            map.put(size, count + <span class=\"hljs-number\">1</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            map.put(size, <span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。</li>\n<li>EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；</li>\n<li>位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。</li>\n<li>对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。</li>\n</ol>\n<h1 id=\"4-堆与优先级队列\"><a href=\"#4-堆与优先级队列\" class=\"headerlink\" title=\"4 堆与优先级队列\"></a>4 堆与优先级队列</h1><h2 id=\"4-1-完全二叉树\"><a href=\"#4-1-完全二叉树\" class=\"headerlink\" title=\"4.1 完全二叉树\"></a>4.1 完全二叉树</h2><ol>\n<li>完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其<strong>父节点</strong>和<strong>孩子节点</strong>的编号。<strong>例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 * i，右孩子节点编号为2 * i + 1;</strong></li>\n<li>基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；</li>\n</ol>\n<h2 id=\"4-2-PriorityQueue\"><a href=\"#4-2-PriorityQueue\" class=\"headerlink\" title=\"4.2 PriorityQueue\"></a>4.2 PriorityQueue</h2><ol>\n<li>PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Task</span> &#123;<br>    <span class=\"hljs-type\">int</span> priority; <span class=\"hljs-comment\">// 数值越大，优先级越高</span><br>    String name; <span class=\"hljs-comment\">// 表示任务的名称</span><br>    <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Comparator&lt;Task&gt; taskComparator = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Comparator</span>() &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">compare</span><span class=\"hljs-params\">(Task o1, Task o2)</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> (o1.getPriority() &gt; o2.getPriority()) &#123;<br>                <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (o1.getPriority() &lt; o2.getPriority())&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Queue&lt;Task&gt; tasks = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Priority</span>&lt;&gt;(<span class=\"hljs-number\">11</span>, taskComparator);<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">&quot;写日记&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&quot;看电视&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">&quot;写代码&quot;</span>));<br><span class=\"hljs-type\">Task</span> <span class=\"hljs-variable\">task</span> <span class=\"hljs-operator\">=</span> tasks.poll();<br><span class=\"hljs-keyword\">while</span> (task != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.print(<span class=\"hljs-string\">&quot;处理任务：&quot;</span> + task.getName() + <span class=\"hljs-string\">&quot;, 优先级：&quot;</span> + task.getPriority());<br>    task = tasks.poll();<br>&#125;<br><span class=\"hljs-comment\">// 结果如下：</span><br>处理任务：写代码，优先级：<span class=\"hljs-number\">100</span><br>处理任务：写日记，优先级：<span class=\"hljs-number\">20</span><br>处理任务：看电视，优先级：<span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>PriorityQueue有如下特点：</li>\n</ol>\n<ul>\n<li>实现了优先级队列，最先出队的总是优先级最高的；</li>\n<li>优先级相同时，内部元素不完全有序；</li>\n<li>查询头部元素效率很高，入队、出队效率很高；</li>\n<li>根据值查找和删除元素效率很低</li>\n<li>具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；</li>\n</ul>\n<h1 id=\"5-通用容器类\"><a href=\"#5-通用容器类\" class=\"headerlink\" title=\"5 通用容器类\"></a>5 通用容器类</h1><ol>\n<li>Collections提供了很多针对容器接口的通用算法和功能；</li>\n<li>容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；</li>\n<li>容器类中运用了大量的适配器模式</li>\n</ol>\n<ul>\n<li>空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）</li>\n<li>单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）</li>\n<li>其他适配方法，例如将Map转换为Set等。</li>\n</ul>\n<ol>\n<li>基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；</li>\n</ol>\n"},{"title":"Java编程原理——并发","date":"2022-02-16T14:31:00.000Z","updated":"2022-02-16T14:31:00.000Z","_content":"\n# 并发基础\n\n1. 线程表示一条单独的执行流，它有自己的执行计数器，有自己的栈；\n2. 使用线程的方式有两种，继承Thread类以及实现Runnable接口，两种达到的效果是一样的。\n3. 线程具有下列状态：\n\n+ NEW：没有调用start方法线程状态；\n+ TERMINATED：线程运行结束后状态；\n+ RUNNABLE：调用start后线程执行run方法且没有阻塞时状态；\n+ BLOCKED、WAITING、TIMED_WAITING：线程被阻塞；\n\n1. join方法：可以让调用join方法的线程等待该线程结束；\n2. 竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确；\n\n## synchronized关键字\n\n1. synchronized实例方法实际保护的是同一个对象的方法调用，每次只能被一个线程持有；\n2. synchronized关键字保护的是对象，针对实例对象保护的是当前，对于静态方法保护的类对象；\n3. 被synchronized关键字保护的对象都维护着1个锁以及等待队列；\n4. synchronized具有下列特点：\n\n+ 可重入性：对于同一个执行线程在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用；\n+ 内存可见性：释放锁时会将所有的更改写回内存；但是开销有些过高，可以使用volatile关键字实现相同的效果；\n+ 死锁：尽量避免在持有一个锁的同时再去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁；（使用开发过程中可以使用JDK提供的jstack检测死锁）\n\n1. 对于同步容器对象，单个操作是线程安全的，迭代却不是线程安全的。（因为在多线程操作中容易对容器产生结构性变化）；\n2. 如果需要在迭代容器的过程中保证线程安全，需要在遍历整个容器的过程中给整个容器对象加锁；\n3. 除11中所写到的方法，推荐使用并发容器类：\n\n+ CopyOnWriteArrayList\n+ ConcurrentHashMap;\n+ CocurrentLinkedQueue;\n+ ConcurrentSkipSet;\n\n## 线程协作机制\n\n1. 生产/消费者模式：生产者生产数据并放至消费队列中，消费者从消费队列中消费数据，如果队列为空消费者等待，如果队列满，生产者等待；\n2. 同时开始：在模拟仿真程序中，多个线程同时开始；\n3. 等待结束：主线程将任务拆解成多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕；\n4. 异步结果：将子线程封装为异步调用，子线程在正确返回结果前先返回一个Future对象，通过Future对象可以获得子线程最终的执行结果；\n5. Map/Reduce操作：也需要使用线程进行操作；\n\n## wait/notify机制：\n\n1. 每个同步对象都拥有一个锁以及一个等待队列，当调用wait方法，系统会将对象放入等待队列，直到调用notify方法再将其从等待队列中取出。\n2. 设计多线程程序的时候需要想清楚共享变量和条件，这是设计多线程协作的核心。\n3. 以生产者/消费者模式为例：生产者生产产品，并放入缓冲队列；消费者从缓冲队列取出产品进行消费。当生产者生产速度过快导致缓冲队列满了，此时生产者应停止生产。同样，当生产者生产过慢导致缓冲队列空，此时消费者应停止消费。等待生产者生产。\n4. 同时进行：一个主线程以及N个子线程，当主线程发送指令后，子线程开始同时执行；\n5. 各个线程分头行动，给咱达到一个集合点，在集合点需要集齐所有线程交换数据。然后再进行下一步动作。\n\n## 取消/关闭线程机制\n\n1. 停止一个线程的手段主要是中断，中断线程的目的并不是强迫线程终止，而是给线程发送一个停止信号，由线程自行决定中断的时机。本质上依旧是一种协作机制。\n2. Java中关于中断的方法有如下三种：\n\n```java\npublic boolean isInterrupted(); // 返回对应线程的中断标志位是否为true\npublic void interrupt(); // 表示中断对应的线程\npublic static boolean interrupted(); // 返回当前线程的中断标志位是否为true，但还有一个副作用：清空中断标志位。\n```\n\n1. 对于以线程提供的服务的应用程序模块而言，应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用库应该调用这些方法而不是直接调用interrupt方法；\n\n# 并发包基石\n\n## 原子变量\n\n1. 原子变量即为操作一次性完成，期间不进行线程上下文切换，并且能保证线程安全的原子变量。\n2. 原子变量有AtomicBoolean, AtomicInteger, AtomicLong以及AtomicReference（原子引用类型）类型\n3. 之所以称之为原子变量，是因为其包含一些原子方法实现组合操作的方法\n4. compareAndSet方法，也就是常说的CAS。如果当前值等于expect，则更新为update，否则不更新。如果更新成功，返回true，否则返回false。\n5. 乐观锁与悲观锁的区别：乐观锁假设每次操作都是不会出现冲突，因此在更新时不管是否出现冲突都会先进行一次更新，即便冲突了只需要再检测一次即可；而别管锁假设每次操作都会产生冲突，因此每次操作前都需要获得锁才能继续操作（例如：synchronized关键字）；\n6. 使用CAS会出现一个ABA问题：假设当前值为A，如果另一个线程将A改为B然后再修改回A，当前线程的CAS操作是无法分辨当前值发生过变化的。解决ABA可以在线程修改值时加上一个时间戳，以此来判断当前线程持有变量的版本；\n\n```java\nPair pair = new Pair(100, 200);\nint stamp = 1;\nAtomicStampedReference<Pair> pairRef = new AtomicStampedReference<>(pair, stamp);\nint newStamp = 2;\npairRef.copareAndSet(pair, new Pair(200, 200), stamp, newStamp);\n```\n\n1. 总结：CAS是并发包的基础，基于它可以实现高效、乐观、非阻塞式数据结构的算法，它也是并发包中锁、同步工具以及各种容器的基础；\n\n## 显式锁\n\n1. 包括锁Lock，主要实现类为ReentrantLock；读写锁接口ReadWriteLock，主要实现类是ReetrantReadWriteLock;\n2. 显式锁一般有下列方法：\n\n+ lock()/unlock()：普通获取锁和释放锁方法；会阻塞直至成功；\n+ lockInterruptibly()：可以响应中断，如果被其他线程中断会抛出InterruptedException；\n+ tryLock()：只是尝试获取锁，立即返回；如果获取成功返回true，否则返回false;\n+ newCondition()：新建一个条件\n\n1. 相比于synchronized，显式锁支持非阻塞方式获取锁、可以响应中断、可以限时；\n2. Lock是可重入的（一个线程持有一个锁的前提下可以继续获得该锁）、可以解决竞态条件、可以保证内存的可见性（volatile）\n3. 保证竞态条件的公平性会影响性能，一般情况下我们不作保证；例如：\n\n```java\npublic class Counter {\n    private final Lock lock = new ReetrantLock();\n    private volatile int count;\n    \n    public void incr() {\n        lock.lock(); // 使用lock获得显式锁\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // 用完要及时释放掉\n        }\n    }\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n1. 使用tryLock()可以避免死锁，在持有一个锁获另一个锁而获取不到的时候，可以释放自己已持有的锁，给其他线程获得锁的机会，然后重试获取所有锁；例如下面这样写会产生死锁，使用tryLock()判断可以避免死锁问题：\n\n```java\n// Account.java\npublic class Account {\n    private Lock lock = new ReetrantLock();\n    private volatile double money;\n    \n    public Account(double money) {\n        lock.lock();\n        try {\n            this.money += money;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public void reduce(double money) {\n        lock.lock();\n        try {\n            this.money -= money;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public double getMoney() {\n        return money;\n    }\n    \n    void lock() {\n        lock.lock();\n    }\n    \n    void unlock() {\n        lock.unlock();\n    }\n    \n    boolean tryLock() {\n        return lock.tryLock();\n    }\n}\n\n// AccountMgr.java\npublic class AccountMgr {\n    public static class NoEnoughMoneyException extends Exception{}\n    public static void transfer(Account from, Account to, double money)throws NoEnoughMoneyException {\n        from.lock(); // from获得锁\n        try {\n            to.lock(); // to获得锁\n            try {\n                if (from.getMoney() >= money) {\n                    from.reduce(money);\n                    to.add(money);\n                } else {\n                    throw new NoEnoughMoneyException();\n                } finally {\n                    to.unlock(); // to释放锁\n                }\n            } finally {\n                from.unlock(); // from释放锁\n            }\n        }\n    }\n}\n```\n\n1. Java中封装了一个抽象类AQS用于简化并发工具类的实现。AQS全称（AbstractQueuedSynchronizer）。AQS的实现比较复杂。AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。\n2. Lock锁的基本原理如下：能获得锁就立即获得，否则加入等待队列，被唤醒后检查自己是否是第一个等待的线程，如果是且能获得锁则返回；否则继续等待，这个过程如果发生了中断，lock会记录中断标志位，但不会提前返回或者是抛出异常；\n3. 保证公平性的结果是整体性能会降低，低的原因不在于检查速度慢，而是会让活跃线程得不到锁，进入等待状态，引起频繁上下文切换，降低整体的效率。需要说明的是即便fair参数为true，ReetrantLock中不带参数的tryLock方法也是不保证公平的。\n4. synchronized关键字是声明式编程，而Lock是命令式编程，所有内部的细节都需要自己实现。目前JVM对synchronized的优化已经相当的好。因此能用synchronized的地方建议使用synchronized，不能使用synchronized关键字的地方再考虑Lock；\n\n## 显式条件\n\n1. 锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，显式条件和wait/notify相对应。\n2. 实现显式锁的显式条件为Condition类，该类为一个接口，其中包含下列方法：其中绝大部分是响应中断的。即：当出现中断会清空标志位：\n\n```java\nvoid await() // 相当于Object中的wait();\nvoid awaitUnInterruptibly(); // 不响应中断\nlong awaitNanos(long nanoTimeout);\nboolean await(long times, TimeUnit unit);\nboolean awaitUntil(Date deadline);\nvoid signal(); // 相当于notify();\nvoid signalAll(); // 相当于notifyAll();\n```\n\n1. await在进入等待队列后，会释放锁以及CPU，当其他线程将它唤醒后、等待超时后以及发生中断退出后都需要重新获得锁，获取锁后才从await方法中退出。\n2. 使用显式锁的示例如下：\n\n```java\npublic class WaitThread extends Thread {\n    private volatile boolean fire = false;\n    private Lock lock = new ReetrantLock();\n    private Condition condition = lock.newCondition();\n    \n    @Override\n    public void run() {\n        try {\n            lock.lock();\n            try {\n                while(!fire) {\n                    condition.await();\n                }\n            } finally {\n                lock.unlock();\n            }\n            System.out.println(\"fired\");\n        } catch (InterruptedException e) {\n            Thread.interrupted();\n        }\n    }\n    \n    public void fire() {\n        lock.lock();\n        try {\n            this.fire = true;\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException{\n        WaitThread waitThread = new WaitThread();\n        waitThread.start();\n        Thread.sleep(1000);\n        System.out.println(\"fire\");\n        waitThread.fire();\n    }\n}\n```\n\n1. await()/signal()方法与显式锁配合使用；而wait()/notify()要与synchronized方法使用，不能使用混淆。否则即便编译器不报错也会出现IllegalStateException方法。\n\n# 并发容器\n\n## CopyOnWriteArrayList以及CopyOnWriteArraySet\n\n1. 特点：线程安全，可以被多个线程并发访问；\n2. 迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；\n3. 以原子方式支持一些复合操作\n4. 写时复制的技术思路为：每次出现修改操作时，都会新建一个数组，复制原数组内容到新数组，在新数组上进行需要的修改，然后一原子方式设置内部数组引用。同理：所有的读操作都是**先拿到当前引用的数组**，然后**直接访问**该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响操作，它依旧访问原数组内容。\n5. 截至当前保证线程安全的思路有三种：\n\n+ 使用锁：例如synchronized关键字以及ReetrantLock；\n+ 使用CAS：\n+ 写时复制也是一种常见的线程安全保证思路，在操作系统内部的进程管理和内存管理经常会使用到。\n\n1. 总结：CopyOnWriteList和CopyOnWriteSet适用于读远多于写、集合不太大的场景，它们采用了写时复制技术，这也是计算机中一种重要的思维和技术。\n\n## ConcurrentHashMap\n\n1. 特点：并发安全、支持一些原子复合操作、支持高并发，读完全并行、弱一致性；\n2. HashMap不是线程安全的，在高并发场景下容易出现死循环以及占满CPU的问题；\n3. Collections.synchronizedMap()在调用一些更新操作时需要加锁，而ConcurrentHashMap()就不存在这个问题；\n4. ConcurrentHashMap使用了很复杂的技术实现高并发，但是简要概括下有下列两种：\n\n+ 分段锁：将读取的数据分为多段，每段都拥有自己的锁，每个段都相当于独立的Hash表。使用分段锁可以有效地提高并发效率。\n+ 读不需要锁：对于写操作需要获取锁，不能并行，但是读操作可以并行。写的同时也可以读。\n\n1. 弱一致性：ConcurrentHashMap在创建完迭代器后，会按照哈希表中反映的结构迭代元素。如果结构的变化发生在已经迭代过的元素上，则结构性变化不会反映出来。反之，若结构变化发生在未发生改变的元素上，结构变化就可以被反映出来。这种现象就称之为弱一致性；\n\n## 基于SkipList的Map和Set\n\n1. 特点：所有的操作都可以并行，包括读和写；\n2. 与TreeMap/TreeSet一样，可以实现按键的自然排序；使用方法如下：\n\n```java\npublic void CurrentSkipMapDemo {\n    public static void main(String[] args) {\n        Map<String, Object> map = new ConcurrentSkipMap<>(Collections.reverseOrder());\n        map.put(\"a\", \"abstract\");\n        map.put(\"b\", \"basic\");\n        map.put(\"c\", \"call\");\n        System.out.println(map.toString());\n    }\n}\n```\n\n1. SkipMap和SkipSet是基于跳表实现，跳表是基于链表实现的。在链表的基础上增加了多层索引结构。跳表实际上一个类似于二分查找的数据结构。因此有了这样的数据结构就可以更好地实现，关于其复杂度就不再赘述。\n\n## 并发队列\n\n1. Java中的并发队列一般包括下列几种：\n\n+ 无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque\n+ 普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque；\n+ 优先级阻塞队列：PriorityBlockingQueue；\n+ 延时阻塞队列：DelayQueue；\n+ 其他阻塞队列：SynchronousQueue和LinkedTransferQueue；\n\n1. 这里的无锁指的是不使用锁，使用CAS方式实现；\n2. 普通阻塞队列适用于生产者/消费者模式；\n3. 优先级队列是按照优先级出队列的，优先级高的先出\n4. 延时阻塞队列可以用于定时任务，按照元素的延时时间出队，其特殊点在于只有当元素的延时过期之后才能从队列中被拿走\n5. SynchronousQueue没有存储空间，适用于两进程之间传递信息；LinkedTransferQueue适用于一些消息传递类型的应用中。\n\n# 异步执行任务\n\n## 执行接口\n\n+ Runnable（没有返回结果）和Callable（有返回结果）：表示要执行的异步任务\n+ Executor和ExecutorService：表示执行服务\n+ Future：表示异步任务的结果\n\n## Future接口的使用\n\n1. 示例代码\n\n```java\npublic class BasicDemo {\n    static class Task implements Callable<Integer> {\n        @Override\n        public Integer call() throws Exception {\n            int sleepSeconds = new Random().nextInt(1000);\n            Thread.sleep(sleepSeconds);\n            return sleepSeconds;\n        }\n    }\n    public static void main(String[] args) throws InterruptedException{\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<Integer> future = executor.submit(new Task());\n        Thread.sleep(100);\n        try {\n            System.out.println(future.get());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        executor.shutdown();\n    }\n}\n```\n\n1. 实现原理：ExecutorService的主要实现类是ThreadPoolExecutor，是基于线程池实现的。\n2. 总结：并发包执行任务执行服务体现了并发异步开发中的“关注点分离”的思想，使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。\n\n## 线程池\n\n1. 线程池主要有任务队列以及工作者线程组成；\n2. 线程池有下列优点：\n\n+ 可以重用线程，避免线程创建的开销；\n+ 任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争；\n\n1. Java中最常用的线程池类是ThreadPoolExecutor；其中最重要的4个参数是：corePoolSize（核心线程个数）,maximumPoolSize（最大线程个数）keepAliveTime和unit（空闲线程存活时间）\n2. ThreadPoolExecutor中的队列均为阻塞队列，分为有界和无界两种类型。需要说明的是如果使用了无界队列，线程个数最多只能达到corePoolSize，达到corePoolSize之后新的任务总会排队，参数maximumPoolSize也就没有意义了。\n3. 当队列有界并且maximumPoolSize有限时，只要队列排满，新任务总会被拒绝，因此也会出发任务拒绝策略。不过任务拒绝策略是可以自定义的。\n\n+ ThreadPoolExecutor.AbortPolicy：默认方式，抛出异常\n+ ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛出异常也不执行\n+ ThreadPoolExecutor.DiscardOldestPolicy：扔掉等待时间最长的任务，然后自己排队\n+ ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，不交给线程池中的线程执行\n\n## 定时任务\n\n1. TimerTask表示一个定时任务，具体的定时任务需要继承该抽象类，实现run方法。示例：\n\n```java\npublic class BasicTimer {\n    static class DelayTask extends TimerTask {\n        @Override\n        public void run() {\n            System.out.println(\"delayed task\");\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        Timer timer = new Timer();\n        timer.schedule(new DelayTask(), 1000);\n        Thread.sleep(2000);\n        timer.cancel();\n    }\n}\n```\n\n1. Timer内部主要是由任务队列和Timer线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。一个Timer对象只有一个Timer线程。\n2. 对于固定延时任务，延时相对的是任务执行前的当前时间；对于固定频率任务，延时相对的是最优先计划；\n3. 在执行一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的定时任务都会被取消。因此，如果希望各个定时任务不互相干扰，一定要在run方法内捕获异常。\n4. 并发包中使用ScheduledExecutorService来实现定时任务，其为一个接口，多线程执行定时任务的示例如下：\n\n```java\npublic class ScheduledFixedDelay {\n    static class LongRunningTask implements Runnable {}\n    static class FixedDelayTask implements Runnable {}\n    public static void main(String[] args) {\n        ScheduledExecutorService timer = Executors.newScheduledThreadPool(10);\n        timer.schedule(new LongRunningTask(), 10, TimeUnit.MILLISECONDS);\n        timer.scheduleWithFixedDelay(new FixedDelayTask(), 100, 1000, TimeUnit.MILLISECONDS);\n    }\n}\n```\n\n1. ScheduledExecutorService的实现原理如下：\n\n+ 实现背后是线程池，可以有多个线程执行任务；\n+ 在任务执行后再设置下次执行的时间，对于固定延时的任务更合理；\n+ 任务执行线程会捕获任务执行过程中的所有异常。一个定时任务的异常不会影响其他定时任务；\n\n# 同步以及协作工具类\n\n1. 同步工具类包括：\n\n+ ReetrantReadWriteLock：读写显式锁\n+ Semaphore：信号量\n+ CountDownLatch：倒计时门栓\n+ CyclicBarrier：循环栅栏\n+ ThreadLocal：线程本地 2.ReetrantReadWriteLock读写显式锁：只有“读-读”可以并行，“读-写”和“写-写”都是不可以的。只有一个线程可以进行写操作。是基于CAS实现的；\n\n1. Semaphore：限制并发数量，是基于AQS实现的；\n2. CountDownLatch：默认是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过。门栓是一次性的，打开了就不能再关上了。\n3. CyclicBarrier：所有线程在到达该栅栏后都需要等待其他线程，等待所有线程都到达后在一起通过。它是循环的，可以用重复的同步。\n4. ThreadLocal：每个线程都有同一个变量的独有拷贝，也就是说每个线程都拥有一个属于自己的独立值。一般来说ThreadLocal都定义为静态类型便于引用\n\n# 并发总结\n","source":"_posts/java-core/ch05.md","raw":"---\ntitle: Java编程原理——并发\ndate: 2022-02-16 22:31:00\nupdated: 2022-02-16 22:31:00\ntags: Java基础\ncategories: Java\n---\n\n# 并发基础\n\n1. 线程表示一条单独的执行流，它有自己的执行计数器，有自己的栈；\n2. 使用线程的方式有两种，继承Thread类以及实现Runnable接口，两种达到的效果是一样的。\n3. 线程具有下列状态：\n\n+ NEW：没有调用start方法线程状态；\n+ TERMINATED：线程运行结束后状态；\n+ RUNNABLE：调用start后线程执行run方法且没有阻塞时状态；\n+ BLOCKED、WAITING、TIMED_WAITING：线程被阻塞；\n\n1. join方法：可以让调用join方法的线程等待该线程结束；\n2. 竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确；\n\n## synchronized关键字\n\n1. synchronized实例方法实际保护的是同一个对象的方法调用，每次只能被一个线程持有；\n2. synchronized关键字保护的是对象，针对实例对象保护的是当前，对于静态方法保护的类对象；\n3. 被synchronized关键字保护的对象都维护着1个锁以及等待队列；\n4. synchronized具有下列特点：\n\n+ 可重入性：对于同一个执行线程在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用；\n+ 内存可见性：释放锁时会将所有的更改写回内存；但是开销有些过高，可以使用volatile关键字实现相同的效果；\n+ 死锁：尽量避免在持有一个锁的同时再去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁；（使用开发过程中可以使用JDK提供的jstack检测死锁）\n\n1. 对于同步容器对象，单个操作是线程安全的，迭代却不是线程安全的。（因为在多线程操作中容易对容器产生结构性变化）；\n2. 如果需要在迭代容器的过程中保证线程安全，需要在遍历整个容器的过程中给整个容器对象加锁；\n3. 除11中所写到的方法，推荐使用并发容器类：\n\n+ CopyOnWriteArrayList\n+ ConcurrentHashMap;\n+ CocurrentLinkedQueue;\n+ ConcurrentSkipSet;\n\n## 线程协作机制\n\n1. 生产/消费者模式：生产者生产数据并放至消费队列中，消费者从消费队列中消费数据，如果队列为空消费者等待，如果队列满，生产者等待；\n2. 同时开始：在模拟仿真程序中，多个线程同时开始；\n3. 等待结束：主线程将任务拆解成多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕；\n4. 异步结果：将子线程封装为异步调用，子线程在正确返回结果前先返回一个Future对象，通过Future对象可以获得子线程最终的执行结果；\n5. Map/Reduce操作：也需要使用线程进行操作；\n\n## wait/notify机制：\n\n1. 每个同步对象都拥有一个锁以及一个等待队列，当调用wait方法，系统会将对象放入等待队列，直到调用notify方法再将其从等待队列中取出。\n2. 设计多线程程序的时候需要想清楚共享变量和条件，这是设计多线程协作的核心。\n3. 以生产者/消费者模式为例：生产者生产产品，并放入缓冲队列；消费者从缓冲队列取出产品进行消费。当生产者生产速度过快导致缓冲队列满了，此时生产者应停止生产。同样，当生产者生产过慢导致缓冲队列空，此时消费者应停止消费。等待生产者生产。\n4. 同时进行：一个主线程以及N个子线程，当主线程发送指令后，子线程开始同时执行；\n5. 各个线程分头行动，给咱达到一个集合点，在集合点需要集齐所有线程交换数据。然后再进行下一步动作。\n\n## 取消/关闭线程机制\n\n1. 停止一个线程的手段主要是中断，中断线程的目的并不是强迫线程终止，而是给线程发送一个停止信号，由线程自行决定中断的时机。本质上依旧是一种协作机制。\n2. Java中关于中断的方法有如下三种：\n\n```java\npublic boolean isInterrupted(); // 返回对应线程的中断标志位是否为true\npublic void interrupt(); // 表示中断对应的线程\npublic static boolean interrupted(); // 返回当前线程的中断标志位是否为true，但还有一个副作用：清空中断标志位。\n```\n\n1. 对于以线程提供的服务的应用程序模块而言，应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用库应该调用这些方法而不是直接调用interrupt方法；\n\n# 并发包基石\n\n## 原子变量\n\n1. 原子变量即为操作一次性完成，期间不进行线程上下文切换，并且能保证线程安全的原子变量。\n2. 原子变量有AtomicBoolean, AtomicInteger, AtomicLong以及AtomicReference（原子引用类型）类型\n3. 之所以称之为原子变量，是因为其包含一些原子方法实现组合操作的方法\n4. compareAndSet方法，也就是常说的CAS。如果当前值等于expect，则更新为update，否则不更新。如果更新成功，返回true，否则返回false。\n5. 乐观锁与悲观锁的区别：乐观锁假设每次操作都是不会出现冲突，因此在更新时不管是否出现冲突都会先进行一次更新，即便冲突了只需要再检测一次即可；而别管锁假设每次操作都会产生冲突，因此每次操作前都需要获得锁才能继续操作（例如：synchronized关键字）；\n6. 使用CAS会出现一个ABA问题：假设当前值为A，如果另一个线程将A改为B然后再修改回A，当前线程的CAS操作是无法分辨当前值发生过变化的。解决ABA可以在线程修改值时加上一个时间戳，以此来判断当前线程持有变量的版本；\n\n```java\nPair pair = new Pair(100, 200);\nint stamp = 1;\nAtomicStampedReference<Pair> pairRef = new AtomicStampedReference<>(pair, stamp);\nint newStamp = 2;\npairRef.copareAndSet(pair, new Pair(200, 200), stamp, newStamp);\n```\n\n1. 总结：CAS是并发包的基础，基于它可以实现高效、乐观、非阻塞式数据结构的算法，它也是并发包中锁、同步工具以及各种容器的基础；\n\n## 显式锁\n\n1. 包括锁Lock，主要实现类为ReentrantLock；读写锁接口ReadWriteLock，主要实现类是ReetrantReadWriteLock;\n2. 显式锁一般有下列方法：\n\n+ lock()/unlock()：普通获取锁和释放锁方法；会阻塞直至成功；\n+ lockInterruptibly()：可以响应中断，如果被其他线程中断会抛出InterruptedException；\n+ tryLock()：只是尝试获取锁，立即返回；如果获取成功返回true，否则返回false;\n+ newCondition()：新建一个条件\n\n1. 相比于synchronized，显式锁支持非阻塞方式获取锁、可以响应中断、可以限时；\n2. Lock是可重入的（一个线程持有一个锁的前提下可以继续获得该锁）、可以解决竞态条件、可以保证内存的可见性（volatile）\n3. 保证竞态条件的公平性会影响性能，一般情况下我们不作保证；例如：\n\n```java\npublic class Counter {\n    private final Lock lock = new ReetrantLock();\n    private volatile int count;\n    \n    public void incr() {\n        lock.lock(); // 使用lock获得显式锁\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // 用完要及时释放掉\n        }\n    }\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n1. 使用tryLock()可以避免死锁，在持有一个锁获另一个锁而获取不到的时候，可以释放自己已持有的锁，给其他线程获得锁的机会，然后重试获取所有锁；例如下面这样写会产生死锁，使用tryLock()判断可以避免死锁问题：\n\n```java\n// Account.java\npublic class Account {\n    private Lock lock = new ReetrantLock();\n    private volatile double money;\n    \n    public Account(double money) {\n        lock.lock();\n        try {\n            this.money += money;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public void reduce(double money) {\n        lock.lock();\n        try {\n            this.money -= money;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public double getMoney() {\n        return money;\n    }\n    \n    void lock() {\n        lock.lock();\n    }\n    \n    void unlock() {\n        lock.unlock();\n    }\n    \n    boolean tryLock() {\n        return lock.tryLock();\n    }\n}\n\n// AccountMgr.java\npublic class AccountMgr {\n    public static class NoEnoughMoneyException extends Exception{}\n    public static void transfer(Account from, Account to, double money)throws NoEnoughMoneyException {\n        from.lock(); // from获得锁\n        try {\n            to.lock(); // to获得锁\n            try {\n                if (from.getMoney() >= money) {\n                    from.reduce(money);\n                    to.add(money);\n                } else {\n                    throw new NoEnoughMoneyException();\n                } finally {\n                    to.unlock(); // to释放锁\n                }\n            } finally {\n                from.unlock(); // from释放锁\n            }\n        }\n    }\n}\n```\n\n1. Java中封装了一个抽象类AQS用于简化并发工具类的实现。AQS全称（AbstractQueuedSynchronizer）。AQS的实现比较复杂。AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。\n2. Lock锁的基本原理如下：能获得锁就立即获得，否则加入等待队列，被唤醒后检查自己是否是第一个等待的线程，如果是且能获得锁则返回；否则继续等待，这个过程如果发生了中断，lock会记录中断标志位，但不会提前返回或者是抛出异常；\n3. 保证公平性的结果是整体性能会降低，低的原因不在于检查速度慢，而是会让活跃线程得不到锁，进入等待状态，引起频繁上下文切换，降低整体的效率。需要说明的是即便fair参数为true，ReetrantLock中不带参数的tryLock方法也是不保证公平的。\n4. synchronized关键字是声明式编程，而Lock是命令式编程，所有内部的细节都需要自己实现。目前JVM对synchronized的优化已经相当的好。因此能用synchronized的地方建议使用synchronized，不能使用synchronized关键字的地方再考虑Lock；\n\n## 显式条件\n\n1. 锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，显式条件和wait/notify相对应。\n2. 实现显式锁的显式条件为Condition类，该类为一个接口，其中包含下列方法：其中绝大部分是响应中断的。即：当出现中断会清空标志位：\n\n```java\nvoid await() // 相当于Object中的wait();\nvoid awaitUnInterruptibly(); // 不响应中断\nlong awaitNanos(long nanoTimeout);\nboolean await(long times, TimeUnit unit);\nboolean awaitUntil(Date deadline);\nvoid signal(); // 相当于notify();\nvoid signalAll(); // 相当于notifyAll();\n```\n\n1. await在进入等待队列后，会释放锁以及CPU，当其他线程将它唤醒后、等待超时后以及发生中断退出后都需要重新获得锁，获取锁后才从await方法中退出。\n2. 使用显式锁的示例如下：\n\n```java\npublic class WaitThread extends Thread {\n    private volatile boolean fire = false;\n    private Lock lock = new ReetrantLock();\n    private Condition condition = lock.newCondition();\n    \n    @Override\n    public void run() {\n        try {\n            lock.lock();\n            try {\n                while(!fire) {\n                    condition.await();\n                }\n            } finally {\n                lock.unlock();\n            }\n            System.out.println(\"fired\");\n        } catch (InterruptedException e) {\n            Thread.interrupted();\n        }\n    }\n    \n    public void fire() {\n        lock.lock();\n        try {\n            this.fire = true;\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException{\n        WaitThread waitThread = new WaitThread();\n        waitThread.start();\n        Thread.sleep(1000);\n        System.out.println(\"fire\");\n        waitThread.fire();\n    }\n}\n```\n\n1. await()/signal()方法与显式锁配合使用；而wait()/notify()要与synchronized方法使用，不能使用混淆。否则即便编译器不报错也会出现IllegalStateException方法。\n\n# 并发容器\n\n## CopyOnWriteArrayList以及CopyOnWriteArraySet\n\n1. 特点：线程安全，可以被多个线程并发访问；\n2. 迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；\n3. 以原子方式支持一些复合操作\n4. 写时复制的技术思路为：每次出现修改操作时，都会新建一个数组，复制原数组内容到新数组，在新数组上进行需要的修改，然后一原子方式设置内部数组引用。同理：所有的读操作都是**先拿到当前引用的数组**，然后**直接访问**该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响操作，它依旧访问原数组内容。\n5. 截至当前保证线程安全的思路有三种：\n\n+ 使用锁：例如synchronized关键字以及ReetrantLock；\n+ 使用CAS：\n+ 写时复制也是一种常见的线程安全保证思路，在操作系统内部的进程管理和内存管理经常会使用到。\n\n1. 总结：CopyOnWriteList和CopyOnWriteSet适用于读远多于写、集合不太大的场景，它们采用了写时复制技术，这也是计算机中一种重要的思维和技术。\n\n## ConcurrentHashMap\n\n1. 特点：并发安全、支持一些原子复合操作、支持高并发，读完全并行、弱一致性；\n2. HashMap不是线程安全的，在高并发场景下容易出现死循环以及占满CPU的问题；\n3. Collections.synchronizedMap()在调用一些更新操作时需要加锁，而ConcurrentHashMap()就不存在这个问题；\n4. ConcurrentHashMap使用了很复杂的技术实现高并发，但是简要概括下有下列两种：\n\n+ 分段锁：将读取的数据分为多段，每段都拥有自己的锁，每个段都相当于独立的Hash表。使用分段锁可以有效地提高并发效率。\n+ 读不需要锁：对于写操作需要获取锁，不能并行，但是读操作可以并行。写的同时也可以读。\n\n1. 弱一致性：ConcurrentHashMap在创建完迭代器后，会按照哈希表中反映的结构迭代元素。如果结构的变化发生在已经迭代过的元素上，则结构性变化不会反映出来。反之，若结构变化发生在未发生改变的元素上，结构变化就可以被反映出来。这种现象就称之为弱一致性；\n\n## 基于SkipList的Map和Set\n\n1. 特点：所有的操作都可以并行，包括读和写；\n2. 与TreeMap/TreeSet一样，可以实现按键的自然排序；使用方法如下：\n\n```java\npublic void CurrentSkipMapDemo {\n    public static void main(String[] args) {\n        Map<String, Object> map = new ConcurrentSkipMap<>(Collections.reverseOrder());\n        map.put(\"a\", \"abstract\");\n        map.put(\"b\", \"basic\");\n        map.put(\"c\", \"call\");\n        System.out.println(map.toString());\n    }\n}\n```\n\n1. SkipMap和SkipSet是基于跳表实现，跳表是基于链表实现的。在链表的基础上增加了多层索引结构。跳表实际上一个类似于二分查找的数据结构。因此有了这样的数据结构就可以更好地实现，关于其复杂度就不再赘述。\n\n## 并发队列\n\n1. Java中的并发队列一般包括下列几种：\n\n+ 无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque\n+ 普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque；\n+ 优先级阻塞队列：PriorityBlockingQueue；\n+ 延时阻塞队列：DelayQueue；\n+ 其他阻塞队列：SynchronousQueue和LinkedTransferQueue；\n\n1. 这里的无锁指的是不使用锁，使用CAS方式实现；\n2. 普通阻塞队列适用于生产者/消费者模式；\n3. 优先级队列是按照优先级出队列的，优先级高的先出\n4. 延时阻塞队列可以用于定时任务，按照元素的延时时间出队，其特殊点在于只有当元素的延时过期之后才能从队列中被拿走\n5. SynchronousQueue没有存储空间，适用于两进程之间传递信息；LinkedTransferQueue适用于一些消息传递类型的应用中。\n\n# 异步执行任务\n\n## 执行接口\n\n+ Runnable（没有返回结果）和Callable（有返回结果）：表示要执行的异步任务\n+ Executor和ExecutorService：表示执行服务\n+ Future：表示异步任务的结果\n\n## Future接口的使用\n\n1. 示例代码\n\n```java\npublic class BasicDemo {\n    static class Task implements Callable<Integer> {\n        @Override\n        public Integer call() throws Exception {\n            int sleepSeconds = new Random().nextInt(1000);\n            Thread.sleep(sleepSeconds);\n            return sleepSeconds;\n        }\n    }\n    public static void main(String[] args) throws InterruptedException{\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<Integer> future = executor.submit(new Task());\n        Thread.sleep(100);\n        try {\n            System.out.println(future.get());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        executor.shutdown();\n    }\n}\n```\n\n1. 实现原理：ExecutorService的主要实现类是ThreadPoolExecutor，是基于线程池实现的。\n2. 总结：并发包执行任务执行服务体现了并发异步开发中的“关注点分离”的思想，使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。\n\n## 线程池\n\n1. 线程池主要有任务队列以及工作者线程组成；\n2. 线程池有下列优点：\n\n+ 可以重用线程，避免线程创建的开销；\n+ 任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争；\n\n1. Java中最常用的线程池类是ThreadPoolExecutor；其中最重要的4个参数是：corePoolSize（核心线程个数）,maximumPoolSize（最大线程个数）keepAliveTime和unit（空闲线程存活时间）\n2. ThreadPoolExecutor中的队列均为阻塞队列，分为有界和无界两种类型。需要说明的是如果使用了无界队列，线程个数最多只能达到corePoolSize，达到corePoolSize之后新的任务总会排队，参数maximumPoolSize也就没有意义了。\n3. 当队列有界并且maximumPoolSize有限时，只要队列排满，新任务总会被拒绝，因此也会出发任务拒绝策略。不过任务拒绝策略是可以自定义的。\n\n+ ThreadPoolExecutor.AbortPolicy：默认方式，抛出异常\n+ ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛出异常也不执行\n+ ThreadPoolExecutor.DiscardOldestPolicy：扔掉等待时间最长的任务，然后自己排队\n+ ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，不交给线程池中的线程执行\n\n## 定时任务\n\n1. TimerTask表示一个定时任务，具体的定时任务需要继承该抽象类，实现run方法。示例：\n\n```java\npublic class BasicTimer {\n    static class DelayTask extends TimerTask {\n        @Override\n        public void run() {\n            System.out.println(\"delayed task\");\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        Timer timer = new Timer();\n        timer.schedule(new DelayTask(), 1000);\n        Thread.sleep(2000);\n        timer.cancel();\n    }\n}\n```\n\n1. Timer内部主要是由任务队列和Timer线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。一个Timer对象只有一个Timer线程。\n2. 对于固定延时任务，延时相对的是任务执行前的当前时间；对于固定频率任务，延时相对的是最优先计划；\n3. 在执行一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的定时任务都会被取消。因此，如果希望各个定时任务不互相干扰，一定要在run方法内捕获异常。\n4. 并发包中使用ScheduledExecutorService来实现定时任务，其为一个接口，多线程执行定时任务的示例如下：\n\n```java\npublic class ScheduledFixedDelay {\n    static class LongRunningTask implements Runnable {}\n    static class FixedDelayTask implements Runnable {}\n    public static void main(String[] args) {\n        ScheduledExecutorService timer = Executors.newScheduledThreadPool(10);\n        timer.schedule(new LongRunningTask(), 10, TimeUnit.MILLISECONDS);\n        timer.scheduleWithFixedDelay(new FixedDelayTask(), 100, 1000, TimeUnit.MILLISECONDS);\n    }\n}\n```\n\n1. ScheduledExecutorService的实现原理如下：\n\n+ 实现背后是线程池，可以有多个线程执行任务；\n+ 在任务执行后再设置下次执行的时间，对于固定延时的任务更合理；\n+ 任务执行线程会捕获任务执行过程中的所有异常。一个定时任务的异常不会影响其他定时任务；\n\n# 同步以及协作工具类\n\n1. 同步工具类包括：\n\n+ ReetrantReadWriteLock：读写显式锁\n+ Semaphore：信号量\n+ CountDownLatch：倒计时门栓\n+ CyclicBarrier：循环栅栏\n+ ThreadLocal：线程本地 2.ReetrantReadWriteLock读写显式锁：只有“读-读”可以并行，“读-写”和“写-写”都是不可以的。只有一个线程可以进行写操作。是基于CAS实现的；\n\n1. Semaphore：限制并发数量，是基于AQS实现的；\n2. CountDownLatch：默认是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过。门栓是一次性的，打开了就不能再关上了。\n3. CyclicBarrier：所有线程在到达该栅栏后都需要等待其他线程，等待所有线程都到达后在一起通过。它是循环的，可以用重复的同步。\n4. ThreadLocal：每个线程都有同一个变量的独有拷贝，也就是说每个线程都拥有一个属于自己的独立值。一般来说ThreadLocal都定义为静态类型便于引用\n\n# 并发总结\n","slug":"java-core/ch05","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v2000c4f618p6dezby","content":"<h1 id=\"并发基础\"><a href=\"#并发基础\" class=\"headerlink\" title=\"并发基础\"></a>并发基础</h1><ol>\n<li>线程表示一条单独的执行流，它有自己的执行计数器，有自己的栈；</li>\n<li>使用线程的方式有两种，继承Thread类以及实现Runnable接口，两种达到的效果是一样的。</li>\n<li>线程具有下列状态：</li>\n</ol>\n<ul>\n<li>NEW：没有调用start方法线程状态；</li>\n<li>TERMINATED：线程运行结束后状态；</li>\n<li>RUNNABLE：调用start后线程执行run方法且没有阻塞时状态；</li>\n<li>BLOCKED、WAITING、TIMED_WAITING：线程被阻塞；</li>\n</ul>\n<ol>\n<li>join方法：可以让调用join方法的线程等待该线程结束；</li>\n<li>竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确；</li>\n</ol>\n<h2 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h2><ol>\n<li>synchronized实例方法实际保护的是同一个对象的方法调用，每次只能被一个线程持有；</li>\n<li>synchronized关键字保护的是对象，针对实例对象保护的是当前，对于静态方法保护的类对象；</li>\n<li>被synchronized关键字保护的对象都维护着1个锁以及等待队列；</li>\n<li>synchronized具有下列特点：</li>\n</ol>\n<ul>\n<li>可重入性：对于同一个执行线程在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用；</li>\n<li>内存可见性：释放锁时会将所有的更改写回内存；但是开销有些过高，可以使用volatile关键字实现相同的效果；</li>\n<li>死锁：尽量避免在持有一个锁的同时再去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁；（使用开发过程中可以使用JDK提供的jstack检测死锁）</li>\n</ul>\n<ol>\n<li>对于同步容器对象，单个操作是线程安全的，迭代却不是线程安全的。（因为在多线程操作中容易对容器产生结构性变化）；</li>\n<li>如果需要在迭代容器的过程中保证线程安全，需要在遍历整个容器的过程中给整个容器对象加锁；</li>\n<li>除11中所写到的方法，推荐使用并发容器类：</li>\n</ol>\n<ul>\n<li>CopyOnWriteArrayList</li>\n<li>ConcurrentHashMap;</li>\n<li>CocurrentLinkedQueue;</li>\n<li>ConcurrentSkipSet;</li>\n</ul>\n<h2 id=\"线程协作机制\"><a href=\"#线程协作机制\" class=\"headerlink\" title=\"线程协作机制\"></a>线程协作机制</h2><ol>\n<li>生产/消费者模式：生产者生产数据并放至消费队列中，消费者从消费队列中消费数据，如果队列为空消费者等待，如果队列满，生产者等待；</li>\n<li>同时开始：在模拟仿真程序中，多个线程同时开始；</li>\n<li>等待结束：主线程将任务拆解成多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕；</li>\n<li>异步结果：将子线程封装为异步调用，子线程在正确返回结果前先返回一个Future对象，通过Future对象可以获得子线程最终的执行结果；</li>\n<li>Map/Reduce操作：也需要使用线程进行操作；</li>\n</ol>\n<h2 id=\"wait-notify机制：\"><a href=\"#wait-notify机制：\" class=\"headerlink\" title=\"wait/notify机制：\"></a>wait/notify机制：</h2><ol>\n<li>每个同步对象都拥有一个锁以及一个等待队列，当调用wait方法，系统会将对象放入等待队列，直到调用notify方法再将其从等待队列中取出。</li>\n<li>设计多线程程序的时候需要想清楚共享变量和条件，这是设计多线程协作的核心。</li>\n<li>以生产者/消费者模式为例：生产者生产产品，并放入缓冲队列；消费者从缓冲队列取出产品进行消费。当生产者生产速度过快导致缓冲队列满了，此时生产者应停止生产。同样，当生产者生产过慢导致缓冲队列空，此时消费者应停止消费。等待生产者生产。</li>\n<li>同时进行：一个主线程以及N个子线程，当主线程发送指令后，子线程开始同时执行；</li>\n<li>各个线程分头行动，给咱达到一个集合点，在集合点需要集齐所有线程交换数据。然后再进行下一步动作。</li>\n</ol>\n<h2 id=\"取消-关闭线程机制\"><a href=\"#取消-关闭线程机制\" class=\"headerlink\" title=\"取消/关闭线程机制\"></a>取消/关闭线程机制</h2><ol>\n<li>停止一个线程的手段主要是中断，中断线程的目的并不是强迫线程终止，而是给线程发送一个停止信号，由线程自行决定中断的时机。本质上依旧是一种协作机制。</li>\n<li>Java中关于中断的方法有如下三种：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isInterrupted</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 返回对应线程的中断标志位是否为true</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">interrupt</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 表示中断对应的线程</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">interrupted</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 返回当前线程的中断标志位是否为true，但还有一个副作用：清空中断标志位。</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>对于以线程提供的服务的应用程序模块而言，应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用库应该调用这些方法而不是直接调用interrupt方法；</li>\n</ol>\n<h1 id=\"并发包基石\"><a href=\"#并发包基石\" class=\"headerlink\" title=\"并发包基石\"></a>并发包基石</h1><h2 id=\"原子变量\"><a href=\"#原子变量\" class=\"headerlink\" title=\"原子变量\"></a>原子变量</h2><ol>\n<li>原子变量即为操作一次性完成，期间不进行线程上下文切换，并且能保证线程安全的原子变量。</li>\n<li>原子变量有AtomicBoolean, AtomicInteger, AtomicLong以及AtomicReference（原子引用类型）类型</li>\n<li>之所以称之为原子变量，是因为其包含一些原子方法实现组合操作的方法</li>\n<li>compareAndSet方法，也就是常说的CAS。如果当前值等于expect，则更新为update，否则不更新。如果更新成功，返回true，否则返回false。</li>\n<li>乐观锁与悲观锁的区别：乐观锁假设每次操作都是不会出现冲突，因此在更新时不管是否出现冲突都会先进行一次更新，即便冲突了只需要再检测一次即可；而别管锁假设每次操作都会产生冲突，因此每次操作前都需要获得锁才能继续操作（例如：synchronized关键字）；</li>\n<li>使用CAS会出现一个ABA问题：假设当前值为A，如果另一个线程将A改为B然后再修改回A，当前线程的CAS操作是无法分辨当前值发生过变化的。解决ABA可以在线程修改值时加上一个时间戳，以此来判断当前线程持有变量的版本；</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Pair</span> <span class=\"hljs-variable\">pair</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pair</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">stamp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>AtomicStampedReference&lt;Pair&gt; pairRef = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicStampedReference</span>&lt;&gt;(pair, stamp);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newStamp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br>pairRef.copareAndSet(pair, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pair</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>), stamp, newStamp);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>总结：CAS是并发包的基础，基于它可以实现高效、乐观、非阻塞式数据结构的算法，它也是并发包中锁、同步工具以及各种容器的基础；</li>\n</ol>\n<h2 id=\"显式锁\"><a href=\"#显式锁\" class=\"headerlink\" title=\"显式锁\"></a>显式锁</h2><ol>\n<li>包括锁Lock，主要实现类为ReentrantLock；读写锁接口ReadWriteLock，主要实现类是ReetrantReadWriteLock;</li>\n<li>显式锁一般有下列方法：</li>\n</ol>\n<ul>\n<li>lock()/unlock()：普通获取锁和释放锁方法；会阻塞直至成功；</li>\n<li>lockInterruptibly()：可以响应中断，如果被其他线程中断会抛出InterruptedException；</li>\n<li>tryLock()：只是尝试获取锁，立即返回；如果获取成功返回true，否则返回false;</li>\n<li>newCondition()：新建一个条件</li>\n</ul>\n<ol>\n<li>相比于synchronized，显式锁支持非阻塞方式获取锁、可以响应中断、可以限时；</li>\n<li>Lock是可重入的（一个线程持有一个锁的前提下可以继续获得该锁）、可以解决竞态条件、可以保证内存的可见性（volatile）</li>\n<li>保证竞态条件的公平性会影响性能，一般情况下我们不作保证；例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">int</span> count;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">incr</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock(); <span class=\"hljs-comment\">// 使用lock获得显式锁</span><br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            count++;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock(); <span class=\"hljs-comment\">// 用完要及时释放掉</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getCount</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用tryLock()可以避免死锁，在持有一个锁获另一个锁而获取不到的时候，可以释放自己已持有的锁，给其他线程获得锁的机会，然后重试获取所有锁；例如下面这样写会产生死锁，使用tryLock()判断可以避免死锁问题：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// Account.java</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Account</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">double</span> money;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Account</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> money)</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.money += money;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> money)</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.money -= money;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getMoney</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> money;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">lock</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">unlock</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <br>    <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">tryLock</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> lock.tryLock();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// AccountMgr.java</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AccountMgr</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NoEnoughMoneyException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Exception</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">transfer</span><span class=\"hljs-params\">(Account from, Account to, <span class=\"hljs-type\">double</span> money)</span><span class=\"hljs-keyword\">throws</span> NoEnoughMoneyException &#123;<br>        from.lock(); <span class=\"hljs-comment\">// from获得锁</span><br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            to.lock(); <span class=\"hljs-comment\">// to获得锁</span><br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-keyword\">if</span> (from.getMoney() &gt;= money) &#123;<br>                    from.reduce(money);<br>                    to.add(money);<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoEnoughMoneyException</span>();<br>                &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                    to.unlock(); <span class=\"hljs-comment\">// to释放锁</span><br>                &#125;<br>            &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                from.unlock(); <span class=\"hljs-comment\">// from释放锁</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Java中封装了一个抽象类AQS用于简化并发工具类的实现。AQS全称（AbstractQueuedSynchronizer）。AQS的实现比较复杂。AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。</li>\n<li>Lock锁的基本原理如下：能获得锁就立即获得，否则加入等待队列，被唤醒后检查自己是否是第一个等待的线程，如果是且能获得锁则返回；否则继续等待，这个过程如果发生了中断，lock会记录中断标志位，但不会提前返回或者是抛出异常；</li>\n<li>保证公平性的结果是整体性能会降低，低的原因不在于检查速度慢，而是会让活跃线程得不到锁，进入等待状态，引起频繁上下文切换，降低整体的效率。需要说明的是即便fair参数为true，ReetrantLock中不带参数的tryLock方法也是不保证公平的。</li>\n<li>synchronized关键字是声明式编程，而Lock是命令式编程，所有内部的细节都需要自己实现。目前JVM对synchronized的优化已经相当的好。因此能用synchronized的地方建议使用synchronized，不能使用synchronized关键字的地方再考虑Lock；</li>\n</ol>\n<h2 id=\"显式条件\"><a href=\"#显式条件\" class=\"headerlink\" title=\"显式条件\"></a>显式条件</h2><ol>\n<li>锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，显式条件和wait/notify相对应。</li>\n<li>实现显式锁的显式条件为Condition类，该类为一个接口，其中包含下列方法：其中绝大部分是响应中断的。即：当出现中断会清空标志位：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">await</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 相当于Object中的wait();</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">awaitUnInterruptibly</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 不响应中断</span><br><span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">awaitNanos</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> nanoTimeout)</span>;<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">await</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> times, TimeUnit unit)</span>;<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">awaitUntil</span><span class=\"hljs-params\">(Date deadline)</span>;<br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">signal</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 相当于notify();</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">signalAll</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 相当于notifyAll();</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>await在进入等待队列后，会释放锁以及CPU，当其他线程将它唤醒后、等待超时后以及发生中断退出后都需要重新获得锁，获取锁后才从await方法中退出。</li>\n<li>使用显式锁的示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WaitThread</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Thread</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">fire</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Condition</span> <span class=\"hljs-variable\">condition</span> <span class=\"hljs-operator\">=</span> lock.newCondition();<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            lock.lock();<br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-keyword\">while</span>(!fire) &#123;<br>                    condition.await();<br>                &#125;<br>            &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>            System.out.println(<span class=\"hljs-string\">&quot;fired&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;<br>            Thread.interrupted();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fire</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.fire = <span class=\"hljs-literal\">true</span>;<br>            condition.signal();<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException&#123;<br>        <span class=\"hljs-type\">WaitThread</span> <span class=\"hljs-variable\">waitThread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WaitThread</span>();<br>        waitThread.start();<br>        Thread.sleep(<span class=\"hljs-number\">1000</span>);<br>        System.out.println(<span class=\"hljs-string\">&quot;fire&quot;</span>);<br>        waitThread.fire();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>await()/signal()方法与显式锁配合使用；而wait()/notify()要与synchronized方法使用，不能使用混淆。否则即便编译器不报错也会出现IllegalStateException方法。</li>\n</ol>\n<h1 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h1><h2 id=\"CopyOnWriteArrayList以及CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArrayList以及CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArrayList以及CopyOnWriteArraySet\"></a>CopyOnWriteArrayList以及CopyOnWriteArraySet</h2><ol>\n<li>特点：线程安全，可以被多个线程并发访问；</li>\n<li>迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；</li>\n<li>以原子方式支持一些复合操作</li>\n<li>写时复制的技术思路为：每次出现修改操作时，都会新建一个数组，复制原数组内容到新数组，在新数组上进行需要的修改，然后一原子方式设置内部数组引用。同理：所有的读操作都是<strong>先拿到当前引用的数组</strong>，然后<strong>直接访问</strong>该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响操作，它依旧访问原数组内容。</li>\n<li>截至当前保证线程安全的思路有三种：</li>\n</ol>\n<ul>\n<li>使用锁：例如synchronized关键字以及ReetrantLock；</li>\n<li>使用CAS：</li>\n<li>写时复制也是一种常见的线程安全保证思路，在操作系统内部的进程管理和内存管理经常会使用到。</li>\n</ul>\n<ol>\n<li>总结：CopyOnWriteList和CopyOnWriteSet适用于读远多于写、集合不太大的场景，它们采用了写时复制技术，这也是计算机中一种重要的思维和技术。</li>\n</ol>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><ol>\n<li>特点：并发安全、支持一些原子复合操作、支持高并发，读完全并行、弱一致性；</li>\n<li>HashMap不是线程安全的，在高并发场景下容易出现死循环以及占满CPU的问题；</li>\n<li>Collections.synchronizedMap()在调用一些更新操作时需要加锁，而ConcurrentHashMap()就不存在这个问题；</li>\n<li>ConcurrentHashMap使用了很复杂的技术实现高并发，但是简要概括下有下列两种：</li>\n</ol>\n<ul>\n<li>分段锁：将读取的数据分为多段，每段都拥有自己的锁，每个段都相当于独立的Hash表。使用分段锁可以有效地提高并发效率。</li>\n<li>读不需要锁：对于写操作需要获取锁，不能并行，但是读操作可以并行。写的同时也可以读。</li>\n</ul>\n<ol>\n<li>弱一致性：ConcurrentHashMap在创建完迭代器后，会按照哈希表中反映的结构迭代元素。如果结构的变化发生在已经迭代过的元素上，则结构性变化不会反映出来。反之，若结构变化发生在未发生改变的元素上，结构变化就可以被反映出来。这种现象就称之为弱一致性；</li>\n</ol>\n<h2 id=\"基于SkipList的Map和Set\"><a href=\"#基于SkipList的Map和Set\" class=\"headerlink\" title=\"基于SkipList的Map和Set\"></a>基于SkipList的Map和Set</h2><ol>\n<li>特点：所有的操作都可以并行，包括读和写；</li>\n<li>与TreeMap/TreeSet一样，可以实现按键的自然排序；使用方法如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> CurrentSkipMapDemo &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentSkipMap</span>&lt;&gt;(Collections.reverseOrder());<br>        map.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>        map.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>        map.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>        System.out.println(map.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>SkipMap和SkipSet是基于跳表实现，跳表是基于链表实现的。在链表的基础上增加了多层索引结构。跳表实际上一个类似于二分查找的数据结构。因此有了这样的数据结构就可以更好地实现，关于其复杂度就不再赘述。</li>\n</ol>\n<h2 id=\"并发队列\"><a href=\"#并发队列\" class=\"headerlink\" title=\"并发队列\"></a>并发队列</h2><ol>\n<li>Java中的并发队列一般包括下列几种：</li>\n</ol>\n<ul>\n<li>无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque</li>\n<li>普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque；</li>\n<li>优先级阻塞队列：PriorityBlockingQueue；</li>\n<li>延时阻塞队列：DelayQueue；</li>\n<li>其他阻塞队列：SynchronousQueue和LinkedTransferQueue；</li>\n</ul>\n<ol>\n<li>这里的无锁指的是不使用锁，使用CAS方式实现；</li>\n<li>普通阻塞队列适用于生产者/消费者模式；</li>\n<li>优先级队列是按照优先级出队列的，优先级高的先出</li>\n<li>延时阻塞队列可以用于定时任务，按照元素的延时时间出队，其特殊点在于只有当元素的延时过期之后才能从队列中被拿走</li>\n<li>SynchronousQueue没有存储空间，适用于两进程之间传递信息；LinkedTransferQueue适用于一些消息传递类型的应用中。</li>\n</ol>\n<h1 id=\"异步执行任务\"><a href=\"#异步执行任务\" class=\"headerlink\" title=\"异步执行任务\"></a>异步执行任务</h1><h2 id=\"执行接口\"><a href=\"#执行接口\" class=\"headerlink\" title=\"执行接口\"></a>执行接口</h2><ul>\n<li>Runnable（没有返回结果）和Callable（有返回结果）：表示要执行的异步任务</li>\n<li>Executor和ExecutorService：表示执行服务</li>\n<li>Future：表示异步任务的结果</li>\n</ul>\n<h2 id=\"Future接口的使用\"><a href=\"#Future接口的使用\" class=\"headerlink\" title=\"Future接口的使用\"></a>Future接口的使用</h2><ol>\n<li>示例代码</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Callable</span>&lt;Integer&gt; &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Integer <span class=\"hljs-title function_\">call</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sleepSeconds</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>().nextInt(<span class=\"hljs-number\">1000</span>);<br>            Thread.sleep(sleepSeconds);<br>            <span class=\"hljs-keyword\">return</span> sleepSeconds;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException&#123;<br>        <span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newSingleThreadExecutor();<br>        Future&lt;Integer&gt; future = executor.submit(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>());<br>        Thread.sleep(<span class=\"hljs-number\">100</span>);<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            System.out.println(future.get());<br>        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>实现原理：ExecutorService的主要实现类是ThreadPoolExecutor，是基于线程池实现的。</li>\n<li>总结：并发包执行任务执行服务体现了并发异步开发中的“关注点分离”的思想，使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。</li>\n</ol>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><ol>\n<li>线程池主要有任务队列以及工作者线程组成；</li>\n<li>线程池有下列优点：</li>\n</ol>\n<ul>\n<li>可以重用线程，避免线程创建的开销；</li>\n<li>任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争；</li>\n</ul>\n<ol>\n<li>Java中最常用的线程池类是ThreadPoolExecutor；其中最重要的4个参数是：corePoolSize（核心线程个数）,maximumPoolSize（最大线程个数）keepAliveTime和unit（空闲线程存活时间）</li>\n<li>ThreadPoolExecutor中的队列均为阻塞队列，分为有界和无界两种类型。需要说明的是如果使用了无界队列，线程个数最多只能达到corePoolSize，达到corePoolSize之后新的任务总会排队，参数maximumPoolSize也就没有意义了。</li>\n<li>当队列有界并且maximumPoolSize有限时，只要队列排满，新任务总会被拒绝，因此也会出发任务拒绝策略。不过任务拒绝策略是可以自定义的。</li>\n</ol>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy：默认方式，抛出异常</li>\n<li>ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛出异常也不执行</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：扔掉等待时间最长的任务，然后自己排队</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，不交给线程池中的线程执行</li>\n</ul>\n<h2 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h2><ol>\n<li>TimerTask表示一个定时任务，具体的定时任务需要继承该抽象类，实现run方法。示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicTimer</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DelayTask</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">TimerTask</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;delayed task&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br>        <span class=\"hljs-type\">Timer</span> <span class=\"hljs-variable\">timer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Timer</span>();<br>        timer.schedule(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DelayTask</span>(), <span class=\"hljs-number\">1000</span>);<br>        Thread.sleep(<span class=\"hljs-number\">2000</span>);<br>        timer.cancel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Timer内部主要是由任务队列和Timer线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。一个Timer对象只有一个Timer线程。</li>\n<li>对于固定延时任务，延时相对的是任务执行前的当前时间；对于固定频率任务，延时相对的是最优先计划；</li>\n<li>在执行一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的定时任务都会被取消。因此，如果希望各个定时任务不互相干扰，一定要在run方法内捕获异常。</li>\n<li>并发包中使用ScheduledExecutorService来实现定时任务，其为一个接口，多线程执行定时任务的示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ScheduledFixedDelay</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LongRunningTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;&#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FixedDelayTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ScheduledExecutorService</span> <span class=\"hljs-variable\">timer</span> <span class=\"hljs-operator\">=</span> Executors.newScheduledThreadPool(<span class=\"hljs-number\">10</span>);<br>        timer.schedule(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LongRunningTask</span>(), <span class=\"hljs-number\">10</span>, TimeUnit.MILLISECONDS);<br>        timer.scheduleWithFixedDelay(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FixedDelayTask</span>(), <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1000</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>ScheduledExecutorService的实现原理如下：</li>\n</ol>\n<ul>\n<li>实现背后是线程池，可以有多个线程执行任务；</li>\n<li>在任务执行后再设置下次执行的时间，对于固定延时的任务更合理；</li>\n<li>任务执行线程会捕获任务执行过程中的所有异常。一个定时任务的异常不会影响其他定时任务；</li>\n</ul>\n<h1 id=\"同步以及协作工具类\"><a href=\"#同步以及协作工具类\" class=\"headerlink\" title=\"同步以及协作工具类\"></a>同步以及协作工具类</h1><ol>\n<li>同步工具类包括：</li>\n</ol>\n<ul>\n<li>ReetrantReadWriteLock：读写显式锁</li>\n<li>Semaphore：信号量</li>\n<li>CountDownLatch：倒计时门栓</li>\n<li>CyclicBarrier：循环栅栏</li>\n<li>ThreadLocal：线程本地 2.ReetrantReadWriteLock读写显式锁：只有“读-读”可以并行，“读-写”和“写-写”都是不可以的。只有一个线程可以进行写操作。是基于CAS实现的；</li>\n</ul>\n<ol>\n<li>Semaphore：限制并发数量，是基于AQS实现的；</li>\n<li>CountDownLatch：默认是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过。门栓是一次性的，打开了就不能再关上了。</li>\n<li>CyclicBarrier：所有线程在到达该栅栏后都需要等待其他线程，等待所有线程都到达后在一起通过。它是循环的，可以用重复的同步。</li>\n<li>ThreadLocal：每个线程都有同一个变量的独有拷贝，也就是说每个线程都拥有一个属于自己的独立值。一般来说ThreadLocal都定义为静态类型便于引用</li>\n</ol>\n<h1 id=\"并发总结\"><a href=\"#并发总结\" class=\"headerlink\" title=\"并发总结\"></a>并发总结</h1>","site":{"data":{}},"wordcount":11172,"excerpt":"","more":"<h1 id=\"并发基础\"><a href=\"#并发基础\" class=\"headerlink\" title=\"并发基础\"></a>并发基础</h1><ol>\n<li>线程表示一条单独的执行流，它有自己的执行计数器，有自己的栈；</li>\n<li>使用线程的方式有两种，继承Thread类以及实现Runnable接口，两种达到的效果是一样的。</li>\n<li>线程具有下列状态：</li>\n</ol>\n<ul>\n<li>NEW：没有调用start方法线程状态；</li>\n<li>TERMINATED：线程运行结束后状态；</li>\n<li>RUNNABLE：调用start后线程执行run方法且没有阻塞时状态；</li>\n<li>BLOCKED、WAITING、TIMED_WAITING：线程被阻塞；</li>\n</ul>\n<ol>\n<li>join方法：可以让调用join方法的线程等待该线程结束；</li>\n<li>竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确；</li>\n</ol>\n<h2 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h2><ol>\n<li>synchronized实例方法实际保护的是同一个对象的方法调用，每次只能被一个线程持有；</li>\n<li>synchronized关键字保护的是对象，针对实例对象保护的是当前，对于静态方法保护的类对象；</li>\n<li>被synchronized关键字保护的对象都维护着1个锁以及等待队列；</li>\n<li>synchronized具有下列特点：</li>\n</ol>\n<ul>\n<li>可重入性：对于同一个执行线程在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用；</li>\n<li>内存可见性：释放锁时会将所有的更改写回内存；但是开销有些过高，可以使用volatile关键字实现相同的效果；</li>\n<li>死锁：尽量避免在持有一个锁的同时再去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁；（使用开发过程中可以使用JDK提供的jstack检测死锁）</li>\n</ul>\n<ol>\n<li>对于同步容器对象，单个操作是线程安全的，迭代却不是线程安全的。（因为在多线程操作中容易对容器产生结构性变化）；</li>\n<li>如果需要在迭代容器的过程中保证线程安全，需要在遍历整个容器的过程中给整个容器对象加锁；</li>\n<li>除11中所写到的方法，推荐使用并发容器类：</li>\n</ol>\n<ul>\n<li>CopyOnWriteArrayList</li>\n<li>ConcurrentHashMap;</li>\n<li>CocurrentLinkedQueue;</li>\n<li>ConcurrentSkipSet;</li>\n</ul>\n<h2 id=\"线程协作机制\"><a href=\"#线程协作机制\" class=\"headerlink\" title=\"线程协作机制\"></a>线程协作机制</h2><ol>\n<li>生产/消费者模式：生产者生产数据并放至消费队列中，消费者从消费队列中消费数据，如果队列为空消费者等待，如果队列满，生产者等待；</li>\n<li>同时开始：在模拟仿真程序中，多个线程同时开始；</li>\n<li>等待结束：主线程将任务拆解成多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕；</li>\n<li>异步结果：将子线程封装为异步调用，子线程在正确返回结果前先返回一个Future对象，通过Future对象可以获得子线程最终的执行结果；</li>\n<li>Map/Reduce操作：也需要使用线程进行操作；</li>\n</ol>\n<h2 id=\"wait-notify机制：\"><a href=\"#wait-notify机制：\" class=\"headerlink\" title=\"wait/notify机制：\"></a>wait/notify机制：</h2><ol>\n<li>每个同步对象都拥有一个锁以及一个等待队列，当调用wait方法，系统会将对象放入等待队列，直到调用notify方法再将其从等待队列中取出。</li>\n<li>设计多线程程序的时候需要想清楚共享变量和条件，这是设计多线程协作的核心。</li>\n<li>以生产者/消费者模式为例：生产者生产产品，并放入缓冲队列；消费者从缓冲队列取出产品进行消费。当生产者生产速度过快导致缓冲队列满了，此时生产者应停止生产。同样，当生产者生产过慢导致缓冲队列空，此时消费者应停止消费。等待生产者生产。</li>\n<li>同时进行：一个主线程以及N个子线程，当主线程发送指令后，子线程开始同时执行；</li>\n<li>各个线程分头行动，给咱达到一个集合点，在集合点需要集齐所有线程交换数据。然后再进行下一步动作。</li>\n</ol>\n<h2 id=\"取消-关闭线程机制\"><a href=\"#取消-关闭线程机制\" class=\"headerlink\" title=\"取消/关闭线程机制\"></a>取消/关闭线程机制</h2><ol>\n<li>停止一个线程的手段主要是中断，中断线程的目的并不是强迫线程终止，而是给线程发送一个停止信号，由线程自行决定中断的时机。本质上依旧是一种协作机制。</li>\n<li>Java中关于中断的方法有如下三种：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isInterrupted</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 返回对应线程的中断标志位是否为true</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">interrupt</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 表示中断对应的线程</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">interrupted</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 返回当前线程的中断标志位是否为true，但还有一个副作用：清空中断标志位。</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>对于以线程提供的服务的应用程序模块而言，应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用库应该调用这些方法而不是直接调用interrupt方法；</li>\n</ol>\n<h1 id=\"并发包基石\"><a href=\"#并发包基石\" class=\"headerlink\" title=\"并发包基石\"></a>并发包基石</h1><h2 id=\"原子变量\"><a href=\"#原子变量\" class=\"headerlink\" title=\"原子变量\"></a>原子变量</h2><ol>\n<li>原子变量即为操作一次性完成，期间不进行线程上下文切换，并且能保证线程安全的原子变量。</li>\n<li>原子变量有AtomicBoolean, AtomicInteger, AtomicLong以及AtomicReference（原子引用类型）类型</li>\n<li>之所以称之为原子变量，是因为其包含一些原子方法实现组合操作的方法</li>\n<li>compareAndSet方法，也就是常说的CAS。如果当前值等于expect，则更新为update，否则不更新。如果更新成功，返回true，否则返回false。</li>\n<li>乐观锁与悲观锁的区别：乐观锁假设每次操作都是不会出现冲突，因此在更新时不管是否出现冲突都会先进行一次更新，即便冲突了只需要再检测一次即可；而别管锁假设每次操作都会产生冲突，因此每次操作前都需要获得锁才能继续操作（例如：synchronized关键字）；</li>\n<li>使用CAS会出现一个ABA问题：假设当前值为A，如果另一个线程将A改为B然后再修改回A，当前线程的CAS操作是无法分辨当前值发生过变化的。解决ABA可以在线程修改值时加上一个时间戳，以此来判断当前线程持有变量的版本；</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Pair</span> <span class=\"hljs-variable\">pair</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pair</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">stamp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>AtomicStampedReference&lt;Pair&gt; pairRef = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicStampedReference</span>&lt;&gt;(pair, stamp);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newStamp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br>pairRef.copareAndSet(pair, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pair</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>), stamp, newStamp);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>总结：CAS是并发包的基础，基于它可以实现高效、乐观、非阻塞式数据结构的算法，它也是并发包中锁、同步工具以及各种容器的基础；</li>\n</ol>\n<h2 id=\"显式锁\"><a href=\"#显式锁\" class=\"headerlink\" title=\"显式锁\"></a>显式锁</h2><ol>\n<li>包括锁Lock，主要实现类为ReentrantLock；读写锁接口ReadWriteLock，主要实现类是ReetrantReadWriteLock;</li>\n<li>显式锁一般有下列方法：</li>\n</ol>\n<ul>\n<li>lock()/unlock()：普通获取锁和释放锁方法；会阻塞直至成功；</li>\n<li>lockInterruptibly()：可以响应中断，如果被其他线程中断会抛出InterruptedException；</li>\n<li>tryLock()：只是尝试获取锁，立即返回；如果获取成功返回true，否则返回false;</li>\n<li>newCondition()：新建一个条件</li>\n</ul>\n<ol>\n<li>相比于synchronized，显式锁支持非阻塞方式获取锁、可以响应中断、可以限时；</li>\n<li>Lock是可重入的（一个线程持有一个锁的前提下可以继续获得该锁）、可以解决竞态条件、可以保证内存的可见性（volatile）</li>\n<li>保证竞态条件的公平性会影响性能，一般情况下我们不作保证；例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">int</span> count;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">incr</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock(); <span class=\"hljs-comment\">// 使用lock获得显式锁</span><br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            count++;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock(); <span class=\"hljs-comment\">// 用完要及时释放掉</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getCount</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用tryLock()可以避免死锁，在持有一个锁获另一个锁而获取不到的时候，可以释放自己已持有的锁，给其他线程获得锁的机会，然后重试获取所有锁；例如下面这样写会产生死锁，使用tryLock()判断可以避免死锁问题：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// Account.java</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Account</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">double</span> money;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Account</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> money)</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.money += money;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> money)</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.money -= money;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getMoney</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> money;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">lock</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">unlock</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <br>    <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">tryLock</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> lock.tryLock();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// AccountMgr.java</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AccountMgr</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NoEnoughMoneyException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Exception</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">transfer</span><span class=\"hljs-params\">(Account from, Account to, <span class=\"hljs-type\">double</span> money)</span><span class=\"hljs-keyword\">throws</span> NoEnoughMoneyException &#123;<br>        from.lock(); <span class=\"hljs-comment\">// from获得锁</span><br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            to.lock(); <span class=\"hljs-comment\">// to获得锁</span><br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-keyword\">if</span> (from.getMoney() &gt;= money) &#123;<br>                    from.reduce(money);<br>                    to.add(money);<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoEnoughMoneyException</span>();<br>                &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                    to.unlock(); <span class=\"hljs-comment\">// to释放锁</span><br>                &#125;<br>            &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                from.unlock(); <span class=\"hljs-comment\">// from释放锁</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Java中封装了一个抽象类AQS用于简化并发工具类的实现。AQS全称（AbstractQueuedSynchronizer）。AQS的实现比较复杂。AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。</li>\n<li>Lock锁的基本原理如下：能获得锁就立即获得，否则加入等待队列，被唤醒后检查自己是否是第一个等待的线程，如果是且能获得锁则返回；否则继续等待，这个过程如果发生了中断，lock会记录中断标志位，但不会提前返回或者是抛出异常；</li>\n<li>保证公平性的结果是整体性能会降低，低的原因不在于检查速度慢，而是会让活跃线程得不到锁，进入等待状态，引起频繁上下文切换，降低整体的效率。需要说明的是即便fair参数为true，ReetrantLock中不带参数的tryLock方法也是不保证公平的。</li>\n<li>synchronized关键字是声明式编程，而Lock是命令式编程，所有内部的细节都需要自己实现。目前JVM对synchronized的优化已经相当的好。因此能用synchronized的地方建议使用synchronized，不能使用synchronized关键字的地方再考虑Lock；</li>\n</ol>\n<h2 id=\"显式条件\"><a href=\"#显式条件\" class=\"headerlink\" title=\"显式条件\"></a>显式条件</h2><ol>\n<li>锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，显式条件和wait/notify相对应。</li>\n<li>实现显式锁的显式条件为Condition类，该类为一个接口，其中包含下列方法：其中绝大部分是响应中断的。即：当出现中断会清空标志位：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">await</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 相当于Object中的wait();</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">awaitUnInterruptibly</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 不响应中断</span><br><span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">awaitNanos</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> nanoTimeout)</span>;<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">await</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> times, TimeUnit unit)</span>;<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">awaitUntil</span><span class=\"hljs-params\">(Date deadline)</span>;<br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">signal</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 相当于notify();</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">signalAll</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 相当于notifyAll();</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>await在进入等待队列后，会释放锁以及CPU，当其他线程将它唤醒后、等待超时后以及发生中断退出后都需要重新获得锁，获取锁后才从await方法中退出。</li>\n<li>使用显式锁的示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WaitThread</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Thread</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">fire</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Condition</span> <span class=\"hljs-variable\">condition</span> <span class=\"hljs-operator\">=</span> lock.newCondition();<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            lock.lock();<br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-keyword\">while</span>(!fire) &#123;<br>                    condition.await();<br>                &#125;<br>            &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>            System.out.println(<span class=\"hljs-string\">&quot;fired&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;<br>            Thread.interrupted();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fire</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.fire = <span class=\"hljs-literal\">true</span>;<br>            condition.signal();<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException&#123;<br>        <span class=\"hljs-type\">WaitThread</span> <span class=\"hljs-variable\">waitThread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WaitThread</span>();<br>        waitThread.start();<br>        Thread.sleep(<span class=\"hljs-number\">1000</span>);<br>        System.out.println(<span class=\"hljs-string\">&quot;fire&quot;</span>);<br>        waitThread.fire();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>await()/signal()方法与显式锁配合使用；而wait()/notify()要与synchronized方法使用，不能使用混淆。否则即便编译器不报错也会出现IllegalStateException方法。</li>\n</ol>\n<h1 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h1><h2 id=\"CopyOnWriteArrayList以及CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArrayList以及CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArrayList以及CopyOnWriteArraySet\"></a>CopyOnWriteArrayList以及CopyOnWriteArraySet</h2><ol>\n<li>特点：线程安全，可以被多个线程并发访问；</li>\n<li>迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；</li>\n<li>以原子方式支持一些复合操作</li>\n<li>写时复制的技术思路为：每次出现修改操作时，都会新建一个数组，复制原数组内容到新数组，在新数组上进行需要的修改，然后一原子方式设置内部数组引用。同理：所有的读操作都是<strong>先拿到当前引用的数组</strong>，然后<strong>直接访问</strong>该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响操作，它依旧访问原数组内容。</li>\n<li>截至当前保证线程安全的思路有三种：</li>\n</ol>\n<ul>\n<li>使用锁：例如synchronized关键字以及ReetrantLock；</li>\n<li>使用CAS：</li>\n<li>写时复制也是一种常见的线程安全保证思路，在操作系统内部的进程管理和内存管理经常会使用到。</li>\n</ul>\n<ol>\n<li>总结：CopyOnWriteList和CopyOnWriteSet适用于读远多于写、集合不太大的场景，它们采用了写时复制技术，这也是计算机中一种重要的思维和技术。</li>\n</ol>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><ol>\n<li>特点：并发安全、支持一些原子复合操作、支持高并发，读完全并行、弱一致性；</li>\n<li>HashMap不是线程安全的，在高并发场景下容易出现死循环以及占满CPU的问题；</li>\n<li>Collections.synchronizedMap()在调用一些更新操作时需要加锁，而ConcurrentHashMap()就不存在这个问题；</li>\n<li>ConcurrentHashMap使用了很复杂的技术实现高并发，但是简要概括下有下列两种：</li>\n</ol>\n<ul>\n<li>分段锁：将读取的数据分为多段，每段都拥有自己的锁，每个段都相当于独立的Hash表。使用分段锁可以有效地提高并发效率。</li>\n<li>读不需要锁：对于写操作需要获取锁，不能并行，但是读操作可以并行。写的同时也可以读。</li>\n</ul>\n<ol>\n<li>弱一致性：ConcurrentHashMap在创建完迭代器后，会按照哈希表中反映的结构迭代元素。如果结构的变化发生在已经迭代过的元素上，则结构性变化不会反映出来。反之，若结构变化发生在未发生改变的元素上，结构变化就可以被反映出来。这种现象就称之为弱一致性；</li>\n</ol>\n<h2 id=\"基于SkipList的Map和Set\"><a href=\"#基于SkipList的Map和Set\" class=\"headerlink\" title=\"基于SkipList的Map和Set\"></a>基于SkipList的Map和Set</h2><ol>\n<li>特点：所有的操作都可以并行，包括读和写；</li>\n<li>与TreeMap/TreeSet一样，可以实现按键的自然排序；使用方法如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> CurrentSkipMapDemo &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentSkipMap</span>&lt;&gt;(Collections.reverseOrder());<br>        map.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>        map.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>        map.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>        System.out.println(map.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>SkipMap和SkipSet是基于跳表实现，跳表是基于链表实现的。在链表的基础上增加了多层索引结构。跳表实际上一个类似于二分查找的数据结构。因此有了这样的数据结构就可以更好地实现，关于其复杂度就不再赘述。</li>\n</ol>\n<h2 id=\"并发队列\"><a href=\"#并发队列\" class=\"headerlink\" title=\"并发队列\"></a>并发队列</h2><ol>\n<li>Java中的并发队列一般包括下列几种：</li>\n</ol>\n<ul>\n<li>无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque</li>\n<li>普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque；</li>\n<li>优先级阻塞队列：PriorityBlockingQueue；</li>\n<li>延时阻塞队列：DelayQueue；</li>\n<li>其他阻塞队列：SynchronousQueue和LinkedTransferQueue；</li>\n</ul>\n<ol>\n<li>这里的无锁指的是不使用锁，使用CAS方式实现；</li>\n<li>普通阻塞队列适用于生产者/消费者模式；</li>\n<li>优先级队列是按照优先级出队列的，优先级高的先出</li>\n<li>延时阻塞队列可以用于定时任务，按照元素的延时时间出队，其特殊点在于只有当元素的延时过期之后才能从队列中被拿走</li>\n<li>SynchronousQueue没有存储空间，适用于两进程之间传递信息；LinkedTransferQueue适用于一些消息传递类型的应用中。</li>\n</ol>\n<h1 id=\"异步执行任务\"><a href=\"#异步执行任务\" class=\"headerlink\" title=\"异步执行任务\"></a>异步执行任务</h1><h2 id=\"执行接口\"><a href=\"#执行接口\" class=\"headerlink\" title=\"执行接口\"></a>执行接口</h2><ul>\n<li>Runnable（没有返回结果）和Callable（有返回结果）：表示要执行的异步任务</li>\n<li>Executor和ExecutorService：表示执行服务</li>\n<li>Future：表示异步任务的结果</li>\n</ul>\n<h2 id=\"Future接口的使用\"><a href=\"#Future接口的使用\" class=\"headerlink\" title=\"Future接口的使用\"></a>Future接口的使用</h2><ol>\n<li>示例代码</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Callable</span>&lt;Integer&gt; &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Integer <span class=\"hljs-title function_\">call</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sleepSeconds</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>().nextInt(<span class=\"hljs-number\">1000</span>);<br>            Thread.sleep(sleepSeconds);<br>            <span class=\"hljs-keyword\">return</span> sleepSeconds;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException&#123;<br>        <span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newSingleThreadExecutor();<br>        Future&lt;Integer&gt; future = executor.submit(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>());<br>        Thread.sleep(<span class=\"hljs-number\">100</span>);<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            System.out.println(future.get());<br>        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>实现原理：ExecutorService的主要实现类是ThreadPoolExecutor，是基于线程池实现的。</li>\n<li>总结：并发包执行任务执行服务体现了并发异步开发中的“关注点分离”的思想，使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。</li>\n</ol>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><ol>\n<li>线程池主要有任务队列以及工作者线程组成；</li>\n<li>线程池有下列优点：</li>\n</ol>\n<ul>\n<li>可以重用线程，避免线程创建的开销；</li>\n<li>任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争；</li>\n</ul>\n<ol>\n<li>Java中最常用的线程池类是ThreadPoolExecutor；其中最重要的4个参数是：corePoolSize（核心线程个数）,maximumPoolSize（最大线程个数）keepAliveTime和unit（空闲线程存活时间）</li>\n<li>ThreadPoolExecutor中的队列均为阻塞队列，分为有界和无界两种类型。需要说明的是如果使用了无界队列，线程个数最多只能达到corePoolSize，达到corePoolSize之后新的任务总会排队，参数maximumPoolSize也就没有意义了。</li>\n<li>当队列有界并且maximumPoolSize有限时，只要队列排满，新任务总会被拒绝，因此也会出发任务拒绝策略。不过任务拒绝策略是可以自定义的。</li>\n</ol>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy：默认方式，抛出异常</li>\n<li>ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛出异常也不执行</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：扔掉等待时间最长的任务，然后自己排队</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，不交给线程池中的线程执行</li>\n</ul>\n<h2 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h2><ol>\n<li>TimerTask表示一个定时任务，具体的定时任务需要继承该抽象类，实现run方法。示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicTimer</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DelayTask</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">TimerTask</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;delayed task&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br>        <span class=\"hljs-type\">Timer</span> <span class=\"hljs-variable\">timer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Timer</span>();<br>        timer.schedule(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DelayTask</span>(), <span class=\"hljs-number\">1000</span>);<br>        Thread.sleep(<span class=\"hljs-number\">2000</span>);<br>        timer.cancel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Timer内部主要是由任务队列和Timer线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。一个Timer对象只有一个Timer线程。</li>\n<li>对于固定延时任务，延时相对的是任务执行前的当前时间；对于固定频率任务，延时相对的是最优先计划；</li>\n<li>在执行一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的定时任务都会被取消。因此，如果希望各个定时任务不互相干扰，一定要在run方法内捕获异常。</li>\n<li>并发包中使用ScheduledExecutorService来实现定时任务，其为一个接口，多线程执行定时任务的示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ScheduledFixedDelay</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LongRunningTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;&#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FixedDelayTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ScheduledExecutorService</span> <span class=\"hljs-variable\">timer</span> <span class=\"hljs-operator\">=</span> Executors.newScheduledThreadPool(<span class=\"hljs-number\">10</span>);<br>        timer.schedule(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LongRunningTask</span>(), <span class=\"hljs-number\">10</span>, TimeUnit.MILLISECONDS);<br>        timer.scheduleWithFixedDelay(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FixedDelayTask</span>(), <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1000</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>ScheduledExecutorService的实现原理如下：</li>\n</ol>\n<ul>\n<li>实现背后是线程池，可以有多个线程执行任务；</li>\n<li>在任务执行后再设置下次执行的时间，对于固定延时的任务更合理；</li>\n<li>任务执行线程会捕获任务执行过程中的所有异常。一个定时任务的异常不会影响其他定时任务；</li>\n</ul>\n<h1 id=\"同步以及协作工具类\"><a href=\"#同步以及协作工具类\" class=\"headerlink\" title=\"同步以及协作工具类\"></a>同步以及协作工具类</h1><ol>\n<li>同步工具类包括：</li>\n</ol>\n<ul>\n<li>ReetrantReadWriteLock：读写显式锁</li>\n<li>Semaphore：信号量</li>\n<li>CountDownLatch：倒计时门栓</li>\n<li>CyclicBarrier：循环栅栏</li>\n<li>ThreadLocal：线程本地 2.ReetrantReadWriteLock读写显式锁：只有“读-读”可以并行，“读-写”和“写-写”都是不可以的。只有一个线程可以进行写操作。是基于CAS实现的；</li>\n</ul>\n<ol>\n<li>Semaphore：限制并发数量，是基于AQS实现的；</li>\n<li>CountDownLatch：默认是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过。门栓是一次性的，打开了就不能再关上了。</li>\n<li>CyclicBarrier：所有线程在到达该栅栏后都需要等待其他线程，等待所有线程都到达后在一起通过。它是循环的，可以用重复的同步。</li>\n<li>ThreadLocal：每个线程都有同一个变量的独有拷贝，也就是说每个线程都拥有一个属于自己的独立值。一般来说ThreadLocal都定义为静态类型便于引用</li>\n</ol>\n<h1 id=\"并发总结\"><a href=\"#并发总结\" class=\"headerlink\" title=\"并发总结\"></a>并发总结</h1>"},{"title":"Java编程原理——动态与函数式编程","date":"2022-02-16T14:33:55.000Z","updated":"2022-02-16T14:33:55.000Z","_content":"\n# 反射\n\n1. 反射是在类运行时动态获取类型的信息。比如接口信息、成员信息、方法信息、构造函数信息等。根据动态获取到的信息创建对象、访问/修改成员、调用方法等。\n2. 使用反射可以得到类的名称，调用方法getName()。其中还包括getSimpleName()，getCanonicalName()以及getPackage()。\n3. 类中定义的静态和实例变量称之为字段，使用Field类表示，可以获取字段的访问权限，设置访问权限，获得字段值以及设置字段值。除此之外，还可以获得字段的修饰符以及基本类型。需要注意的是使用反射返回的修饰符是一个整型。如果需要查看具体的返回值类型，可以使用Modifier进行再次判断。\n4. 通过反射也可以获取类中的方法信息：对于invoke方法而言，如果Method是静态方法，则obj被忽略为null，args可以为null；\n5. 创建对象和构造方法：`public T newInstance() throws InstantiationException, IllegalAccessException`；\n6. 类型检查和转换：使用`instanceof`关键字可以用于判断变量指向的实际对象类型，instanceof后面的类型是在代码中确定的；\n7. 除此之外，Class方法中还有其他的一些方法可以用于获取类的声明信息、修饰符、父类、接口以及注解等；\n8. 对于数组类型可以使用`public native Class<T> getComponentType()`获取其元素类型；\n9. 反射与枚举：枚举类型也有一个专门的方法：`public T[] getEnumConstants()`；\n10. 反射与泛型：可以获取泛型参数的信息：\n\n+ Class类有如下方法：`public TypeVariable<Class<T>>[] getTypeParameters()`\n+ Field有如下方法：`public Type getGenericType()`\n+ Method有如下方法：`public Type getGenericReturnType()`，`public Type[] getGenericParameterTypes()`和`public Type[] getGenericExceptionTypes()`\n+ Constructor有如下方法：`public Type[] getGenericParameterTypes()`\n\n1. Type实现了Class方法，其中还实现了下列方法：\n\n+ TypeVariable类型参数可以有上界；\n+ ParameterizedType参数化的类型，有原始类型和具体类型；\n+ WildcardType通配符类型\n+ 通过反射获取泛型示例\n\n```java\npublic class GenericDemo {\n    static class GenericTest<U extends Comparable<U, V> {\n        U u;\n        V v;\n        List<String> list;\n        public U test(List<? extends Number> numbers) {\n            return null;\n        }\n    }\n    public static void main(String[] args) {\n        Class<?> cls = GenericTest.class;\n        for (TypeVariable t : cls.getTypeParameters()) {\n            System.out.println(t.getName() + \" extends \" + Arrays.toString(t.getBounds()));\n        }\n        Field fu = cls.getDeclaredField(\"u\");\n        System.out.println(fu.getGenericType());\n        Field first = cls.getDeclaredField(\"list\");\n        Type listType = first.getGenericType();\n        if (!listType instanceof ParameterizedType) {\n            ParameterizedType pType = (ParameterizedType)listType;\n            System.out.println(\"raw type: \" + pType.getRawType() + \" ,type arguments:\" + Arrays.toString(pType.getActualTypeArguments()));\n        }\n        // 省略代码\n    }\n}\n```\n\n1. 总结：反射虽然灵活，但一般情况下我们并不优先建议，原因有如下：\n\n+ 反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力；\n+ 反射会降低性能，在访问字段、调用方法前，反射要先查找对应的Field/Method，要慢一些；\n\n1. 如果能用接口实现同样的灵活性，就不要使用反射；\n\n# 注解\n\n1. 注解是给程序添加一些信息，这些信息可以用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序；\n2. Java内置`@Override`，`@Deprecated`和`@SuppressWarning`三个注解，这三个注解远远不能满足日常开发需求，因此自定义注解产生。\n3. 注解是声明式编程中的一种巧妙应用，在这种风格中，程序通常由下列三部分实现：\n\n+ 声明的关键字和语法本身；\n+ 系统/框架/库，它们负责解释，执行声明式的语句；\n+ 应用程序，使用声明式编程风格编写程序；\n\n1. 创建注解：使用`@interface`关键字声明注解，另外是需要在声明的注解标明元注解。以`@Override`注解为例：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n4.1 ElementType是一个枚举，可以取下列值：\n\n+ TYPE：表示类、接口（包括注解），或者是枚举类型\n+ FIELD：字段，包括枚举常量\n+ METHOD：方法\n+ PARAMETER：方法中的参数\n+ CONSTRUCTOR：构造方法\n+ LOCAL_VARIABLE：本地变量\n+ MODULE：模块（Java 9引入）\n+ \n\n4.2 如果没有声明`@Target`，默认适用于所有类型；\n\n4.3 `@Retention`表示注解信息保留到什么时候，取值只有一个，类型为RetentionPolicy，它是一个枚举，有三个值：\n\n+ SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后去掉；\n+ CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留（默认值）；\n+ RUNTIME：一直保留到运行时\n\n4.4 `@Documented`注解表示注解信息包含到生成文档中；\n\n4.5 注解不能继承，但是使用了注解的父类一旦被子类继承，那么子类就可以继承父类的注解，如果要实现这样的效果，需要在父类的注解中加上`@Inherited`\n\n1. 总结：注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离。框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作；\n\n# 动态代理\n\n1. 静态代理\n\n```java\npublic class SImpleStaticProxy {\n    interface IService {\n        void sayHello();\n    }\n\n    // 真实对象\n    static class RealService implements IService {\n        @Override\n        public void sayHello() {\n            System.out.println(\"RealService Say Hello!\");\n        }\n    }\n\n    // 代理对象\n    static class TraceProxy implements IService {\n        private IService realService;\n\n        TraceProxy(IService realService) {\n            this.realService = realService;\n        }\n\n        @Override\n        public void sayHello() {\n            System.out.println(\"entering say hello...\");\n            this.realService.sayHello();\n            System.out.println(\"exited say hello...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = new TraceProxy(realService);\n        proxyService.sayHello();\n    }\n}\n```\n\n1. 动态代理\n\n```java\npublic class SimpleDynamicProxy {\n    interface IService {\n        void sayHello();\n    }\n    \n    // 真实对象\n    static class RealService implements IService {\n        @Override\n        public void sayHello() {\n            System.out.println(\"Real Service Say Hello\");\n        }\n    }\n    \n    // 代理对象实现JDK中的InvocationHandler接口\n    static class SimpleInvocationHandle implements InvocationHandler {\n        private Object realObj;\n\n        SimpleInvocationHandle(Object realObj) {\n            this.realObj = realObj;\n        }\n        \n        // 重写invoke方法\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            // proxy：表示代理对象本身，不是被代理对象，一般用处不大\n            // method：表示正在被调用的方法\n            // args：表示方法的参数\n            System.out.println(\"entering \" + method.getName());\n            Object result = method.invoke(realObj, args);\n            System.out.println(\"leaving \" + method.getName());\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = (IService) Proxy.newProxyInstance(IService.class.getClassLoader(), new Class<?>[]{IService.class},\n                new SimpleInvocationHandle(realService)); // 使用Proxy.newProxyInstance生成一个代理对象\n        proxyService.sayHello();\n    }\n}\n```\n\n+ newProxyInstance的声明如下：\n\n```java\npublic static Object newProxyInstance(ClassLoader classLoader, Class<?>[] interfaces, InvocationHandler h);\n// ClassLoader：表示类加载器；\n// Class<?>[] interfaces：表示代理类要实现的接口列表，元素类型只能是接口，不能是普通类；\n// InvocationHandler：是一个接口，对代理接口所有方法的调用都会转给该方法；\n// newProxyInstance是Object类型，它不能强制转换为某个类型，只能转换为接口类型；\n```\n\n1. 类定义本身与被代理的对象没有关系，与InvocationHandler的具体实现也没有关系，而主要与接口数组有关，给定的接口数组会动态地创建每个接口的实现代码，实现就是转发给InvocationHandler，与被代理对象的关系以及对它的调用由InvocationHandler实现管理。\n2. 总结：使用动态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每个被代理的类型都是创建一个静态代理类。\n3. 局限性：JDK中的动态代理只能为接口创建代理，返回的代理对象也只能转换到某个接口类型；如果一个类没有接口，或者希望代理非接口中定义的方法，就无能为力了。\n4. 使用cglib的动态代理类可以解决上述的痛点。示例如下：\n\n```java\npublic class SimpleCGLibDemo {\n    static class RealService {\n        public void sayHello() {\n            System.out.println(\"hello\");\n        }\n    }\n    static class SimpleInterceptor implements MethodInterceptor {\n        @Override\n        public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            System.out.println(\"entering \" + method.getName());\n            Object result = proxy.invokeSuper(object, args);\n            System.out.println(\"leaving \" + method.getName());\n        }\n    }\n    private static <T> T getProxy(Class<T> cls) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(cls);\n        enhancer.setCallback(new SimpleInterceptor());\n        return (T)enhancer.create();\n    }\n    \n    public static void main(String[] args) {\n        RealService proxyService = getProxy(RealService.class);\n        proxyService.sayHello();\n    }\n}\n```\n\n1. cglib代理面向的一个具体的类，创建对象只有一个；而SDK代理面向的是接口；\n\n# 类加载机制\n\n1. 类加载机制可以应用于下列场景：\n\n+ 热部署：不重启程序的情况下动态替换\n+ 应用模块化和互相隔离：不同的ClassLoader可以加载相同的类，但是互相隔离、互不影响。例如：Tomcat管理多个Web应用程序；\n+ 从不同地方灵活加载：系统默认从本地.class文件或者.jar包中加载字节码文件，通过自定义ClassLoader可以从共享服务器、数据库、缓存服务器等其他地方加载字节码文件；\n\n1. 类加载机制组成部分：\n\n+ 启动类型加载器（Bootstrap Classloader）：一般由C++实现的，它负责加载Java的基础类，主要是<JAVA_HOME>/lib/rt.jar；\n+ 扩展类加载器（Extension Classloader）：加载器的实现类sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类；\n+ 应用程序类加载器（Application ClassLoader）：实现类是sun.misc.Launcher$AppClassLoader。负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类；\n\n1. 类加载的全过程：\n\n+ 1）判断是否已经加载过，如果加载过直接返回Class对象，一个类只会被一个ClassLoader加载过一次；\n+ 2）如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象；\n+ 3）在父ClassLoader没有加载成功的前提下，自己尝试加载类；\n\n1. 这个过程称之为“双亲委派”模型。优先让父ClassLoader去加载。\n2. 类加载都按照“双亲委派”模型，但是也有例外：\n\n+ 自定义加载顺序：即自定义的类加载器可以不遵循“双亲委派”模型，但一般上是不推荐的；\n+ 网状加载顺序：在OSGI和Java9中存在网状加载的情况。\n+ 父加载器委派给子加载器：典型应用有JNDI。\n\n1. 类加载器的例子：\n\n```java\npublic class ClassLoaderDemo {\n    public static void main(String[] args) {\n        ClassLoader c1 = ClassLoaderDemo.class.getClassLoader();\n        while (c1 != null) {\n            System.out.println(c1.getClass().getName());\n            c1 = c1.getParent();\n        }\n        System.out.println(String.class.getClassLoader());\n    }\n}\n// 输出结果为：\n// sun.misc.Launcher.$AppClassLoader\n// sun.misc.Launcher.$ExtClassLoader\n```\n\n1. ClassLoader中有一个默认方法`public static ClassLoader getSystemClassLoader()`，还有一个默认方法用于加载类： `public class<?> loadClass(String name) throws ClassNotFoundException`。示例如下：\n\n```java\nClassLoader c1 = ClassLoader.getSystemClassLoader();\ntry {\n    Class<?> cls = c1.loadClass(\"java.util.ArrayList\");\n    ClassLoader actualLoader = cls.getClassLoader();\n    System.out.println(actualloader);\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n}\n```\n\n1. 类加载器是一个抽象类。Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader以及sun.misc.Launcher$ExtClassLoader。Bootstrap ClassLoader不是由Java实现的。因此没有实现类。需要说明的是，由于是委派机制。使用getClassLoader()方法返回的不一定调用load-Class.\n2. ClassLoader中的loadClass方法只会加载类但是不会执行。示例如下：\n\n```java\npublic class CLInitDemo {\n    public static class Hello {\n        static {\n            System.out.println(\"hello\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ClassLoader c1 = ClassLoader.getSystemClassLoader();\n        String className = CLInitDemo.class.getName() + \"$Hello\";\n        try {\n            Class<?> cls = c1.loadClass(className); // 不会输出\"hello\"\n            // Class<?> cls = Class.forName(className); // 会输出\"hello\"\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n1. 通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，也是一种策略模式。\n\n# 正则表达式\n\n## 单个字符\n\n1. 用字符本身表示\n2. 特殊字符：例如制表符'\\t'，换行符'\\n'以及回车符'\\r'；\n3. 八进制表示的字符：以'\\0'开头，后面加上1~3位数字，例如\\0141(8) -> 97(10)\n4. 十六进制表示的字符：以'\\x'开头，后面跟两位字符，比如\\x6A(16) -> 106(10)\n5. Unicode表示字符，以'\\u'开头，后面跟4位字符\n6. 斜杠本身就是特殊字符，如果需要使用斜杠需要用一个斜杠进行转义；\n7. 元字符：例如“.、*、?、+”等，如果要皮匹配自身，需要在前面加''进行转义\n\n## 字符祖\n\n1. '.'字符匹配除了换行符以外的任意字符，也可以使用“单行匹配模式”或者“点号匹配模式”。可以以(?s)开头，s表示single line；\n2. 中括号[]表示匹配字符组中的任意一个字符，例如[abcd]匹配任意一个字母；\n3. '^'表示排除符号；\n4. \\d：匹配一个数字字符，等同于[0-9]；\n5. \\w：匹配一个单词字符，等同于[a-zA-Z_0-9]；\n6. \\s：匹配一个空白字符，等同于[\\t\\n\\x0B\\f\\r]\n7. \\D：匹配一个非数字字符，即[^\\d]；\n8. \\W：匹配一个非单词字符，即[^\\w]；\n9. \\S：匹配一个非空白字符，即[^\\s]；\n\n## 量词\n\n1. 量词是指定出现次数的元字符，常见的有三种+、*、？\n2. '+'表示前面字符的一次或多次出现。比如正则表达式ab+c，既能匹配abc，也能匹配abbc:\n3. '*'表示前面的字符的零次或多次出现，例如：ab*c。既能匹配abc，也能匹配ac或abbbc；\n4. '?'表示前面字符可能出现，也可能不出现。例如正则表达式ab?c，既能匹配abc，也能匹配ac；\n5. 通用表示出现次数的语法为{m,n}，出现次数从m到n，包括m和n。如果n没有限制可以省略。如果m和n一样，可以省略一个写为{m}。例如：\n\n+ ab{1,10}c：b可以出现1次到10次\n+ ab{3}c：b必须出现三次\n+ ab{1,}c：等同于ab+c\n+ ab{0,}c：等同于ab*c\n+ ab{0,1}c：等同于ab?c\n\n1. 量词默认是贪婪的，也就是说会从正则开始匹配到结束内的所有字符，如果需要在匹配到第一个就终止，需要使用懒惰量词。即在两次后面加上一个符号'?'；\n\n## 分组\n\n1. 可以用括号将表达式括起来，表示一个分组。分组匹配的子字符串可以在后续访问，好像被被捕获了一样，所以默认分组称之为捕获分组；\n2. 在正则表达式中，可以使用斜杠\\加分组编号引用之前匹配的分组，称之为回溯引用；\n\n## 特殊边界匹配\n\n1. 常见的特殊边界的元字符有^、$、\\A、\\Z、\\z和\\b。\n2. ‘’匹配整个字符串的开始，此外‘’也表示排除，默认单行匹配；\n3. ‘$’匹配整个字符串的结束，默认单行匹配；\n4. 多行匹配的方式如下：以(?m)开头。例如：(?m)^abc$\n5. \\A和^类似；\n6. \\Z和$类似；\\z匹配的总是结束的边界；\n7. \\b匹配的是单词的边界；\n8. 边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界；\n\n## 环视边界匹配\n\n1. 此部分内容比较晦涩，暂不做了解；\n\n# 函数式编程\n\n## 函数是接口：\n\n1. Java中预定义了大量的函数式接口：\n\n| 函数接口            | 方法定义               | 说明                                 |\n| ------------------- | ---------------------- | ------------------------------------ |\n| Predicate<T>        | boolean test(T t)      | 谓词，测试输入条件是否满足要求       |\n| Function<T, R>      | R apply(T t)           | 函数转换，输入类型T，输出类型R       |\n| Consumer<T>         | void accept(T t)       | 消费者，输入类型T                    |\n| Supplier<T>         | T get()                | 工厂方法                             |\n| UnaryOperator<T>    | T apply(T t)           | 函数转换的特例，输入和输出类型一样   |\n| BiFunction<T, U, R> | R apply(T t, U u)      | 函数转换，接受两个参数，输出R        |\n| BinaryOperator<T>   | T apply(T t, T u)      | BiFunction的特例，输入和输出类型一样 |\n| BiConsumer<T, U>    | void accept(T t, U u)  | 消费者，接受两个参数                 |\n| BiPredicate<T, U>   | boolean test(T t, U u) | 谓词，接受两个参数                   |\n\n1. Predicate示例：\n\n```java\nstatic class Student {\n    String name;\n    double score;\n    // 省略getter/setter\n}\n\n// 借助Predicate撰写一个filter的逻辑，例如：\nstudents = filter(students, t -> t.getScore() > 90);\n```\n\n1. Function示例：数据转换\n\n```java\n// 根据学生列表返回名称列表的代码：\nList<Student> names = map(students, t -> t.getName());\n\n// 将学生名称转换为大写：\nstudents = map(students, t -> new Student(t.getName().toUpperCase(), t.getScore()))\n```\n\n1. Consumer示例：直接对原值进行修改\n\n```java\nforeach(students, t -> t.setName(t.getName(),.toUpperCase()))\n```\n\n## 方法引用\n\n1. 示例代码中`Student::getName`称之为方法引用，使用::分隔开。分隔符前面是类型或变量名，后者是方法名。方法可以是实例方法，也可以是静态方法。例如：\n\n```java\npublic static String getColleageName() {\n    return \"Test String\";\n}\n// 下面两条句子的等价的\nSupplier<String> s = Student::getColleageName;\nSupplier<String> s = () -> Student.getColleageName()；\n```\n\n## 函数的复合\n\n1. 函数式接口和Lambda表达式可以用作方法的返回值，传递代码回调者，将上述两种方法结合起来，可以构造复合的函数，使程序简洁易读；\n2. 复合Comparator中的复合方法：\n\n```java\nArrays.sort(files, (f1, f2) -> f1.getName().compareTo(f2.getName()));\n// 进一步简化\nArrays.sort(files, Comparator.comparing(File::getName()));\n```\n\n## Stream API\n\n1. 基本过滤\n\n```java\n// 使用Stream API之前\nList<Student> above90List = new ArrayList<>();\nfor (Student t : students) {\n    if (t.getScore() > 90) {\n        above90List.add(t);\n    }\n}\n\n// 使用Stream API之后\nList<Student> above90List = students.stream()\n    .filter(t -> t.getScore() > 90).collect(Collectors.toList());\n```\n\n+ 没有显式的迭代循环，循环过程被Stream隐藏；\n+ 提供了声明式的处理函数；\n+ 流畅式接口；\n\n1. 基本转换\n\n```java\n// 使用Stream API之前\nList<String> nameList = new ArrayList<>();\nfor (Student t : students) {\n    nameList.add(t.getName());\n}\n\n// 使用Stream API之后\nList<String> nameList = students.stream()\n    .map(Student::getName).collect(Collectors.toList());\n```\n\n1. 基本过滤和转换组合\n\n```java\nList<String> above90List = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .map(Student::getName)\n    .collect(Collectors.toList());\n```\n\n1. distinct运算\n\n+ 用于过滤重复元素，只留下唯一元素，是否重复根据equals()方法来比较。\n\n```java\nList<String> list = Arrays.asList(new String[]{\"abc\", \"def\", \"hello\", \"Abc\"});\nList<String> retList = list.stream()\n    .filter(s -> s.length() <= 3).map(String::toLowerCase).distinct()\n    .collect(Collectors.toList());\n```\n\n1. sorted方法\n\n+ 对流中的元素进行排序，返回一个排序后的stream。例如：\n\n```java\nList<Student> list = students.stream().filter(t -> t.getScore() > 0)\n    .sorted(Comparator.comparing(Student::getScore)\n    .reversed().thenComparing(Student::getName))\n    .collect(Collectors.toList());\n```\n\n1. skip/limit\n\n+ 跳过流中的n个元素，如果流的长度不足n个，返回一个空流。例如：\n\n```java\nList<Student> list = students.stream()\n    .sorted(Comparator.comparing(Student::getScore).reversed()\n    .skip(2).limit(3).collect(Coolectors.toList()));\n```\n\n1. peek\n\n+ 返回一个与之前一样的流，没有变化。但是提供一个Consumer，会将流中的每一个元素传给Consumer。这个方法主要目的用于支持调试，可以使用该方法观察在流水线中流转的元素。例如：\n\n```java\nList<String> above90Names = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .peek(System.out::println).map(Student::getName)\n    .collect(Collectors.toList());\n```\n\n1. mapToLong/mapToInt/mapToDouble\n\n+ map函数接受函数参数是一个`Function<T, R>`，为避免拆箱，装箱提高性能。例如：\n\n```java\ndouble sum = students.stream()\n    .mapToDouble(Student::getScore).sum();\n```\n\n1. flatMap\n\n+ 接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换成一个流Stream。然后将新生成流的每一个元素传递给下一个操作。比如：\n\n```java\nList<String> lines = Arrays.asList(new String[]{\"hello abc\", \"laoma biancheng\"});\nList<String> words = lines.stream()\n    .flatMap(line -> Arrays.stream(line.split(\"\\\\s+\")))\n    .collect(Collectors.toList());\nSystem.out.println(words); // [hello, abc. laoma, biancheng]\n```\n\n## 终端操作\n\n1. 中间操作不触发实际执行，返回值是Stream，而终端操作触发执行，返回一个具体的值。除了collect之外还有：max, min, count, allMatch, anyMatch, noneMatch, findFirst, findAny, forEach, toArray, reduce等。\n2. max/min: 返回流中的最大值/最小值。其返回类型为Optional<T>而非T。Optional表明可能为null，程序应当进行适当的处理。例子：\n\n```java\nStudent student = students.stream()\n    .max(Comparator.comparing(Student::getScore).reversed()).get();\n```\n\n1. count：返回流中的元素个数，例如：\n\n```java\nlong above90Count = students.stream()\n    .filter(t -> t.getScore() > 90).count();\n```\n\n1. allMatch/anyMatch/noneMatch：用于判定流中额元素是否满足一定的条件，区别在于：\n\n+ allMatch：流中所有元素都满足条件的情况下返回true;\n+ anyMatch：流中的元素只要有一个元素满足条件即返回true;\n+ noneMatch：只有流中的所有元素都不满足条件才返回true;\n+ 示例如下：\n\n```java\nboolean allPass = students.stream()\n    .allMatch(t -> t.getScore() >= 60);\n```\n\n1. findFirst/findAny：返回类型均为Optional，如果流为空则返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素。均为短路操作。示例：\n\n```java\nOptional<Student> student = students.stream()\n    .filter(t -> t.getScore() < 60)\n    .findAny();\nif (student.isPresent()) {\n    // 处理不符合要求的数据\n}\n```\n\n1. forEach/forEachOrdered：并行流中forEach不保证顺序，forEachOrdered能保证顺序。例如：\n\n```java\nstudents.stream()\n    .filter(t -> t.getScore() > 90)\n    .forEach(System.out::println);\n```\n\n1. toArray：将流转换为数组，包含两个方法。\n\n```java\nObject[] toArray() // 返回值为Object[]\n<A> A[] toArray(IntFunction<A[]> generator) // 得到指定类型的数组\n```\n\n+ 示例为：\n\n```java\nStudent[] above90Arr = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .toArray(Student[]::new); // Student[]::new就是一个IntFunction类型的ggenerator\n```\n\n1. reduce：归约或折叠，将流中的元素归约为一个值，有三种reduce函数：\n\n```java\nOptional<T> reduce(BinaryOperator<T> accumulator);\nT reduce(T identity, BinaryOperator<T> accumulator);\n<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);\n```\n\n+ 第一个reduce函数的使用\n\n```java\nStudent topStudent = students.stream()\n    .reduce((acc, t) -> {\n        if(acc.getScore() >= t.getScore()) {\n            return acc;\n        } else {\n            return t;\n        }\n    }).get();\n```\n\n+ 第二个reduce函数比第一个多了identity参数，表示初始值\n+ 第三个reduce函数更为通用，可以自定义归约类型，另外还多了一个combiner参数，在并行流中用于合并子线程结果。还有示例：\n\n```java\ndouble sumScore = students.stream()\n    .reduce(0d, (sum, t) -> sum += t.getScore(), \n    (sum1, sum2) -> sum1 += sum2)\n    );\n```\n\n1. 迭代Map的过程删除元素，直接使用forEach会报ConcurrentModificationException\n\n```java\nMap<String, Object> map = other.getHashMap<>();\nmap.entrySet().removeIf(entryElement -> \"some condition\".equals(entryElement.getKey()))\n```\n","source":"_posts/java-core/ch06.md","raw":"---\ntitle: Java编程原理——动态与函数式编程\ndate: 2022-02-16 22:33:55\nupdated: 2022-02-16 22:33:55\ntags: Java基础\ncategories: Java\n---\n\n# 反射\n\n1. 反射是在类运行时动态获取类型的信息。比如接口信息、成员信息、方法信息、构造函数信息等。根据动态获取到的信息创建对象、访问/修改成员、调用方法等。\n2. 使用反射可以得到类的名称，调用方法getName()。其中还包括getSimpleName()，getCanonicalName()以及getPackage()。\n3. 类中定义的静态和实例变量称之为字段，使用Field类表示，可以获取字段的访问权限，设置访问权限，获得字段值以及设置字段值。除此之外，还可以获得字段的修饰符以及基本类型。需要注意的是使用反射返回的修饰符是一个整型。如果需要查看具体的返回值类型，可以使用Modifier进行再次判断。\n4. 通过反射也可以获取类中的方法信息：对于invoke方法而言，如果Method是静态方法，则obj被忽略为null，args可以为null；\n5. 创建对象和构造方法：`public T newInstance() throws InstantiationException, IllegalAccessException`；\n6. 类型检查和转换：使用`instanceof`关键字可以用于判断变量指向的实际对象类型，instanceof后面的类型是在代码中确定的；\n7. 除此之外，Class方法中还有其他的一些方法可以用于获取类的声明信息、修饰符、父类、接口以及注解等；\n8. 对于数组类型可以使用`public native Class<T> getComponentType()`获取其元素类型；\n9. 反射与枚举：枚举类型也有一个专门的方法：`public T[] getEnumConstants()`；\n10. 反射与泛型：可以获取泛型参数的信息：\n\n+ Class类有如下方法：`public TypeVariable<Class<T>>[] getTypeParameters()`\n+ Field有如下方法：`public Type getGenericType()`\n+ Method有如下方法：`public Type getGenericReturnType()`，`public Type[] getGenericParameterTypes()`和`public Type[] getGenericExceptionTypes()`\n+ Constructor有如下方法：`public Type[] getGenericParameterTypes()`\n\n1. Type实现了Class方法，其中还实现了下列方法：\n\n+ TypeVariable类型参数可以有上界；\n+ ParameterizedType参数化的类型，有原始类型和具体类型；\n+ WildcardType通配符类型\n+ 通过反射获取泛型示例\n\n```java\npublic class GenericDemo {\n    static class GenericTest<U extends Comparable<U, V> {\n        U u;\n        V v;\n        List<String> list;\n        public U test(List<? extends Number> numbers) {\n            return null;\n        }\n    }\n    public static void main(String[] args) {\n        Class<?> cls = GenericTest.class;\n        for (TypeVariable t : cls.getTypeParameters()) {\n            System.out.println(t.getName() + \" extends \" + Arrays.toString(t.getBounds()));\n        }\n        Field fu = cls.getDeclaredField(\"u\");\n        System.out.println(fu.getGenericType());\n        Field first = cls.getDeclaredField(\"list\");\n        Type listType = first.getGenericType();\n        if (!listType instanceof ParameterizedType) {\n            ParameterizedType pType = (ParameterizedType)listType;\n            System.out.println(\"raw type: \" + pType.getRawType() + \" ,type arguments:\" + Arrays.toString(pType.getActualTypeArguments()));\n        }\n        // 省略代码\n    }\n}\n```\n\n1. 总结：反射虽然灵活，但一般情况下我们并不优先建议，原因有如下：\n\n+ 反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力；\n+ 反射会降低性能，在访问字段、调用方法前，反射要先查找对应的Field/Method，要慢一些；\n\n1. 如果能用接口实现同样的灵活性，就不要使用反射；\n\n# 注解\n\n1. 注解是给程序添加一些信息，这些信息可以用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序；\n2. Java内置`@Override`，`@Deprecated`和`@SuppressWarning`三个注解，这三个注解远远不能满足日常开发需求，因此自定义注解产生。\n3. 注解是声明式编程中的一种巧妙应用，在这种风格中，程序通常由下列三部分实现：\n\n+ 声明的关键字和语法本身；\n+ 系统/框架/库，它们负责解释，执行声明式的语句；\n+ 应用程序，使用声明式编程风格编写程序；\n\n1. 创建注解：使用`@interface`关键字声明注解，另外是需要在声明的注解标明元注解。以`@Override`注解为例：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n4.1 ElementType是一个枚举，可以取下列值：\n\n+ TYPE：表示类、接口（包括注解），或者是枚举类型\n+ FIELD：字段，包括枚举常量\n+ METHOD：方法\n+ PARAMETER：方法中的参数\n+ CONSTRUCTOR：构造方法\n+ LOCAL_VARIABLE：本地变量\n+ MODULE：模块（Java 9引入）\n+ \n\n4.2 如果没有声明`@Target`，默认适用于所有类型；\n\n4.3 `@Retention`表示注解信息保留到什么时候，取值只有一个，类型为RetentionPolicy，它是一个枚举，有三个值：\n\n+ SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后去掉；\n+ CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留（默认值）；\n+ RUNTIME：一直保留到运行时\n\n4.4 `@Documented`注解表示注解信息包含到生成文档中；\n\n4.5 注解不能继承，但是使用了注解的父类一旦被子类继承，那么子类就可以继承父类的注解，如果要实现这样的效果，需要在父类的注解中加上`@Inherited`\n\n1. 总结：注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离。框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作；\n\n# 动态代理\n\n1. 静态代理\n\n```java\npublic class SImpleStaticProxy {\n    interface IService {\n        void sayHello();\n    }\n\n    // 真实对象\n    static class RealService implements IService {\n        @Override\n        public void sayHello() {\n            System.out.println(\"RealService Say Hello!\");\n        }\n    }\n\n    // 代理对象\n    static class TraceProxy implements IService {\n        private IService realService;\n\n        TraceProxy(IService realService) {\n            this.realService = realService;\n        }\n\n        @Override\n        public void sayHello() {\n            System.out.println(\"entering say hello...\");\n            this.realService.sayHello();\n            System.out.println(\"exited say hello...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = new TraceProxy(realService);\n        proxyService.sayHello();\n    }\n}\n```\n\n1. 动态代理\n\n```java\npublic class SimpleDynamicProxy {\n    interface IService {\n        void sayHello();\n    }\n    \n    // 真实对象\n    static class RealService implements IService {\n        @Override\n        public void sayHello() {\n            System.out.println(\"Real Service Say Hello\");\n        }\n    }\n    \n    // 代理对象实现JDK中的InvocationHandler接口\n    static class SimpleInvocationHandle implements InvocationHandler {\n        private Object realObj;\n\n        SimpleInvocationHandle(Object realObj) {\n            this.realObj = realObj;\n        }\n        \n        // 重写invoke方法\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            // proxy：表示代理对象本身，不是被代理对象，一般用处不大\n            // method：表示正在被调用的方法\n            // args：表示方法的参数\n            System.out.println(\"entering \" + method.getName());\n            Object result = method.invoke(realObj, args);\n            System.out.println(\"leaving \" + method.getName());\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = (IService) Proxy.newProxyInstance(IService.class.getClassLoader(), new Class<?>[]{IService.class},\n                new SimpleInvocationHandle(realService)); // 使用Proxy.newProxyInstance生成一个代理对象\n        proxyService.sayHello();\n    }\n}\n```\n\n+ newProxyInstance的声明如下：\n\n```java\npublic static Object newProxyInstance(ClassLoader classLoader, Class<?>[] interfaces, InvocationHandler h);\n// ClassLoader：表示类加载器；\n// Class<?>[] interfaces：表示代理类要实现的接口列表，元素类型只能是接口，不能是普通类；\n// InvocationHandler：是一个接口，对代理接口所有方法的调用都会转给该方法；\n// newProxyInstance是Object类型，它不能强制转换为某个类型，只能转换为接口类型；\n```\n\n1. 类定义本身与被代理的对象没有关系，与InvocationHandler的具体实现也没有关系，而主要与接口数组有关，给定的接口数组会动态地创建每个接口的实现代码，实现就是转发给InvocationHandler，与被代理对象的关系以及对它的调用由InvocationHandler实现管理。\n2. 总结：使用动态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每个被代理的类型都是创建一个静态代理类。\n3. 局限性：JDK中的动态代理只能为接口创建代理，返回的代理对象也只能转换到某个接口类型；如果一个类没有接口，或者希望代理非接口中定义的方法，就无能为力了。\n4. 使用cglib的动态代理类可以解决上述的痛点。示例如下：\n\n```java\npublic class SimpleCGLibDemo {\n    static class RealService {\n        public void sayHello() {\n            System.out.println(\"hello\");\n        }\n    }\n    static class SimpleInterceptor implements MethodInterceptor {\n        @Override\n        public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            System.out.println(\"entering \" + method.getName());\n            Object result = proxy.invokeSuper(object, args);\n            System.out.println(\"leaving \" + method.getName());\n        }\n    }\n    private static <T> T getProxy(Class<T> cls) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(cls);\n        enhancer.setCallback(new SimpleInterceptor());\n        return (T)enhancer.create();\n    }\n    \n    public static void main(String[] args) {\n        RealService proxyService = getProxy(RealService.class);\n        proxyService.sayHello();\n    }\n}\n```\n\n1. cglib代理面向的一个具体的类，创建对象只有一个；而SDK代理面向的是接口；\n\n# 类加载机制\n\n1. 类加载机制可以应用于下列场景：\n\n+ 热部署：不重启程序的情况下动态替换\n+ 应用模块化和互相隔离：不同的ClassLoader可以加载相同的类，但是互相隔离、互不影响。例如：Tomcat管理多个Web应用程序；\n+ 从不同地方灵活加载：系统默认从本地.class文件或者.jar包中加载字节码文件，通过自定义ClassLoader可以从共享服务器、数据库、缓存服务器等其他地方加载字节码文件；\n\n1. 类加载机制组成部分：\n\n+ 启动类型加载器（Bootstrap Classloader）：一般由C++实现的，它负责加载Java的基础类，主要是<JAVA_HOME>/lib/rt.jar；\n+ 扩展类加载器（Extension Classloader）：加载器的实现类sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类；\n+ 应用程序类加载器（Application ClassLoader）：实现类是sun.misc.Launcher$AppClassLoader。负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类；\n\n1. 类加载的全过程：\n\n+ 1）判断是否已经加载过，如果加载过直接返回Class对象，一个类只会被一个ClassLoader加载过一次；\n+ 2）如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象；\n+ 3）在父ClassLoader没有加载成功的前提下，自己尝试加载类；\n\n1. 这个过程称之为“双亲委派”模型。优先让父ClassLoader去加载。\n2. 类加载都按照“双亲委派”模型，但是也有例外：\n\n+ 自定义加载顺序：即自定义的类加载器可以不遵循“双亲委派”模型，但一般上是不推荐的；\n+ 网状加载顺序：在OSGI和Java9中存在网状加载的情况。\n+ 父加载器委派给子加载器：典型应用有JNDI。\n\n1. 类加载器的例子：\n\n```java\npublic class ClassLoaderDemo {\n    public static void main(String[] args) {\n        ClassLoader c1 = ClassLoaderDemo.class.getClassLoader();\n        while (c1 != null) {\n            System.out.println(c1.getClass().getName());\n            c1 = c1.getParent();\n        }\n        System.out.println(String.class.getClassLoader());\n    }\n}\n// 输出结果为：\n// sun.misc.Launcher.$AppClassLoader\n// sun.misc.Launcher.$ExtClassLoader\n```\n\n1. ClassLoader中有一个默认方法`public static ClassLoader getSystemClassLoader()`，还有一个默认方法用于加载类： `public class<?> loadClass(String name) throws ClassNotFoundException`。示例如下：\n\n```java\nClassLoader c1 = ClassLoader.getSystemClassLoader();\ntry {\n    Class<?> cls = c1.loadClass(\"java.util.ArrayList\");\n    ClassLoader actualLoader = cls.getClassLoader();\n    System.out.println(actualloader);\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n}\n```\n\n1. 类加载器是一个抽象类。Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader以及sun.misc.Launcher$ExtClassLoader。Bootstrap ClassLoader不是由Java实现的。因此没有实现类。需要说明的是，由于是委派机制。使用getClassLoader()方法返回的不一定调用load-Class.\n2. ClassLoader中的loadClass方法只会加载类但是不会执行。示例如下：\n\n```java\npublic class CLInitDemo {\n    public static class Hello {\n        static {\n            System.out.println(\"hello\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ClassLoader c1 = ClassLoader.getSystemClassLoader();\n        String className = CLInitDemo.class.getName() + \"$Hello\";\n        try {\n            Class<?> cls = c1.loadClass(className); // 不会输出\"hello\"\n            // Class<?> cls = Class.forName(className); // 会输出\"hello\"\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n1. 通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，也是一种策略模式。\n\n# 正则表达式\n\n## 单个字符\n\n1. 用字符本身表示\n2. 特殊字符：例如制表符'\\t'，换行符'\\n'以及回车符'\\r'；\n3. 八进制表示的字符：以'\\0'开头，后面加上1~3位数字，例如\\0141(8) -> 97(10)\n4. 十六进制表示的字符：以'\\x'开头，后面跟两位字符，比如\\x6A(16) -> 106(10)\n5. Unicode表示字符，以'\\u'开头，后面跟4位字符\n6. 斜杠本身就是特殊字符，如果需要使用斜杠需要用一个斜杠进行转义；\n7. 元字符：例如“.、*、?、+”等，如果要皮匹配自身，需要在前面加''进行转义\n\n## 字符祖\n\n1. '.'字符匹配除了换行符以外的任意字符，也可以使用“单行匹配模式”或者“点号匹配模式”。可以以(?s)开头，s表示single line；\n2. 中括号[]表示匹配字符组中的任意一个字符，例如[abcd]匹配任意一个字母；\n3. '^'表示排除符号；\n4. \\d：匹配一个数字字符，等同于[0-9]；\n5. \\w：匹配一个单词字符，等同于[a-zA-Z_0-9]；\n6. \\s：匹配一个空白字符，等同于[\\t\\n\\x0B\\f\\r]\n7. \\D：匹配一个非数字字符，即[^\\d]；\n8. \\W：匹配一个非单词字符，即[^\\w]；\n9. \\S：匹配一个非空白字符，即[^\\s]；\n\n## 量词\n\n1. 量词是指定出现次数的元字符，常见的有三种+、*、？\n2. '+'表示前面字符的一次或多次出现。比如正则表达式ab+c，既能匹配abc，也能匹配abbc:\n3. '*'表示前面的字符的零次或多次出现，例如：ab*c。既能匹配abc，也能匹配ac或abbbc；\n4. '?'表示前面字符可能出现，也可能不出现。例如正则表达式ab?c，既能匹配abc，也能匹配ac；\n5. 通用表示出现次数的语法为{m,n}，出现次数从m到n，包括m和n。如果n没有限制可以省略。如果m和n一样，可以省略一个写为{m}。例如：\n\n+ ab{1,10}c：b可以出现1次到10次\n+ ab{3}c：b必须出现三次\n+ ab{1,}c：等同于ab+c\n+ ab{0,}c：等同于ab*c\n+ ab{0,1}c：等同于ab?c\n\n1. 量词默认是贪婪的，也就是说会从正则开始匹配到结束内的所有字符，如果需要在匹配到第一个就终止，需要使用懒惰量词。即在两次后面加上一个符号'?'；\n\n## 分组\n\n1. 可以用括号将表达式括起来，表示一个分组。分组匹配的子字符串可以在后续访问，好像被被捕获了一样，所以默认分组称之为捕获分组；\n2. 在正则表达式中，可以使用斜杠\\加分组编号引用之前匹配的分组，称之为回溯引用；\n\n## 特殊边界匹配\n\n1. 常见的特殊边界的元字符有^、$、\\A、\\Z、\\z和\\b。\n2. ‘’匹配整个字符串的开始，此外‘’也表示排除，默认单行匹配；\n3. ‘$’匹配整个字符串的结束，默认单行匹配；\n4. 多行匹配的方式如下：以(?m)开头。例如：(?m)^abc$\n5. \\A和^类似；\n6. \\Z和$类似；\\z匹配的总是结束的边界；\n7. \\b匹配的是单词的边界；\n8. 边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界；\n\n## 环视边界匹配\n\n1. 此部分内容比较晦涩，暂不做了解；\n\n# 函数式编程\n\n## 函数是接口：\n\n1. Java中预定义了大量的函数式接口：\n\n| 函数接口            | 方法定义               | 说明                                 |\n| ------------------- | ---------------------- | ------------------------------------ |\n| Predicate<T>        | boolean test(T t)      | 谓词，测试输入条件是否满足要求       |\n| Function<T, R>      | R apply(T t)           | 函数转换，输入类型T，输出类型R       |\n| Consumer<T>         | void accept(T t)       | 消费者，输入类型T                    |\n| Supplier<T>         | T get()                | 工厂方法                             |\n| UnaryOperator<T>    | T apply(T t)           | 函数转换的特例，输入和输出类型一样   |\n| BiFunction<T, U, R> | R apply(T t, U u)      | 函数转换，接受两个参数，输出R        |\n| BinaryOperator<T>   | T apply(T t, T u)      | BiFunction的特例，输入和输出类型一样 |\n| BiConsumer<T, U>    | void accept(T t, U u)  | 消费者，接受两个参数                 |\n| BiPredicate<T, U>   | boolean test(T t, U u) | 谓词，接受两个参数                   |\n\n1. Predicate示例：\n\n```java\nstatic class Student {\n    String name;\n    double score;\n    // 省略getter/setter\n}\n\n// 借助Predicate撰写一个filter的逻辑，例如：\nstudents = filter(students, t -> t.getScore() > 90);\n```\n\n1. Function示例：数据转换\n\n```java\n// 根据学生列表返回名称列表的代码：\nList<Student> names = map(students, t -> t.getName());\n\n// 将学生名称转换为大写：\nstudents = map(students, t -> new Student(t.getName().toUpperCase(), t.getScore()))\n```\n\n1. Consumer示例：直接对原值进行修改\n\n```java\nforeach(students, t -> t.setName(t.getName(),.toUpperCase()))\n```\n\n## 方法引用\n\n1. 示例代码中`Student::getName`称之为方法引用，使用::分隔开。分隔符前面是类型或变量名，后者是方法名。方法可以是实例方法，也可以是静态方法。例如：\n\n```java\npublic static String getColleageName() {\n    return \"Test String\";\n}\n// 下面两条句子的等价的\nSupplier<String> s = Student::getColleageName;\nSupplier<String> s = () -> Student.getColleageName()；\n```\n\n## 函数的复合\n\n1. 函数式接口和Lambda表达式可以用作方法的返回值，传递代码回调者，将上述两种方法结合起来，可以构造复合的函数，使程序简洁易读；\n2. 复合Comparator中的复合方法：\n\n```java\nArrays.sort(files, (f1, f2) -> f1.getName().compareTo(f2.getName()));\n// 进一步简化\nArrays.sort(files, Comparator.comparing(File::getName()));\n```\n\n## Stream API\n\n1. 基本过滤\n\n```java\n// 使用Stream API之前\nList<Student> above90List = new ArrayList<>();\nfor (Student t : students) {\n    if (t.getScore() > 90) {\n        above90List.add(t);\n    }\n}\n\n// 使用Stream API之后\nList<Student> above90List = students.stream()\n    .filter(t -> t.getScore() > 90).collect(Collectors.toList());\n```\n\n+ 没有显式的迭代循环，循环过程被Stream隐藏；\n+ 提供了声明式的处理函数；\n+ 流畅式接口；\n\n1. 基本转换\n\n```java\n// 使用Stream API之前\nList<String> nameList = new ArrayList<>();\nfor (Student t : students) {\n    nameList.add(t.getName());\n}\n\n// 使用Stream API之后\nList<String> nameList = students.stream()\n    .map(Student::getName).collect(Collectors.toList());\n```\n\n1. 基本过滤和转换组合\n\n```java\nList<String> above90List = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .map(Student::getName)\n    .collect(Collectors.toList());\n```\n\n1. distinct运算\n\n+ 用于过滤重复元素，只留下唯一元素，是否重复根据equals()方法来比较。\n\n```java\nList<String> list = Arrays.asList(new String[]{\"abc\", \"def\", \"hello\", \"Abc\"});\nList<String> retList = list.stream()\n    .filter(s -> s.length() <= 3).map(String::toLowerCase).distinct()\n    .collect(Collectors.toList());\n```\n\n1. sorted方法\n\n+ 对流中的元素进行排序，返回一个排序后的stream。例如：\n\n```java\nList<Student> list = students.stream().filter(t -> t.getScore() > 0)\n    .sorted(Comparator.comparing(Student::getScore)\n    .reversed().thenComparing(Student::getName))\n    .collect(Collectors.toList());\n```\n\n1. skip/limit\n\n+ 跳过流中的n个元素，如果流的长度不足n个，返回一个空流。例如：\n\n```java\nList<Student> list = students.stream()\n    .sorted(Comparator.comparing(Student::getScore).reversed()\n    .skip(2).limit(3).collect(Coolectors.toList()));\n```\n\n1. peek\n\n+ 返回一个与之前一样的流，没有变化。但是提供一个Consumer，会将流中的每一个元素传给Consumer。这个方法主要目的用于支持调试，可以使用该方法观察在流水线中流转的元素。例如：\n\n```java\nList<String> above90Names = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .peek(System.out::println).map(Student::getName)\n    .collect(Collectors.toList());\n```\n\n1. mapToLong/mapToInt/mapToDouble\n\n+ map函数接受函数参数是一个`Function<T, R>`，为避免拆箱，装箱提高性能。例如：\n\n```java\ndouble sum = students.stream()\n    .mapToDouble(Student::getScore).sum();\n```\n\n1. flatMap\n\n+ 接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换成一个流Stream。然后将新生成流的每一个元素传递给下一个操作。比如：\n\n```java\nList<String> lines = Arrays.asList(new String[]{\"hello abc\", \"laoma biancheng\"});\nList<String> words = lines.stream()\n    .flatMap(line -> Arrays.stream(line.split(\"\\\\s+\")))\n    .collect(Collectors.toList());\nSystem.out.println(words); // [hello, abc. laoma, biancheng]\n```\n\n## 终端操作\n\n1. 中间操作不触发实际执行，返回值是Stream，而终端操作触发执行，返回一个具体的值。除了collect之外还有：max, min, count, allMatch, anyMatch, noneMatch, findFirst, findAny, forEach, toArray, reduce等。\n2. max/min: 返回流中的最大值/最小值。其返回类型为Optional<T>而非T。Optional表明可能为null，程序应当进行适当的处理。例子：\n\n```java\nStudent student = students.stream()\n    .max(Comparator.comparing(Student::getScore).reversed()).get();\n```\n\n1. count：返回流中的元素个数，例如：\n\n```java\nlong above90Count = students.stream()\n    .filter(t -> t.getScore() > 90).count();\n```\n\n1. allMatch/anyMatch/noneMatch：用于判定流中额元素是否满足一定的条件，区别在于：\n\n+ allMatch：流中所有元素都满足条件的情况下返回true;\n+ anyMatch：流中的元素只要有一个元素满足条件即返回true;\n+ noneMatch：只有流中的所有元素都不满足条件才返回true;\n+ 示例如下：\n\n```java\nboolean allPass = students.stream()\n    .allMatch(t -> t.getScore() >= 60);\n```\n\n1. findFirst/findAny：返回类型均为Optional，如果流为空则返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素。均为短路操作。示例：\n\n```java\nOptional<Student> student = students.stream()\n    .filter(t -> t.getScore() < 60)\n    .findAny();\nif (student.isPresent()) {\n    // 处理不符合要求的数据\n}\n```\n\n1. forEach/forEachOrdered：并行流中forEach不保证顺序，forEachOrdered能保证顺序。例如：\n\n```java\nstudents.stream()\n    .filter(t -> t.getScore() > 90)\n    .forEach(System.out::println);\n```\n\n1. toArray：将流转换为数组，包含两个方法。\n\n```java\nObject[] toArray() // 返回值为Object[]\n<A> A[] toArray(IntFunction<A[]> generator) // 得到指定类型的数组\n```\n\n+ 示例为：\n\n```java\nStudent[] above90Arr = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .toArray(Student[]::new); // Student[]::new就是一个IntFunction类型的ggenerator\n```\n\n1. reduce：归约或折叠，将流中的元素归约为一个值，有三种reduce函数：\n\n```java\nOptional<T> reduce(BinaryOperator<T> accumulator);\nT reduce(T identity, BinaryOperator<T> accumulator);\n<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);\n```\n\n+ 第一个reduce函数的使用\n\n```java\nStudent topStudent = students.stream()\n    .reduce((acc, t) -> {\n        if(acc.getScore() >= t.getScore()) {\n            return acc;\n        } else {\n            return t;\n        }\n    }).get();\n```\n\n+ 第二个reduce函数比第一个多了identity参数，表示初始值\n+ 第三个reduce函数更为通用，可以自定义归约类型，另外还多了一个combiner参数，在并行流中用于合并子线程结果。还有示例：\n\n```java\ndouble sumScore = students.stream()\n    .reduce(0d, (sum, t) -> sum += t.getScore(), \n    (sum1, sum2) -> sum1 += sum2)\n    );\n```\n\n1. 迭代Map的过程删除元素，直接使用forEach会报ConcurrentModificationException\n\n```java\nMap<String, Object> map = other.getHashMap<>();\nmap.entrySet().removeIf(entryElement -> \"some condition\".equals(entryElement.getKey()))\n```\n","slug":"java-core/ch06","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v3000d4f617v0m8ryv","content":"<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><ol>\n<li>反射是在类运行时动态获取类型的信息。比如接口信息、成员信息、方法信息、构造函数信息等。根据动态获取到的信息创建对象、访问/修改成员、调用方法等。</li>\n<li>使用反射可以得到类的名称，调用方法getName()。其中还包括getSimpleName()，getCanonicalName()以及getPackage()。</li>\n<li>类中定义的静态和实例变量称之为字段，使用Field类表示，可以获取字段的访问权限，设置访问权限，获得字段值以及设置字段值。除此之外，还可以获得字段的修饰符以及基本类型。需要注意的是使用反射返回的修饰符是一个整型。如果需要查看具体的返回值类型，可以使用Modifier进行再次判断。</li>\n<li>通过反射也可以获取类中的方法信息：对于invoke方法而言，如果Method是静态方法，则obj被忽略为null，args可以为null；</li>\n<li>创建对象和构造方法：<code>public T newInstance() throws InstantiationException, IllegalAccessException</code>；</li>\n<li>类型检查和转换：使用<code>instanceof</code>关键字可以用于判断变量指向的实际对象类型，instanceof后面的类型是在代码中确定的；</li>\n<li>除此之外，Class方法中还有其他的一些方法可以用于获取类的声明信息、修饰符、父类、接口以及注解等；</li>\n<li>对于数组类型可以使用<code>public native Class&lt;T&gt; getComponentType()</code>获取其元素类型；</li>\n<li>反射与枚举：枚举类型也有一个专门的方法：<code>public T[] getEnumConstants()</code>；</li>\n<li>反射与泛型：可以获取泛型参数的信息：</li>\n</ol>\n<ul>\n<li>Class类有如下方法：<code>public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters()</code></li>\n<li>Field有如下方法：<code>public Type getGenericType()</code></li>\n<li>Method有如下方法：<code>public Type getGenericReturnType()</code>，<code>public Type[] getGenericParameterTypes()</code>和<code>public Type[] getGenericExceptionTypes()</code></li>\n<li>Constructor有如下方法：<code>public Type[] getGenericParameterTypes()</code></li>\n</ul>\n<ol>\n<li>Type实现了Class方法，其中还实现了下列方法：</li>\n</ol>\n<ul>\n<li>TypeVariable类型参数可以有上界；</li>\n<li>ParameterizedType参数化的类型，有原始类型和具体类型；</li>\n<li>WildcardType通配符类型</li>\n<li>通过反射获取泛型示例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericTest</span>&lt;U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Comparable</span>&lt;U, V&gt; &#123;<br>        U u;<br>        V v;<br>        List&lt;String&gt; list;<br>        <span class=\"hljs-keyword\">public</span> U <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(List&lt;? extends Number&gt; numbers)</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        Class&lt;?&gt; cls = GenericTest.class;<br>        <span class=\"hljs-keyword\">for</span> (TypeVariable t : cls.getTypeParameters()) &#123;<br>            System.out.println(t.getName() + <span class=\"hljs-string\">&quot; extends &quot;</span> + Arrays.toString(t.getBounds()));<br>        &#125;<br>        <span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">fu</span> <span class=\"hljs-operator\">=</span> cls.getDeclaredField(<span class=\"hljs-string\">&quot;u&quot;</span>);<br>        System.out.println(fu.getGenericType());<br>        <span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> cls.getDeclaredField(<span class=\"hljs-string\">&quot;list&quot;</span>);<br>        <span class=\"hljs-type\">Type</span> <span class=\"hljs-variable\">listType</span> <span class=\"hljs-operator\">=</span> first.getGenericType();<br>        <span class=\"hljs-keyword\">if</span> (!listType <span class=\"hljs-keyword\">instanceof</span> ParameterizedType) &#123;<br>            <span class=\"hljs-type\">ParameterizedType</span> <span class=\"hljs-variable\">pType</span> <span class=\"hljs-operator\">=</span> (ParameterizedType)listType;<br>            System.out.println(<span class=\"hljs-string\">&quot;raw type: &quot;</span> + pType.getRawType() + <span class=\"hljs-string\">&quot; ,type arguments:&quot;</span> + Arrays.toString(pType.getActualTypeArguments()));<br>        &#125;<br>        <span class=\"hljs-comment\">// 省略代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>总结：反射虽然灵活，但一般情况下我们并不优先建议，原因有如下：</li>\n</ol>\n<ul>\n<li>反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力；</li>\n<li>反射会降低性能，在访问字段、调用方法前，反射要先查找对应的Field/Method，要慢一些；</li>\n</ul>\n<ol>\n<li>如果能用接口实现同样的灵活性，就不要使用反射；</li>\n</ol>\n<h1 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h1><ol>\n<li>注解是给程序添加一些信息，这些信息可以用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序；</li>\n<li>Java内置<code>@Override</code>，<code>@Deprecated</code>和<code>@SuppressWarning</code>三个注解，这三个注解远远不能满足日常开发需求，因此自定义注解产生。</li>\n<li>注解是声明式编程中的一种巧妙应用，在这种风格中，程序通常由下列三部分实现：</li>\n</ol>\n<ul>\n<li>声明的关键字和语法本身；</li>\n<li>系统/框架/库，它们负责解释，执行声明式的语句；</li>\n<li>应用程序，使用声明式编程风格编写程序；</li>\n</ul>\n<ol>\n<li>创建注解：使用<code>@interface</code>关键字声明注解，另外是需要在声明的注解标明元注解。以<code>@Override</code>注解为例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Target(ElementType.METHOD)</span><br><span class=\"hljs-meta\">@Retention(RetentionPolicy.SOURCE)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>4.1 ElementType是一个枚举，可以取下列值：</p>\n<ul>\n<li>TYPE：表示类、接口（包括注解），或者是枚举类型</li>\n<li>FIELD：字段，包括枚举常量</li>\n<li>METHOD：方法</li>\n<li>PARAMETER：方法中的参数</li>\n<li>CONSTRUCTOR：构造方法</li>\n<li>LOCAL_VARIABLE：本地变量</li>\n<li>MODULE：模块（Java 9引入）</li>\n<li></li>\n</ul>\n<p>4.2 如果没有声明<code>@Target</code>，默认适用于所有类型；</p>\n<p>4.3 <code>@Retention</code>表示注解信息保留到什么时候，取值只有一个，类型为RetentionPolicy，它是一个枚举，有三个值：</p>\n<ul>\n<li>SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后去掉；</li>\n<li>CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留（默认值）；</li>\n<li>RUNTIME：一直保留到运行时</li>\n</ul>\n<p>4.4 <code>@Documented</code>注解表示注解信息包含到生成文档中；</p>\n<p>4.5 注解不能继承，但是使用了注解的父类一旦被子类继承，那么子类就可以继承父类的注解，如果要实现这样的效果，需要在父类的注解中加上<code>@Inherited</code></p>\n<ol>\n<li>总结：注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离。框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作；</li>\n</ol>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><ol>\n<li>静态代理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SImpleStaticProxy</span> &#123;<br>    <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 真实对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;RealService Say Hello!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 代理对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TraceProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">private</span> IService realService;<br><br>        TraceProxy(IService realService) &#123;<br>            <span class=\"hljs-built_in\">this</span>.realService = realService;<br>        &#125;<br><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;entering say hello...&quot;</span>);<br>            <span class=\"hljs-built_in\">this</span>.realService.sayHello();<br>            System.out.println(<span class=\"hljs-string\">&quot;exited say hello...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">realService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RealService</span>();<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TraceProxy</span>(realService);<br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>动态代理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleDynamicProxy</span> &#123;<br>    <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 真实对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;Real Service Say Hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 代理对象实现JDK中的InvocationHandler接口</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleInvocationHandle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">InvocationHandler</span> &#123;<br>        <span class=\"hljs-keyword\">private</span> Object realObj;<br><br>        SimpleInvocationHandle(Object realObj) &#123;<br>            <span class=\"hljs-built_in\">this</span>.realObj = realObj;<br>        &#125;<br>        <br>        <span class=\"hljs-comment\">// 重写invoke方法</span><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title function_\">invoke</span><span class=\"hljs-params\">(Object proxy, Method method, Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable &#123;<br>            <span class=\"hljs-comment\">// proxy：表示代理对象本身，不是被代理对象，一般用处不大</span><br>            <span class=\"hljs-comment\">// method：表示正在被调用的方法</span><br>            <span class=\"hljs-comment\">// args：表示方法的参数</span><br>            System.out.println(<span class=\"hljs-string\">&quot;entering &quot;</span> + method.getName());<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> method.invoke(realObj, args);<br>            System.out.println(<span class=\"hljs-string\">&quot;leaving &quot;</span> + method.getName());<br>            <span class=\"hljs-keyword\">return</span> result;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">realService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RealService</span>();<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> (IService) Proxy.newProxyInstance(IService.class.getClassLoader(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Class</span>&lt;?&gt;[]&#123;IService.class&#125;,<br>                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleInvocationHandle</span>(realService)); <span class=\"hljs-comment\">// 使用Proxy.newProxyInstance生成一个代理对象</span><br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>newProxyInstance的声明如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Object <span class=\"hljs-title function_\">newProxyInstance</span><span class=\"hljs-params\">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;<br><span class=\"hljs-comment\">// ClassLoader：表示类加载器；</span><br><span class=\"hljs-comment\">// Class&lt;?&gt;[] interfaces：表示代理类要实现的接口列表，元素类型只能是接口，不能是普通类；</span><br><span class=\"hljs-comment\">// InvocationHandler：是一个接口，对代理接口所有方法的调用都会转给该方法；</span><br><span class=\"hljs-comment\">// newProxyInstance是Object类型，它不能强制转换为某个类型，只能转换为接口类型；</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>类定义本身与被代理的对象没有关系，与InvocationHandler的具体实现也没有关系，而主要与接口数组有关，给定的接口数组会动态地创建每个接口的实现代码，实现就是转发给InvocationHandler，与被代理对象的关系以及对它的调用由InvocationHandler实现管理。</li>\n<li>总结：使用动态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每个被代理的类型都是创建一个静态代理类。</li>\n<li>局限性：JDK中的动态代理只能为接口创建代理，返回的代理对象也只能转换到某个接口类型；如果一个类没有接口，或者希望代理非接口中定义的方法，就无能为力了。</li>\n<li>使用cglib的动态代理类可以解决上述的痛点。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleCGLibDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">MethodInterceptor</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title function_\">intercept</span><span class=\"hljs-params\">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"hljs-keyword\">throws</span> Throwable &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;entering &quot;</span> + method.getName());<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> proxy.invokeSuper(object, args);<br>            System.out.println(<span class=\"hljs-string\">&quot;leaving &quot;</span> + method.getName());<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; T <span class=\"hljs-title function_\">getProxy</span><span class=\"hljs-params\">(Class&lt;T&gt; cls)</span> &#123;<br>        <span class=\"hljs-type\">Enhancer</span> <span class=\"hljs-variable\">enhancer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Enhancer</span>();<br>        enhancer.setSuperclass(cls);<br>        enhancer.setCallback(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleInterceptor</span>());<br>        <span class=\"hljs-keyword\">return</span> (T)enhancer.create();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">RealService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> getProxy(RealService.class);<br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>cglib代理面向的一个具体的类，创建对象只有一个；而SDK代理面向的是接口；</li>\n</ol>\n<h1 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h1><ol>\n<li>类加载机制可以应用于下列场景：</li>\n</ol>\n<ul>\n<li>热部署：不重启程序的情况下动态替换</li>\n<li>应用模块化和互相隔离：不同的ClassLoader可以加载相同的类，但是互相隔离、互不影响。例如：Tomcat管理多个Web应用程序；</li>\n<li>从不同地方灵活加载：系统默认从本地.class文件或者.jar包中加载字节码文件，通过自定义ClassLoader可以从共享服务器、数据库、缓存服务器等其他地方加载字节码文件；</li>\n</ul>\n<ol>\n<li>类加载机制组成部分：</li>\n</ol>\n<ul>\n<li>启动类型加载器（Bootstrap Classloader）：一般由C++实现的，它负责加载Java的基础类，主要是<JAVA_HOME>/lib/rt.jar；</li>\n<li>扩展类加载器（Extension Classloader）：加载器的实现类sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类；</li>\n<li>应用程序类加载器（Application ClassLoader）：实现类是sun.misc.Launcher$AppClassLoader。负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类；</li>\n</ul>\n<ol>\n<li>类加载的全过程：</li>\n</ol>\n<ul>\n<li>1）判断是否已经加载过，如果加载过直接返回Class对象，一个类只会被一个ClassLoader加载过一次；</li>\n<li>2）如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象；</li>\n<li>3）在父ClassLoader没有加载成功的前提下，自己尝试加载类；</li>\n</ul>\n<ol>\n<li>这个过程称之为“双亲委派”模型。优先让父ClassLoader去加载。</li>\n<li>类加载都按照“双亲委派”模型，但是也有例外：</li>\n</ol>\n<ul>\n<li>自定义加载顺序：即自定义的类加载器可以不遵循“双亲委派”模型，但一般上是不推荐的；</li>\n<li>网状加载顺序：在OSGI和Java9中存在网状加载的情况。</li>\n<li>父加载器委派给子加载器：典型应用有JNDI。</li>\n</ul>\n<ol>\n<li>类加载器的例子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassLoaderDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoaderDemo.class.getClassLoader();<br>        <span class=\"hljs-keyword\">while</span> (c1 != <span class=\"hljs-literal\">null</span>) &#123;<br>            System.out.println(c1.getClass().getName());<br>            c1 = c1.getParent();<br>        &#125;<br>        System.out.println(String.class.getClassLoader());<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 输出结果为：</span><br><span class=\"hljs-comment\">// sun.misc.Launcher.$AppClassLoader</span><br><span class=\"hljs-comment\">// sun.misc.Launcher.$ExtClassLoader</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>ClassLoader中有一个默认方法<code>public static ClassLoader getSystemClassLoader()</code>，还有一个默认方法用于加载类： <code>public class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br><span class=\"hljs-keyword\">try</span> &#123;<br>    Class&lt;?&gt; cls = c1.loadClass(<span class=\"hljs-string\">&quot;java.util.ArrayList&quot;</span>);<br>    <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">actualLoader</span> <span class=\"hljs-operator\">=</span> cls.getClassLoader();<br>    System.out.println(actualloader);<br>&#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>类加载器是一个抽象类。Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader以及sun.misc.Launcher$ExtClassLoader。Bootstrap ClassLoader不是由Java实现的。因此没有实现类。需要说明的是，由于是委派机制。使用getClassLoader()方法返回的不一定调用load-Class.</li>\n<li>ClassLoader中的loadClass方法只会加载类但是不会执行。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CLInitDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hello</span> &#123;<br>        <span class=\"hljs-keyword\">static</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> CLInitDemo.class.getName() + <span class=\"hljs-string\">&quot;$Hello&quot;</span>;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            Class&lt;?&gt; cls = c1.loadClass(className); <span class=\"hljs-comment\">// 不会输出&quot;hello&quot;</span><br>            <span class=\"hljs-comment\">// Class&lt;?&gt; cls = Class.forName(className); // 会输出&quot;hello&quot;</span><br>        &#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，也是一种策略模式。</li>\n</ol>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"单个字符\"><a href=\"#单个字符\" class=\"headerlink\" title=\"单个字符\"></a>单个字符</h2><ol>\n<li>用字符本身表示</li>\n<li>特殊字符：例如制表符’\\t’，换行符’\\n’以及回车符’\\r’；</li>\n<li>八进制表示的字符：以’\\0’开头，后面加上1~3位数字，例如\\0141(8) -&gt; 97(10)</li>\n<li>十六进制表示的字符：以’\\x’开头，后面跟两位字符，比如\\x6A(16) -&gt; 106(10)</li>\n<li>Unicode表示字符，以’\\u’开头，后面跟4位字符</li>\n<li>斜杠本身就是特殊字符，如果需要使用斜杠需要用一个斜杠进行转义；</li>\n<li>元字符：例如“.、*、?、+”等，如果要皮匹配自身，需要在前面加’’进行转义</li>\n</ol>\n<h2 id=\"字符祖\"><a href=\"#字符祖\" class=\"headerlink\" title=\"字符祖\"></a>字符祖</h2><ol>\n<li>‘.’字符匹配除了换行符以外的任意字符，也可以使用“单行匹配模式”或者“点号匹配模式”。可以以(?s)开头，s表示single line；</li>\n<li>中括号[]表示匹配字符组中的任意一个字符，例如[abcd]匹配任意一个字母；</li>\n<li>‘^’表示排除符号；</li>\n<li>\\d：匹配一个数字字符，等同于[0-9]；</li>\n<li>\\w：匹配一个单词字符，等同于[a-zA-Z_0-9]；</li>\n<li>\\s：匹配一个空白字符，等同于[\\t\\n\\x0B\\f\\r]</li>\n<li>\\D：匹配一个非数字字符，即<sup><a href=\"#fn_\\d\" id=\"reffn_\\d\">\\d</a></sup>；</li>\n<li>\\W：匹配一个非单词字符，即<sup><a href=\"#fn_\\w\" id=\"reffn_\\w\">\\w</a></sup>；</li>\n<li>\\S：匹配一个非空白字符，即<sup><a href=\"#fn_\\s\" id=\"reffn_\\s\">\\s</a></sup>；</li>\n</ol>\n<h2 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h2><ol>\n<li>量词是指定出现次数的元字符，常见的有三种+、*、？</li>\n<li>‘+’表示前面字符的一次或多次出现。比如正则表达式ab+c，既能匹配abc，也能匹配abbc:</li>\n<li>‘<em>‘表示前面的字符的零次或多次出现，例如：ab</em>c。既能匹配abc，也能匹配ac或abbbc；</li>\n<li>‘?’表示前面字符可能出现，也可能不出现。例如正则表达式ab?c，既能匹配abc，也能匹配ac；</li>\n<li>通用表示出现次数的语法为{m,n}，出现次数从m到n，包括m和n。如果n没有限制可以省略。如果m和n一样，可以省略一个写为{m}。例如：</li>\n</ol>\n<ul>\n<li>ab{1,10}c：b可以出现1次到10次</li>\n<li>ab{3}c：b必须出现三次</li>\n<li>ab{1,}c：等同于ab+c</li>\n<li>ab{0,}c：等同于ab*c</li>\n<li>ab{0,1}c：等同于ab?c</li>\n</ul>\n<ol>\n<li>量词默认是贪婪的，也就是说会从正则开始匹配到结束内的所有字符，如果需要在匹配到第一个就终止，需要使用懒惰量词。即在两次后面加上一个符号’?’；</li>\n</ol>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><ol>\n<li>可以用括号将表达式括起来，表示一个分组。分组匹配的子字符串可以在后续访问，好像被被捕获了一样，所以默认分组称之为捕获分组；</li>\n<li>在正则表达式中，可以使用斜杠\\加分组编号引用之前匹配的分组，称之为回溯引用；</li>\n</ol>\n<h2 id=\"特殊边界匹配\"><a href=\"#特殊边界匹配\" class=\"headerlink\" title=\"特殊边界匹配\"></a>特殊边界匹配</h2><ol>\n<li>常见的特殊边界的元字符有^、$、\\A、\\Z、\\z和\\b。</li>\n<li>‘’匹配整个字符串的开始，此外‘’也表示排除，默认单行匹配；</li>\n<li>‘$’匹配整个字符串的结束，默认单行匹配；</li>\n<li>多行匹配的方式如下：以(?m)开头。例如：(?m)^abc$</li>\n<li>\\A和^类似；</li>\n<li>\\Z和$类似；\\z匹配的总是结束的边界；</li>\n<li>\\b匹配的是单词的边界；</li>\n<li>边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界；</li>\n</ol>\n<h2 id=\"环视边界匹配\"><a href=\"#环视边界匹配\" class=\"headerlink\" title=\"环视边界匹配\"></a>环视边界匹配</h2><ol>\n<li>此部分内容比较晦涩，暂不做了解；</li>\n</ol>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><h2 id=\"函数是接口：\"><a href=\"#函数是接口：\" class=\"headerlink\" title=\"函数是接口：\"></a>函数是接口：</h2><ol>\n<li>Java中预定义了大量的函数式接口：</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数接口</th>\n<th>方法定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Predicate<T></td>\n<td>boolean test(T t)</td>\n<td>谓词，测试输入条件是否满足要求</td>\n</tr>\n<tr>\n<td>Function<T, R></td>\n<td>R apply(T t)</td>\n<td>函数转换，输入类型T，输出类型R</td>\n</tr>\n<tr>\n<td>Consumer<T></td>\n<td>void accept(T t)</td>\n<td>消费者，输入类型T</td>\n</tr>\n<tr>\n<td>Supplier<T></td>\n<td>T get()</td>\n<td>工厂方法</td>\n</tr>\n<tr>\n<td>UnaryOperator<T></td>\n<td>T apply(T t)</td>\n<td>函数转换的特例，输入和输出类型一样</td>\n</tr>\n<tr>\n<td>BiFunction<T, U, R></td>\n<td>R apply(T t, U u)</td>\n<td>函数转换，接受两个参数，输出R</td>\n</tr>\n<tr>\n<td>BinaryOperator<T></td>\n<td>T apply(T t, T u)</td>\n<td>BiFunction的特例，输入和输出类型一样</td>\n</tr>\n<tr>\n<td>BiConsumer<T, U></td>\n<td>void accept(T t, U u)</td>\n<td>消费者，接受两个参数</td>\n</tr>\n<tr>\n<td>BiPredicate<T, U></td>\n<td>boolean test(T t, U u)</td>\n<td>谓词，接受两个参数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li>Predicate示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br>    String name;<br>    <span class=\"hljs-type\">double</span> score;<br>    <span class=\"hljs-comment\">// 省略getter/setter</span><br>&#125;<br><br><span class=\"hljs-comment\">// 借助Predicate撰写一个filter的逻辑，例如：</span><br>students = filter(students, t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Function示例：数据转换</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 根据学生列表返回名称列表的代码：</span><br>List&lt;Student&gt; names = map(students, t -&gt; t.getName());<br><br><span class=\"hljs-comment\">// 将学生名称转换为大写：</span><br>students = map(students, t -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>(t.getName().toUpperCase(), t.getScore()))<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Consumer示例：直接对原值进行修改</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">foreach(students, t -&gt; t.setName(t.getName(),.toUpperCase()))<br></code></pre></td></tr></table></figure>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><ol>\n<li>示例代码中<code>Student::getName</code>称之为方法引用，使用::分隔开。分隔符前面是类型或变量名，后者是方法名。方法可以是实例方法，也可以是静态方法。例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">getColleageName</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Test String&quot;</span>;<br>&#125;<br><span class=\"hljs-comment\">// 下面两条句子的等价的</span><br>Supplier&lt;String&gt; s = Student::getColleageName;<br>Supplier&lt;String&gt; s = () -&gt; Student.getColleageName()；<br></code></pre></td></tr></table></figure>\n<h2 id=\"函数的复合\"><a href=\"#函数的复合\" class=\"headerlink\" title=\"函数的复合\"></a>函数的复合</h2><ol>\n<li>函数式接口和Lambda表达式可以用作方法的返回值，传递代码回调者，将上述两种方法结合起来，可以构造复合的函数，使程序简洁易读；</li>\n<li>复合Comparator中的复合方法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Arrays.sort(files, (f1, f2) -&gt; f1.getName().compareTo(f2.getName()));<br><span class=\"hljs-comment\">// 进一步简化</span><br>Arrays.sort(files, Comparator.comparing(File::getName()));<br></code></pre></td></tr></table></figure>\n<h2 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h2><ol>\n<li>基本过滤</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用Stream API之前</span><br>List&lt;Student&gt; above90List = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><span class=\"hljs-keyword\">for</span> (Student t : students) &#123;<br>    <span class=\"hljs-keyword\">if</span> (t.getScore() &gt; <span class=\"hljs-number\">90</span>) &#123;<br>        above90List.add(t);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用Stream API之后</span><br>List&lt;Student&gt; above90List = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ul>\n<li>没有显式的迭代循环，循环过程被Stream隐藏；</li>\n<li>提供了声明式的处理函数；</li>\n<li>流畅式接口；</li>\n</ul>\n<ol>\n<li>基本转换</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用Stream API之前</span><br>List&lt;String&gt; nameList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><span class=\"hljs-keyword\">for</span> (Student t : students) &#123;<br>    nameList.add(t.getName());<br>&#125;<br><br><span class=\"hljs-comment\">// 使用Stream API之后</span><br>List&lt;String&gt; nameList = students.stream()<br>    .map(Student::getName).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>基本过滤和转换组合</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; above90List = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .map(Student::getName)<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>distinct运算</li>\n</ol>\n<ul>\n<li>用于过滤重复元素，只留下唯一元素，是否重复根据equals()方法来比较。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;abc&quot;</span>, <span class=\"hljs-string\">&quot;def&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-string\">&quot;Abc&quot;</span>&#125;);<br>List&lt;String&gt; retList = list.stream()<br>    .filter(s -&gt; s.length() &lt;= <span class=\"hljs-number\">3</span>).map(String::toLowerCase).distinct()<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>sorted方法</li>\n</ol>\n<ul>\n<li>对流中的元素进行排序，返回一个排序后的stream。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Student&gt; list = students.stream().filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">0</span>)<br>    .sorted(Comparator.comparing(Student::getScore)<br>    .reversed().thenComparing(Student::getName))<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>skip/limit</li>\n</ol>\n<ul>\n<li>跳过流中的n个元素，如果流的长度不足n个，返回一个空流。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Student&gt; list = students.stream()<br>    .sorted(Comparator.comparing(Student::getScore).reversed()<br>    .skip(<span class=\"hljs-number\">2</span>).limit(<span class=\"hljs-number\">3</span>).collect(Coolectors.toList()));<br></code></pre></td></tr></table></figure>\n<ol>\n<li>peek</li>\n</ol>\n<ul>\n<li>返回一个与之前一样的流，没有变化。但是提供一个Consumer，会将流中的每一个元素传给Consumer。这个方法主要目的用于支持调试，可以使用该方法观察在流水线中流转的元素。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; above90Names = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .peek(System.out::println).map(Student::getName)<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>mapToLong/mapToInt/mapToDouble</li>\n</ol>\n<ul>\n<li>map函数接受函数参数是一个<code>Function&lt;T, R&gt;</code>，为避免拆箱，装箱提高性能。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .mapToDouble(Student::getScore).sum();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>flatMap</li>\n</ol>\n<ul>\n<li>接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换成一个流Stream。然后将新生成流的每一个元素传递给下一个操作。比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; lines = Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello abc&quot;</span>, <span class=\"hljs-string\">&quot;laoma biancheng&quot;</span>&#125;);<br>List&lt;String&gt; words = lines.stream()<br>    .flatMap(line -&gt; Arrays.stream(line.split(<span class=\"hljs-string\">&quot;\\\\s+&quot;</span>)))<br>    .collect(Collectors.toList());<br>System.out.println(words); <span class=\"hljs-comment\">// [hello, abc. laoma, biancheng]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"终端操作\"><a href=\"#终端操作\" class=\"headerlink\" title=\"终端操作\"></a>终端操作</h2><ol>\n<li>中间操作不触发实际执行，返回值是Stream，而终端操作触发执行，返回一个具体的值。除了collect之外还有：max, min, count, allMatch, anyMatch, noneMatch, findFirst, findAny, forEach, toArray, reduce等。</li>\n<li>max/min: 返回流中的最大值/最小值。其返回类型为Optional<T>而非T。Optional表明可能为null，程序应当进行适当的处理。例子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">student</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .max(Comparator.comparing(Student::getScore).reversed()).get();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>count：返回流中的元素个数，例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">above90Count</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>).count();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>allMatch/anyMatch/noneMatch：用于判定流中额元素是否满足一定的条件，区别在于：</li>\n</ol>\n<ul>\n<li>allMatch：流中所有元素都满足条件的情况下返回true;</li>\n<li>anyMatch：流中的元素只要有一个元素满足条件即返回true;</li>\n<li>noneMatch：只有流中的所有元素都不满足条件才返回true;</li>\n<li>示例如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">allPass</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .allMatch(t -&gt; t.getScore() &gt;= <span class=\"hljs-number\">60</span>);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>findFirst/findAny：返回类型均为Optional，如果流为空则返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素。均为短路操作。示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Optional&lt;Student&gt; student = students.stream()<br>    .filter(t -&gt; t.getScore() &lt; <span class=\"hljs-number\">60</span>)<br>    .findAny();<br><span class=\"hljs-keyword\">if</span> (student.isPresent()) &#123;<br>    <span class=\"hljs-comment\">// 处理不符合要求的数据</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>forEach/forEachOrdered：并行流中forEach不保证顺序，forEachOrdered能保证顺序。例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>toArray：将流转换为数组，包含两个方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Object[] toArray() <span class=\"hljs-comment\">// 返回值为Object[]</span><br>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) <span class=\"hljs-comment\">// 得到指定类型的数组</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>示例为：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Student[] above90Arr = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .toArray(Student[]::<span class=\"hljs-keyword\">new</span>); <span class=\"hljs-comment\">// Student[]::new就是一个IntFunction类型的ggenerator</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>reduce：归约或折叠，将流中的元素归约为一个值，有三种reduce函数：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Optional&lt;T&gt; <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(BinaryOperator&lt;T&gt; accumulator)</span>;<br>T <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;<br>&lt;U&gt; U <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(U identity, BiFunction&lt;U, ? <span class=\"hljs-built_in\">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第一个reduce函数的使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">topStudent</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .reduce((acc, t) -&gt; &#123;<br>        <span class=\"hljs-keyword\">if</span>(acc.getScore() &gt;= t.getScore()) &#123;<br>            <span class=\"hljs-keyword\">return</span> acc;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> t;<br>        &#125;<br>    &#125;).get();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第二个reduce函数比第一个多了identity参数，表示初始值</li>\n<li>第三个reduce函数更为通用，可以自定义归约类型，另外还多了一个combiner参数，在并行流中用于合并子线程结果。还有示例：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">sumScore</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .reduce(<span class=\"hljs-number\">0d</span>, (sum, t) -&gt; sum += t.getScore(), <br>    (sum1, sum2) -&gt; sum1 += sum2)<br>    );<br></code></pre></td></tr></table></figure>\n<ol>\n<li>迭代Map的过程删除元素，直接使用forEach会报ConcurrentModificationException</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Object&gt; map = other.getHashMap&lt;&gt;();<br>map.entrySet().removeIf(entryElement -&gt; <span class=\"hljs-string\">&quot;some condition&quot;</span>.equals(entryElement.getKey()))<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":15854,"excerpt":"","more":"<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><ol>\n<li>反射是在类运行时动态获取类型的信息。比如接口信息、成员信息、方法信息、构造函数信息等。根据动态获取到的信息创建对象、访问/修改成员、调用方法等。</li>\n<li>使用反射可以得到类的名称，调用方法getName()。其中还包括getSimpleName()，getCanonicalName()以及getPackage()。</li>\n<li>类中定义的静态和实例变量称之为字段，使用Field类表示，可以获取字段的访问权限，设置访问权限，获得字段值以及设置字段值。除此之外，还可以获得字段的修饰符以及基本类型。需要注意的是使用反射返回的修饰符是一个整型。如果需要查看具体的返回值类型，可以使用Modifier进行再次判断。</li>\n<li>通过反射也可以获取类中的方法信息：对于invoke方法而言，如果Method是静态方法，则obj被忽略为null，args可以为null；</li>\n<li>创建对象和构造方法：<code>public T newInstance() throws InstantiationException, IllegalAccessException</code>；</li>\n<li>类型检查和转换：使用<code>instanceof</code>关键字可以用于判断变量指向的实际对象类型，instanceof后面的类型是在代码中确定的；</li>\n<li>除此之外，Class方法中还有其他的一些方法可以用于获取类的声明信息、修饰符、父类、接口以及注解等；</li>\n<li>对于数组类型可以使用<code>public native Class&lt;T&gt; getComponentType()</code>获取其元素类型；</li>\n<li>反射与枚举：枚举类型也有一个专门的方法：<code>public T[] getEnumConstants()</code>；</li>\n<li>反射与泛型：可以获取泛型参数的信息：</li>\n</ol>\n<ul>\n<li>Class类有如下方法：<code>public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters()</code></li>\n<li>Field有如下方法：<code>public Type getGenericType()</code></li>\n<li>Method有如下方法：<code>public Type getGenericReturnType()</code>，<code>public Type[] getGenericParameterTypes()</code>和<code>public Type[] getGenericExceptionTypes()</code></li>\n<li>Constructor有如下方法：<code>public Type[] getGenericParameterTypes()</code></li>\n</ul>\n<ol>\n<li>Type实现了Class方法，其中还实现了下列方法：</li>\n</ol>\n<ul>\n<li>TypeVariable类型参数可以有上界；</li>\n<li>ParameterizedType参数化的类型，有原始类型和具体类型；</li>\n<li>WildcardType通配符类型</li>\n<li>通过反射获取泛型示例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericTest</span>&lt;U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Comparable</span>&lt;U, V&gt; &#123;<br>        U u;<br>        V v;<br>        List&lt;String&gt; list;<br>        <span class=\"hljs-keyword\">public</span> U <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(List&lt;? extends Number&gt; numbers)</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        Class&lt;?&gt; cls = GenericTest.class;<br>        <span class=\"hljs-keyword\">for</span> (TypeVariable t : cls.getTypeParameters()) &#123;<br>            System.out.println(t.getName() + <span class=\"hljs-string\">&quot; extends &quot;</span> + Arrays.toString(t.getBounds()));<br>        &#125;<br>        <span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">fu</span> <span class=\"hljs-operator\">=</span> cls.getDeclaredField(<span class=\"hljs-string\">&quot;u&quot;</span>);<br>        System.out.println(fu.getGenericType());<br>        <span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> cls.getDeclaredField(<span class=\"hljs-string\">&quot;list&quot;</span>);<br>        <span class=\"hljs-type\">Type</span> <span class=\"hljs-variable\">listType</span> <span class=\"hljs-operator\">=</span> first.getGenericType();<br>        <span class=\"hljs-keyword\">if</span> (!listType <span class=\"hljs-keyword\">instanceof</span> ParameterizedType) &#123;<br>            <span class=\"hljs-type\">ParameterizedType</span> <span class=\"hljs-variable\">pType</span> <span class=\"hljs-operator\">=</span> (ParameterizedType)listType;<br>            System.out.println(<span class=\"hljs-string\">&quot;raw type: &quot;</span> + pType.getRawType() + <span class=\"hljs-string\">&quot; ,type arguments:&quot;</span> + Arrays.toString(pType.getActualTypeArguments()));<br>        &#125;<br>        <span class=\"hljs-comment\">// 省略代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>总结：反射虽然灵活，但一般情况下我们并不优先建议，原因有如下：</li>\n</ol>\n<ul>\n<li>反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力；</li>\n<li>反射会降低性能，在访问字段、调用方法前，反射要先查找对应的Field/Method，要慢一些；</li>\n</ul>\n<ol>\n<li>如果能用接口实现同样的灵活性，就不要使用反射；</li>\n</ol>\n<h1 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h1><ol>\n<li>注解是给程序添加一些信息，这些信息可以用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序；</li>\n<li>Java内置<code>@Override</code>，<code>@Deprecated</code>和<code>@SuppressWarning</code>三个注解，这三个注解远远不能满足日常开发需求，因此自定义注解产生。</li>\n<li>注解是声明式编程中的一种巧妙应用，在这种风格中，程序通常由下列三部分实现：</li>\n</ol>\n<ul>\n<li>声明的关键字和语法本身；</li>\n<li>系统/框架/库，它们负责解释，执行声明式的语句；</li>\n<li>应用程序，使用声明式编程风格编写程序；</li>\n</ul>\n<ol>\n<li>创建注解：使用<code>@interface</code>关键字声明注解，另外是需要在声明的注解标明元注解。以<code>@Override</code>注解为例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Target(ElementType.METHOD)</span><br><span class=\"hljs-meta\">@Retention(RetentionPolicy.SOURCE)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>4.1 ElementType是一个枚举，可以取下列值：</p>\n<ul>\n<li>TYPE：表示类、接口（包括注解），或者是枚举类型</li>\n<li>FIELD：字段，包括枚举常量</li>\n<li>METHOD：方法</li>\n<li>PARAMETER：方法中的参数</li>\n<li>CONSTRUCTOR：构造方法</li>\n<li>LOCAL_VARIABLE：本地变量</li>\n<li>MODULE：模块（Java 9引入）</li>\n<li></li>\n</ul>\n<p>4.2 如果没有声明<code>@Target</code>，默认适用于所有类型；</p>\n<p>4.3 <code>@Retention</code>表示注解信息保留到什么时候，取值只有一个，类型为RetentionPolicy，它是一个枚举，有三个值：</p>\n<ul>\n<li>SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后去掉；</li>\n<li>CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留（默认值）；</li>\n<li>RUNTIME：一直保留到运行时</li>\n</ul>\n<p>4.4 <code>@Documented</code>注解表示注解信息包含到生成文档中；</p>\n<p>4.5 注解不能继承，但是使用了注解的父类一旦被子类继承，那么子类就可以继承父类的注解，如果要实现这样的效果，需要在父类的注解中加上<code>@Inherited</code></p>\n<ol>\n<li>总结：注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离。框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作；</li>\n</ol>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><ol>\n<li>静态代理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SImpleStaticProxy</span> &#123;<br>    <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 真实对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;RealService Say Hello!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 代理对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TraceProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">private</span> IService realService;<br><br>        TraceProxy(IService realService) &#123;<br>            <span class=\"hljs-built_in\">this</span>.realService = realService;<br>        &#125;<br><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;entering say hello...&quot;</span>);<br>            <span class=\"hljs-built_in\">this</span>.realService.sayHello();<br>            System.out.println(<span class=\"hljs-string\">&quot;exited say hello...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">realService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RealService</span>();<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TraceProxy</span>(realService);<br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>动态代理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleDynamicProxy</span> &#123;<br>    <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 真实对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;Real Service Say Hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 代理对象实现JDK中的InvocationHandler接口</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleInvocationHandle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">InvocationHandler</span> &#123;<br>        <span class=\"hljs-keyword\">private</span> Object realObj;<br><br>        SimpleInvocationHandle(Object realObj) &#123;<br>            <span class=\"hljs-built_in\">this</span>.realObj = realObj;<br>        &#125;<br>        <br>        <span class=\"hljs-comment\">// 重写invoke方法</span><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title function_\">invoke</span><span class=\"hljs-params\">(Object proxy, Method method, Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable &#123;<br>            <span class=\"hljs-comment\">// proxy：表示代理对象本身，不是被代理对象，一般用处不大</span><br>            <span class=\"hljs-comment\">// method：表示正在被调用的方法</span><br>            <span class=\"hljs-comment\">// args：表示方法的参数</span><br>            System.out.println(<span class=\"hljs-string\">&quot;entering &quot;</span> + method.getName());<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> method.invoke(realObj, args);<br>            System.out.println(<span class=\"hljs-string\">&quot;leaving &quot;</span> + method.getName());<br>            <span class=\"hljs-keyword\">return</span> result;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">realService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RealService</span>();<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> (IService) Proxy.newProxyInstance(IService.class.getClassLoader(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Class</span>&lt;?&gt;[]&#123;IService.class&#125;,<br>                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleInvocationHandle</span>(realService)); <span class=\"hljs-comment\">// 使用Proxy.newProxyInstance生成一个代理对象</span><br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>newProxyInstance的声明如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Object <span class=\"hljs-title function_\">newProxyInstance</span><span class=\"hljs-params\">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;<br><span class=\"hljs-comment\">// ClassLoader：表示类加载器；</span><br><span class=\"hljs-comment\">// Class&lt;?&gt;[] interfaces：表示代理类要实现的接口列表，元素类型只能是接口，不能是普通类；</span><br><span class=\"hljs-comment\">// InvocationHandler：是一个接口，对代理接口所有方法的调用都会转给该方法；</span><br><span class=\"hljs-comment\">// newProxyInstance是Object类型，它不能强制转换为某个类型，只能转换为接口类型；</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>类定义本身与被代理的对象没有关系，与InvocationHandler的具体实现也没有关系，而主要与接口数组有关，给定的接口数组会动态地创建每个接口的实现代码，实现就是转发给InvocationHandler，与被代理对象的关系以及对它的调用由InvocationHandler实现管理。</li>\n<li>总结：使用动态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每个被代理的类型都是创建一个静态代理类。</li>\n<li>局限性：JDK中的动态代理只能为接口创建代理，返回的代理对象也只能转换到某个接口类型；如果一个类没有接口，或者希望代理非接口中定义的方法，就无能为力了。</li>\n<li>使用cglib的动态代理类可以解决上述的痛点。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleCGLibDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">MethodInterceptor</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title function_\">intercept</span><span class=\"hljs-params\">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"hljs-keyword\">throws</span> Throwable &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;entering &quot;</span> + method.getName());<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> proxy.invokeSuper(object, args);<br>            System.out.println(<span class=\"hljs-string\">&quot;leaving &quot;</span> + method.getName());<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; T <span class=\"hljs-title function_\">getProxy</span><span class=\"hljs-params\">(Class&lt;T&gt; cls)</span> &#123;<br>        <span class=\"hljs-type\">Enhancer</span> <span class=\"hljs-variable\">enhancer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Enhancer</span>();<br>        enhancer.setSuperclass(cls);<br>        enhancer.setCallback(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleInterceptor</span>());<br>        <span class=\"hljs-keyword\">return</span> (T)enhancer.create();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">RealService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> getProxy(RealService.class);<br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>cglib代理面向的一个具体的类，创建对象只有一个；而SDK代理面向的是接口；</li>\n</ol>\n<h1 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h1><ol>\n<li>类加载机制可以应用于下列场景：</li>\n</ol>\n<ul>\n<li>热部署：不重启程序的情况下动态替换</li>\n<li>应用模块化和互相隔离：不同的ClassLoader可以加载相同的类，但是互相隔离、互不影响。例如：Tomcat管理多个Web应用程序；</li>\n<li>从不同地方灵活加载：系统默认从本地.class文件或者.jar包中加载字节码文件，通过自定义ClassLoader可以从共享服务器、数据库、缓存服务器等其他地方加载字节码文件；</li>\n</ul>\n<ol>\n<li>类加载机制组成部分：</li>\n</ol>\n<ul>\n<li>启动类型加载器（Bootstrap Classloader）：一般由C++实现的，它负责加载Java的基础类，主要是<JAVA_HOME>/lib/rt.jar；</li>\n<li>扩展类加载器（Extension Classloader）：加载器的实现类sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类；</li>\n<li>应用程序类加载器（Application ClassLoader）：实现类是sun.misc.Launcher$AppClassLoader。负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类；</li>\n</ul>\n<ol>\n<li>类加载的全过程：</li>\n</ol>\n<ul>\n<li>1）判断是否已经加载过，如果加载过直接返回Class对象，一个类只会被一个ClassLoader加载过一次；</li>\n<li>2）如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象；</li>\n<li>3）在父ClassLoader没有加载成功的前提下，自己尝试加载类；</li>\n</ul>\n<ol>\n<li>这个过程称之为“双亲委派”模型。优先让父ClassLoader去加载。</li>\n<li>类加载都按照“双亲委派”模型，但是也有例外：</li>\n</ol>\n<ul>\n<li>自定义加载顺序：即自定义的类加载器可以不遵循“双亲委派”模型，但一般上是不推荐的；</li>\n<li>网状加载顺序：在OSGI和Java9中存在网状加载的情况。</li>\n<li>父加载器委派给子加载器：典型应用有JNDI。</li>\n</ul>\n<ol>\n<li>类加载器的例子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassLoaderDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoaderDemo.class.getClassLoader();<br>        <span class=\"hljs-keyword\">while</span> (c1 != <span class=\"hljs-literal\">null</span>) &#123;<br>            System.out.println(c1.getClass().getName());<br>            c1 = c1.getParent();<br>        &#125;<br>        System.out.println(String.class.getClassLoader());<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 输出结果为：</span><br><span class=\"hljs-comment\">// sun.misc.Launcher.$AppClassLoader</span><br><span class=\"hljs-comment\">// sun.misc.Launcher.$ExtClassLoader</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>ClassLoader中有一个默认方法<code>public static ClassLoader getSystemClassLoader()</code>，还有一个默认方法用于加载类： <code>public class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br><span class=\"hljs-keyword\">try</span> &#123;<br>    Class&lt;?&gt; cls = c1.loadClass(<span class=\"hljs-string\">&quot;java.util.ArrayList&quot;</span>);<br>    <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">actualLoader</span> <span class=\"hljs-operator\">=</span> cls.getClassLoader();<br>    System.out.println(actualloader);<br>&#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>类加载器是一个抽象类。Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader以及sun.misc.Launcher$ExtClassLoader。Bootstrap ClassLoader不是由Java实现的。因此没有实现类。需要说明的是，由于是委派机制。使用getClassLoader()方法返回的不一定调用load-Class.</li>\n<li>ClassLoader中的loadClass方法只会加载类但是不会执行。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CLInitDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hello</span> &#123;<br>        <span class=\"hljs-keyword\">static</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> CLInitDemo.class.getName() + <span class=\"hljs-string\">&quot;$Hello&quot;</span>;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            Class&lt;?&gt; cls = c1.loadClass(className); <span class=\"hljs-comment\">// 不会输出&quot;hello&quot;</span><br>            <span class=\"hljs-comment\">// Class&lt;?&gt; cls = Class.forName(className); // 会输出&quot;hello&quot;</span><br>        &#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，也是一种策略模式。</li>\n</ol>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"单个字符\"><a href=\"#单个字符\" class=\"headerlink\" title=\"单个字符\"></a>单个字符</h2><ol>\n<li>用字符本身表示</li>\n<li>特殊字符：例如制表符’\\t’，换行符’\\n’以及回车符’\\r’；</li>\n<li>八进制表示的字符：以’\\0’开头，后面加上1~3位数字，例如\\0141(8) -&gt; 97(10)</li>\n<li>十六进制表示的字符：以’\\x’开头，后面跟两位字符，比如\\x6A(16) -&gt; 106(10)</li>\n<li>Unicode表示字符，以’\\u’开头，后面跟4位字符</li>\n<li>斜杠本身就是特殊字符，如果需要使用斜杠需要用一个斜杠进行转义；</li>\n<li>元字符：例如“.、*、?、+”等，如果要皮匹配自身，需要在前面加’’进行转义</li>\n</ol>\n<h2 id=\"字符祖\"><a href=\"#字符祖\" class=\"headerlink\" title=\"字符祖\"></a>字符祖</h2><ol>\n<li>‘.’字符匹配除了换行符以外的任意字符，也可以使用“单行匹配模式”或者“点号匹配模式”。可以以(?s)开头，s表示single line；</li>\n<li>中括号[]表示匹配字符组中的任意一个字符，例如[abcd]匹配任意一个字母；</li>\n<li>‘^’表示排除符号；</li>\n<li>\\d：匹配一个数字字符，等同于[0-9]；</li>\n<li>\\w：匹配一个单词字符，等同于[a-zA-Z_0-9]；</li>\n<li>\\s：匹配一个空白字符，等同于[\\t\\n\\x0B\\f\\r]</li>\n<li>\\D：匹配一个非数字字符，即<sup><a href=\"#fn_\\d\" id=\"reffn_\\d\">\\d</a></sup>；</li>\n<li>\\W：匹配一个非单词字符，即<sup><a href=\"#fn_\\w\" id=\"reffn_\\w\">\\w</a></sup>；</li>\n<li>\\S：匹配一个非空白字符，即<sup><a href=\"#fn_\\s\" id=\"reffn_\\s\">\\s</a></sup>；</li>\n</ol>\n<h2 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h2><ol>\n<li>量词是指定出现次数的元字符，常见的有三种+、*、？</li>\n<li>‘+’表示前面字符的一次或多次出现。比如正则表达式ab+c，既能匹配abc，也能匹配abbc:</li>\n<li>‘<em>‘表示前面的字符的零次或多次出现，例如：ab</em>c。既能匹配abc，也能匹配ac或abbbc；</li>\n<li>‘?’表示前面字符可能出现，也可能不出现。例如正则表达式ab?c，既能匹配abc，也能匹配ac；</li>\n<li>通用表示出现次数的语法为{m,n}，出现次数从m到n，包括m和n。如果n没有限制可以省略。如果m和n一样，可以省略一个写为{m}。例如：</li>\n</ol>\n<ul>\n<li>ab{1,10}c：b可以出现1次到10次</li>\n<li>ab{3}c：b必须出现三次</li>\n<li>ab{1,}c：等同于ab+c</li>\n<li>ab{0,}c：等同于ab*c</li>\n<li>ab{0,1}c：等同于ab?c</li>\n</ul>\n<ol>\n<li>量词默认是贪婪的，也就是说会从正则开始匹配到结束内的所有字符，如果需要在匹配到第一个就终止，需要使用懒惰量词。即在两次后面加上一个符号’?’；</li>\n</ol>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><ol>\n<li>可以用括号将表达式括起来，表示一个分组。分组匹配的子字符串可以在后续访问，好像被被捕获了一样，所以默认分组称之为捕获分组；</li>\n<li>在正则表达式中，可以使用斜杠\\加分组编号引用之前匹配的分组，称之为回溯引用；</li>\n</ol>\n<h2 id=\"特殊边界匹配\"><a href=\"#特殊边界匹配\" class=\"headerlink\" title=\"特殊边界匹配\"></a>特殊边界匹配</h2><ol>\n<li>常见的特殊边界的元字符有^、$、\\A、\\Z、\\z和\\b。</li>\n<li>‘’匹配整个字符串的开始，此外‘’也表示排除，默认单行匹配；</li>\n<li>‘$’匹配整个字符串的结束，默认单行匹配；</li>\n<li>多行匹配的方式如下：以(?m)开头。例如：(?m)^abc$</li>\n<li>\\A和^类似；</li>\n<li>\\Z和$类似；\\z匹配的总是结束的边界；</li>\n<li>\\b匹配的是单词的边界；</li>\n<li>边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界；</li>\n</ol>\n<h2 id=\"环视边界匹配\"><a href=\"#环视边界匹配\" class=\"headerlink\" title=\"环视边界匹配\"></a>环视边界匹配</h2><ol>\n<li>此部分内容比较晦涩，暂不做了解；</li>\n</ol>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><h2 id=\"函数是接口：\"><a href=\"#函数是接口：\" class=\"headerlink\" title=\"函数是接口：\"></a>函数是接口：</h2><ol>\n<li>Java中预定义了大量的函数式接口：</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数接口</th>\n<th>方法定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Predicate<T></td>\n<td>boolean test(T t)</td>\n<td>谓词，测试输入条件是否满足要求</td>\n</tr>\n<tr>\n<td>Function<T, R></td>\n<td>R apply(T t)</td>\n<td>函数转换，输入类型T，输出类型R</td>\n</tr>\n<tr>\n<td>Consumer<T></td>\n<td>void accept(T t)</td>\n<td>消费者，输入类型T</td>\n</tr>\n<tr>\n<td>Supplier<T></td>\n<td>T get()</td>\n<td>工厂方法</td>\n</tr>\n<tr>\n<td>UnaryOperator<T></td>\n<td>T apply(T t)</td>\n<td>函数转换的特例，输入和输出类型一样</td>\n</tr>\n<tr>\n<td>BiFunction<T, U, R></td>\n<td>R apply(T t, U u)</td>\n<td>函数转换，接受两个参数，输出R</td>\n</tr>\n<tr>\n<td>BinaryOperator<T></td>\n<td>T apply(T t, T u)</td>\n<td>BiFunction的特例，输入和输出类型一样</td>\n</tr>\n<tr>\n<td>BiConsumer<T, U></td>\n<td>void accept(T t, U u)</td>\n<td>消费者，接受两个参数</td>\n</tr>\n<tr>\n<td>BiPredicate<T, U></td>\n<td>boolean test(T t, U u)</td>\n<td>谓词，接受两个参数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li>Predicate示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br>    String name;<br>    <span class=\"hljs-type\">double</span> score;<br>    <span class=\"hljs-comment\">// 省略getter/setter</span><br>&#125;<br><br><span class=\"hljs-comment\">// 借助Predicate撰写一个filter的逻辑，例如：</span><br>students = filter(students, t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Function示例：数据转换</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 根据学生列表返回名称列表的代码：</span><br>List&lt;Student&gt; names = map(students, t -&gt; t.getName());<br><br><span class=\"hljs-comment\">// 将学生名称转换为大写：</span><br>students = map(students, t -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>(t.getName().toUpperCase(), t.getScore()))<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Consumer示例：直接对原值进行修改</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">foreach(students, t -&gt; t.setName(t.getName(),.toUpperCase()))<br></code></pre></td></tr></table></figure>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><ol>\n<li>示例代码中<code>Student::getName</code>称之为方法引用，使用::分隔开。分隔符前面是类型或变量名，后者是方法名。方法可以是实例方法，也可以是静态方法。例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">getColleageName</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Test String&quot;</span>;<br>&#125;<br><span class=\"hljs-comment\">// 下面两条句子的等价的</span><br>Supplier&lt;String&gt; s = Student::getColleageName;<br>Supplier&lt;String&gt; s = () -&gt; Student.getColleageName()；<br></code></pre></td></tr></table></figure>\n<h2 id=\"函数的复合\"><a href=\"#函数的复合\" class=\"headerlink\" title=\"函数的复合\"></a>函数的复合</h2><ol>\n<li>函数式接口和Lambda表达式可以用作方法的返回值，传递代码回调者，将上述两种方法结合起来，可以构造复合的函数，使程序简洁易读；</li>\n<li>复合Comparator中的复合方法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Arrays.sort(files, (f1, f2) -&gt; f1.getName().compareTo(f2.getName()));<br><span class=\"hljs-comment\">// 进一步简化</span><br>Arrays.sort(files, Comparator.comparing(File::getName()));<br></code></pre></td></tr></table></figure>\n<h2 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h2><ol>\n<li>基本过滤</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用Stream API之前</span><br>List&lt;Student&gt; above90List = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><span class=\"hljs-keyword\">for</span> (Student t : students) &#123;<br>    <span class=\"hljs-keyword\">if</span> (t.getScore() &gt; <span class=\"hljs-number\">90</span>) &#123;<br>        above90List.add(t);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用Stream API之后</span><br>List&lt;Student&gt; above90List = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ul>\n<li>没有显式的迭代循环，循环过程被Stream隐藏；</li>\n<li>提供了声明式的处理函数；</li>\n<li>流畅式接口；</li>\n</ul>\n<ol>\n<li>基本转换</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用Stream API之前</span><br>List&lt;String&gt; nameList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><span class=\"hljs-keyword\">for</span> (Student t : students) &#123;<br>    nameList.add(t.getName());<br>&#125;<br><br><span class=\"hljs-comment\">// 使用Stream API之后</span><br>List&lt;String&gt; nameList = students.stream()<br>    .map(Student::getName).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>基本过滤和转换组合</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; above90List = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .map(Student::getName)<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>distinct运算</li>\n</ol>\n<ul>\n<li>用于过滤重复元素，只留下唯一元素，是否重复根据equals()方法来比较。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;abc&quot;</span>, <span class=\"hljs-string\">&quot;def&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-string\">&quot;Abc&quot;</span>&#125;);<br>List&lt;String&gt; retList = list.stream()<br>    .filter(s -&gt; s.length() &lt;= <span class=\"hljs-number\">3</span>).map(String::toLowerCase).distinct()<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>sorted方法</li>\n</ol>\n<ul>\n<li>对流中的元素进行排序，返回一个排序后的stream。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Student&gt; list = students.stream().filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">0</span>)<br>    .sorted(Comparator.comparing(Student::getScore)<br>    .reversed().thenComparing(Student::getName))<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>skip/limit</li>\n</ol>\n<ul>\n<li>跳过流中的n个元素，如果流的长度不足n个，返回一个空流。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Student&gt; list = students.stream()<br>    .sorted(Comparator.comparing(Student::getScore).reversed()<br>    .skip(<span class=\"hljs-number\">2</span>).limit(<span class=\"hljs-number\">3</span>).collect(Coolectors.toList()));<br></code></pre></td></tr></table></figure>\n<ol>\n<li>peek</li>\n</ol>\n<ul>\n<li>返回一个与之前一样的流，没有变化。但是提供一个Consumer，会将流中的每一个元素传给Consumer。这个方法主要目的用于支持调试，可以使用该方法观察在流水线中流转的元素。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; above90Names = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .peek(System.out::println).map(Student::getName)<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>mapToLong/mapToInt/mapToDouble</li>\n</ol>\n<ul>\n<li>map函数接受函数参数是一个<code>Function&lt;T, R&gt;</code>，为避免拆箱，装箱提高性能。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .mapToDouble(Student::getScore).sum();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>flatMap</li>\n</ol>\n<ul>\n<li>接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换成一个流Stream。然后将新生成流的每一个元素传递给下一个操作。比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; lines = Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello abc&quot;</span>, <span class=\"hljs-string\">&quot;laoma biancheng&quot;</span>&#125;);<br>List&lt;String&gt; words = lines.stream()<br>    .flatMap(line -&gt; Arrays.stream(line.split(<span class=\"hljs-string\">&quot;\\\\s+&quot;</span>)))<br>    .collect(Collectors.toList());<br>System.out.println(words); <span class=\"hljs-comment\">// [hello, abc. laoma, biancheng]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"终端操作\"><a href=\"#终端操作\" class=\"headerlink\" title=\"终端操作\"></a>终端操作</h2><ol>\n<li>中间操作不触发实际执行，返回值是Stream，而终端操作触发执行，返回一个具体的值。除了collect之外还有：max, min, count, allMatch, anyMatch, noneMatch, findFirst, findAny, forEach, toArray, reduce等。</li>\n<li>max/min: 返回流中的最大值/最小值。其返回类型为Optional<T>而非T。Optional表明可能为null，程序应当进行适当的处理。例子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">student</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .max(Comparator.comparing(Student::getScore).reversed()).get();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>count：返回流中的元素个数，例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">above90Count</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>).count();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>allMatch/anyMatch/noneMatch：用于判定流中额元素是否满足一定的条件，区别在于：</li>\n</ol>\n<ul>\n<li>allMatch：流中所有元素都满足条件的情况下返回true;</li>\n<li>anyMatch：流中的元素只要有一个元素满足条件即返回true;</li>\n<li>noneMatch：只有流中的所有元素都不满足条件才返回true;</li>\n<li>示例如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">allPass</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .allMatch(t -&gt; t.getScore() &gt;= <span class=\"hljs-number\">60</span>);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>findFirst/findAny：返回类型均为Optional，如果流为空则返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素。均为短路操作。示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Optional&lt;Student&gt; student = students.stream()<br>    .filter(t -&gt; t.getScore() &lt; <span class=\"hljs-number\">60</span>)<br>    .findAny();<br><span class=\"hljs-keyword\">if</span> (student.isPresent()) &#123;<br>    <span class=\"hljs-comment\">// 处理不符合要求的数据</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>forEach/forEachOrdered：并行流中forEach不保证顺序，forEachOrdered能保证顺序。例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>toArray：将流转换为数组，包含两个方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Object[] toArray() <span class=\"hljs-comment\">// 返回值为Object[]</span><br>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) <span class=\"hljs-comment\">// 得到指定类型的数组</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>示例为：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Student[] above90Arr = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .toArray(Student[]::<span class=\"hljs-keyword\">new</span>); <span class=\"hljs-comment\">// Student[]::new就是一个IntFunction类型的ggenerator</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>reduce：归约或折叠，将流中的元素归约为一个值，有三种reduce函数：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Optional&lt;T&gt; <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(BinaryOperator&lt;T&gt; accumulator)</span>;<br>T <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;<br>&lt;U&gt; U <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(U identity, BiFunction&lt;U, ? <span class=\"hljs-built_in\">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第一个reduce函数的使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">topStudent</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .reduce((acc, t) -&gt; &#123;<br>        <span class=\"hljs-keyword\">if</span>(acc.getScore() &gt;= t.getScore()) &#123;<br>            <span class=\"hljs-keyword\">return</span> acc;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> t;<br>        &#125;<br>    &#125;).get();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第二个reduce函数比第一个多了identity参数，表示初始值</li>\n<li>第三个reduce函数更为通用，可以自定义归约类型，另外还多了一个combiner参数，在并行流中用于合并子线程结果。还有示例：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">sumScore</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .reduce(<span class=\"hljs-number\">0d</span>, (sum, t) -&gt; sum += t.getScore(), <br>    (sum1, sum2) -&gt; sum1 += sum2)<br>    );<br></code></pre></td></tr></table></figure>\n<ol>\n<li>迭代Map的过程删除元素，直接使用forEach会报ConcurrentModificationException</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Object&gt; map = other.getHashMap&lt;&gt;();<br>map.entrySet().removeIf(entryElement -&gt; <span class=\"hljs-string\">&quot;some condition&quot;</span>.equals(entryElement.getKey()))<br></code></pre></td></tr></table></figure>\n"},{"title":"Java面试汇总","date":"2022-02-24T07:57:25.000Z","updated":"2022-02-24T07:57:25.000Z","_content":"\n# 一、Java基础\n\n## 1. JDK和JRE有什么区别？\n\n+ JDK：Java Development Kit的简称，提供Java开发环境和运行环境；\n+ JRE：Java Runtime Environment的简称，Java运行环境；\n\n简单来说：JDK包含JRE，想要开发Java程序需要安装JDK；想要运行Java运行只需要JRE；\n\n\n\n## 2. == 和 equals的区别\n\n### 2.1 基本区别\n\n+ 基本类型：比较值是否相同\n+ 引用类型：比较引用是否相同\n\nequals本质上也是 ==，只不过String和Integer重写了equals方法，所以变成了值比较；\n\n如果要保证两个对象相等就要重写它的equals方法\n\n\n\n### 2.2 equals和hashCode的区别\n\n+ 两个对象的hashCode()相同，equals()不一定相同；\n+ 两个对象equals()相同，hashCode()一定相同；\n\n\n\n## 3. final在java类中的作用\n\n+ final修饰的类不能被继承；\n+ final修饰的方法不能被重写；\n+ final修饰的量叫常量，常量必须初始化，初始化后的值不能被修改；\n\n\n\n## 4. Java的基础类型\n\n有8种，分别是：byte, boolean, char, short, float, long和double\n\nString不属于Java的基本类型，属于对象；\n\n\n\n## 5. Java操作字符串的类\n\n有：String，StringBuilder和StringBuffer。其中StringBuffer是线程安全的，而StringBuilder是非线程安全的。但是StringBuilder的性能高于StringBuffer。所以单线程环境下使用StringBuilder，多线程环境下使用StringBuffer；\n\n\n\n## 6. String str = \"i\"和String str = new String(\"i\")区别\n\n+ String str = \"i\"会在JVM虚拟机中分配到常量池\n\n+ String str = new String(\"i\")会被分配到堆内存中（并且会产生冗余对象）；\n\n\n\n## 7. String类的常用方法\n\n+ indexOf()：返回指定字符串的索引\n+ charAt()：返回指定索引处的字符\n+ replace()：字符串替换；\n+ trim()：去除字符串两端的空白\n+ split()：分割字符串，返回一个分割后的字符串数组\n+ getBytes()：返回字符串的byte类型数组\n+ length()：返回字符串长度\n+ toLowerCase()：字符串转小写\n+ toUpperCase()：字符串转大写\n+ substring()：截取字符串\n+ equals()：字符串比较\n\n\n\n## 8. 抽象类必须要有抽象方法吗？\n\n不需要，抽象类不一定非要有抽象方法\n\n```java\npublic abstract class Cat {\n    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n```\n\n+ 普通类不能包括抽象方法，抽象类可以包括抽象方法；\n+ 抽象类不能直接实例化，普通类可以直接实例化；\n+ 抽象类不能被final修饰（因为final 修饰的类不能被继承）\n\n\n\n## 9. 接口和抽象类的区别\n\n实现：抽象子类使用`extends`继承，接口必须使用`implements`实现；\n\n构造函数：抽象类有构造函数，接口没有（当然1.8中接口可以有default方法）\n\n实现数量：类可以实现很多个接口，但是只能继承一个抽象类；\n\n访问修饰符：接口的方法默认使用public修饰，抽象类无此限制；\n\n\n\n## 10. Java I/O流\n\n+ 功能分类：输入流、输出流\n+ 类型分类：字节流（8位）和字符流（16位）\n\n\n\n## 11. BIO、NIO、AIO区别\n\n+ BIO：Block IO同步阻塞式IO，平常使用的传统IO，特点是简单方便使用，并发能力低；\n+ NIO：同步非阻塞IO，客户端和服务端通过Channel（通道）通讯，实现了多路复用；\n+ AIO：异步非阻塞IO，异步IO的操作基于事件和回调机制；\n\n\n\n## 12. File常用方法\n\n+ exists()：检测文件路径是否存在；\n+ createFile()：创建文件；\n+ createDirectory()：创建目录；\n+ delete()：删除一个文件或者目录\n+ copy()：复制文件\n+ move()：移动文件\n+ size()：查看文件个数\n+ read()：读取文件\n+ write()：写入文件\n\n\n\n# 二、容器\n\n## 13. java容器分类\n\n![image-20220224165841246](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220224165841246.png)\n\n## 14. HashMap和Hashtable的区别\n\n+ 存储：HashMap允许key和value为null，而Hashtable不允许；\n+ 线程安全：Hashtable是线程安全的，而HashMap是非线程安全的；\n+ 推荐使用：Hashtable是保留类不建议使用，单线程环境用HashMap，多线程用ConcurrentHashMap；\n\n\n\n## 15. 如何决定使用HashMap还是TreeMap\n\n+ 想要对一个key集合进行有序遍历，使用TreeMap；\n+ 只做插入、删除、定位一个元素的操作，使用HashMap；\n\n\n\n## 16. HashMap/HashSet的实现原理\n\n开个专题学习\n\n\n\n## 17. ArrayList和LinkedList的区别\n\n+ **数据结构：**ArrayList是动态数组，LinkedList是双链表结构；\n\n+ **随机访问：**ArrayList是数组结构，所以随机访问效率高；LinkedList是线性数据存储，所以需要移动指针从前往后遍历；\n\n+ **增加和删除效率：**非首尾增加删除操作，LinkedList效率比ArrayList高；\n\n综述：需要频繁读取集合中的元素，推荐使用ArrayList，插入删除操作比较多就用LinkedList；\n\n\n\n## 18. 数组和List的转换\n\n+ 数组转List：`Arrays.asList(array)`；\n+ List转数组：List自带的toArray()方法；\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"sdv\");\nlist.add(\"drgd\");\nObject[] objects = list.toArray();\nSystem.out.println(Arrays.toString(objects));\n\nString[] array = new String[]{\"ssdv\", \"svsdfb\"};\nSystem.out.println(Arrays.asList(array));\n```\n\n\n\n## 19. ArrayList和Vector的区别\n\n+ 线程安全：Vector使用Synchronized实现同步，是线程安全的；而ArrayList是非线程安全的；\n+ 性能：ArrayList性能优于Vector；\n+ 扩容：两者都会根据实际需要动态扩容，但是Vector扩容每次增加1倍，ArrayList只会增加50%；\n\n\n\n## 20. Queue中的poll()和remove()的区别\n\n+ 相同：返回第一个元素，并在队列中删除返回的对象；\n+ 不同：poll()没元素返回null，remove()会直接抛出NoSuchElementException异常；\n\n\n\n## 21. 哪些集合类是线程安全的\n\nVector、Hashtable、Stack是线程安全的，HashMap是非线程安全的，对应的线程安全类是ConcurrentHashMap;\n\n\n\n## 22. 迭代器iterator是什么\n\n提供遍历任何Collection的接口，可以从一个Collection中使用迭代器方法获取迭代器实例。\n\n```java\nList<String> list = new ArrayList<>();\nIterator<String> it = List.iterator();\nwhile(it.hasNext()) {\n    String obj = it.next();\n    System.out.println(obj);\n}\n```\n\nIterator特点是安全，因为可以确保在当前遍历集合元素被更改时，抛出ConcurrentModificationException异常；\n\n\n\n## 23. 怎么确保一个集合不能被更改\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"x\");\nCollection<String> clist = Collections.unmodifiableCollection(list);\nclist.add(\"y\"); // throw error\nSystem.out.println(list.size());\n```\n\n","source":"_posts/java-core/java-summary.md","raw":"---\ntitle: Java面试汇总\ndate: 2022-02-24 15:57:25\nupdated: 2022-02-24 15:57:25\ntags: Java\ncategories: 面试技巧\n---\n\n# 一、Java基础\n\n## 1. JDK和JRE有什么区别？\n\n+ JDK：Java Development Kit的简称，提供Java开发环境和运行环境；\n+ JRE：Java Runtime Environment的简称，Java运行环境；\n\n简单来说：JDK包含JRE，想要开发Java程序需要安装JDK；想要运行Java运行只需要JRE；\n\n\n\n## 2. == 和 equals的区别\n\n### 2.1 基本区别\n\n+ 基本类型：比较值是否相同\n+ 引用类型：比较引用是否相同\n\nequals本质上也是 ==，只不过String和Integer重写了equals方法，所以变成了值比较；\n\n如果要保证两个对象相等就要重写它的equals方法\n\n\n\n### 2.2 equals和hashCode的区别\n\n+ 两个对象的hashCode()相同，equals()不一定相同；\n+ 两个对象equals()相同，hashCode()一定相同；\n\n\n\n## 3. final在java类中的作用\n\n+ final修饰的类不能被继承；\n+ final修饰的方法不能被重写；\n+ final修饰的量叫常量，常量必须初始化，初始化后的值不能被修改；\n\n\n\n## 4. Java的基础类型\n\n有8种，分别是：byte, boolean, char, short, float, long和double\n\nString不属于Java的基本类型，属于对象；\n\n\n\n## 5. Java操作字符串的类\n\n有：String，StringBuilder和StringBuffer。其中StringBuffer是线程安全的，而StringBuilder是非线程安全的。但是StringBuilder的性能高于StringBuffer。所以单线程环境下使用StringBuilder，多线程环境下使用StringBuffer；\n\n\n\n## 6. String str = \"i\"和String str = new String(\"i\")区别\n\n+ String str = \"i\"会在JVM虚拟机中分配到常量池\n\n+ String str = new String(\"i\")会被分配到堆内存中（并且会产生冗余对象）；\n\n\n\n## 7. String类的常用方法\n\n+ indexOf()：返回指定字符串的索引\n+ charAt()：返回指定索引处的字符\n+ replace()：字符串替换；\n+ trim()：去除字符串两端的空白\n+ split()：分割字符串，返回一个分割后的字符串数组\n+ getBytes()：返回字符串的byte类型数组\n+ length()：返回字符串长度\n+ toLowerCase()：字符串转小写\n+ toUpperCase()：字符串转大写\n+ substring()：截取字符串\n+ equals()：字符串比较\n\n\n\n## 8. 抽象类必须要有抽象方法吗？\n\n不需要，抽象类不一定非要有抽象方法\n\n```java\npublic abstract class Cat {\n    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n```\n\n+ 普通类不能包括抽象方法，抽象类可以包括抽象方法；\n+ 抽象类不能直接实例化，普通类可以直接实例化；\n+ 抽象类不能被final修饰（因为final 修饰的类不能被继承）\n\n\n\n## 9. 接口和抽象类的区别\n\n实现：抽象子类使用`extends`继承，接口必须使用`implements`实现；\n\n构造函数：抽象类有构造函数，接口没有（当然1.8中接口可以有default方法）\n\n实现数量：类可以实现很多个接口，但是只能继承一个抽象类；\n\n访问修饰符：接口的方法默认使用public修饰，抽象类无此限制；\n\n\n\n## 10. Java I/O流\n\n+ 功能分类：输入流、输出流\n+ 类型分类：字节流（8位）和字符流（16位）\n\n\n\n## 11. BIO、NIO、AIO区别\n\n+ BIO：Block IO同步阻塞式IO，平常使用的传统IO，特点是简单方便使用，并发能力低；\n+ NIO：同步非阻塞IO，客户端和服务端通过Channel（通道）通讯，实现了多路复用；\n+ AIO：异步非阻塞IO，异步IO的操作基于事件和回调机制；\n\n\n\n## 12. File常用方法\n\n+ exists()：检测文件路径是否存在；\n+ createFile()：创建文件；\n+ createDirectory()：创建目录；\n+ delete()：删除一个文件或者目录\n+ copy()：复制文件\n+ move()：移动文件\n+ size()：查看文件个数\n+ read()：读取文件\n+ write()：写入文件\n\n\n\n# 二、容器\n\n## 13. java容器分类\n\n![image-20220224165841246](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220224165841246.png)\n\n## 14. HashMap和Hashtable的区别\n\n+ 存储：HashMap允许key和value为null，而Hashtable不允许；\n+ 线程安全：Hashtable是线程安全的，而HashMap是非线程安全的；\n+ 推荐使用：Hashtable是保留类不建议使用，单线程环境用HashMap，多线程用ConcurrentHashMap；\n\n\n\n## 15. 如何决定使用HashMap还是TreeMap\n\n+ 想要对一个key集合进行有序遍历，使用TreeMap；\n+ 只做插入、删除、定位一个元素的操作，使用HashMap；\n\n\n\n## 16. HashMap/HashSet的实现原理\n\n开个专题学习\n\n\n\n## 17. ArrayList和LinkedList的区别\n\n+ **数据结构：**ArrayList是动态数组，LinkedList是双链表结构；\n\n+ **随机访问：**ArrayList是数组结构，所以随机访问效率高；LinkedList是线性数据存储，所以需要移动指针从前往后遍历；\n\n+ **增加和删除效率：**非首尾增加删除操作，LinkedList效率比ArrayList高；\n\n综述：需要频繁读取集合中的元素，推荐使用ArrayList，插入删除操作比较多就用LinkedList；\n\n\n\n## 18. 数组和List的转换\n\n+ 数组转List：`Arrays.asList(array)`；\n+ List转数组：List自带的toArray()方法；\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"sdv\");\nlist.add(\"drgd\");\nObject[] objects = list.toArray();\nSystem.out.println(Arrays.toString(objects));\n\nString[] array = new String[]{\"ssdv\", \"svsdfb\"};\nSystem.out.println(Arrays.asList(array));\n```\n\n\n\n## 19. ArrayList和Vector的区别\n\n+ 线程安全：Vector使用Synchronized实现同步，是线程安全的；而ArrayList是非线程安全的；\n+ 性能：ArrayList性能优于Vector；\n+ 扩容：两者都会根据实际需要动态扩容，但是Vector扩容每次增加1倍，ArrayList只会增加50%；\n\n\n\n## 20. Queue中的poll()和remove()的区别\n\n+ 相同：返回第一个元素，并在队列中删除返回的对象；\n+ 不同：poll()没元素返回null，remove()会直接抛出NoSuchElementException异常；\n\n\n\n## 21. 哪些集合类是线程安全的\n\nVector、Hashtable、Stack是线程安全的，HashMap是非线程安全的，对应的线程安全类是ConcurrentHashMap;\n\n\n\n## 22. 迭代器iterator是什么\n\n提供遍历任何Collection的接口，可以从一个Collection中使用迭代器方法获取迭代器实例。\n\n```java\nList<String> list = new ArrayList<>();\nIterator<String> it = List.iterator();\nwhile(it.hasNext()) {\n    String obj = it.next();\n    System.out.println(obj);\n}\n```\n\nIterator特点是安全，因为可以确保在当前遍历集合元素被更改时，抛出ConcurrentModificationException异常；\n\n\n\n## 23. 怎么确保一个集合不能被更改\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"x\");\nCollection<String> clist = Collections.unmodifiableCollection(list);\nclist.add(\"y\"); // throw error\nSystem.out.println(list.size());\n```\n\n","slug":"java-core/java-summary","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v5000i4f6178dtd40q","content":"<h1 id=\"一、Java基础\"><a href=\"#一、Java基础\" class=\"headerlink\" title=\"一、Java基础\"></a>一、Java基础</h1><h2 id=\"1-JDK和JRE有什么区别？\"><a href=\"#1-JDK和JRE有什么区别？\" class=\"headerlink\" title=\"1. JDK和JRE有什么区别？\"></a>1. JDK和JRE有什么区别？</h2><ul>\n<li>JDK：Java Development Kit的简称，提供Java开发环境和运行环境；</li>\n<li>JRE：Java Runtime Environment的简称，Java运行环境；</li>\n</ul>\n<p>简单来说：JDK包含JRE，想要开发Java程序需要安装JDK；想要运行Java运行只需要JRE；</p>\n<h2 id=\"2-和-equals的区别\"><a href=\"#2-和-equals的区别\" class=\"headerlink\" title=\"2. == 和 equals的区别\"></a>2. == 和 equals的区别</h2><h3 id=\"2-1-基本区别\"><a href=\"#2-1-基本区别\" class=\"headerlink\" title=\"2.1 基本区别\"></a>2.1 基本区别</h3><ul>\n<li>基本类型：比较值是否相同</li>\n<li>引用类型：比较引用是否相同</li>\n</ul>\n<p>equals本质上也是 ==，只不过String和Integer重写了equals方法，所以变成了值比较；</p>\n<p>如果要保证两个对象相等就要重写它的equals方法</p>\n<h3 id=\"2-2-equals和hashCode的区别\"><a href=\"#2-2-equals和hashCode的区别\" class=\"headerlink\" title=\"2.2 equals和hashCode的区别\"></a>2.2 equals和hashCode的区别</h3><ul>\n<li>两个对象的hashCode()相同，equals()不一定相同；</li>\n<li>两个对象equals()相同，hashCode()一定相同；</li>\n</ul>\n<h2 id=\"3-final在java类中的作用\"><a href=\"#3-final在java类中的作用\" class=\"headerlink\" title=\"3. final在java类中的作用\"></a>3. final在java类中的作用</h2><ul>\n<li>final修饰的类不能被继承；</li>\n<li>final修饰的方法不能被重写；</li>\n<li>final修饰的量叫常量，常量必须初始化，初始化后的值不能被修改；</li>\n</ul>\n<h2 id=\"4-Java的基础类型\"><a href=\"#4-Java的基础类型\" class=\"headerlink\" title=\"4. Java的基础类型\"></a>4. Java的基础类型</h2><p>有8种，分别是：byte, boolean, char, short, float, long和double</p>\n<p>String不属于Java的基本类型，属于对象；</p>\n<h2 id=\"5-Java操作字符串的类\"><a href=\"#5-Java操作字符串的类\" class=\"headerlink\" title=\"5. Java操作字符串的类\"></a>5. Java操作字符串的类</h2><p>有：String，StringBuilder和StringBuffer。其中StringBuffer是线程安全的，而StringBuilder是非线程安全的。但是StringBuilder的性能高于StringBuffer。所以单线程环境下使用StringBuilder，多线程环境下使用StringBuffer；</p>\n<h2 id=\"6-String-str-“i”和String-str-new-String-“i”-区别\"><a href=\"#6-String-str-“i”和String-str-new-String-“i”-区别\" class=\"headerlink\" title=\"6. String str = “i”和String str = new String(“i”)区别\"></a>6. String str = “i”和String str = new String(“i”)区别</h2><ul>\n<li><p>String str = “i”会在JVM虚拟机中分配到常量池</p>\n</li>\n<li><p>String str = new String(“i”)会被分配到堆内存中（并且会产生冗余对象）；</p>\n</li>\n</ul>\n<h2 id=\"7-String类的常用方法\"><a href=\"#7-String类的常用方法\" class=\"headerlink\" title=\"7. String类的常用方法\"></a>7. String类的常用方法</h2><ul>\n<li>indexOf()：返回指定字符串的索引</li>\n<li>charAt()：返回指定索引处的字符</li>\n<li>replace()：字符串替换；</li>\n<li>trim()：去除字符串两端的空白</li>\n<li>split()：分割字符串，返回一个分割后的字符串数组</li>\n<li>getBytes()：返回字符串的byte类型数组</li>\n<li>length()：返回字符串长度</li>\n<li>toLowerCase()：字符串转小写</li>\n<li>toUpperCase()：字符串转大写</li>\n<li>substring()：截取字符串</li>\n<li>equals()：字符串比较</li>\n</ul>\n<h2 id=\"8-抽象类必须要有抽象方法吗？\"><a href=\"#8-抽象类必须要有抽象方法吗？\" class=\"headerlink\" title=\"8. 抽象类必须要有抽象方法吗？\"></a>8. 抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHi</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;hi~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>普通类不能包括抽象方法，抽象类可以包括抽象方法；</li>\n<li>抽象类不能直接实例化，普通类可以直接实例化；</li>\n<li>抽象类不能被final修饰（因为final 修饰的类不能被继承）</li>\n</ul>\n<h2 id=\"9-接口和抽象类的区别\"><a href=\"#9-接口和抽象类的区别\" class=\"headerlink\" title=\"9. 接口和抽象类的区别\"></a>9. 接口和抽象类的区别</h2><p>实现：抽象子类使用<code>extends</code>继承，接口必须使用<code>implements</code>实现；</p>\n<p>构造函数：抽象类有构造函数，接口没有（当然1.8中接口可以有default方法）</p>\n<p>实现数量：类可以实现很多个接口，但是只能继承一个抽象类；</p>\n<p>访问修饰符：接口的方法默认使用public修饰，抽象类无此限制；</p>\n<h2 id=\"10-Java-I-O流\"><a href=\"#10-Java-I-O流\" class=\"headerlink\" title=\"10. Java I/O流\"></a>10. Java I/O流</h2><ul>\n<li>功能分类：输入流、输出流</li>\n<li>类型分类：字节流（8位）和字符流（16位）</li>\n</ul>\n<h2 id=\"11-BIO、NIO、AIO区别\"><a href=\"#11-BIO、NIO、AIO区别\" class=\"headerlink\" title=\"11. BIO、NIO、AIO区别\"></a>11. BIO、NIO、AIO区别</h2><ul>\n<li>BIO：Block IO同步阻塞式IO，平常使用的传统IO，特点是简单方便使用，并发能力低；</li>\n<li>NIO：同步非阻塞IO，客户端和服务端通过Channel（通道）通讯，实现了多路复用；</li>\n<li>AIO：异步非阻塞IO，异步IO的操作基于事件和回调机制；</li>\n</ul>\n<h2 id=\"12-File常用方法\"><a href=\"#12-File常用方法\" class=\"headerlink\" title=\"12. File常用方法\"></a>12. File常用方法</h2><ul>\n<li>exists()：检测文件路径是否存在；</li>\n<li>createFile()：创建文件；</li>\n<li>createDirectory()：创建目录；</li>\n<li>delete()：删除一个文件或者目录</li>\n<li>copy()：复制文件</li>\n<li>move()：移动文件</li>\n<li>size()：查看文件个数</li>\n<li>read()：读取文件</li>\n<li>write()：写入文件</li>\n</ul>\n<h1 id=\"二、容器\"><a href=\"#二、容器\" class=\"headerlink\" title=\"二、容器\"></a>二、容器</h1><h2 id=\"13-java容器分类\"><a href=\"#13-java容器分类\" class=\"headerlink\" title=\"13. java容器分类\"></a>13. java容器分类</h2><p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220224165841246.png\" alt=\"image-20220224165841246\"></p>\n<h2 id=\"14-HashMap和Hashtable的区别\"><a href=\"#14-HashMap和Hashtable的区别\" class=\"headerlink\" title=\"14. HashMap和Hashtable的区别\"></a>14. HashMap和Hashtable的区别</h2><ul>\n<li>存储：HashMap允许key和value为null，而Hashtable不允许；</li>\n<li>线程安全：Hashtable是线程安全的，而HashMap是非线程安全的；</li>\n<li>推荐使用：Hashtable是保留类不建议使用，单线程环境用HashMap，多线程用ConcurrentHashMap；</li>\n</ul>\n<h2 id=\"15-如何决定使用HashMap还是TreeMap\"><a href=\"#15-如何决定使用HashMap还是TreeMap\" class=\"headerlink\" title=\"15. 如何决定使用HashMap还是TreeMap\"></a>15. 如何决定使用HashMap还是TreeMap</h2><ul>\n<li>想要对一个key集合进行有序遍历，使用TreeMap；</li>\n<li>只做插入、删除、定位一个元素的操作，使用HashMap；</li>\n</ul>\n<h2 id=\"16-HashMap-HashSet的实现原理\"><a href=\"#16-HashMap-HashSet的实现原理\" class=\"headerlink\" title=\"16. HashMap/HashSet的实现原理\"></a>16. HashMap/HashSet的实现原理</h2><p>开个专题学习</p>\n<h2 id=\"17-ArrayList和LinkedList的区别\"><a href=\"#17-ArrayList和LinkedList的区别\" class=\"headerlink\" title=\"17. ArrayList和LinkedList的区别\"></a>17. ArrayList和LinkedList的区别</h2><ul>\n<li><p><strong>数据结构：</strong>ArrayList是动态数组，LinkedList是双链表结构；</p>\n</li>\n<li><p><strong>随机访问：</strong>ArrayList是数组结构，所以随机访问效率高；LinkedList是线性数据存储，所以需要移动指针从前往后遍历；</p>\n</li>\n<li><p><strong>增加和删除效率：</strong>非首尾增加删除操作，LinkedList效率比ArrayList高；</p>\n</li>\n</ul>\n<p>综述：需要频繁读取集合中的元素，推荐使用ArrayList，插入删除操作比较多就用LinkedList；</p>\n<h2 id=\"18-数组和List的转换\"><a href=\"#18-数组和List的转换\" class=\"headerlink\" title=\"18. 数组和List的转换\"></a>18. 数组和List的转换</h2><ul>\n<li>数组转List：<code>Arrays.asList(array)</code>；</li>\n<li>List转数组：List自带的toArray()方法；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;sdv&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;drgd&quot;</span>);<br>Object[] objects = list.toArray();<br>System.out.println(Arrays.toString(objects));<br><br>String[] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;ssdv&quot;</span>, <span class=\"hljs-string\">&quot;svsdfb&quot;</span>&#125;;<br>System.out.println(Arrays.asList(array));<br></code></pre></td></tr></table></figure>\n<h2 id=\"19-ArrayList和Vector的区别\"><a href=\"#19-ArrayList和Vector的区别\" class=\"headerlink\" title=\"19. ArrayList和Vector的区别\"></a>19. ArrayList和Vector的区别</h2><ul>\n<li>线程安全：Vector使用Synchronized实现同步，是线程安全的；而ArrayList是非线程安全的；</li>\n<li>性能：ArrayList性能优于Vector；</li>\n<li>扩容：两者都会根据实际需要动态扩容，但是Vector扩容每次增加1倍，ArrayList只会增加50%；</li>\n</ul>\n<h2 id=\"20-Queue中的poll-和remove-的区别\"><a href=\"#20-Queue中的poll-和remove-的区别\" class=\"headerlink\" title=\"20. Queue中的poll()和remove()的区别\"></a>20. Queue中的poll()和remove()的区别</h2><ul>\n<li>相同：返回第一个元素，并在队列中删除返回的对象；</li>\n<li>不同：poll()没元素返回null，remove()会直接抛出NoSuchElementException异常；</li>\n</ul>\n<h2 id=\"21-哪些集合类是线程安全的\"><a href=\"#21-哪些集合类是线程安全的\" class=\"headerlink\" title=\"21. 哪些集合类是线程安全的\"></a>21. 哪些集合类是线程安全的</h2><p>Vector、Hashtable、Stack是线程安全的，HashMap是非线程安全的，对应的线程安全类是ConcurrentHashMap;</p>\n<h2 id=\"22-迭代器iterator是什么\"><a href=\"#22-迭代器iterator是什么\" class=\"headerlink\" title=\"22. 迭代器iterator是什么\"></a>22. 迭代器iterator是什么</h2><p>提供遍历任何Collection的接口，可以从一个Collection中使用迭代器方法获取迭代器实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>Iterator&lt;String&gt; it = List.iterator();<br><span class=\"hljs-keyword\">while</span>(it.hasNext()) &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> it.next();<br>    System.out.println(obj);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Iterator特点是安全，因为可以确保在当前遍历集合元素被更改时，抛出ConcurrentModificationException异常；</p>\n<h2 id=\"23-怎么确保一个集合不能被更改\"><a href=\"#23-怎么确保一个集合不能被更改\" class=\"headerlink\" title=\"23. 怎么确保一个集合不能被更改\"></a>23. 怎么确保一个集合不能被更改</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);<br>clist.add(<span class=\"hljs-string\">&quot;y&quot;</span>); <span class=\"hljs-comment\">// throw error</span><br>System.out.println(list.size());<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":3482,"excerpt":"","more":"<h1 id=\"一、Java基础\"><a href=\"#一、Java基础\" class=\"headerlink\" title=\"一、Java基础\"></a>一、Java基础</h1><h2 id=\"1-JDK和JRE有什么区别？\"><a href=\"#1-JDK和JRE有什么区别？\" class=\"headerlink\" title=\"1. JDK和JRE有什么区别？\"></a>1. JDK和JRE有什么区别？</h2><ul>\n<li>JDK：Java Development Kit的简称，提供Java开发环境和运行环境；</li>\n<li>JRE：Java Runtime Environment的简称，Java运行环境；</li>\n</ul>\n<p>简单来说：JDK包含JRE，想要开发Java程序需要安装JDK；想要运行Java运行只需要JRE；</p>\n<h2 id=\"2-和-equals的区别\"><a href=\"#2-和-equals的区别\" class=\"headerlink\" title=\"2. == 和 equals的区别\"></a>2. == 和 equals的区别</h2><h3 id=\"2-1-基本区别\"><a href=\"#2-1-基本区别\" class=\"headerlink\" title=\"2.1 基本区别\"></a>2.1 基本区别</h3><ul>\n<li>基本类型：比较值是否相同</li>\n<li>引用类型：比较引用是否相同</li>\n</ul>\n<p>equals本质上也是 ==，只不过String和Integer重写了equals方法，所以变成了值比较；</p>\n<p>如果要保证两个对象相等就要重写它的equals方法</p>\n<h3 id=\"2-2-equals和hashCode的区别\"><a href=\"#2-2-equals和hashCode的区别\" class=\"headerlink\" title=\"2.2 equals和hashCode的区别\"></a>2.2 equals和hashCode的区别</h3><ul>\n<li>两个对象的hashCode()相同，equals()不一定相同；</li>\n<li>两个对象equals()相同，hashCode()一定相同；</li>\n</ul>\n<h2 id=\"3-final在java类中的作用\"><a href=\"#3-final在java类中的作用\" class=\"headerlink\" title=\"3. final在java类中的作用\"></a>3. final在java类中的作用</h2><ul>\n<li>final修饰的类不能被继承；</li>\n<li>final修饰的方法不能被重写；</li>\n<li>final修饰的量叫常量，常量必须初始化，初始化后的值不能被修改；</li>\n</ul>\n<h2 id=\"4-Java的基础类型\"><a href=\"#4-Java的基础类型\" class=\"headerlink\" title=\"4. Java的基础类型\"></a>4. Java的基础类型</h2><p>有8种，分别是：byte, boolean, char, short, float, long和double</p>\n<p>String不属于Java的基本类型，属于对象；</p>\n<h2 id=\"5-Java操作字符串的类\"><a href=\"#5-Java操作字符串的类\" class=\"headerlink\" title=\"5. Java操作字符串的类\"></a>5. Java操作字符串的类</h2><p>有：String，StringBuilder和StringBuffer。其中StringBuffer是线程安全的，而StringBuilder是非线程安全的。但是StringBuilder的性能高于StringBuffer。所以单线程环境下使用StringBuilder，多线程环境下使用StringBuffer；</p>\n<h2 id=\"6-String-str-“i”和String-str-new-String-“i”-区别\"><a href=\"#6-String-str-“i”和String-str-new-String-“i”-区别\" class=\"headerlink\" title=\"6. String str = “i”和String str = new String(“i”)区别\"></a>6. String str = “i”和String str = new String(“i”)区别</h2><ul>\n<li><p>String str = “i”会在JVM虚拟机中分配到常量池</p>\n</li>\n<li><p>String str = new String(“i”)会被分配到堆内存中（并且会产生冗余对象）；</p>\n</li>\n</ul>\n<h2 id=\"7-String类的常用方法\"><a href=\"#7-String类的常用方法\" class=\"headerlink\" title=\"7. String类的常用方法\"></a>7. String类的常用方法</h2><ul>\n<li>indexOf()：返回指定字符串的索引</li>\n<li>charAt()：返回指定索引处的字符</li>\n<li>replace()：字符串替换；</li>\n<li>trim()：去除字符串两端的空白</li>\n<li>split()：分割字符串，返回一个分割后的字符串数组</li>\n<li>getBytes()：返回字符串的byte类型数组</li>\n<li>length()：返回字符串长度</li>\n<li>toLowerCase()：字符串转小写</li>\n<li>toUpperCase()：字符串转大写</li>\n<li>substring()：截取字符串</li>\n<li>equals()：字符串比较</li>\n</ul>\n<h2 id=\"8-抽象类必须要有抽象方法吗？\"><a href=\"#8-抽象类必须要有抽象方法吗？\" class=\"headerlink\" title=\"8. 抽象类必须要有抽象方法吗？\"></a>8. 抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHi</span><span class=\"hljs-params\">()</span> &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;hi~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>普通类不能包括抽象方法，抽象类可以包括抽象方法；</li>\n<li>抽象类不能直接实例化，普通类可以直接实例化；</li>\n<li>抽象类不能被final修饰（因为final 修饰的类不能被继承）</li>\n</ul>\n<h2 id=\"9-接口和抽象类的区别\"><a href=\"#9-接口和抽象类的区别\" class=\"headerlink\" title=\"9. 接口和抽象类的区别\"></a>9. 接口和抽象类的区别</h2><p>实现：抽象子类使用<code>extends</code>继承，接口必须使用<code>implements</code>实现；</p>\n<p>构造函数：抽象类有构造函数，接口没有（当然1.8中接口可以有default方法）</p>\n<p>实现数量：类可以实现很多个接口，但是只能继承一个抽象类；</p>\n<p>访问修饰符：接口的方法默认使用public修饰，抽象类无此限制；</p>\n<h2 id=\"10-Java-I-O流\"><a href=\"#10-Java-I-O流\" class=\"headerlink\" title=\"10. Java I/O流\"></a>10. Java I/O流</h2><ul>\n<li>功能分类：输入流、输出流</li>\n<li>类型分类：字节流（8位）和字符流（16位）</li>\n</ul>\n<h2 id=\"11-BIO、NIO、AIO区别\"><a href=\"#11-BIO、NIO、AIO区别\" class=\"headerlink\" title=\"11. BIO、NIO、AIO区别\"></a>11. BIO、NIO、AIO区别</h2><ul>\n<li>BIO：Block IO同步阻塞式IO，平常使用的传统IO，特点是简单方便使用，并发能力低；</li>\n<li>NIO：同步非阻塞IO，客户端和服务端通过Channel（通道）通讯，实现了多路复用；</li>\n<li>AIO：异步非阻塞IO，异步IO的操作基于事件和回调机制；</li>\n</ul>\n<h2 id=\"12-File常用方法\"><a href=\"#12-File常用方法\" class=\"headerlink\" title=\"12. File常用方法\"></a>12. File常用方法</h2><ul>\n<li>exists()：检测文件路径是否存在；</li>\n<li>createFile()：创建文件；</li>\n<li>createDirectory()：创建目录；</li>\n<li>delete()：删除一个文件或者目录</li>\n<li>copy()：复制文件</li>\n<li>move()：移动文件</li>\n<li>size()：查看文件个数</li>\n<li>read()：读取文件</li>\n<li>write()：写入文件</li>\n</ul>\n<h1 id=\"二、容器\"><a href=\"#二、容器\" class=\"headerlink\" title=\"二、容器\"></a>二、容器</h1><h2 id=\"13-java容器分类\"><a href=\"#13-java容器分类\" class=\"headerlink\" title=\"13. java容器分类\"></a>13. java容器分类</h2><p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220224165841246.png\" alt=\"image-20220224165841246\"></p>\n<h2 id=\"14-HashMap和Hashtable的区别\"><a href=\"#14-HashMap和Hashtable的区别\" class=\"headerlink\" title=\"14. HashMap和Hashtable的区别\"></a>14. HashMap和Hashtable的区别</h2><ul>\n<li>存储：HashMap允许key和value为null，而Hashtable不允许；</li>\n<li>线程安全：Hashtable是线程安全的，而HashMap是非线程安全的；</li>\n<li>推荐使用：Hashtable是保留类不建议使用，单线程环境用HashMap，多线程用ConcurrentHashMap；</li>\n</ul>\n<h2 id=\"15-如何决定使用HashMap还是TreeMap\"><a href=\"#15-如何决定使用HashMap还是TreeMap\" class=\"headerlink\" title=\"15. 如何决定使用HashMap还是TreeMap\"></a>15. 如何决定使用HashMap还是TreeMap</h2><ul>\n<li>想要对一个key集合进行有序遍历，使用TreeMap；</li>\n<li>只做插入、删除、定位一个元素的操作，使用HashMap；</li>\n</ul>\n<h2 id=\"16-HashMap-HashSet的实现原理\"><a href=\"#16-HashMap-HashSet的实现原理\" class=\"headerlink\" title=\"16. HashMap/HashSet的实现原理\"></a>16. HashMap/HashSet的实现原理</h2><p>开个专题学习</p>\n<h2 id=\"17-ArrayList和LinkedList的区别\"><a href=\"#17-ArrayList和LinkedList的区别\" class=\"headerlink\" title=\"17. ArrayList和LinkedList的区别\"></a>17. ArrayList和LinkedList的区别</h2><ul>\n<li><p><strong>数据结构：</strong>ArrayList是动态数组，LinkedList是双链表结构；</p>\n</li>\n<li><p><strong>随机访问：</strong>ArrayList是数组结构，所以随机访问效率高；LinkedList是线性数据存储，所以需要移动指针从前往后遍历；</p>\n</li>\n<li><p><strong>增加和删除效率：</strong>非首尾增加删除操作，LinkedList效率比ArrayList高；</p>\n</li>\n</ul>\n<p>综述：需要频繁读取集合中的元素，推荐使用ArrayList，插入删除操作比较多就用LinkedList；</p>\n<h2 id=\"18-数组和List的转换\"><a href=\"#18-数组和List的转换\" class=\"headerlink\" title=\"18. 数组和List的转换\"></a>18. 数组和List的转换</h2><ul>\n<li>数组转List：<code>Arrays.asList(array)</code>；</li>\n<li>List转数组：List自带的toArray()方法；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;sdv&quot;</span>);<br>list.add(<span class=\"hljs-string\">&quot;drgd&quot;</span>);<br>Object[] objects = list.toArray();<br>System.out.println(Arrays.toString(objects));<br><br>String[] array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;ssdv&quot;</span>, <span class=\"hljs-string\">&quot;svsdfb&quot;</span>&#125;;<br>System.out.println(Arrays.asList(array));<br></code></pre></td></tr></table></figure>\n<h2 id=\"19-ArrayList和Vector的区别\"><a href=\"#19-ArrayList和Vector的区别\" class=\"headerlink\" title=\"19. ArrayList和Vector的区别\"></a>19. ArrayList和Vector的区别</h2><ul>\n<li>线程安全：Vector使用Synchronized实现同步，是线程安全的；而ArrayList是非线程安全的；</li>\n<li>性能：ArrayList性能优于Vector；</li>\n<li>扩容：两者都会根据实际需要动态扩容，但是Vector扩容每次增加1倍，ArrayList只会增加50%；</li>\n</ul>\n<h2 id=\"20-Queue中的poll-和remove-的区别\"><a href=\"#20-Queue中的poll-和remove-的区别\" class=\"headerlink\" title=\"20. Queue中的poll()和remove()的区别\"></a>20. Queue中的poll()和remove()的区别</h2><ul>\n<li>相同：返回第一个元素，并在队列中删除返回的对象；</li>\n<li>不同：poll()没元素返回null，remove()会直接抛出NoSuchElementException异常；</li>\n</ul>\n<h2 id=\"21-哪些集合类是线程安全的\"><a href=\"#21-哪些集合类是线程安全的\" class=\"headerlink\" title=\"21. 哪些集合类是线程安全的\"></a>21. 哪些集合类是线程安全的</h2><p>Vector、Hashtable、Stack是线程安全的，HashMap是非线程安全的，对应的线程安全类是ConcurrentHashMap;</p>\n<h2 id=\"22-迭代器iterator是什么\"><a href=\"#22-迭代器iterator是什么\" class=\"headerlink\" title=\"22. 迭代器iterator是什么\"></a>22. 迭代器iterator是什么</h2><p>提供遍历任何Collection的接口，可以从一个Collection中使用迭代器方法获取迭代器实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>Iterator&lt;String&gt; it = List.iterator();<br><span class=\"hljs-keyword\">while</span>(it.hasNext()) &#123;<br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> it.next();<br>    System.out.println(obj);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Iterator特点是安全，因为可以确保在当前遍历集合元素被更改时，抛出ConcurrentModificationException异常；</p>\n<h2 id=\"23-怎么确保一个集合不能被更改\"><a href=\"#23-怎么确保一个集合不能被更改\" class=\"headerlink\" title=\"23. 怎么确保一个集合不能被更改\"></a>23. 怎么确保一个集合不能被更改</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>list.add(<span class=\"hljs-string\">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);<br>clist.add(<span class=\"hljs-string\">&quot;y&quot;</span>); <span class=\"hljs-comment\">// throw error</span><br>System.out.println(list.size());<br></code></pre></td></tr></table></figure>\n"},{"title":"Java多线程面试汇总","date":"2022-02-24T10:35:13.000Z","updated":"2022-02-24T10:35:13.000Z","_content":"\n# 三、多线程\n\n## 1. 并行和并发的区别\n\n+ 并行：多个处理器或多核处理器同时处理多个任务；\n+ 并发：多个任务在一个CPU按细分的时间片轮流（交替）执行，从逻辑上来看是同时执行；\n\n\n\n## 2. 线程与进程的区别\n\n一个程序至少有一个进程，一个进程至少有一个线程，一个进程下可以有多个线程来增加执行程序的速度；\n\n\n\n## 3. 守护线程\n\n运行在后台的一种特殊进程，独立于控制终端并且周期性执行某种任务或等待处理某些发生的事情。例如java中垃圾回收的线程就是特殊的守护线程；\n\n\n\n## 4. 创建线程的方式\n\n+ 继承Thread类重写run方法；\n+ 实现Runnable接口也是执行run方法；\n+ 实现Callable接口；\n\n已继承别的类的情况下想要实现多线程，只能使用接口实现；Runnable没有返回值，Callable可以拿到返回值。因此Callable可以看做是Runnable的补充；\n\n\n\n## 5. 线程有哪些状态\n\n+ NEW 尚未启动\n+ RUNNABLE 正在执行中\n+ BLOCKED 阻塞（被同步锁或者IO锁阻塞）\n+ WAITING 永久等待状态\n+ TIME_WAITED 等待指定时间重新被唤醒\n+ TERMINATED 执行完成\n\n\n\n## 6. 线程的生命周期\n\n![image-20220224190305461](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220224190305461.png)\n\n\n\n## 7. sleep()和wait()的区别\n\n+ 类不同：sleep()来自Thread，wait()来自Object\n+ 释放锁：sleep()不释放锁，wait()释放锁；\n+ 用法不同：sleep()时间到会自动恢复，wait()可以使用notify() / notifyAll()直接唤醒\n\n\n\n## 8. notify() / notifyAll()的区别\n\n+ notifyAll()会唤醒所有线程，notify()之后只会唤醒一个线程；\n+ notifyAll()调用后，会将全部线程由等待转移到锁池，然后参与锁竞争，竞争成功后继续执行；不成功则留在锁池等待锁释放后再次参与竞争；\n+ notify()只会唤醒一个线程，具体唤醒哪一个有虚拟机控制；\n\n\n\n## 9. run()和start()的区别\n\nstart()适用于启动线程，run()方法用于执行线程的运行时代码，run()可以重复调用，start()只调用一次；\n\n\n\n## 10. 创建线程池的方式\n\n+ newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；\n+ newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；\n+ newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；\n+ newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；\n+ newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；\n+ newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；\n+ ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。\n\n```java\n// 以其中一个为例子，后面相同\nExecutorService threadPool = Executors.newFixedThreadPool(5);\n```\n\n\n\n## 11. 线程池的状态\n\n+ RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。\n+ SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。\n+ STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。\n+ TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。\n+ TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n\n\n\n## 12. 线程池中submit()和execute()的方法区别\n\n+ execute()：只能执行 Runnable 类型的任务。\n+ submit()：可以执行 Runnable 和 Callable 类型的任务。\n\nCallable类型的任务可以获取执行的返回结果，而Runnable执行无返回值；\n\n\n\n## 13. Java如何保证多线程运行安全\n\n+ 使用安全类，比如java.util.concurrent下的类；\n+ 使用自动锁synchronized；\n+ 使用手动锁lock;\n\n```java\nLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    System.out.println(\"获得锁\");\n} catch (Exception e) {\n    //todo: handle exception\n} finally {\n    System.out.println(\"释放锁\");\n    lock.unlock();\n}\n```\n\n\n\n## 14. 多线程中synchronized锁升级原理是什么\n\n在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。\n\n锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。\n\n\n\n## 15. 死锁\n\n### 什么是死锁\n\n当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。\n\n### 如何防范死锁\n\n+ 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。\n+ 尽量使用 java.util.concurrent 并发类代替自己手写锁。\n+ 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。\n+ 尽量减少同步的代码块。\n\n#### \n\n## 16. ThreadLocal是什么，有哪些应用场景\n\n为每个使用该变量的线程提供独立的变量副本，每个线程都可以独立改变自己的副本，并且不会影响其他线程对应的副本；\n\n\n\n## 17. 说一下atomic原理\n\n利用CAS（Compare And Swap）、volatile和native方法保证原子操作，从而避免synchronized的高开销，执行效率大大提升；\n\n\n\n# 18. 讲讲进程、线程和协程的区别\n\n## 进程\n\n进程是具有一定独立功能的程序在一个数据集上的一次动态执行过程，是操作系统分配和调度的独立单位。也是应用程序的载体。\n\n进程一般由程序、数据集和进程控制块三部分组成。\n\n+ 程序用于描述进程需要完成的功能；\n+ 数据集是程序在执行过程中所需要的数据和工作区；\n+ 程序控制块包括进程的描述信息和控制信息，是进程存在的唯一标识；\n\n进程具有下列特征：\n\n+ 动态性：进程是程序的一次执行过程，是临时的、有生命周期的、动态产生/消亡的；\n+ 并发性：任何进程都可以同其他进程一起并发执行；\n+ 独立性：进程是系统进行数据分配和调度的一个独立单位；\n+ 结构性：进程由程序、数据和进程控制块三部分组成；\n\n\n\n## 线程\n\n线程是程序执行中的一个单一顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以拥有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。\n\n\n\n## 进程和线程的区别\n\n+ 线程是程序执行的最小单位，进程是操作系统分配资源的最小单位；\n+ 一个进程由一个或多个线程组成，线程是一个进程代码的不同执行路线；\n+ 进程之间相互独立，同一个进程下的各个线程之间共享程序的内存空间；\n+ 调度和切换：线程的上下文切换要比进程的上下文切换快得多；\n\n![image-20220302152529598](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302152529598.png)\n\n\n\n## 协程\n\n一种基于线程之上但又比线程更加轻量级的存在，这种由程序自己写程序来管理的轻量级线程叫做“用户空间线程”\n","source":"_posts/java-core/java-thread-summary.md","raw":"---\ntitle: Java多线程面试汇总\ndate: 2022-02-24 18:35:13\nupdated: 2022-02-24 18:35:13\ntags: Java\ncategories: 面试盘点\n---\n\n# 三、多线程\n\n## 1. 并行和并发的区别\n\n+ 并行：多个处理器或多核处理器同时处理多个任务；\n+ 并发：多个任务在一个CPU按细分的时间片轮流（交替）执行，从逻辑上来看是同时执行；\n\n\n\n## 2. 线程与进程的区别\n\n一个程序至少有一个进程，一个进程至少有一个线程，一个进程下可以有多个线程来增加执行程序的速度；\n\n\n\n## 3. 守护线程\n\n运行在后台的一种特殊进程，独立于控制终端并且周期性执行某种任务或等待处理某些发生的事情。例如java中垃圾回收的线程就是特殊的守护线程；\n\n\n\n## 4. 创建线程的方式\n\n+ 继承Thread类重写run方法；\n+ 实现Runnable接口也是执行run方法；\n+ 实现Callable接口；\n\n已继承别的类的情况下想要实现多线程，只能使用接口实现；Runnable没有返回值，Callable可以拿到返回值。因此Callable可以看做是Runnable的补充；\n\n\n\n## 5. 线程有哪些状态\n\n+ NEW 尚未启动\n+ RUNNABLE 正在执行中\n+ BLOCKED 阻塞（被同步锁或者IO锁阻塞）\n+ WAITING 永久等待状态\n+ TIME_WAITED 等待指定时间重新被唤醒\n+ TERMINATED 执行完成\n\n\n\n## 6. 线程的生命周期\n\n![image-20220224190305461](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220224190305461.png)\n\n\n\n## 7. sleep()和wait()的区别\n\n+ 类不同：sleep()来自Thread，wait()来自Object\n+ 释放锁：sleep()不释放锁，wait()释放锁；\n+ 用法不同：sleep()时间到会自动恢复，wait()可以使用notify() / notifyAll()直接唤醒\n\n\n\n## 8. notify() / notifyAll()的区别\n\n+ notifyAll()会唤醒所有线程，notify()之后只会唤醒一个线程；\n+ notifyAll()调用后，会将全部线程由等待转移到锁池，然后参与锁竞争，竞争成功后继续执行；不成功则留在锁池等待锁释放后再次参与竞争；\n+ notify()只会唤醒一个线程，具体唤醒哪一个有虚拟机控制；\n\n\n\n## 9. run()和start()的区别\n\nstart()适用于启动线程，run()方法用于执行线程的运行时代码，run()可以重复调用，start()只调用一次；\n\n\n\n## 10. 创建线程池的方式\n\n+ newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；\n+ newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；\n+ newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；\n+ newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；\n+ newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；\n+ newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；\n+ ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。\n\n```java\n// 以其中一个为例子，后面相同\nExecutorService threadPool = Executors.newFixedThreadPool(5);\n```\n\n\n\n## 11. 线程池的状态\n\n+ RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。\n+ SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。\n+ STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。\n+ TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。\n+ TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n\n\n\n## 12. 线程池中submit()和execute()的方法区别\n\n+ execute()：只能执行 Runnable 类型的任务。\n+ submit()：可以执行 Runnable 和 Callable 类型的任务。\n\nCallable类型的任务可以获取执行的返回结果，而Runnable执行无返回值；\n\n\n\n## 13. Java如何保证多线程运行安全\n\n+ 使用安全类，比如java.util.concurrent下的类；\n+ 使用自动锁synchronized；\n+ 使用手动锁lock;\n\n```java\nLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    System.out.println(\"获得锁\");\n} catch (Exception e) {\n    //todo: handle exception\n} finally {\n    System.out.println(\"释放锁\");\n    lock.unlock();\n}\n```\n\n\n\n## 14. 多线程中synchronized锁升级原理是什么\n\n在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。\n\n锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。\n\n\n\n## 15. 死锁\n\n### 什么是死锁\n\n当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。\n\n### 如何防范死锁\n\n+ 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。\n+ 尽量使用 java.util.concurrent 并发类代替自己手写锁。\n+ 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。\n+ 尽量减少同步的代码块。\n\n#### \n\n## 16. ThreadLocal是什么，有哪些应用场景\n\n为每个使用该变量的线程提供独立的变量副本，每个线程都可以独立改变自己的副本，并且不会影响其他线程对应的副本；\n\n\n\n## 17. 说一下atomic原理\n\n利用CAS（Compare And Swap）、volatile和native方法保证原子操作，从而避免synchronized的高开销，执行效率大大提升；\n\n\n\n# 18. 讲讲进程、线程和协程的区别\n\n## 进程\n\n进程是具有一定独立功能的程序在一个数据集上的一次动态执行过程，是操作系统分配和调度的独立单位。也是应用程序的载体。\n\n进程一般由程序、数据集和进程控制块三部分组成。\n\n+ 程序用于描述进程需要完成的功能；\n+ 数据集是程序在执行过程中所需要的数据和工作区；\n+ 程序控制块包括进程的描述信息和控制信息，是进程存在的唯一标识；\n\n进程具有下列特征：\n\n+ 动态性：进程是程序的一次执行过程，是临时的、有生命周期的、动态产生/消亡的；\n+ 并发性：任何进程都可以同其他进程一起并发执行；\n+ 独立性：进程是系统进行数据分配和调度的一个独立单位；\n+ 结构性：进程由程序、数据和进程控制块三部分组成；\n\n\n\n## 线程\n\n线程是程序执行中的一个单一顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以拥有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。\n\n\n\n## 进程和线程的区别\n\n+ 线程是程序执行的最小单位，进程是操作系统分配资源的最小单位；\n+ 一个进程由一个或多个线程组成，线程是一个进程代码的不同执行路线；\n+ 进程之间相互独立，同一个进程下的各个线程之间共享程序的内存空间；\n+ 调度和切换：线程的上下文切换要比进程的上下文切换快得多；\n\n![image-20220302152529598](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302152529598.png)\n\n\n\n## 协程\n\n一种基于线程之上但又比线程更加轻量级的存在，这种由程序自己写程序来管理的轻量级线程叫做“用户空间线程”\n","slug":"java-core/java-thread-summary","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v5000k4f615s6c2ib8","content":"<h1 id=\"三、多线程\"><a href=\"#三、多线程\" class=\"headerlink\" title=\"三、多线程\"></a>三、多线程</h1><h2 id=\"1-并行和并发的区别\"><a href=\"#1-并行和并发的区别\" class=\"headerlink\" title=\"1. 并行和并发的区别\"></a>1. 并行和并发的区别</h2><ul>\n<li>并行：多个处理器或多核处理器同时处理多个任务；</li>\n<li>并发：多个任务在一个CPU按细分的时间片轮流（交替）执行，从逻辑上来看是同时执行；</li>\n</ul>\n<h2 id=\"2-线程与进程的区别\"><a href=\"#2-线程与进程的区别\" class=\"headerlink\" title=\"2. 线程与进程的区别\"></a>2. 线程与进程的区别</h2><p>一个程序至少有一个进程，一个进程至少有一个线程，一个进程下可以有多个线程来增加执行程序的速度；</p>\n<h2 id=\"3-守护线程\"><a href=\"#3-守护线程\" class=\"headerlink\" title=\"3. 守护线程\"></a>3. 守护线程</h2><p>运行在后台的一种特殊进程，独立于控制终端并且周期性执行某种任务或等待处理某些发生的事情。例如java中垃圾回收的线程就是特殊的守护线程；</p>\n<h2 id=\"4-创建线程的方式\"><a href=\"#4-创建线程的方式\" class=\"headerlink\" title=\"4. 创建线程的方式\"></a>4. 创建线程的方式</h2><ul>\n<li>继承Thread类重写run方法；</li>\n<li>实现Runnable接口也是执行run方法；</li>\n<li>实现Callable接口；</li>\n</ul>\n<p>已继承别的类的情况下想要实现多线程，只能使用接口实现；Runnable没有返回值，Callable可以拿到返回值。因此Callable可以看做是Runnable的补充；</p>\n<h2 id=\"5-线程有哪些状态\"><a href=\"#5-线程有哪些状态\" class=\"headerlink\" title=\"5. 线程有哪些状态\"></a>5. 线程有哪些状态</h2><ul>\n<li>NEW 尚未启动</li>\n<li>RUNNABLE 正在执行中</li>\n<li>BLOCKED 阻塞（被同步锁或者IO锁阻塞）</li>\n<li>WAITING 永久等待状态</li>\n<li>TIME_WAITED 等待指定时间重新被唤醒</li>\n<li>TERMINATED 执行完成</li>\n</ul>\n<h2 id=\"6-线程的生命周期\"><a href=\"#6-线程的生命周期\" class=\"headerlink\" title=\"6. 线程的生命周期\"></a>6. 线程的生命周期</h2><p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220224190305461.png\" alt=\"image-20220224190305461\"></p>\n<h2 id=\"7-sleep-和wait-的区别\"><a href=\"#7-sleep-和wait-的区别\" class=\"headerlink\" title=\"7. sleep()和wait()的区别\"></a>7. sleep()和wait()的区别</h2><ul>\n<li>类不同：sleep()来自Thread，wait()来自Object</li>\n<li>释放锁：sleep()不释放锁，wait()释放锁；</li>\n<li>用法不同：sleep()时间到会自动恢复，wait()可以使用notify() / notifyAll()直接唤醒</li>\n</ul>\n<h2 id=\"8-notify-notifyAll-的区别\"><a href=\"#8-notify-notifyAll-的区别\" class=\"headerlink\" title=\"8. notify() / notifyAll()的区别\"></a>8. notify() / notifyAll()的区别</h2><ul>\n<li>notifyAll()会唤醒所有线程，notify()之后只会唤醒一个线程；</li>\n<li>notifyAll()调用后，会将全部线程由等待转移到锁池，然后参与锁竞争，竞争成功后继续执行；不成功则留在锁池等待锁释放后再次参与竞争；</li>\n<li>notify()只会唤醒一个线程，具体唤醒哪一个有虚拟机控制；</li>\n</ul>\n<h2 id=\"9-run-和start-的区别\"><a href=\"#9-run-和start-的区别\" class=\"headerlink\" title=\"9. run()和start()的区别\"></a>9. run()和start()的区别</h2><p>start()适用于启动线程，run()方法用于执行线程的运行时代码，run()可以重复调用，start()只调用一次；</p>\n<h2 id=\"10-创建线程池的方式\"><a href=\"#10-创建线程池的方式\" class=\"headerlink\" title=\"10. 创建线程池的方式\"></a>10. 创建线程池的方式</h2><ul>\n<li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>\n<li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>\n<li>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li>\n<li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li>\n<li>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li>\n<li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>\n<li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 以其中一个为例子，后面相同</span><br><span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">threadPool</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">5</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"11-线程池的状态\"><a href=\"#11-线程池的状态\" class=\"headerlink\" title=\"11. 线程池的状态\"></a>11. 线程池的状态</h2><ul>\n<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>\n<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>\n<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>\n<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li>\n<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>\n</ul>\n<h2 id=\"12-线程池中submit-和execute-的方法区别\"><a href=\"#12-线程池中submit-和execute-的方法区别\" class=\"headerlink\" title=\"12. 线程池中submit()和execute()的方法区别\"></a>12. 线程池中submit()和execute()的方法区别</h2><ul>\n<li>execute()：只能执行 Runnable 类型的任务。</li>\n<li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li>\n</ul>\n<p>Callable类型的任务可以获取执行的返回结果，而Runnable执行无返回值；</p>\n<h2 id=\"13-Java如何保证多线程运行安全\"><a href=\"#13-Java如何保证多线程运行安全\" class=\"headerlink\" title=\"13. Java如何保证多线程运行安全\"></a>13. Java如何保证多线程运行安全</h2><ul>\n<li>使用安全类，比如java.util.concurrent下的类；</li>\n<li>使用自动锁synchronized；</li>\n<li>使用手动锁lock;</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReentrantLock</span>();<br>lock.lock();<br><span class=\"hljs-keyword\">try</span> &#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;获得锁&quot;</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>    <span class=\"hljs-comment\">//todo: handle exception</span><br>&#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;释放锁&quot;</span>);<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"14-多线程中synchronized锁升级原理是什么\"><a href=\"#14-多线程中synchronized锁升级原理是什么\" class=\"headerlink\" title=\"14. 多线程中synchronized锁升级原理是什么\"></a>14. 多线程中synchronized锁升级原理是什么</h2><p>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>\n<p>锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>\n<h2 id=\"15-死锁\"><a href=\"#15-死锁\" class=\"headerlink\" title=\"15. 死锁\"></a>15. 死锁</h2><h3 id=\"什么是死锁\"><a href=\"#什么是死锁\" class=\"headerlink\" title=\"什么是死锁\"></a>什么是死锁</h3><p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>\n<h3 id=\"如何防范死锁\"><a href=\"#如何防范死锁\" class=\"headerlink\" title=\"如何防范死锁\"></a>如何防范死锁</h3><ul>\n<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>\n<li>尽量使用 java.util.concurrent 并发类代替自己手写锁。</li>\n<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>\n<li>尽量减少同步的代码块。</li>\n</ul>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h4><h2 id=\"16-ThreadLocal是什么，有哪些应用场景\"><a href=\"#16-ThreadLocal是什么，有哪些应用场景\" class=\"headerlink\" title=\"16. ThreadLocal是什么，有哪些应用场景\"></a>16. ThreadLocal是什么，有哪些应用场景</h2><p>为每个使用该变量的线程提供独立的变量副本，每个线程都可以独立改变自己的副本，并且不会影响其他线程对应的副本；</p>\n<h2 id=\"17-说一下atomic原理\"><a href=\"#17-说一下atomic原理\" class=\"headerlink\" title=\"17. 说一下atomic原理\"></a>17. 说一下atomic原理</h2><p>利用CAS（Compare And Swap）、volatile和native方法保证原子操作，从而避免synchronized的高开销，执行效率大大提升；</p>\n<h1 id=\"18-讲讲进程、线程和协程的区别\"><a href=\"#18-讲讲进程、线程和协程的区别\" class=\"headerlink\" title=\"18. 讲讲进程、线程和协程的区别\"></a>18. 讲讲进程、线程和协程的区别</h1><h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>进程是具有一定独立功能的程序在一个数据集上的一次动态执行过程，是操作系统分配和调度的独立单位。也是应用程序的载体。</p>\n<p>进程一般由程序、数据集和进程控制块三部分组成。</p>\n<ul>\n<li>程序用于描述进程需要完成的功能；</li>\n<li>数据集是程序在执行过程中所需要的数据和工作区；</li>\n<li>程序控制块包括进程的描述信息和控制信息，是进程存在的唯一标识；</li>\n</ul>\n<p>进程具有下列特征：</p>\n<ul>\n<li>动态性：进程是程序的一次执行过程，是临时的、有生命周期的、动态产生/消亡的；</li>\n<li>并发性：任何进程都可以同其他进程一起并发执行；</li>\n<li>独立性：进程是系统进行数据分配和调度的一个独立单位；</li>\n<li>结构性：进程由程序、数据和进程控制块三部分组成；</li>\n</ul>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是程序执行中的一个单一顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以拥有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。</p>\n<h2 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h2><ul>\n<li>线程是程序执行的最小单位，进程是操作系统分配资源的最小单位；</li>\n<li>一个进程由一个或多个线程组成，线程是一个进程代码的不同执行路线；</li>\n<li>进程之间相互独立，同一个进程下的各个线程之间共享程序的内存空间；</li>\n<li>调度和切换：线程的上下文切换要比进程的上下文切换快得多；</li>\n</ul>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302152529598.png\" alt=\"image-20220302152529598\"></p>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><p>一种基于线程之上但又比线程更加轻量级的存在，这种由程序自己写程序来管理的轻量级线程叫做“用户空间线程”</p>\n","site":{"data":{}},"wordcount":3794,"excerpt":"","more":"<h1 id=\"三、多线程\"><a href=\"#三、多线程\" class=\"headerlink\" title=\"三、多线程\"></a>三、多线程</h1><h2 id=\"1-并行和并发的区别\"><a href=\"#1-并行和并发的区别\" class=\"headerlink\" title=\"1. 并行和并发的区别\"></a>1. 并行和并发的区别</h2><ul>\n<li>并行：多个处理器或多核处理器同时处理多个任务；</li>\n<li>并发：多个任务在一个CPU按细分的时间片轮流（交替）执行，从逻辑上来看是同时执行；</li>\n</ul>\n<h2 id=\"2-线程与进程的区别\"><a href=\"#2-线程与进程的区别\" class=\"headerlink\" title=\"2. 线程与进程的区别\"></a>2. 线程与进程的区别</h2><p>一个程序至少有一个进程，一个进程至少有一个线程，一个进程下可以有多个线程来增加执行程序的速度；</p>\n<h2 id=\"3-守护线程\"><a href=\"#3-守护线程\" class=\"headerlink\" title=\"3. 守护线程\"></a>3. 守护线程</h2><p>运行在后台的一种特殊进程，独立于控制终端并且周期性执行某种任务或等待处理某些发生的事情。例如java中垃圾回收的线程就是特殊的守护线程；</p>\n<h2 id=\"4-创建线程的方式\"><a href=\"#4-创建线程的方式\" class=\"headerlink\" title=\"4. 创建线程的方式\"></a>4. 创建线程的方式</h2><ul>\n<li>继承Thread类重写run方法；</li>\n<li>实现Runnable接口也是执行run方法；</li>\n<li>实现Callable接口；</li>\n</ul>\n<p>已继承别的类的情况下想要实现多线程，只能使用接口实现；Runnable没有返回值，Callable可以拿到返回值。因此Callable可以看做是Runnable的补充；</p>\n<h2 id=\"5-线程有哪些状态\"><a href=\"#5-线程有哪些状态\" class=\"headerlink\" title=\"5. 线程有哪些状态\"></a>5. 线程有哪些状态</h2><ul>\n<li>NEW 尚未启动</li>\n<li>RUNNABLE 正在执行中</li>\n<li>BLOCKED 阻塞（被同步锁或者IO锁阻塞）</li>\n<li>WAITING 永久等待状态</li>\n<li>TIME_WAITED 等待指定时间重新被唤醒</li>\n<li>TERMINATED 执行完成</li>\n</ul>\n<h2 id=\"6-线程的生命周期\"><a href=\"#6-线程的生命周期\" class=\"headerlink\" title=\"6. 线程的生命周期\"></a>6. 线程的生命周期</h2><p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220224190305461.png\" alt=\"image-20220224190305461\"></p>\n<h2 id=\"7-sleep-和wait-的区别\"><a href=\"#7-sleep-和wait-的区别\" class=\"headerlink\" title=\"7. sleep()和wait()的区别\"></a>7. sleep()和wait()的区别</h2><ul>\n<li>类不同：sleep()来自Thread，wait()来自Object</li>\n<li>释放锁：sleep()不释放锁，wait()释放锁；</li>\n<li>用法不同：sleep()时间到会自动恢复，wait()可以使用notify() / notifyAll()直接唤醒</li>\n</ul>\n<h2 id=\"8-notify-notifyAll-的区别\"><a href=\"#8-notify-notifyAll-的区别\" class=\"headerlink\" title=\"8. notify() / notifyAll()的区别\"></a>8. notify() / notifyAll()的区别</h2><ul>\n<li>notifyAll()会唤醒所有线程，notify()之后只会唤醒一个线程；</li>\n<li>notifyAll()调用后，会将全部线程由等待转移到锁池，然后参与锁竞争，竞争成功后继续执行；不成功则留在锁池等待锁释放后再次参与竞争；</li>\n<li>notify()只会唤醒一个线程，具体唤醒哪一个有虚拟机控制；</li>\n</ul>\n<h2 id=\"9-run-和start-的区别\"><a href=\"#9-run-和start-的区别\" class=\"headerlink\" title=\"9. run()和start()的区别\"></a>9. run()和start()的区别</h2><p>start()适用于启动线程，run()方法用于执行线程的运行时代码，run()可以重复调用，start()只调用一次；</p>\n<h2 id=\"10-创建线程池的方式\"><a href=\"#10-创建线程池的方式\" class=\"headerlink\" title=\"10. 创建线程池的方式\"></a>10. 创建线程池的方式</h2><ul>\n<li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>\n<li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>\n<li>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li>\n<li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li>\n<li>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li>\n<li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>\n<li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 以其中一个为例子，后面相同</span><br><span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">threadPool</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">5</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"11-线程池的状态\"><a href=\"#11-线程池的状态\" class=\"headerlink\" title=\"11. 线程池的状态\"></a>11. 线程池的状态</h2><ul>\n<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>\n<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>\n<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>\n<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li>\n<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>\n</ul>\n<h2 id=\"12-线程池中submit-和execute-的方法区别\"><a href=\"#12-线程池中submit-和execute-的方法区别\" class=\"headerlink\" title=\"12. 线程池中submit()和execute()的方法区别\"></a>12. 线程池中submit()和execute()的方法区别</h2><ul>\n<li>execute()：只能执行 Runnable 类型的任务。</li>\n<li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li>\n</ul>\n<p>Callable类型的任务可以获取执行的返回结果，而Runnable执行无返回值；</p>\n<h2 id=\"13-Java如何保证多线程运行安全\"><a href=\"#13-Java如何保证多线程运行安全\" class=\"headerlink\" title=\"13. Java如何保证多线程运行安全\"></a>13. Java如何保证多线程运行安全</h2><ul>\n<li>使用安全类，比如java.util.concurrent下的类；</li>\n<li>使用自动锁synchronized；</li>\n<li>使用手动锁lock;</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReentrantLock</span>();<br>lock.lock();<br><span class=\"hljs-keyword\">try</span> &#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;获得锁&quot;</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>    <span class=\"hljs-comment\">//todo: handle exception</span><br>&#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;释放锁&quot;</span>);<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"14-多线程中synchronized锁升级原理是什么\"><a href=\"#14-多线程中synchronized锁升级原理是什么\" class=\"headerlink\" title=\"14. 多线程中synchronized锁升级原理是什么\"></a>14. 多线程中synchronized锁升级原理是什么</h2><p>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>\n<p>锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>\n<h2 id=\"15-死锁\"><a href=\"#15-死锁\" class=\"headerlink\" title=\"15. 死锁\"></a>15. 死锁</h2><h3 id=\"什么是死锁\"><a href=\"#什么是死锁\" class=\"headerlink\" title=\"什么是死锁\"></a>什么是死锁</h3><p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>\n<h3 id=\"如何防范死锁\"><a href=\"#如何防范死锁\" class=\"headerlink\" title=\"如何防范死锁\"></a>如何防范死锁</h3><ul>\n<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>\n<li>尽量使用 java.util.concurrent 并发类代替自己手写锁。</li>\n<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>\n<li>尽量减少同步的代码块。</li>\n</ul>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h4><h2 id=\"16-ThreadLocal是什么，有哪些应用场景\"><a href=\"#16-ThreadLocal是什么，有哪些应用场景\" class=\"headerlink\" title=\"16. ThreadLocal是什么，有哪些应用场景\"></a>16. ThreadLocal是什么，有哪些应用场景</h2><p>为每个使用该变量的线程提供独立的变量副本，每个线程都可以独立改变自己的副本，并且不会影响其他线程对应的副本；</p>\n<h2 id=\"17-说一下atomic原理\"><a href=\"#17-说一下atomic原理\" class=\"headerlink\" title=\"17. 说一下atomic原理\"></a>17. 说一下atomic原理</h2><p>利用CAS（Compare And Swap）、volatile和native方法保证原子操作，从而避免synchronized的高开销，执行效率大大提升；</p>\n<h1 id=\"18-讲讲进程、线程和协程的区别\"><a href=\"#18-讲讲进程、线程和协程的区别\" class=\"headerlink\" title=\"18. 讲讲进程、线程和协程的区别\"></a>18. 讲讲进程、线程和协程的区别</h1><h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>进程是具有一定独立功能的程序在一个数据集上的一次动态执行过程，是操作系统分配和调度的独立单位。也是应用程序的载体。</p>\n<p>进程一般由程序、数据集和进程控制块三部分组成。</p>\n<ul>\n<li>程序用于描述进程需要完成的功能；</li>\n<li>数据集是程序在执行过程中所需要的数据和工作区；</li>\n<li>程序控制块包括进程的描述信息和控制信息，是进程存在的唯一标识；</li>\n</ul>\n<p>进程具有下列特征：</p>\n<ul>\n<li>动态性：进程是程序的一次执行过程，是临时的、有生命周期的、动态产生/消亡的；</li>\n<li>并发性：任何进程都可以同其他进程一起并发执行；</li>\n<li>独立性：进程是系统进行数据分配和调度的一个独立单位；</li>\n<li>结构性：进程由程序、数据和进程控制块三部分组成；</li>\n</ul>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是程序执行中的一个单一顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以拥有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。</p>\n<h2 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h2><ul>\n<li>线程是程序执行的最小单位，进程是操作系统分配资源的最小单位；</li>\n<li>一个进程由一个或多个线程组成，线程是一个进程代码的不同执行路线；</li>\n<li>进程之间相互独立，同一个进程下的各个线程之间共享程序的内存空间；</li>\n<li>调度和切换：线程的上下文切换要比进程的上下文切换快得多；</li>\n</ul>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302152529598.png\" alt=\"image-20220302152529598\"></p>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><p>一种基于线程之上但又比线程更加轻量级的存在，这种由程序自己写程序来管理的轻量级线程叫做“用户空间线程”</p>\n"},{"title":"JVM知识汇总","date":"2022-02-21T14:38:31.000Z","updated":"2022-02-21T14:38:31.000Z","_content":"\n# 1. JVM内存区域\n\n## 1.1. JVM内存组成及其作用\n\n如下图所示：\n\n![image-20220221232111788](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221232111788.png)\n\nJVM总共包含两个子系统和两个组件。分别是：\n\n+ 两个子系统：类加载器和执行引擎；\n+ 两个子组件：运行时数据区和本地接口；\n\n它们各自有不同的作用：\n\n+ 类加载器：根据给定的全限定类型装在class文件到运行数据域中的方法域中；\n+ 执行引擎：执行classes文件中的指令；\n+ 本地接口：与本地方法库交互，是其它编程语言交互的接口；\n+ 运行时数据区域：也就是常说的JVM内存；\n\n## 1.2 JVM运行机制\n\n1. Java文件源码编译成.class字节码文件，加载至类加载器中；\n2. 类加载器再将.class文件加载到JVM中；\n\n通俗来说：类加载器将类的.class文件读入内存，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构；\n\n\n\n## 1.3 JVM运行时数据\n\n+ 程序计数器：当前线程执行字节码的行号指示器，字节码解析的工作是通过改变计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能；\n+ Java虚拟机栈：存储局部变量表、操作数栈、动态链接以及方法出口等；\n+ 本地方法栈：作用与虚拟机栈一样，只是针对的是虚拟机调用Native方法服务的；\n+ Java堆：虚拟机中内存最大的一块，被所有线程共享，几乎所有对象的实例都在这里分配内存；\n+ 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据；\n\n\n\n## 1.4 深拷贝浅拷贝\n\n+ 浅拷贝：增加一个指针指向已存在的内存地址；\n+ 深拷贝：增加一个指针并且申请一个新内存，使这个增加的指针指向新的内存；\n\n> 使用深拷贝时，释放内存不会因为出现浅拷贝释放同一个内存的错误\n\n+ 浅复制：仅仅指向被复制的内存地址，如果原地址变化，浅复制出来的对象也会改变；\n+ 深复制：在计算机内存中开辟一块新的内存地址用于存放复制的对象；\n\n\n\n## 1.5 堆栈的区别\n\n### 堆 Heap\n\n1. 内存空间不连续，内存分配在**运行期**确认，大小不固定；\n2. GC有不同的算法回收（标记-清除，标记-复制，标记，压缩，分代算法）\n3. 存放的是对象（包括静态对象）的实例和数组，因此更关注数据的存储；\n4. 对于整个应用程序可见，并且共享；\n\n### 栈 Stack\n\n1. 先进后出原则，物理地址分配连续，性能快；\n2. 内存分配是在**编译期**确认，大小固定；\n3. 局部变量、操作数栈，返回结果，静态变量等；\n4. 线程私有，生命周期和线程相同；\n\n\n\n# 2. Hotspot虚拟机对象探索\n\n## 2.1 对象创建\n\n记住一点：只有clone和反序列化创建对象没调用构造函数，其他的创建对象方式都调用了构造函数。\n\n对象创建的流程如下：\n\n+ 检查常量池中是否有已经加载的类\n  + 没有：执行对应的类加载器；\n  + 有：从内存中直接加载，不需要调用对应的类加载器；\n+ 当前内存区域是否规整？\n  + 是：使用“指针碰撞”来分配内存\n  + 不是：从空闲列表中分配内存\n+ 考虑并发问题，比如CAS同步处理以及本地线程分配缓冲（TLAB）\n+ 设置对象的必要信息（元信息、哈希码）；\n+ 执行`<init>`方法，完成对象创建；\n\n## 2.2 对象内存分配\n\n对象分配内存（在堆中分配）也有两种方式：\n\n+ 指针碰撞：规整内存的前提下，将用过的内存放一边，空闲放另一边。分配时将位于中间的指针指示器向空闲的内存移动一段与对象大小同等的距离，从而完成分配工作；\n+ 空闲列表：不规整内存的前提下，需要有JVM维护一个列表记录哪些内存空间课哟就那个，这样在分配的时候可以从列表中查询到足够大的内存分配给对象；\n\n## 2.3 并发安全问题处理\n\n处理并发安全问题也有如下两个方式：\n\n+ 采用CAS（什么是CAS）+失败重试来保障更新操作的原子性；\n+ 按照线程划分在不同空间进行内存分配，即在每个线程在Java堆中预先分配一小块内存，成为TLAB。哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB才需要同步锁。借助`-XX:+/-UserTLAB`参数设定JVM是否使用TLAB；\n\n## 2.4 对象的访问定位\n\nJava需要通过JVM栈上的引用访问堆中的具体对象，对象访问直接取决于JVM虚拟机的实现。主流的方式有**句柄**和**直接指针**两种方式：\n\n+ 句柄：指向指针的指针，维护对象的指针。不直接指向对象，而是指向对象的地址（句柄不发生变化，指向固定的内存地址），再由对象的指针指向对象的真是内存地址；\n+ 指针：指向对象，代表一个对象在内存中的起始地址；\n\n### 句柄访问\n\n句柄池是Java堆中的一块内存，引用存储对象的句柄地址，句柄包含了**对象实例数据**与**对象类型数据**各自的**具体地址**信息，具体构造如下：\n\n![image-20220222115625143](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222115625143.png)\n\n优点：引用中存储的是**稳定**的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变**句柄中的实例数据指针**，而引用本身不需要修改；\n\n### 直接指针\n\n使用直接指针访问，引用中存储的是对象地址，在Java堆对象内部的布局中就必须考虑如何放置访问**类型数据**的相关信息；\n\n![image-20220222120220653](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222120220653.png)\n\n优势：速度快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的成本。HotSpot虚拟机使用的就是这种方式。\n\n\n\n# 3. 内存溢出异常\n\n## 3.1 什么是内存泄露，Java存在内存泄露\n\n内存泄露指的是不再被使用的对象或者变量一直占据在内存中，理论上说Java有GC垃圾回收机制，不再被使用的对象，会被GC自动回收，自动从内存中清除；\n\n但即便如此，Java依然存在内存泄露的情况：即**长生命周期的对象持有短声明周期对象的引用**就可能发生内存泄露，尽管短生命周期对象已经不再需要，但由于长生命周期的对象一直持有短生命周期的引用导致它不能被GC回收。这样就会产生JVM内存泄露；\n\n\n\n# 4. GC垃圾收集器\n\n## 4.1简述Java垃圾回收机制\n\n在Java中程序不需要显示释放一个对象的内存，一切都是交给JVM虚拟机完成。在JVM中存在一个垃圾回收线程为低优先级，正常情况下不会执行，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行。扫描那些没有被任何对象引用的对象，并将其添加到要回收的集合中，完成回收。\n\n\n\n## 4.2 什么是GC？为什么要GC\n\nGC是（Garbage Collection）的意思，内存处理是编程人员容易出问题的地方，忘记或错误的内存回收会导致程序或系统不稳定甚至崩溃。Java提供GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。\n\n需要注意的是：和C++不同，**Java没有提供释放已分配内存的显式操作；**\n\n\n\n## 4.3 垃圾回收的优点和原理\n\n### 原理\n\n对于GC来说，当程序员创建对象时，GC就开始监控对象的地址、大小以及使用情况。\n\n通常来说，GC采用有向图的方式记录和管理堆（Heap）中的所有对象，通过这种方式确定哪些对象是“可达的”；哪些对象是“不可达的”，当GC确定一些对象“不可达”时，GC就有责任回收这些内存空间；\n\n> 程序员可以显式调用`System.gc()`来通知GC运行，但是Java语言不能保证GC一定会执行。\n\n### 优点\n\n可以看出，垃圾回收机制有效地防止了内存泄露，可以有效地使用可使用的内存。并且作为一个单独的低级别线程运行，在不可预知的情况下对内存堆中已经死亡或者很长时间没有使用的对象进行清除和回收。\n\n### 垃圾回收的方式\n\n有下面三种回收方式：\n\n+ 复制垃圾回收\n+ 标记垃圾回收\n+ 增量垃圾回收\n\n## 4.4 Java中的引用类型\n\n+ 强引用：发生gc时不会被回收；(最经典的：去看ArrayList的clear方法)\n  + **被GC回收的时间：**从来不会被回收\n  + **用途：**对象的一般状态\n  + **生存时间：**JVM停止运行时终止\n+ 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收；\n  + **被GC回收的时间：**内存不足时\n  + **用途：**对象缓存\n  + **生存时间：**内存不足时终止\n+ 弱引用：有用但不是必须的对象，在下次GC时会被回收；\n  + **被GC回收的时间：**正常垃圾回收\n  + **用途：**对象缓存\n  + **生存时间：**垃圾回收后终止\n+ 虚引用：（幽灵引用/幻引用）：无法通过虚拟引用获得对象，用PhantomReference实现幻引用，虚引用的用途是在GC时返回一个通知；\n  + **被GC回收的时间：**正常垃圾回收时\n  + **用途：**跟踪对象的垃圾回收\n  + **生存时间：**垃圾回收后终止\n\n## 4.5 JVM对象回收\n\n### 判断对象能否被回收\n\n有两种方法：\n\n+ 引用计数器法：每个对象创建一个引用计数，有对象引用计数器+1，引用释放计数器-1，计数器为0代表没有引用。缺点就是当出现循环引用，该对象无法被回收；\n+ 可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是可以被回收的；\n\n### 对象什么时候可以被垃圾回收\n\n当对象对当前使用这个对象的应用程序变得不可触及时，这个对象就可以被回收；\n\n需要注意的是：通常垃圾回收不会发生在永久代，如果永久代满了或超过临界值会触发Full GC。因此**正确的永久代大小对避免Full GC是非常至关重要的。**\n\n\n\n## 4.6 JVM垃圾清除算法\n\n### 标记——清除算法\n\n标记无用对象，然后清除回收；\n\n**优点：**实现简单，不需要对象进行移动；\n\n**缺点：**效率不高，无法清除垃圾碎片；\n\n### 复制算法\n\n按照容量划分两个大小相等的内存区域，一块用完后将活着的对象复制到另一块上，然后再把已使用的内存空间一次性清理；\n\n**优点：**按顺序分配内存即可，实现简单，运行高效，不用考虑内存碎片；\n\n**缺点：**可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制；\n\n### 标记——整理算法\n\n标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存；\n\n**优点：**解决了标记——清理算法存在的内存碎片问题；\n\n**缺点：**仍需要进行局部对象移动，一定程度上降低了效率；\n\n### 分代算法\n\n根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代采用复制算法，老年代采用标记——整理算法；\n\n![image-20220222141359995](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222141359995.png)\n\n## 4.7 垃圾回收器的工作原理\n\n有7种作用不同分代的收集器，如下图：\n\n![image-20220222141536146](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222141536146.png)\n\n回收新生代的收集器：\n\n+ Serial\n+ ParNew\n+ Parallel Scavenge\n\n回收老年带的收集器：\n\n+ Serial Old\n+ Parallel Old\n+ CMS\n\n回收整个Java堆的收集器：G1\n\n### 关系\n\n+ **Serial（复制算法）**：新生代单线程收集器，标记和清理都是单线程，优点是简单高效；\n+ **ParNew（复制算法）**：新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；\n+ **Parallel Scavenge（复制算法）**：新生代并行收集器，高吞吐量，高效利用CPU，适合后台应用等对交互响应要求不高的场景；\n+ **Serial Old（标记——整理）**：老年代单线程收集，Serial收集器的老年代版本；\n+ **Parallel Old（标记——整理）**：老年代并行收集器，吞吐量优先；Parallel Scavenge收集器的老年代版本；\n+ **CMS（标记——清除算法）**：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间；\n+ **G1（标记——整理算法）**：Java堆并行收集器，G1收集器是JDK1.7提供的新收集器，此外G1回收的范围是整个Java堆（包括新生代、老年代），前6种收集器回收的范围仅限于新生代和老年代；\n\n### CMS垃圾回收器\n\n英文全称Concurrent Mark-Sweep简称，以牺牲吞吐量为代价获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上非常适合。在JVM参数上用`-XX:+UseConcMarkSweepGC`来指定使用CMS垃圾回收器。\n\n由于使用“标记——清除”算法来实现，因此在gc过程中容易产生大量内存碎片，当剩余内存不能满足程序运行要求，系统会出现`Concurrent Mode Failure`，临时CMS会采用Serial Old回收器进行垃圾清除，此时性能将会被降低；\n\n### 垃圾回收器的工作原理\n\n分代回收器有两个分区：新生代和老年代，新生代默认空间占比总空间的1/3，老生代的默认占比是2/3；\n\n分区如下：\n\n+ 新生代：Eden，To Survivor，From Survivor。默认占比是8:1:1，执行流程如下：\n  + 将Eden + From Survivor存活的对象放入To Survivor区；\n  + 清空Eden和From Survivor分区；\n  + 交换From Survivor 和 To Survivor分区\n\n每次在From Survivor到To Survivor移动时都存活的对象，年龄+1；当年龄达到15升级为老年代，大对象也会直接进入老年代；\n\n+ 老年代当空间占用达到某个值后就会触发Full GC，一般通过标记——整理算法执行\n\n+ 以此循环往复就构成了整个分代垃圾回收的整体执行流程；\n\n# 5. 内存分配策略\n\n## 5.1 内存分配以及回收策略\n\n自动内存管理，最终要解决的问题也是内存分配和内存回收，这里谈谈内存分配：\n\n+ 通常在Java堆上分配（随着JVM优化技术，某些场景下也在栈上分配）\n+ 分配的区域有下面两种：\n  + 未开启TLAB，在新生代的Eden区分配，少数情况直接会在老年代分配；\n  + 开启TLAB，按照线程优先在TLAB上分配；\n\n\n\n## 5.2 对象在内存区域的分配\n\n### 普世规则\n\n#### 对象优先在Eden区分配\n\n多数情况下，对象都是在新生代的Eden区分配，当Eden区没有足够的空间，虚拟机就会触发一次Minor GC。如果Minor GC后还是没有足够的空间，则**启用分配担保机制**在老年代分配；\n\n+ **Minor GC：**发生在新生代的GC，Java对象大多都是朝生夕死，所有Minor GC非常频繁，一般回收速度也非常快；\n+ **Major GC / Full GC：**发生在老年代GC，出现Major GC通常会伴随至少一次Minor GC，Major GC的速度会比Minor GC慢10倍以上（知道为什么嘛？因为老年代的GC不经常发生）\n\n#### 大对象直接进老年代\n\n大对象指的是需要大量连续内存空间的对象，频繁出现大量对象是致命的，会导致内存还有不少空间的情况下提前触发GC以获取足够的连续空间来安置新对象；\n\n由于新生代使用的是复制算法回收垃圾，假如大对象一开始就在新生代分配就会导致Eden区和两个Survivor区之间发生大量内存复制。**所以大对象直接进老年代；**\n\n\n\n#### 长期存活对象将进入老年代\n\n由于JVM采用分代收集来管理内存，那么在内存回收时必须判断哪些对象放在新生代，哪些对象放在老年代。\n\n虚拟机给每个对象定义了一个对象年龄计数器：\n\n+ 如果在Eden区出生，并且被Survivor容纳，年龄对象为1；\n+ 对象每在Survivor区逃过一次Minor GC，年龄就+1；\n+ 当年龄达到15，就会晋升到老年代；\n\n\n\n# 6. 虚拟机类加载机制\n\n## 6.1 Java类加载机制\n\n虚拟机把类的描述从Class文件加载到内存，并对数据进行校验，解析和初始化。最终形成可以被虚拟机直接使用的java类型；\n\n\n\n## 6.2 JVM加载Class文件的原理机制\n\nJava中的所有类，都需要类加载器装载到JVM中才能运行，类加载器本身也是一个类，而它的工作就是把class文件从硬盘读到内存中。写程序的时候，几乎不需要关心类加载，因为整个过程都是隐式装载的，除非有特殊用法，例如反射；\n\n\n\n## 6.3 类加载器过程\n\n### 类装载的方式\n\n有下面两种：\n\n+ 隐式装载：程序在运行过程中碰到new等方式生成的对象，隐式调用类装载器加载对应的类到jvm中；\n+ 显式装载：借助`Class.forName()`等方法显式加载需要的类；\n\nJava类的加载是动态的，为了节省内存开销，除了将程序运行的基础类完全加载到jvm中，剩下的其他类则在需要的时候再加载；\n\n### 类加载器\n\n定义：实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器；\n\n主要有以下4种类加载器：\n\n+ 启动类加载器（Bootstrap ClassLoader）：用来加载Java核心类库，无法被Java程序直接引用；\n+ 扩展类加载器（Extensions ClassLoader）：用来加载Java扩展库，Java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载Java类；\n+ 系统类加载器（System ClassLoader）：一般来说，Java应用的类都是由它完成加载的。可以通过`ClassLoader.getSystemClassLoader()`来获取；\n+ 用户自定义类加载器，通过继承`java.lang.ClassLoader`类实现；\n\n### 类装载的执行过程\n\n1. **加载：**根据查找路径找到对应的class文件然后导入；\n2. **验证：**检查加载的class文件的正确性；\n3. **准备：**给类中的静态变量分配内存空间；\n4. **解析：**虚拟机将常量池中的符号引用替换成直接引用。符号引用就理解为一个标识，而在直接引用中指向内存中的地址；\n5. **初始化：**对静态变量和静态代码块执行初始化工作；\n\n\n\n## 6.4 双亲委派模型\n\n对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间，类加载器就是根据指定全限定名称将class文件加载到JVM内存，然后再转化为class对象。\n\n![image-20220222181549279](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222181549279.png)\n\n+ 启动类加载器（Bootstrap ClassLoader）：虚拟机自身的一部分，用来加载JAVA_HOME/lib目录中的，或者被`-Xbootclasspath`参数指定的路径并且被虚拟机识别的类库；\n+ 扩展类加载器（Extension ClassLoader）：负责加载/lib/ext/目录或者Java.ext.dirs系统变量指定的路径中的所有类库；\n+ 应用程序类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认使用的就是这个加载器；\n\n### 什么是双亲委派模型\n\n如果一个类加载器收到类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载器无法完成加载请求，子加载器才会尝试去加载类；\n\n\n\n# 7. JVM调优\n\n## 7.1 JVM调优工具\n\nJVM调优常用的是下面这两个工具：\n\n+ jconsole：用于对JVM中的内存、线程和类进行监控；\n+ jvisualvm：JDK自带分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存变化以及gc变化；\n\n\n\n## 7.2 JVM调优参数\n\n常用的JVM调优参数如下：\n\n+ -Xms2g：初始化堆大小为2g\n+ -Xmx2g：堆最大内存为2g\n+ -XX:NewRatio=4：设置年轻代和老年代的内存比例为1:4\n+ -XX:SurvivorRatio=8：设置新生代Eden和Survivor比例为8:2\n+ -XX:+UseParNewGC：指定使用ParNew + Serial Old垃圾回收器组合\n+ -XX:+UseParallelOldGC：指定使用ParNew + ParNew Old垃圾回收器组合\n+ -XX:+UseConcMarkSweepGC：指定使用CMS + Serial Old垃圾回收器组合\n+ -XX:+PrintGC：开启打印gc信息\n+ -XX:+PrintGCDetails：打印gc详细信息；\n","source":"_posts/jvm/jvm-learning.md","raw":"---\ntitle: JVM知识汇总\ndate: 2022-02-21 22:38:31\nupdated: 2022-02-21 22:38:31\ntags: JVM\ncategories: Java\n---\n\n# 1. JVM内存区域\n\n## 1.1. JVM内存组成及其作用\n\n如下图所示：\n\n![image-20220221232111788](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221232111788.png)\n\nJVM总共包含两个子系统和两个组件。分别是：\n\n+ 两个子系统：类加载器和执行引擎；\n+ 两个子组件：运行时数据区和本地接口；\n\n它们各自有不同的作用：\n\n+ 类加载器：根据给定的全限定类型装在class文件到运行数据域中的方法域中；\n+ 执行引擎：执行classes文件中的指令；\n+ 本地接口：与本地方法库交互，是其它编程语言交互的接口；\n+ 运行时数据区域：也就是常说的JVM内存；\n\n## 1.2 JVM运行机制\n\n1. Java文件源码编译成.class字节码文件，加载至类加载器中；\n2. 类加载器再将.class文件加载到JVM中；\n\n通俗来说：类加载器将类的.class文件读入内存，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构；\n\n\n\n## 1.3 JVM运行时数据\n\n+ 程序计数器：当前线程执行字节码的行号指示器，字节码解析的工作是通过改变计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能；\n+ Java虚拟机栈：存储局部变量表、操作数栈、动态链接以及方法出口等；\n+ 本地方法栈：作用与虚拟机栈一样，只是针对的是虚拟机调用Native方法服务的；\n+ Java堆：虚拟机中内存最大的一块，被所有线程共享，几乎所有对象的实例都在这里分配内存；\n+ 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据；\n\n\n\n## 1.4 深拷贝浅拷贝\n\n+ 浅拷贝：增加一个指针指向已存在的内存地址；\n+ 深拷贝：增加一个指针并且申请一个新内存，使这个增加的指针指向新的内存；\n\n> 使用深拷贝时，释放内存不会因为出现浅拷贝释放同一个内存的错误\n\n+ 浅复制：仅仅指向被复制的内存地址，如果原地址变化，浅复制出来的对象也会改变；\n+ 深复制：在计算机内存中开辟一块新的内存地址用于存放复制的对象；\n\n\n\n## 1.5 堆栈的区别\n\n### 堆 Heap\n\n1. 内存空间不连续，内存分配在**运行期**确认，大小不固定；\n2. GC有不同的算法回收（标记-清除，标记-复制，标记，压缩，分代算法）\n3. 存放的是对象（包括静态对象）的实例和数组，因此更关注数据的存储；\n4. 对于整个应用程序可见，并且共享；\n\n### 栈 Stack\n\n1. 先进后出原则，物理地址分配连续，性能快；\n2. 内存分配是在**编译期**确认，大小固定；\n3. 局部变量、操作数栈，返回结果，静态变量等；\n4. 线程私有，生命周期和线程相同；\n\n\n\n# 2. Hotspot虚拟机对象探索\n\n## 2.1 对象创建\n\n记住一点：只有clone和反序列化创建对象没调用构造函数，其他的创建对象方式都调用了构造函数。\n\n对象创建的流程如下：\n\n+ 检查常量池中是否有已经加载的类\n  + 没有：执行对应的类加载器；\n  + 有：从内存中直接加载，不需要调用对应的类加载器；\n+ 当前内存区域是否规整？\n  + 是：使用“指针碰撞”来分配内存\n  + 不是：从空闲列表中分配内存\n+ 考虑并发问题，比如CAS同步处理以及本地线程分配缓冲（TLAB）\n+ 设置对象的必要信息（元信息、哈希码）；\n+ 执行`<init>`方法，完成对象创建；\n\n## 2.2 对象内存分配\n\n对象分配内存（在堆中分配）也有两种方式：\n\n+ 指针碰撞：规整内存的前提下，将用过的内存放一边，空闲放另一边。分配时将位于中间的指针指示器向空闲的内存移动一段与对象大小同等的距离，从而完成分配工作；\n+ 空闲列表：不规整内存的前提下，需要有JVM维护一个列表记录哪些内存空间课哟就那个，这样在分配的时候可以从列表中查询到足够大的内存分配给对象；\n\n## 2.3 并发安全问题处理\n\n处理并发安全问题也有如下两个方式：\n\n+ 采用CAS（什么是CAS）+失败重试来保障更新操作的原子性；\n+ 按照线程划分在不同空间进行内存分配，即在每个线程在Java堆中预先分配一小块内存，成为TLAB。哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB才需要同步锁。借助`-XX:+/-UserTLAB`参数设定JVM是否使用TLAB；\n\n## 2.4 对象的访问定位\n\nJava需要通过JVM栈上的引用访问堆中的具体对象，对象访问直接取决于JVM虚拟机的实现。主流的方式有**句柄**和**直接指针**两种方式：\n\n+ 句柄：指向指针的指针，维护对象的指针。不直接指向对象，而是指向对象的地址（句柄不发生变化，指向固定的内存地址），再由对象的指针指向对象的真是内存地址；\n+ 指针：指向对象，代表一个对象在内存中的起始地址；\n\n### 句柄访问\n\n句柄池是Java堆中的一块内存，引用存储对象的句柄地址，句柄包含了**对象实例数据**与**对象类型数据**各自的**具体地址**信息，具体构造如下：\n\n![image-20220222115625143](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222115625143.png)\n\n优点：引用中存储的是**稳定**的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变**句柄中的实例数据指针**，而引用本身不需要修改；\n\n### 直接指针\n\n使用直接指针访问，引用中存储的是对象地址，在Java堆对象内部的布局中就必须考虑如何放置访问**类型数据**的相关信息；\n\n![image-20220222120220653](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222120220653.png)\n\n优势：速度快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的成本。HotSpot虚拟机使用的就是这种方式。\n\n\n\n# 3. 内存溢出异常\n\n## 3.1 什么是内存泄露，Java存在内存泄露\n\n内存泄露指的是不再被使用的对象或者变量一直占据在内存中，理论上说Java有GC垃圾回收机制，不再被使用的对象，会被GC自动回收，自动从内存中清除；\n\n但即便如此，Java依然存在内存泄露的情况：即**长生命周期的对象持有短声明周期对象的引用**就可能发生内存泄露，尽管短生命周期对象已经不再需要，但由于长生命周期的对象一直持有短生命周期的引用导致它不能被GC回收。这样就会产生JVM内存泄露；\n\n\n\n# 4. GC垃圾收集器\n\n## 4.1简述Java垃圾回收机制\n\n在Java中程序不需要显示释放一个对象的内存，一切都是交给JVM虚拟机完成。在JVM中存在一个垃圾回收线程为低优先级，正常情况下不会执行，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行。扫描那些没有被任何对象引用的对象，并将其添加到要回收的集合中，完成回收。\n\n\n\n## 4.2 什么是GC？为什么要GC\n\nGC是（Garbage Collection）的意思，内存处理是编程人员容易出问题的地方，忘记或错误的内存回收会导致程序或系统不稳定甚至崩溃。Java提供GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。\n\n需要注意的是：和C++不同，**Java没有提供释放已分配内存的显式操作；**\n\n\n\n## 4.3 垃圾回收的优点和原理\n\n### 原理\n\n对于GC来说，当程序员创建对象时，GC就开始监控对象的地址、大小以及使用情况。\n\n通常来说，GC采用有向图的方式记录和管理堆（Heap）中的所有对象，通过这种方式确定哪些对象是“可达的”；哪些对象是“不可达的”，当GC确定一些对象“不可达”时，GC就有责任回收这些内存空间；\n\n> 程序员可以显式调用`System.gc()`来通知GC运行，但是Java语言不能保证GC一定会执行。\n\n### 优点\n\n可以看出，垃圾回收机制有效地防止了内存泄露，可以有效地使用可使用的内存。并且作为一个单独的低级别线程运行，在不可预知的情况下对内存堆中已经死亡或者很长时间没有使用的对象进行清除和回收。\n\n### 垃圾回收的方式\n\n有下面三种回收方式：\n\n+ 复制垃圾回收\n+ 标记垃圾回收\n+ 增量垃圾回收\n\n## 4.4 Java中的引用类型\n\n+ 强引用：发生gc时不会被回收；(最经典的：去看ArrayList的clear方法)\n  + **被GC回收的时间：**从来不会被回收\n  + **用途：**对象的一般状态\n  + **生存时间：**JVM停止运行时终止\n+ 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收；\n  + **被GC回收的时间：**内存不足时\n  + **用途：**对象缓存\n  + **生存时间：**内存不足时终止\n+ 弱引用：有用但不是必须的对象，在下次GC时会被回收；\n  + **被GC回收的时间：**正常垃圾回收\n  + **用途：**对象缓存\n  + **生存时间：**垃圾回收后终止\n+ 虚引用：（幽灵引用/幻引用）：无法通过虚拟引用获得对象，用PhantomReference实现幻引用，虚引用的用途是在GC时返回一个通知；\n  + **被GC回收的时间：**正常垃圾回收时\n  + **用途：**跟踪对象的垃圾回收\n  + **生存时间：**垃圾回收后终止\n\n## 4.5 JVM对象回收\n\n### 判断对象能否被回收\n\n有两种方法：\n\n+ 引用计数器法：每个对象创建一个引用计数，有对象引用计数器+1，引用释放计数器-1，计数器为0代表没有引用。缺点就是当出现循环引用，该对象无法被回收；\n+ 可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是可以被回收的；\n\n### 对象什么时候可以被垃圾回收\n\n当对象对当前使用这个对象的应用程序变得不可触及时，这个对象就可以被回收；\n\n需要注意的是：通常垃圾回收不会发生在永久代，如果永久代满了或超过临界值会触发Full GC。因此**正确的永久代大小对避免Full GC是非常至关重要的。**\n\n\n\n## 4.6 JVM垃圾清除算法\n\n### 标记——清除算法\n\n标记无用对象，然后清除回收；\n\n**优点：**实现简单，不需要对象进行移动；\n\n**缺点：**效率不高，无法清除垃圾碎片；\n\n### 复制算法\n\n按照容量划分两个大小相等的内存区域，一块用完后将活着的对象复制到另一块上，然后再把已使用的内存空间一次性清理；\n\n**优点：**按顺序分配内存即可，实现简单，运行高效，不用考虑内存碎片；\n\n**缺点：**可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制；\n\n### 标记——整理算法\n\n标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存；\n\n**优点：**解决了标记——清理算法存在的内存碎片问题；\n\n**缺点：**仍需要进行局部对象移动，一定程度上降低了效率；\n\n### 分代算法\n\n根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代采用复制算法，老年代采用标记——整理算法；\n\n![image-20220222141359995](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222141359995.png)\n\n## 4.7 垃圾回收器的工作原理\n\n有7种作用不同分代的收集器，如下图：\n\n![image-20220222141536146](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222141536146.png)\n\n回收新生代的收集器：\n\n+ Serial\n+ ParNew\n+ Parallel Scavenge\n\n回收老年带的收集器：\n\n+ Serial Old\n+ Parallel Old\n+ CMS\n\n回收整个Java堆的收集器：G1\n\n### 关系\n\n+ **Serial（复制算法）**：新生代单线程收集器，标记和清理都是单线程，优点是简单高效；\n+ **ParNew（复制算法）**：新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；\n+ **Parallel Scavenge（复制算法）**：新生代并行收集器，高吞吐量，高效利用CPU，适合后台应用等对交互响应要求不高的场景；\n+ **Serial Old（标记——整理）**：老年代单线程收集，Serial收集器的老年代版本；\n+ **Parallel Old（标记——整理）**：老年代并行收集器，吞吐量优先；Parallel Scavenge收集器的老年代版本；\n+ **CMS（标记——清除算法）**：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间；\n+ **G1（标记——整理算法）**：Java堆并行收集器，G1收集器是JDK1.7提供的新收集器，此外G1回收的范围是整个Java堆（包括新生代、老年代），前6种收集器回收的范围仅限于新生代和老年代；\n\n### CMS垃圾回收器\n\n英文全称Concurrent Mark-Sweep简称，以牺牲吞吐量为代价获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上非常适合。在JVM参数上用`-XX:+UseConcMarkSweepGC`来指定使用CMS垃圾回收器。\n\n由于使用“标记——清除”算法来实现，因此在gc过程中容易产生大量内存碎片，当剩余内存不能满足程序运行要求，系统会出现`Concurrent Mode Failure`，临时CMS会采用Serial Old回收器进行垃圾清除，此时性能将会被降低；\n\n### 垃圾回收器的工作原理\n\n分代回收器有两个分区：新生代和老年代，新生代默认空间占比总空间的1/3，老生代的默认占比是2/3；\n\n分区如下：\n\n+ 新生代：Eden，To Survivor，From Survivor。默认占比是8:1:1，执行流程如下：\n  + 将Eden + From Survivor存活的对象放入To Survivor区；\n  + 清空Eden和From Survivor分区；\n  + 交换From Survivor 和 To Survivor分区\n\n每次在From Survivor到To Survivor移动时都存活的对象，年龄+1；当年龄达到15升级为老年代，大对象也会直接进入老年代；\n\n+ 老年代当空间占用达到某个值后就会触发Full GC，一般通过标记——整理算法执行\n\n+ 以此循环往复就构成了整个分代垃圾回收的整体执行流程；\n\n# 5. 内存分配策略\n\n## 5.1 内存分配以及回收策略\n\n自动内存管理，最终要解决的问题也是内存分配和内存回收，这里谈谈内存分配：\n\n+ 通常在Java堆上分配（随着JVM优化技术，某些场景下也在栈上分配）\n+ 分配的区域有下面两种：\n  + 未开启TLAB，在新生代的Eden区分配，少数情况直接会在老年代分配；\n  + 开启TLAB，按照线程优先在TLAB上分配；\n\n\n\n## 5.2 对象在内存区域的分配\n\n### 普世规则\n\n#### 对象优先在Eden区分配\n\n多数情况下，对象都是在新生代的Eden区分配，当Eden区没有足够的空间，虚拟机就会触发一次Minor GC。如果Minor GC后还是没有足够的空间，则**启用分配担保机制**在老年代分配；\n\n+ **Minor GC：**发生在新生代的GC，Java对象大多都是朝生夕死，所有Minor GC非常频繁，一般回收速度也非常快；\n+ **Major GC / Full GC：**发生在老年代GC，出现Major GC通常会伴随至少一次Minor GC，Major GC的速度会比Minor GC慢10倍以上（知道为什么嘛？因为老年代的GC不经常发生）\n\n#### 大对象直接进老年代\n\n大对象指的是需要大量连续内存空间的对象，频繁出现大量对象是致命的，会导致内存还有不少空间的情况下提前触发GC以获取足够的连续空间来安置新对象；\n\n由于新生代使用的是复制算法回收垃圾，假如大对象一开始就在新生代分配就会导致Eden区和两个Survivor区之间发生大量内存复制。**所以大对象直接进老年代；**\n\n\n\n#### 长期存活对象将进入老年代\n\n由于JVM采用分代收集来管理内存，那么在内存回收时必须判断哪些对象放在新生代，哪些对象放在老年代。\n\n虚拟机给每个对象定义了一个对象年龄计数器：\n\n+ 如果在Eden区出生，并且被Survivor容纳，年龄对象为1；\n+ 对象每在Survivor区逃过一次Minor GC，年龄就+1；\n+ 当年龄达到15，就会晋升到老年代；\n\n\n\n# 6. 虚拟机类加载机制\n\n## 6.1 Java类加载机制\n\n虚拟机把类的描述从Class文件加载到内存，并对数据进行校验，解析和初始化。最终形成可以被虚拟机直接使用的java类型；\n\n\n\n## 6.2 JVM加载Class文件的原理机制\n\nJava中的所有类，都需要类加载器装载到JVM中才能运行，类加载器本身也是一个类，而它的工作就是把class文件从硬盘读到内存中。写程序的时候，几乎不需要关心类加载，因为整个过程都是隐式装载的，除非有特殊用法，例如反射；\n\n\n\n## 6.3 类加载器过程\n\n### 类装载的方式\n\n有下面两种：\n\n+ 隐式装载：程序在运行过程中碰到new等方式生成的对象，隐式调用类装载器加载对应的类到jvm中；\n+ 显式装载：借助`Class.forName()`等方法显式加载需要的类；\n\nJava类的加载是动态的，为了节省内存开销，除了将程序运行的基础类完全加载到jvm中，剩下的其他类则在需要的时候再加载；\n\n### 类加载器\n\n定义：实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器；\n\n主要有以下4种类加载器：\n\n+ 启动类加载器（Bootstrap ClassLoader）：用来加载Java核心类库，无法被Java程序直接引用；\n+ 扩展类加载器（Extensions ClassLoader）：用来加载Java扩展库，Java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载Java类；\n+ 系统类加载器（System ClassLoader）：一般来说，Java应用的类都是由它完成加载的。可以通过`ClassLoader.getSystemClassLoader()`来获取；\n+ 用户自定义类加载器，通过继承`java.lang.ClassLoader`类实现；\n\n### 类装载的执行过程\n\n1. **加载：**根据查找路径找到对应的class文件然后导入；\n2. **验证：**检查加载的class文件的正确性；\n3. **准备：**给类中的静态变量分配内存空间；\n4. **解析：**虚拟机将常量池中的符号引用替换成直接引用。符号引用就理解为一个标识，而在直接引用中指向内存中的地址；\n5. **初始化：**对静态变量和静态代码块执行初始化工作；\n\n\n\n## 6.4 双亲委派模型\n\n对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间，类加载器就是根据指定全限定名称将class文件加载到JVM内存，然后再转化为class对象。\n\n![image-20220222181549279](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222181549279.png)\n\n+ 启动类加载器（Bootstrap ClassLoader）：虚拟机自身的一部分，用来加载JAVA_HOME/lib目录中的，或者被`-Xbootclasspath`参数指定的路径并且被虚拟机识别的类库；\n+ 扩展类加载器（Extension ClassLoader）：负责加载/lib/ext/目录或者Java.ext.dirs系统变量指定的路径中的所有类库；\n+ 应用程序类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认使用的就是这个加载器；\n\n### 什么是双亲委派模型\n\n如果一个类加载器收到类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载器无法完成加载请求，子加载器才会尝试去加载类；\n\n\n\n# 7. JVM调优\n\n## 7.1 JVM调优工具\n\nJVM调优常用的是下面这两个工具：\n\n+ jconsole：用于对JVM中的内存、线程和类进行监控；\n+ jvisualvm：JDK自带分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存变化以及gc变化；\n\n\n\n## 7.2 JVM调优参数\n\n常用的JVM调优参数如下：\n\n+ -Xms2g：初始化堆大小为2g\n+ -Xmx2g：堆最大内存为2g\n+ -XX:NewRatio=4：设置年轻代和老年代的内存比例为1:4\n+ -XX:SurvivorRatio=8：设置新生代Eden和Survivor比例为8:2\n+ -XX:+UseParNewGC：指定使用ParNew + Serial Old垃圾回收器组合\n+ -XX:+UseParallelOldGC：指定使用ParNew + ParNew Old垃圾回收器组合\n+ -XX:+UseConcMarkSweepGC：指定使用CMS + Serial Old垃圾回收器组合\n+ -XX:+PrintGC：开启打印gc信息\n+ -XX:+PrintGCDetails：打印gc详细信息；\n","slug":"jvm/jvm-learning","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v7000p4f610ojtfle5","content":"<h1 id=\"1-JVM内存区域\"><a href=\"#1-JVM内存区域\" class=\"headerlink\" title=\"1. JVM内存区域\"></a>1. JVM内存区域</h1><h2 id=\"1-1-JVM内存组成及其作用\"><a href=\"#1-1-JVM内存组成及其作用\" class=\"headerlink\" title=\"1.1. JVM内存组成及其作用\"></a>1.1. JVM内存组成及其作用</h2><p>如下图所示：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221232111788.png\" alt=\"image-20220221232111788\"></p>\n<p>JVM总共包含两个子系统和两个组件。分别是：</p>\n<ul>\n<li>两个子系统：类加载器和执行引擎；</li>\n<li>两个子组件：运行时数据区和本地接口；</li>\n</ul>\n<p>它们各自有不同的作用：</p>\n<ul>\n<li>类加载器：根据给定的全限定类型装在class文件到运行数据域中的方法域中；</li>\n<li>执行引擎：执行classes文件中的指令；</li>\n<li>本地接口：与本地方法库交互，是其它编程语言交互的接口；</li>\n<li>运行时数据区域：也就是常说的JVM内存；</li>\n</ul>\n<h2 id=\"1-2-JVM运行机制\"><a href=\"#1-2-JVM运行机制\" class=\"headerlink\" title=\"1.2 JVM运行机制\"></a>1.2 JVM运行机制</h2><ol>\n<li>Java文件源码编译成.class字节码文件，加载至类加载器中；</li>\n<li>类加载器再将.class文件加载到JVM中；</li>\n</ol>\n<p>通俗来说：类加载器将类的.class文件读入内存，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构；</p>\n<h2 id=\"1-3-JVM运行时数据\"><a href=\"#1-3-JVM运行时数据\" class=\"headerlink\" title=\"1.3 JVM运行时数据\"></a>1.3 JVM运行时数据</h2><ul>\n<li>程序计数器：当前线程执行字节码的行号指示器，字节码解析的工作是通过改变计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能；</li>\n<li>Java虚拟机栈：存储局部变量表、操作数栈、动态链接以及方法出口等；</li>\n<li>本地方法栈：作用与虚拟机栈一样，只是针对的是虚拟机调用Native方法服务的；</li>\n<li>Java堆：虚拟机中内存最大的一块，被所有线程共享，几乎所有对象的实例都在这里分配内存；</li>\n<li>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据；</li>\n</ul>\n<h2 id=\"1-4-深拷贝浅拷贝\"><a href=\"#1-4-深拷贝浅拷贝\" class=\"headerlink\" title=\"1.4 深拷贝浅拷贝\"></a>1.4 深拷贝浅拷贝</h2><ul>\n<li>浅拷贝：增加一个指针指向已存在的内存地址；</li>\n<li>深拷贝：增加一个指针并且申请一个新内存，使这个增加的指针指向新的内存；</li>\n</ul>\n<blockquote>\n<p>使用深拷贝时，释放内存不会因为出现浅拷贝释放同一个内存的错误</p>\n</blockquote>\n<ul>\n<li>浅复制：仅仅指向被复制的内存地址，如果原地址变化，浅复制出来的对象也会改变；</li>\n<li>深复制：在计算机内存中开辟一块新的内存地址用于存放复制的对象；</li>\n</ul>\n<h2 id=\"1-5-堆栈的区别\"><a href=\"#1-5-堆栈的区别\" class=\"headerlink\" title=\"1.5 堆栈的区别\"></a>1.5 堆栈的区别</h2><h3 id=\"堆-Heap\"><a href=\"#堆-Heap\" class=\"headerlink\" title=\"堆 Heap\"></a>堆 Heap</h3><ol>\n<li>内存空间不连续，内存分配在<strong>运行期</strong>确认，大小不固定；</li>\n<li>GC有不同的算法回收（标记-清除，标记-复制，标记，压缩，分代算法）</li>\n<li>存放的是对象（包括静态对象）的实例和数组，因此更关注数据的存储；</li>\n<li>对于整个应用程序可见，并且共享；</li>\n</ol>\n<h3 id=\"栈-Stack\"><a href=\"#栈-Stack\" class=\"headerlink\" title=\"栈 Stack\"></a>栈 Stack</h3><ol>\n<li>先进后出原则，物理地址分配连续，性能快；</li>\n<li>内存分配是在<strong>编译期</strong>确认，大小固定；</li>\n<li>局部变量、操作数栈，返回结果，静态变量等；</li>\n<li>线程私有，生命周期和线程相同；</li>\n</ol>\n<h1 id=\"2-Hotspot虚拟机对象探索\"><a href=\"#2-Hotspot虚拟机对象探索\" class=\"headerlink\" title=\"2. Hotspot虚拟机对象探索\"></a>2. Hotspot虚拟机对象探索</h1><h2 id=\"2-1-对象创建\"><a href=\"#2-1-对象创建\" class=\"headerlink\" title=\"2.1 对象创建\"></a>2.1 对象创建</h2><p>记住一点：只有clone和反序列化创建对象没调用构造函数，其他的创建对象方式都调用了构造函数。</p>\n<p>对象创建的流程如下：</p>\n<ul>\n<li>检查常量池中是否有已经加载的类<ul>\n<li>没有：执行对应的类加载器；</li>\n<li>有：从内存中直接加载，不需要调用对应的类加载器；</li>\n</ul>\n</li>\n<li>当前内存区域是否规整？<ul>\n<li>是：使用“指针碰撞”来分配内存</li>\n<li>不是：从空闲列表中分配内存</li>\n</ul>\n</li>\n<li>考虑并发问题，比如CAS同步处理以及本地线程分配缓冲（TLAB）</li>\n<li>设置对象的必要信息（元信息、哈希码）；</li>\n<li>执行<code>&lt;init&gt;</code>方法，完成对象创建；</li>\n</ul>\n<h2 id=\"2-2-对象内存分配\"><a href=\"#2-2-对象内存分配\" class=\"headerlink\" title=\"2.2 对象内存分配\"></a>2.2 对象内存分配</h2><p>对象分配内存（在堆中分配）也有两种方式：</p>\n<ul>\n<li>指针碰撞：规整内存的前提下，将用过的内存放一边，空闲放另一边。分配时将位于中间的指针指示器向空闲的内存移动一段与对象大小同等的距离，从而完成分配工作；</li>\n<li>空闲列表：不规整内存的前提下，需要有JVM维护一个列表记录哪些内存空间课哟就那个，这样在分配的时候可以从列表中查询到足够大的内存分配给对象；</li>\n</ul>\n<h2 id=\"2-3-并发安全问题处理\"><a href=\"#2-3-并发安全问题处理\" class=\"headerlink\" title=\"2.3 并发安全问题处理\"></a>2.3 并发安全问题处理</h2><p>处理并发安全问题也有如下两个方式：</p>\n<ul>\n<li>采用CAS（什么是CAS）+失败重试来保障更新操作的原子性；</li>\n<li>按照线程划分在不同空间进行内存分配，即在每个线程在Java堆中预先分配一小块内存，成为TLAB。哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB才需要同步锁。借助<code>-XX:+/-UserTLAB</code>参数设定JVM是否使用TLAB；</li>\n</ul>\n<h2 id=\"2-4-对象的访问定位\"><a href=\"#2-4-对象的访问定位\" class=\"headerlink\" title=\"2.4 对象的访问定位\"></a>2.4 对象的访问定位</h2><p>Java需要通过JVM栈上的引用访问堆中的具体对象，对象访问直接取决于JVM虚拟机的实现。主流的方式有<strong>句柄</strong>和<strong>直接指针</strong>两种方式：</p>\n<ul>\n<li>句柄：指向指针的指针，维护对象的指针。不直接指向对象，而是指向对象的地址（句柄不发生变化，指向固定的内存地址），再由对象的指针指向对象的真是内存地址；</li>\n<li>指针：指向对象，代表一个对象在内存中的起始地址；</li>\n</ul>\n<h3 id=\"句柄访问\"><a href=\"#句柄访问\" class=\"headerlink\" title=\"句柄访问\"></a>句柄访问</h3><p>句柄池是Java堆中的一块内存，引用存储对象的句柄地址，句柄包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222115625143.png\" alt=\"image-20220222115625143\"></p>\n<p>优点：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中的实例数据指针</strong>，而引用本身不需要修改；</p>\n<h3 id=\"直接指针\"><a href=\"#直接指针\" class=\"headerlink\" title=\"直接指针\"></a>直接指针</h3><p>使用直接指针访问，引用中存储的是对象地址，在Java堆对象内部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息；</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222120220653.png\" alt=\"image-20220222120220653\"></p>\n<p>优势：速度快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的成本。HotSpot虚拟机使用的就是这种方式。</p>\n<h1 id=\"3-内存溢出异常\"><a href=\"#3-内存溢出异常\" class=\"headerlink\" title=\"3. 内存溢出异常\"></a>3. 内存溢出异常</h1><h2 id=\"3-1-什么是内存泄露，Java存在内存泄露\"><a href=\"#3-1-什么是内存泄露，Java存在内存泄露\" class=\"headerlink\" title=\"3.1 什么是内存泄露，Java存在内存泄露\"></a>3.1 什么是内存泄露，Java存在内存泄露</h2><p>内存泄露指的是不再被使用的对象或者变量一直占据在内存中，理论上说Java有GC垃圾回收机制，不再被使用的对象，会被GC自动回收，自动从内存中清除；</p>\n<p>但即便如此，Java依然存在内存泄露的情况：即<strong>长生命周期的对象持有短声明周期对象的引用</strong>就可能发生内存泄露，尽管短生命周期对象已经不再需要，但由于长生命周期的对象一直持有短生命周期的引用导致它不能被GC回收。这样就会产生JVM内存泄露；</p>\n<h1 id=\"4-GC垃圾收集器\"><a href=\"#4-GC垃圾收集器\" class=\"headerlink\" title=\"4. GC垃圾收集器\"></a>4. GC垃圾收集器</h1><h2 id=\"4-1简述Java垃圾回收机制\"><a href=\"#4-1简述Java垃圾回收机制\" class=\"headerlink\" title=\"4.1简述Java垃圾回收机制\"></a>4.1简述Java垃圾回收机制</h2><p>在Java中程序不需要显示释放一个对象的内存，一切都是交给JVM虚拟机完成。在JVM中存在一个垃圾回收线程为低优先级，正常情况下不会执行，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行。扫描那些没有被任何对象引用的对象，并将其添加到要回收的集合中，完成回收。</p>\n<h2 id=\"4-2-什么是GC？为什么要GC\"><a href=\"#4-2-什么是GC？为什么要GC\" class=\"headerlink\" title=\"4.2 什么是GC？为什么要GC\"></a>4.2 什么是GC？为什么要GC</h2><p>GC是（Garbage Collection）的意思，内存处理是编程人员容易出问题的地方，忘记或错误的内存回收会导致程序或系统不稳定甚至崩溃。Java提供GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p>\n<p>需要注意的是：和C++不同，<strong>Java没有提供释放已分配内存的显式操作；</strong></p>\n<h2 id=\"4-3-垃圾回收的优点和原理\"><a href=\"#4-3-垃圾回收的优点和原理\" class=\"headerlink\" title=\"4.3 垃圾回收的优点和原理\"></a>4.3 垃圾回收的优点和原理</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>对于GC来说，当程序员创建对象时，GC就开始监控对象的地址、大小以及使用情况。</p>\n<p>通常来说，GC采用有向图的方式记录和管理堆（Heap）中的所有对象，通过这种方式确定哪些对象是“可达的”；哪些对象是“不可达的”，当GC确定一些对象“不可达”时，GC就有责任回收这些内存空间；</p>\n<blockquote>\n<p>程序员可以显式调用<code>System.gc()</code>来通知GC运行，但是Java语言不能保证GC一定会执行。</p>\n</blockquote>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>可以看出，垃圾回收机制有效地防止了内存泄露，可以有效地使用可使用的内存。并且作为一个单独的低级别线程运行，在不可预知的情况下对内存堆中已经死亡或者很长时间没有使用的对象进行清除和回收。</p>\n<h3 id=\"垃圾回收的方式\"><a href=\"#垃圾回收的方式\" class=\"headerlink\" title=\"垃圾回收的方式\"></a>垃圾回收的方式</h3><p>有下面三种回收方式：</p>\n<ul>\n<li>复制垃圾回收</li>\n<li>标记垃圾回收</li>\n<li>增量垃圾回收</li>\n</ul>\n<h2 id=\"4-4-Java中的引用类型\"><a href=\"#4-4-Java中的引用类型\" class=\"headerlink\" title=\"4.4 Java中的引用类型\"></a>4.4 Java中的引用类型</h2><ul>\n<li>强引用：发生gc时不会被回收；(最经典的：去看ArrayList的clear方法)<ul>\n<li><strong>被GC回收的时间：</strong>从来不会被回收</li>\n<li><strong>用途：</strong>对象的一般状态</li>\n<li><strong>生存时间：</strong>JVM停止运行时终止</li>\n</ul>\n</li>\n<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收；<ul>\n<li><strong>被GC回收的时间：</strong>内存不足时</li>\n<li><strong>用途：</strong>对象缓存</li>\n<li><strong>生存时间：</strong>内存不足时终止</li>\n</ul>\n</li>\n<li>弱引用：有用但不是必须的对象，在下次GC时会被回收；<ul>\n<li><strong>被GC回收的时间：</strong>正常垃圾回收</li>\n<li><strong>用途：</strong>对象缓存</li>\n<li><strong>生存时间：</strong>垃圾回收后终止</li>\n</ul>\n</li>\n<li>虚引用：（幽灵引用/幻引用）：无法通过虚拟引用获得对象，用PhantomReference实现幻引用，虚引用的用途是在GC时返回一个通知；<ul>\n<li><strong>被GC回收的时间：</strong>正常垃圾回收时</li>\n<li><strong>用途：</strong>跟踪对象的垃圾回收</li>\n<li><strong>生存时间：</strong>垃圾回收后终止</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-5-JVM对象回收\"><a href=\"#4-5-JVM对象回收\" class=\"headerlink\" title=\"4.5 JVM对象回收\"></a>4.5 JVM对象回收</h2><h3 id=\"判断对象能否被回收\"><a href=\"#判断对象能否被回收\" class=\"headerlink\" title=\"判断对象能否被回收\"></a>判断对象能否被回收</h3><p>有两种方法：</p>\n<ul>\n<li>引用计数器法：每个对象创建一个引用计数，有对象引用计数器+1，引用释放计数器-1，计数器为0代表没有引用。缺点就是当出现循环引用，该对象无法被回收；</li>\n<li>可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是可以被回收的；</li>\n</ul>\n<h3 id=\"对象什么时候可以被垃圾回收\"><a href=\"#对象什么时候可以被垃圾回收\" class=\"headerlink\" title=\"对象什么时候可以被垃圾回收\"></a>对象什么时候可以被垃圾回收</h3><p>当对象对当前使用这个对象的应用程序变得不可触及时，这个对象就可以被回收；</p>\n<p>需要注意的是：通常垃圾回收不会发生在永久代，如果永久代满了或超过临界值会触发Full GC。因此<strong>正确的永久代大小对避免Full GC是非常至关重要的。</strong></p>\n<h2 id=\"4-6-JVM垃圾清除算法\"><a href=\"#4-6-JVM垃圾清除算法\" class=\"headerlink\" title=\"4.6 JVM垃圾清除算法\"></a>4.6 JVM垃圾清除算法</h2><h3 id=\"标记——清除算法\"><a href=\"#标记——清除算法\" class=\"headerlink\" title=\"标记——清除算法\"></a>标记——清除算法</h3><p>标记无用对象，然后清除回收；</p>\n<p><strong>优点：</strong>实现简单，不需要对象进行移动；</p>\n<p><strong>缺点：</strong>效率不高，无法清除垃圾碎片；</p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>按照容量划分两个大小相等的内存区域，一块用完后将活着的对象复制到另一块上，然后再把已使用的内存空间一次性清理；</p>\n<p><strong>优点：</strong>按顺序分配内存即可，实现简单，运行高效，不用考虑内存碎片；</p>\n<p><strong>缺点：</strong>可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制；</p>\n<h3 id=\"标记——整理算法\"><a href=\"#标记——整理算法\" class=\"headerlink\" title=\"标记——整理算法\"></a>标记——整理算法</h3><p>标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存；</p>\n<p><strong>优点：</strong>解决了标记——清理算法存在的内存碎片问题；</p>\n<p><strong>缺点：</strong>仍需要进行局部对象移动，一定程度上降低了效率；</p>\n<h3 id=\"分代算法\"><a href=\"#分代算法\" class=\"headerlink\" title=\"分代算法\"></a>分代算法</h3><p>根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代采用复制算法，老年代采用标记——整理算法；</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222141359995.png\" alt=\"image-20220222141359995\"></p>\n<h2 id=\"4-7-垃圾回收器的工作原理\"><a href=\"#4-7-垃圾回收器的工作原理\" class=\"headerlink\" title=\"4.7 垃圾回收器的工作原理\"></a>4.7 垃圾回收器的工作原理</h2><p>有7种作用不同分代的收集器，如下图：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222141536146.png\" alt=\"image-20220222141536146\"></p>\n<p>回收新生代的收集器：</p>\n<ul>\n<li>Serial</li>\n<li>ParNew</li>\n<li>Parallel Scavenge</li>\n</ul>\n<p>回收老年带的收集器：</p>\n<ul>\n<li>Serial Old</li>\n<li>Parallel Old</li>\n<li>CMS</li>\n</ul>\n<p>回收整个Java堆的收集器：G1</p>\n<h3 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h3><ul>\n<li><strong>Serial（复制算法）</strong>：新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>\n<li><strong>ParNew（复制算法）</strong>：新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>\n<li><strong>Parallel Scavenge（复制算法）</strong>：新生代并行收集器，高吞吐量，高效利用CPU，适合后台应用等对交互响应要求不高的场景；</li>\n<li><strong>Serial Old（标记——整理）</strong>：老年代单线程收集，Serial收集器的老年代版本；</li>\n<li><strong>Parallel Old（标记——整理）</strong>：老年代并行收集器，吞吐量优先；Parallel Scavenge收集器的老年代版本；</li>\n<li><strong>CMS（标记——清除算法）</strong>：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间；</li>\n<li><strong>G1（标记——整理算法）</strong>：Java堆并行收集器，G1收集器是JDK1.7提供的新收集器，此外G1回收的范围是整个Java堆（包括新生代、老年代），前6种收集器回收的范围仅限于新生代和老年代；</li>\n</ul>\n<h3 id=\"CMS垃圾回收器\"><a href=\"#CMS垃圾回收器\" class=\"headerlink\" title=\"CMS垃圾回收器\"></a>CMS垃圾回收器</h3><p>英文全称Concurrent Mark-Sweep简称，以牺牲吞吐量为代价获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上非常适合。在JVM参数上用<code>-XX:+UseConcMarkSweepGC</code>来指定使用CMS垃圾回收器。</p>\n<p>由于使用“标记——清除”算法来实现，因此在gc过程中容易产生大量内存碎片，当剩余内存不能满足程序运行要求，系统会出现<code>Concurrent Mode Failure</code>，临时CMS会采用Serial Old回收器进行垃圾清除，此时性能将会被降低；</p>\n<h3 id=\"垃圾回收器的工作原理\"><a href=\"#垃圾回收器的工作原理\" class=\"headerlink\" title=\"垃圾回收器的工作原理\"></a>垃圾回收器的工作原理</h3><p>分代回收器有两个分区：新生代和老年代，新生代默认空间占比总空间的1/3，老生代的默认占比是2/3；</p>\n<p>分区如下：</p>\n<ul>\n<li>新生代：Eden，To Survivor，From Survivor。默认占比是8:1:1，执行流程如下：<ul>\n<li>将Eden + From Survivor存活的对象放入To Survivor区；</li>\n<li>清空Eden和From Survivor分区；</li>\n<li>交换From Survivor 和 To Survivor分区</li>\n</ul>\n</li>\n</ul>\n<p>每次在From Survivor到To Survivor移动时都存活的对象，年龄+1；当年龄达到15升级为老年代，大对象也会直接进入老年代；</p>\n<ul>\n<li><p>老年代当空间占用达到某个值后就会触发Full GC，一般通过标记——整理算法执行</p>\n</li>\n<li><p>以此循环往复就构成了整个分代垃圾回收的整体执行流程；</p>\n</li>\n</ul>\n<h1 id=\"5-内存分配策略\"><a href=\"#5-内存分配策略\" class=\"headerlink\" title=\"5. 内存分配策略\"></a>5. 内存分配策略</h1><h2 id=\"5-1-内存分配以及回收策略\"><a href=\"#5-1-内存分配以及回收策略\" class=\"headerlink\" title=\"5.1 内存分配以及回收策略\"></a>5.1 内存分配以及回收策略</h2><p>自动内存管理，最终要解决的问题也是内存分配和内存回收，这里谈谈内存分配：</p>\n<ul>\n<li>通常在Java堆上分配（随着JVM优化技术，某些场景下也在栈上分配）</li>\n<li>分配的区域有下面两种：<ul>\n<li>未开启TLAB，在新生代的Eden区分配，少数情况直接会在老年代分配；</li>\n<li>开启TLAB，按照线程优先在TLAB上分配；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-2-对象在内存区域的分配\"><a href=\"#5-2-对象在内存区域的分配\" class=\"headerlink\" title=\"5.2 对象在内存区域的分配\"></a>5.2 对象在内存区域的分配</h2><h3 id=\"普世规则\"><a href=\"#普世规则\" class=\"headerlink\" title=\"普世规则\"></a>普世规则</h3><h4 id=\"对象优先在Eden区分配\"><a href=\"#对象优先在Eden区分配\" class=\"headerlink\" title=\"对象优先在Eden区分配\"></a>对象优先在Eden区分配</h4><p>多数情况下，对象都是在新生代的Eden区分配，当Eden区没有足够的空间，虚拟机就会触发一次Minor GC。如果Minor GC后还是没有足够的空间，则<strong>启用分配担保机制</strong>在老年代分配；</p>\n<ul>\n<li><strong>Minor GC：</strong>发生在新生代的GC，Java对象大多都是朝生夕死，所有Minor GC非常频繁，一般回收速度也非常快；</li>\n<li><strong>Major GC / Full GC：</strong>发生在老年代GC，出现Major GC通常会伴随至少一次Minor GC，Major GC的速度会比Minor GC慢10倍以上（知道为什么嘛？因为老年代的GC不经常发生）</li>\n</ul>\n<h4 id=\"大对象直接进老年代\"><a href=\"#大对象直接进老年代\" class=\"headerlink\" title=\"大对象直接进老年代\"></a>大对象直接进老年代</h4><p>大对象指的是需要大量连续内存空间的对象，频繁出现大量对象是致命的，会导致内存还有不少空间的情况下提前触发GC以获取足够的连续空间来安置新对象；</p>\n<p>由于新生代使用的是复制算法回收垃圾，假如大对象一开始就在新生代分配就会导致Eden区和两个Survivor区之间发生大量内存复制。<strong>所以大对象直接进老年代；</strong></p>\n<h4 id=\"长期存活对象将进入老年代\"><a href=\"#长期存活对象将进入老年代\" class=\"headerlink\" title=\"长期存活对象将进入老年代\"></a>长期存活对象将进入老年代</h4><p>由于JVM采用分代收集来管理内存，那么在内存回收时必须判断哪些对象放在新生代，哪些对象放在老年代。</p>\n<p>虚拟机给每个对象定义了一个对象年龄计数器：</p>\n<ul>\n<li>如果在Eden区出生，并且被Survivor容纳，年龄对象为1；</li>\n<li>对象每在Survivor区逃过一次Minor GC，年龄就+1；</li>\n<li>当年龄达到15，就会晋升到老年代；</li>\n</ul>\n<h1 id=\"6-虚拟机类加载机制\"><a href=\"#6-虚拟机类加载机制\" class=\"headerlink\" title=\"6. 虚拟机类加载机制\"></a>6. 虚拟机类加载机制</h1><h2 id=\"6-1-Java类加载机制\"><a href=\"#6-1-Java类加载机制\" class=\"headerlink\" title=\"6.1 Java类加载机制\"></a>6.1 Java类加载机制</h2><p>虚拟机把类的描述从Class文件加载到内存，并对数据进行校验，解析和初始化。最终形成可以被虚拟机直接使用的java类型；</p>\n<h2 id=\"6-2-JVM加载Class文件的原理机制\"><a href=\"#6-2-JVM加载Class文件的原理机制\" class=\"headerlink\" title=\"6.2 JVM加载Class文件的原理机制\"></a>6.2 JVM加载Class文件的原理机制</h2><p>Java中的所有类，都需要类加载器装载到JVM中才能运行，类加载器本身也是一个类，而它的工作就是把class文件从硬盘读到内存中。写程序的时候，几乎不需要关心类加载，因为整个过程都是隐式装载的，除非有特殊用法，例如反射；</p>\n<h2 id=\"6-3-类加载器过程\"><a href=\"#6-3-类加载器过程\" class=\"headerlink\" title=\"6.3 类加载器过程\"></a>6.3 类加载器过程</h2><h3 id=\"类装载的方式\"><a href=\"#类装载的方式\" class=\"headerlink\" title=\"类装载的方式\"></a>类装载的方式</h3><p>有下面两种：</p>\n<ul>\n<li>隐式装载：程序在运行过程中碰到new等方式生成的对象，隐式调用类装载器加载对应的类到jvm中；</li>\n<li>显式装载：借助<code>Class.forName()</code>等方法显式加载需要的类；</li>\n</ul>\n<p>Java类的加载是动态的，为了节省内存开销，除了将程序运行的基础类完全加载到jvm中，剩下的其他类则在需要的时候再加载；</p>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>定义：实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器；</p>\n<p>主要有以下4种类加载器：</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）：用来加载Java核心类库，无法被Java程序直接引用；</li>\n<li>扩展类加载器（Extensions ClassLoader）：用来加载Java扩展库，Java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载Java类；</li>\n<li>系统类加载器（System ClassLoader）：一般来说，Java应用的类都是由它完成加载的。可以通过<code>ClassLoader.getSystemClassLoader()</code>来获取；</li>\n<li>用户自定义类加载器，通过继承<code>java.lang.ClassLoader</code>类实现；</li>\n</ul>\n<h3 id=\"类装载的执行过程\"><a href=\"#类装载的执行过程\" class=\"headerlink\" title=\"类装载的执行过程\"></a>类装载的执行过程</h3><ol>\n<li><strong>加载：</strong>根据查找路径找到对应的class文件然后导入；</li>\n<li><strong>验证：</strong>检查加载的class文件的正确性；</li>\n<li><strong>准备：</strong>给类中的静态变量分配内存空间；</li>\n<li><strong>解析：</strong>虚拟机将常量池中的符号引用替换成直接引用。符号引用就理解为一个标识，而在直接引用中指向内存中的地址；</li>\n<li><strong>初始化：</strong>对静态变量和静态代码块执行初始化工作；</li>\n</ol>\n<h2 id=\"6-4-双亲委派模型\"><a href=\"#6-4-双亲委派模型\" class=\"headerlink\" title=\"6.4 双亲委派模型\"></a>6.4 双亲委派模型</h2><p>对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间，类加载器就是根据指定全限定名称将class文件加载到JVM内存，然后再转化为class对象。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222181549279.png\" alt=\"image-20220222181549279\"></p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）：虚拟机自身的一部分，用来加载JAVA_HOME/lib目录中的，或者被<code>-Xbootclasspath</code>参数指定的路径并且被虚拟机识别的类库；</li>\n<li>扩展类加载器（Extension ClassLoader）：负责加载/lib/ext/目录或者Java.ext.dirs系统变量指定的路径中的所有类库；</li>\n<li>应用程序类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认使用的就是这个加载器；</li>\n</ul>\n<h3 id=\"什么是双亲委派模型\"><a href=\"#什么是双亲委派模型\" class=\"headerlink\" title=\"什么是双亲委派模型\"></a>什么是双亲委派模型</h3><p>如果一个类加载器收到类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载器无法完成加载请求，子加载器才会尝试去加载类；</p>\n<h1 id=\"7-JVM调优\"><a href=\"#7-JVM调优\" class=\"headerlink\" title=\"7. JVM调优\"></a>7. JVM调优</h1><h2 id=\"7-1-JVM调优工具\"><a href=\"#7-1-JVM调优工具\" class=\"headerlink\" title=\"7.1 JVM调优工具\"></a>7.1 JVM调优工具</h2><p>JVM调优常用的是下面这两个工具：</p>\n<ul>\n<li>jconsole：用于对JVM中的内存、线程和类进行监控；</li>\n<li>jvisualvm：JDK自带分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存变化以及gc变化；</li>\n</ul>\n<h2 id=\"7-2-JVM调优参数\"><a href=\"#7-2-JVM调优参数\" class=\"headerlink\" title=\"7.2 JVM调优参数\"></a>7.2 JVM调优参数</h2><p>常用的JVM调优参数如下：</p>\n<ul>\n<li>-Xms2g：初始化堆大小为2g</li>\n<li>-Xmx2g：堆最大内存为2g</li>\n<li>-XX:NewRatio=4：设置年轻代和老年代的内存比例为1:4</li>\n<li>-XX:SurvivorRatio=8：设置新生代Eden和Survivor比例为8:2</li>\n<li>-XX:+UseParNewGC：指定使用ParNew + Serial Old垃圾回收器组合</li>\n<li>-XX:+UseParallelOldGC：指定使用ParNew + ParNew Old垃圾回收器组合</li>\n<li>-XX:+UseConcMarkSweepGC：指定使用CMS + Serial Old垃圾回收器组合</li>\n<li>-XX:+PrintGC：开启打印gc信息</li>\n<li>-XX:+PrintGCDetails：打印gc详细信息；</li>\n</ul>\n","site":{"data":{}},"wordcount":7529,"excerpt":"","more":"<h1 id=\"1-JVM内存区域\"><a href=\"#1-JVM内存区域\" class=\"headerlink\" title=\"1. JVM内存区域\"></a>1. JVM内存区域</h1><h2 id=\"1-1-JVM内存组成及其作用\"><a href=\"#1-1-JVM内存组成及其作用\" class=\"headerlink\" title=\"1.1. JVM内存组成及其作用\"></a>1.1. JVM内存组成及其作用</h2><p>如下图所示：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221232111788.png\" alt=\"image-20220221232111788\"></p>\n<p>JVM总共包含两个子系统和两个组件。分别是：</p>\n<ul>\n<li>两个子系统：类加载器和执行引擎；</li>\n<li>两个子组件：运行时数据区和本地接口；</li>\n</ul>\n<p>它们各自有不同的作用：</p>\n<ul>\n<li>类加载器：根据给定的全限定类型装在class文件到运行数据域中的方法域中；</li>\n<li>执行引擎：执行classes文件中的指令；</li>\n<li>本地接口：与本地方法库交互，是其它编程语言交互的接口；</li>\n<li>运行时数据区域：也就是常说的JVM内存；</li>\n</ul>\n<h2 id=\"1-2-JVM运行机制\"><a href=\"#1-2-JVM运行机制\" class=\"headerlink\" title=\"1.2 JVM运行机制\"></a>1.2 JVM运行机制</h2><ol>\n<li>Java文件源码编译成.class字节码文件，加载至类加载器中；</li>\n<li>类加载器再将.class文件加载到JVM中；</li>\n</ol>\n<p>通俗来说：类加载器将类的.class文件读入内存，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构；</p>\n<h2 id=\"1-3-JVM运行时数据\"><a href=\"#1-3-JVM运行时数据\" class=\"headerlink\" title=\"1.3 JVM运行时数据\"></a>1.3 JVM运行时数据</h2><ul>\n<li>程序计数器：当前线程执行字节码的行号指示器，字节码解析的工作是通过改变计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能；</li>\n<li>Java虚拟机栈：存储局部变量表、操作数栈、动态链接以及方法出口等；</li>\n<li>本地方法栈：作用与虚拟机栈一样，只是针对的是虚拟机调用Native方法服务的；</li>\n<li>Java堆：虚拟机中内存最大的一块，被所有线程共享，几乎所有对象的实例都在这里分配内存；</li>\n<li>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据；</li>\n</ul>\n<h2 id=\"1-4-深拷贝浅拷贝\"><a href=\"#1-4-深拷贝浅拷贝\" class=\"headerlink\" title=\"1.4 深拷贝浅拷贝\"></a>1.4 深拷贝浅拷贝</h2><ul>\n<li>浅拷贝：增加一个指针指向已存在的内存地址；</li>\n<li>深拷贝：增加一个指针并且申请一个新内存，使这个增加的指针指向新的内存；</li>\n</ul>\n<blockquote>\n<p>使用深拷贝时，释放内存不会因为出现浅拷贝释放同一个内存的错误</p>\n</blockquote>\n<ul>\n<li>浅复制：仅仅指向被复制的内存地址，如果原地址变化，浅复制出来的对象也会改变；</li>\n<li>深复制：在计算机内存中开辟一块新的内存地址用于存放复制的对象；</li>\n</ul>\n<h2 id=\"1-5-堆栈的区别\"><a href=\"#1-5-堆栈的区别\" class=\"headerlink\" title=\"1.5 堆栈的区别\"></a>1.5 堆栈的区别</h2><h3 id=\"堆-Heap\"><a href=\"#堆-Heap\" class=\"headerlink\" title=\"堆 Heap\"></a>堆 Heap</h3><ol>\n<li>内存空间不连续，内存分配在<strong>运行期</strong>确认，大小不固定；</li>\n<li>GC有不同的算法回收（标记-清除，标记-复制，标记，压缩，分代算法）</li>\n<li>存放的是对象（包括静态对象）的实例和数组，因此更关注数据的存储；</li>\n<li>对于整个应用程序可见，并且共享；</li>\n</ol>\n<h3 id=\"栈-Stack\"><a href=\"#栈-Stack\" class=\"headerlink\" title=\"栈 Stack\"></a>栈 Stack</h3><ol>\n<li>先进后出原则，物理地址分配连续，性能快；</li>\n<li>内存分配是在<strong>编译期</strong>确认，大小固定；</li>\n<li>局部变量、操作数栈，返回结果，静态变量等；</li>\n<li>线程私有，生命周期和线程相同；</li>\n</ol>\n<h1 id=\"2-Hotspot虚拟机对象探索\"><a href=\"#2-Hotspot虚拟机对象探索\" class=\"headerlink\" title=\"2. Hotspot虚拟机对象探索\"></a>2. Hotspot虚拟机对象探索</h1><h2 id=\"2-1-对象创建\"><a href=\"#2-1-对象创建\" class=\"headerlink\" title=\"2.1 对象创建\"></a>2.1 对象创建</h2><p>记住一点：只有clone和反序列化创建对象没调用构造函数，其他的创建对象方式都调用了构造函数。</p>\n<p>对象创建的流程如下：</p>\n<ul>\n<li>检查常量池中是否有已经加载的类<ul>\n<li>没有：执行对应的类加载器；</li>\n<li>有：从内存中直接加载，不需要调用对应的类加载器；</li>\n</ul>\n</li>\n<li>当前内存区域是否规整？<ul>\n<li>是：使用“指针碰撞”来分配内存</li>\n<li>不是：从空闲列表中分配内存</li>\n</ul>\n</li>\n<li>考虑并发问题，比如CAS同步处理以及本地线程分配缓冲（TLAB）</li>\n<li>设置对象的必要信息（元信息、哈希码）；</li>\n<li>执行<code>&lt;init&gt;</code>方法，完成对象创建；</li>\n</ul>\n<h2 id=\"2-2-对象内存分配\"><a href=\"#2-2-对象内存分配\" class=\"headerlink\" title=\"2.2 对象内存分配\"></a>2.2 对象内存分配</h2><p>对象分配内存（在堆中分配）也有两种方式：</p>\n<ul>\n<li>指针碰撞：规整内存的前提下，将用过的内存放一边，空闲放另一边。分配时将位于中间的指针指示器向空闲的内存移动一段与对象大小同等的距离，从而完成分配工作；</li>\n<li>空闲列表：不规整内存的前提下，需要有JVM维护一个列表记录哪些内存空间课哟就那个，这样在分配的时候可以从列表中查询到足够大的内存分配给对象；</li>\n</ul>\n<h2 id=\"2-3-并发安全问题处理\"><a href=\"#2-3-并发安全问题处理\" class=\"headerlink\" title=\"2.3 并发安全问题处理\"></a>2.3 并发安全问题处理</h2><p>处理并发安全问题也有如下两个方式：</p>\n<ul>\n<li>采用CAS（什么是CAS）+失败重试来保障更新操作的原子性；</li>\n<li>按照线程划分在不同空间进行内存分配，即在每个线程在Java堆中预先分配一小块内存，成为TLAB。哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB才需要同步锁。借助<code>-XX:+/-UserTLAB</code>参数设定JVM是否使用TLAB；</li>\n</ul>\n<h2 id=\"2-4-对象的访问定位\"><a href=\"#2-4-对象的访问定位\" class=\"headerlink\" title=\"2.4 对象的访问定位\"></a>2.4 对象的访问定位</h2><p>Java需要通过JVM栈上的引用访问堆中的具体对象，对象访问直接取决于JVM虚拟机的实现。主流的方式有<strong>句柄</strong>和<strong>直接指针</strong>两种方式：</p>\n<ul>\n<li>句柄：指向指针的指针，维护对象的指针。不直接指向对象，而是指向对象的地址（句柄不发生变化，指向固定的内存地址），再由对象的指针指向对象的真是内存地址；</li>\n<li>指针：指向对象，代表一个对象在内存中的起始地址；</li>\n</ul>\n<h3 id=\"句柄访问\"><a href=\"#句柄访问\" class=\"headerlink\" title=\"句柄访问\"></a>句柄访问</h3><p>句柄池是Java堆中的一块内存，引用存储对象的句柄地址，句柄包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222115625143.png\" alt=\"image-20220222115625143\"></p>\n<p>优点：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中的实例数据指针</strong>，而引用本身不需要修改；</p>\n<h3 id=\"直接指针\"><a href=\"#直接指针\" class=\"headerlink\" title=\"直接指针\"></a>直接指针</h3><p>使用直接指针访问，引用中存储的是对象地址，在Java堆对象内部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息；</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222120220653.png\" alt=\"image-20220222120220653\"></p>\n<p>优势：速度快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的成本。HotSpot虚拟机使用的就是这种方式。</p>\n<h1 id=\"3-内存溢出异常\"><a href=\"#3-内存溢出异常\" class=\"headerlink\" title=\"3. 内存溢出异常\"></a>3. 内存溢出异常</h1><h2 id=\"3-1-什么是内存泄露，Java存在内存泄露\"><a href=\"#3-1-什么是内存泄露，Java存在内存泄露\" class=\"headerlink\" title=\"3.1 什么是内存泄露，Java存在内存泄露\"></a>3.1 什么是内存泄露，Java存在内存泄露</h2><p>内存泄露指的是不再被使用的对象或者变量一直占据在内存中，理论上说Java有GC垃圾回收机制，不再被使用的对象，会被GC自动回收，自动从内存中清除；</p>\n<p>但即便如此，Java依然存在内存泄露的情况：即<strong>长生命周期的对象持有短声明周期对象的引用</strong>就可能发生内存泄露，尽管短生命周期对象已经不再需要，但由于长生命周期的对象一直持有短生命周期的引用导致它不能被GC回收。这样就会产生JVM内存泄露；</p>\n<h1 id=\"4-GC垃圾收集器\"><a href=\"#4-GC垃圾收集器\" class=\"headerlink\" title=\"4. GC垃圾收集器\"></a>4. GC垃圾收集器</h1><h2 id=\"4-1简述Java垃圾回收机制\"><a href=\"#4-1简述Java垃圾回收机制\" class=\"headerlink\" title=\"4.1简述Java垃圾回收机制\"></a>4.1简述Java垃圾回收机制</h2><p>在Java中程序不需要显示释放一个对象的内存，一切都是交给JVM虚拟机完成。在JVM中存在一个垃圾回收线程为低优先级，正常情况下不会执行，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行。扫描那些没有被任何对象引用的对象，并将其添加到要回收的集合中，完成回收。</p>\n<h2 id=\"4-2-什么是GC？为什么要GC\"><a href=\"#4-2-什么是GC？为什么要GC\" class=\"headerlink\" title=\"4.2 什么是GC？为什么要GC\"></a>4.2 什么是GC？为什么要GC</h2><p>GC是（Garbage Collection）的意思，内存处理是编程人员容易出问题的地方，忘记或错误的内存回收会导致程序或系统不稳定甚至崩溃。Java提供GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p>\n<p>需要注意的是：和C++不同，<strong>Java没有提供释放已分配内存的显式操作；</strong></p>\n<h2 id=\"4-3-垃圾回收的优点和原理\"><a href=\"#4-3-垃圾回收的优点和原理\" class=\"headerlink\" title=\"4.3 垃圾回收的优点和原理\"></a>4.3 垃圾回收的优点和原理</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>对于GC来说，当程序员创建对象时，GC就开始监控对象的地址、大小以及使用情况。</p>\n<p>通常来说，GC采用有向图的方式记录和管理堆（Heap）中的所有对象，通过这种方式确定哪些对象是“可达的”；哪些对象是“不可达的”，当GC确定一些对象“不可达”时，GC就有责任回收这些内存空间；</p>\n<blockquote>\n<p>程序员可以显式调用<code>System.gc()</code>来通知GC运行，但是Java语言不能保证GC一定会执行。</p>\n</blockquote>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>可以看出，垃圾回收机制有效地防止了内存泄露，可以有效地使用可使用的内存。并且作为一个单独的低级别线程运行，在不可预知的情况下对内存堆中已经死亡或者很长时间没有使用的对象进行清除和回收。</p>\n<h3 id=\"垃圾回收的方式\"><a href=\"#垃圾回收的方式\" class=\"headerlink\" title=\"垃圾回收的方式\"></a>垃圾回收的方式</h3><p>有下面三种回收方式：</p>\n<ul>\n<li>复制垃圾回收</li>\n<li>标记垃圾回收</li>\n<li>增量垃圾回收</li>\n</ul>\n<h2 id=\"4-4-Java中的引用类型\"><a href=\"#4-4-Java中的引用类型\" class=\"headerlink\" title=\"4.4 Java中的引用类型\"></a>4.4 Java中的引用类型</h2><ul>\n<li>强引用：发生gc时不会被回收；(最经典的：去看ArrayList的clear方法)<ul>\n<li><strong>被GC回收的时间：</strong>从来不会被回收</li>\n<li><strong>用途：</strong>对象的一般状态</li>\n<li><strong>生存时间：</strong>JVM停止运行时终止</li>\n</ul>\n</li>\n<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收；<ul>\n<li><strong>被GC回收的时间：</strong>内存不足时</li>\n<li><strong>用途：</strong>对象缓存</li>\n<li><strong>生存时间：</strong>内存不足时终止</li>\n</ul>\n</li>\n<li>弱引用：有用但不是必须的对象，在下次GC时会被回收；<ul>\n<li><strong>被GC回收的时间：</strong>正常垃圾回收</li>\n<li><strong>用途：</strong>对象缓存</li>\n<li><strong>生存时间：</strong>垃圾回收后终止</li>\n</ul>\n</li>\n<li>虚引用：（幽灵引用/幻引用）：无法通过虚拟引用获得对象，用PhantomReference实现幻引用，虚引用的用途是在GC时返回一个通知；<ul>\n<li><strong>被GC回收的时间：</strong>正常垃圾回收时</li>\n<li><strong>用途：</strong>跟踪对象的垃圾回收</li>\n<li><strong>生存时间：</strong>垃圾回收后终止</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-5-JVM对象回收\"><a href=\"#4-5-JVM对象回收\" class=\"headerlink\" title=\"4.5 JVM对象回收\"></a>4.5 JVM对象回收</h2><h3 id=\"判断对象能否被回收\"><a href=\"#判断对象能否被回收\" class=\"headerlink\" title=\"判断对象能否被回收\"></a>判断对象能否被回收</h3><p>有两种方法：</p>\n<ul>\n<li>引用计数器法：每个对象创建一个引用计数，有对象引用计数器+1，引用释放计数器-1，计数器为0代表没有引用。缺点就是当出现循环引用，该对象无法被回收；</li>\n<li>可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是可以被回收的；</li>\n</ul>\n<h3 id=\"对象什么时候可以被垃圾回收\"><a href=\"#对象什么时候可以被垃圾回收\" class=\"headerlink\" title=\"对象什么时候可以被垃圾回收\"></a>对象什么时候可以被垃圾回收</h3><p>当对象对当前使用这个对象的应用程序变得不可触及时，这个对象就可以被回收；</p>\n<p>需要注意的是：通常垃圾回收不会发生在永久代，如果永久代满了或超过临界值会触发Full GC。因此<strong>正确的永久代大小对避免Full GC是非常至关重要的。</strong></p>\n<h2 id=\"4-6-JVM垃圾清除算法\"><a href=\"#4-6-JVM垃圾清除算法\" class=\"headerlink\" title=\"4.6 JVM垃圾清除算法\"></a>4.6 JVM垃圾清除算法</h2><h3 id=\"标记——清除算法\"><a href=\"#标记——清除算法\" class=\"headerlink\" title=\"标记——清除算法\"></a>标记——清除算法</h3><p>标记无用对象，然后清除回收；</p>\n<p><strong>优点：</strong>实现简单，不需要对象进行移动；</p>\n<p><strong>缺点：</strong>效率不高，无法清除垃圾碎片；</p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>按照容量划分两个大小相等的内存区域，一块用完后将活着的对象复制到另一块上，然后再把已使用的内存空间一次性清理；</p>\n<p><strong>优点：</strong>按顺序分配内存即可，实现简单，运行高效，不用考虑内存碎片；</p>\n<p><strong>缺点：</strong>可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制；</p>\n<h3 id=\"标记——整理算法\"><a href=\"#标记——整理算法\" class=\"headerlink\" title=\"标记——整理算法\"></a>标记——整理算法</h3><p>标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存；</p>\n<p><strong>优点：</strong>解决了标记——清理算法存在的内存碎片问题；</p>\n<p><strong>缺点：</strong>仍需要进行局部对象移动，一定程度上降低了效率；</p>\n<h3 id=\"分代算法\"><a href=\"#分代算法\" class=\"headerlink\" title=\"分代算法\"></a>分代算法</h3><p>根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代采用复制算法，老年代采用标记——整理算法；</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222141359995.png\" alt=\"image-20220222141359995\"></p>\n<h2 id=\"4-7-垃圾回收器的工作原理\"><a href=\"#4-7-垃圾回收器的工作原理\" class=\"headerlink\" title=\"4.7 垃圾回收器的工作原理\"></a>4.7 垃圾回收器的工作原理</h2><p>有7种作用不同分代的收集器，如下图：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222141536146.png\" alt=\"image-20220222141536146\"></p>\n<p>回收新生代的收集器：</p>\n<ul>\n<li>Serial</li>\n<li>ParNew</li>\n<li>Parallel Scavenge</li>\n</ul>\n<p>回收老年带的收集器：</p>\n<ul>\n<li>Serial Old</li>\n<li>Parallel Old</li>\n<li>CMS</li>\n</ul>\n<p>回收整个Java堆的收集器：G1</p>\n<h3 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h3><ul>\n<li><strong>Serial（复制算法）</strong>：新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>\n<li><strong>ParNew（复制算法）</strong>：新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>\n<li><strong>Parallel Scavenge（复制算法）</strong>：新生代并行收集器，高吞吐量，高效利用CPU，适合后台应用等对交互响应要求不高的场景；</li>\n<li><strong>Serial Old（标记——整理）</strong>：老年代单线程收集，Serial收集器的老年代版本；</li>\n<li><strong>Parallel Old（标记——整理）</strong>：老年代并行收集器，吞吐量优先；Parallel Scavenge收集器的老年代版本；</li>\n<li><strong>CMS（标记——清除算法）</strong>：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间；</li>\n<li><strong>G1（标记——整理算法）</strong>：Java堆并行收集器，G1收集器是JDK1.7提供的新收集器，此外G1回收的范围是整个Java堆（包括新生代、老年代），前6种收集器回收的范围仅限于新生代和老年代；</li>\n</ul>\n<h3 id=\"CMS垃圾回收器\"><a href=\"#CMS垃圾回收器\" class=\"headerlink\" title=\"CMS垃圾回收器\"></a>CMS垃圾回收器</h3><p>英文全称Concurrent Mark-Sweep简称，以牺牲吞吐量为代价获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上非常适合。在JVM参数上用<code>-XX:+UseConcMarkSweepGC</code>来指定使用CMS垃圾回收器。</p>\n<p>由于使用“标记——清除”算法来实现，因此在gc过程中容易产生大量内存碎片，当剩余内存不能满足程序运行要求，系统会出现<code>Concurrent Mode Failure</code>，临时CMS会采用Serial Old回收器进行垃圾清除，此时性能将会被降低；</p>\n<h3 id=\"垃圾回收器的工作原理\"><a href=\"#垃圾回收器的工作原理\" class=\"headerlink\" title=\"垃圾回收器的工作原理\"></a>垃圾回收器的工作原理</h3><p>分代回收器有两个分区：新生代和老年代，新生代默认空间占比总空间的1/3，老生代的默认占比是2/3；</p>\n<p>分区如下：</p>\n<ul>\n<li>新生代：Eden，To Survivor，From Survivor。默认占比是8:1:1，执行流程如下：<ul>\n<li>将Eden + From Survivor存活的对象放入To Survivor区；</li>\n<li>清空Eden和From Survivor分区；</li>\n<li>交换From Survivor 和 To Survivor分区</li>\n</ul>\n</li>\n</ul>\n<p>每次在From Survivor到To Survivor移动时都存活的对象，年龄+1；当年龄达到15升级为老年代，大对象也会直接进入老年代；</p>\n<ul>\n<li><p>老年代当空间占用达到某个值后就会触发Full GC，一般通过标记——整理算法执行</p>\n</li>\n<li><p>以此循环往复就构成了整个分代垃圾回收的整体执行流程；</p>\n</li>\n</ul>\n<h1 id=\"5-内存分配策略\"><a href=\"#5-内存分配策略\" class=\"headerlink\" title=\"5. 内存分配策略\"></a>5. 内存分配策略</h1><h2 id=\"5-1-内存分配以及回收策略\"><a href=\"#5-1-内存分配以及回收策略\" class=\"headerlink\" title=\"5.1 内存分配以及回收策略\"></a>5.1 内存分配以及回收策略</h2><p>自动内存管理，最终要解决的问题也是内存分配和内存回收，这里谈谈内存分配：</p>\n<ul>\n<li>通常在Java堆上分配（随着JVM优化技术，某些场景下也在栈上分配）</li>\n<li>分配的区域有下面两种：<ul>\n<li>未开启TLAB，在新生代的Eden区分配，少数情况直接会在老年代分配；</li>\n<li>开启TLAB，按照线程优先在TLAB上分配；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-2-对象在内存区域的分配\"><a href=\"#5-2-对象在内存区域的分配\" class=\"headerlink\" title=\"5.2 对象在内存区域的分配\"></a>5.2 对象在内存区域的分配</h2><h3 id=\"普世规则\"><a href=\"#普世规则\" class=\"headerlink\" title=\"普世规则\"></a>普世规则</h3><h4 id=\"对象优先在Eden区分配\"><a href=\"#对象优先在Eden区分配\" class=\"headerlink\" title=\"对象优先在Eden区分配\"></a>对象优先在Eden区分配</h4><p>多数情况下，对象都是在新生代的Eden区分配，当Eden区没有足够的空间，虚拟机就会触发一次Minor GC。如果Minor GC后还是没有足够的空间，则<strong>启用分配担保机制</strong>在老年代分配；</p>\n<ul>\n<li><strong>Minor GC：</strong>发生在新生代的GC，Java对象大多都是朝生夕死，所有Minor GC非常频繁，一般回收速度也非常快；</li>\n<li><strong>Major GC / Full GC：</strong>发生在老年代GC，出现Major GC通常会伴随至少一次Minor GC，Major GC的速度会比Minor GC慢10倍以上（知道为什么嘛？因为老年代的GC不经常发生）</li>\n</ul>\n<h4 id=\"大对象直接进老年代\"><a href=\"#大对象直接进老年代\" class=\"headerlink\" title=\"大对象直接进老年代\"></a>大对象直接进老年代</h4><p>大对象指的是需要大量连续内存空间的对象，频繁出现大量对象是致命的，会导致内存还有不少空间的情况下提前触发GC以获取足够的连续空间来安置新对象；</p>\n<p>由于新生代使用的是复制算法回收垃圾，假如大对象一开始就在新生代分配就会导致Eden区和两个Survivor区之间发生大量内存复制。<strong>所以大对象直接进老年代；</strong></p>\n<h4 id=\"长期存活对象将进入老年代\"><a href=\"#长期存活对象将进入老年代\" class=\"headerlink\" title=\"长期存活对象将进入老年代\"></a>长期存活对象将进入老年代</h4><p>由于JVM采用分代收集来管理内存，那么在内存回收时必须判断哪些对象放在新生代，哪些对象放在老年代。</p>\n<p>虚拟机给每个对象定义了一个对象年龄计数器：</p>\n<ul>\n<li>如果在Eden区出生，并且被Survivor容纳，年龄对象为1；</li>\n<li>对象每在Survivor区逃过一次Minor GC，年龄就+1；</li>\n<li>当年龄达到15，就会晋升到老年代；</li>\n</ul>\n<h1 id=\"6-虚拟机类加载机制\"><a href=\"#6-虚拟机类加载机制\" class=\"headerlink\" title=\"6. 虚拟机类加载机制\"></a>6. 虚拟机类加载机制</h1><h2 id=\"6-1-Java类加载机制\"><a href=\"#6-1-Java类加载机制\" class=\"headerlink\" title=\"6.1 Java类加载机制\"></a>6.1 Java类加载机制</h2><p>虚拟机把类的描述从Class文件加载到内存，并对数据进行校验，解析和初始化。最终形成可以被虚拟机直接使用的java类型；</p>\n<h2 id=\"6-2-JVM加载Class文件的原理机制\"><a href=\"#6-2-JVM加载Class文件的原理机制\" class=\"headerlink\" title=\"6.2 JVM加载Class文件的原理机制\"></a>6.2 JVM加载Class文件的原理机制</h2><p>Java中的所有类，都需要类加载器装载到JVM中才能运行，类加载器本身也是一个类，而它的工作就是把class文件从硬盘读到内存中。写程序的时候，几乎不需要关心类加载，因为整个过程都是隐式装载的，除非有特殊用法，例如反射；</p>\n<h2 id=\"6-3-类加载器过程\"><a href=\"#6-3-类加载器过程\" class=\"headerlink\" title=\"6.3 类加载器过程\"></a>6.3 类加载器过程</h2><h3 id=\"类装载的方式\"><a href=\"#类装载的方式\" class=\"headerlink\" title=\"类装载的方式\"></a>类装载的方式</h3><p>有下面两种：</p>\n<ul>\n<li>隐式装载：程序在运行过程中碰到new等方式生成的对象，隐式调用类装载器加载对应的类到jvm中；</li>\n<li>显式装载：借助<code>Class.forName()</code>等方法显式加载需要的类；</li>\n</ul>\n<p>Java类的加载是动态的，为了节省内存开销，除了将程序运行的基础类完全加载到jvm中，剩下的其他类则在需要的时候再加载；</p>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>定义：实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器；</p>\n<p>主要有以下4种类加载器：</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）：用来加载Java核心类库，无法被Java程序直接引用；</li>\n<li>扩展类加载器（Extensions ClassLoader）：用来加载Java扩展库，Java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载Java类；</li>\n<li>系统类加载器（System ClassLoader）：一般来说，Java应用的类都是由它完成加载的。可以通过<code>ClassLoader.getSystemClassLoader()</code>来获取；</li>\n<li>用户自定义类加载器，通过继承<code>java.lang.ClassLoader</code>类实现；</li>\n</ul>\n<h3 id=\"类装载的执行过程\"><a href=\"#类装载的执行过程\" class=\"headerlink\" title=\"类装载的执行过程\"></a>类装载的执行过程</h3><ol>\n<li><strong>加载：</strong>根据查找路径找到对应的class文件然后导入；</li>\n<li><strong>验证：</strong>检查加载的class文件的正确性；</li>\n<li><strong>准备：</strong>给类中的静态变量分配内存空间；</li>\n<li><strong>解析：</strong>虚拟机将常量池中的符号引用替换成直接引用。符号引用就理解为一个标识，而在直接引用中指向内存中的地址；</li>\n<li><strong>初始化：</strong>对静态变量和静态代码块执行初始化工作；</li>\n</ol>\n<h2 id=\"6-4-双亲委派模型\"><a href=\"#6-4-双亲委派模型\" class=\"headerlink\" title=\"6.4 双亲委派模型\"></a>6.4 双亲委派模型</h2><p>对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间，类加载器就是根据指定全限定名称将class文件加载到JVM内存，然后再转化为class对象。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220222181549279.png\" alt=\"image-20220222181549279\"></p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）：虚拟机自身的一部分，用来加载JAVA_HOME/lib目录中的，或者被<code>-Xbootclasspath</code>参数指定的路径并且被虚拟机识别的类库；</li>\n<li>扩展类加载器（Extension ClassLoader）：负责加载/lib/ext/目录或者Java.ext.dirs系统变量指定的路径中的所有类库；</li>\n<li>应用程序类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认使用的就是这个加载器；</li>\n</ul>\n<h3 id=\"什么是双亲委派模型\"><a href=\"#什么是双亲委派模型\" class=\"headerlink\" title=\"什么是双亲委派模型\"></a>什么是双亲委派模型</h3><p>如果一个类加载器收到类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载器无法完成加载请求，子加载器才会尝试去加载类；</p>\n<h1 id=\"7-JVM调优\"><a href=\"#7-JVM调优\" class=\"headerlink\" title=\"7. JVM调优\"></a>7. JVM调优</h1><h2 id=\"7-1-JVM调优工具\"><a href=\"#7-1-JVM调优工具\" class=\"headerlink\" title=\"7.1 JVM调优工具\"></a>7.1 JVM调优工具</h2><p>JVM调优常用的是下面这两个工具：</p>\n<ul>\n<li>jconsole：用于对JVM中的内存、线程和类进行监控；</li>\n<li>jvisualvm：JDK自带分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存变化以及gc变化；</li>\n</ul>\n<h2 id=\"7-2-JVM调优参数\"><a href=\"#7-2-JVM调优参数\" class=\"headerlink\" title=\"7.2 JVM调优参数\"></a>7.2 JVM调优参数</h2><p>常用的JVM调优参数如下：</p>\n<ul>\n<li>-Xms2g：初始化堆大小为2g</li>\n<li>-Xmx2g：堆最大内存为2g</li>\n<li>-XX:NewRatio=4：设置年轻代和老年代的内存比例为1:4</li>\n<li>-XX:SurvivorRatio=8：设置新生代Eden和Survivor比例为8:2</li>\n<li>-XX:+UseParNewGC：指定使用ParNew + Serial Old垃圾回收器组合</li>\n<li>-XX:+UseParallelOldGC：指定使用ParNew + ParNew Old垃圾回收器组合</li>\n<li>-XX:+UseConcMarkSweepGC：指定使用CMS + Serial Old垃圾回收器组合</li>\n<li>-XX:+PrintGC：开启打印gc信息</li>\n<li>-XX:+PrintGCDetails：打印gc详细信息；</li>\n</ul>\n"},{"title":"Apache Kafka盘点","date":"2022-03-02T03:33:20.000Z","updated":"2022-03-02T03:33:20.000Z","_content":"\n# 一、基本术语\n\n## 消息（Message）\n\nKafka中的数据单元称为`消息`，也被称为记录，可以把它看作数据库表中的某一行记录；\n\n## 批次（Batch）\n\n为了提高效率，消息会`分批次`写入Kafka，批次就代指的一组消息；\n\n## 主题（Topic）\n\n消息的种类为`主题`，可以说一个主题代表了一类消息。相当于对消息进行分类，主题就像数据库中的表；\n\n## 分区（Partition）\n\n主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现kafka的伸缩性，单一主题中的分区有序，但是无法保证主题中的所有分区有序；\n\n\n\n## 生产者（Producer）\n\n向主题发布消息的客户端应用程序称为生产者，生产者用于持续不断的向某个主题发送消息；\n\n## 消费者（Consumer）\n\n订阅主题消息的客户端称为消费者，消费者用于处理生产者产生的消息；\n\n## 消费者群组\n\n由一个或者多个消费者组成的群体；\n\n## 偏移量（Consumer Offset）\n\n一种元数据，是一个不断递增的整数值，用来记录消费者发生重平衡的位置，以便用来恢复数据；\n\n## Broker\n\n一个独立的Kafka服务器称为Broker，Broker接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；\n\n## Broker集群\n\n是集群的组成部分，有一个或者多个broker组成，每个集群都有一个broker同时充当集群控制器的角色（自动从集群的活跃成员中选举出来）；\n\n## 副本（Replica）\n\nKafka中消息备份叫副本，副本数量可以配置，并且Kafka定义了两类副本：领导者副本和追随者副本；前者对外提供服务，后者被动跟随；\n\n## 重平衡（Rebalance）\n\n消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalalce是Kafka消费者实现高可用的重要手段；\n\n\n\n# 二、Kafka的特性（设计原则）\n\n+ **高吞吐、低延迟：**收发消息快，每秒可以处理几十万条信息，最低延迟只有几毫秒；\n+ **高伸缩性：**每个主题包含多个分区，主题中的分区可以分布在不同的主机中；\n+ **持久性、可靠性：**允许数据持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka底层的数据存储是基于Zookeeper存储；\n+ **容错性：**允许集群中的节点失败，某个节点宕机，Kafka集群能够正常工作；\n+ **高并发：**支持数千个客户端同时读写；\n\n\n\n# 三、使用场景\n\n+ **活动跟踪：**例如跟踪用户行为；\n+ **消息传递：**例如应用程序的发送通知，不需要关心消息格式，不需要关心数据如何发送；\n+ **度量指标：**记录运营监控数据，包括收集各种分布式应用数据，生产各种操作的集中反馈，例如报警和报告；\n+ **日志记录：**日志提交，例如可以把数据库更新发送到Kafka上，记录数据库更新时间，通过Kafka以统一接口服务的方式开放给各种consumer，例如Handoop，Hbase和Solr等；\n+ **流式处理：**这个不清楚\n+ **限流削峰：**某一时刻请求特别多，可以将请求写入Kafka中，避免直接请求后端程序导致服务崩溃；\n\n\n\n# 四、消息队列\n\n## 点对点模式\n\n一个生产者对一个消费者，就称为点对点模式\n\n![image-20220302144931640](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302144931640.png)\n\n## 发布订阅模式\n\n多个生产者对多个消费者的情况，就成为发布订阅模式的消息队列\n\n![image-20220302145010631](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145010631.png)\n\n# 五、Kafka系统架构\n\n![image-20220302145146617](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145146617.png)\n\n一个典型的Kafka集群包括：\n\n+ 若干个Producer（可以是Web前端的Page View，服务器日志，系统CPU，Memory等）；\n+ 若干个Broker（支持水平扩展，一般broker数量越多，集群吞吐率就越高）；\n+ 若干个Consumer Group：\n+ Zookeeper集群（选举leader，以及在Consumer Group发生变化时进行rebalalce）\n\n其中需要注意的是：Producer使用push模式推送消息，Consumer使用pull模式从broker订阅并消费消息；\n\n\n\n# 六、核心API\n\n有4个核心API，分别是：\n\n+ Producer API：允许应用程序向一个或者多个topics发送消息；\n+ Consumer API：允许应用程序向一个或多个topics并处理为其生成的记录流；\n+ Streams API：允许应用程序作为流处理器，从一个或多个主题中消费输入流并为其生成输出流，有效地将输入流转换为输出流；\n+ Connector API：允许构建和运行将Kafka主题连接到现有应用程序或数据系统的可用生产者和消费者；\n\n![image-20220302145817899](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145817899.png)\n\n\n\n# 七、Kafka为什么这么快\n\n实现了零拷贝原理来快速移动数据，避免内核之间的切换。Kafka将数据记录分批发送，从生产者到文件系统（Kafka主题日志）到消费者，可以端到端的查看这些批次的数据；\n\n总结下来就4个点：\n\n+ 顺序读写\n+ 零拷贝\n+ 消息压缩\n+ 分批发送\n\n","source":"_posts/middleware/kafka-learning.md","raw":"---\ntitle: Apache Kafka盘点\ndate: 2022-03-02 11:33:20\nupdated: 2022-03-02 11:33:20\ntags: Kafka\ncategories: 消息中间件\n---\n\n# 一、基本术语\n\n## 消息（Message）\n\nKafka中的数据单元称为`消息`，也被称为记录，可以把它看作数据库表中的某一行记录；\n\n## 批次（Batch）\n\n为了提高效率，消息会`分批次`写入Kafka，批次就代指的一组消息；\n\n## 主题（Topic）\n\n消息的种类为`主题`，可以说一个主题代表了一类消息。相当于对消息进行分类，主题就像数据库中的表；\n\n## 分区（Partition）\n\n主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现kafka的伸缩性，单一主题中的分区有序，但是无法保证主题中的所有分区有序；\n\n\n\n## 生产者（Producer）\n\n向主题发布消息的客户端应用程序称为生产者，生产者用于持续不断的向某个主题发送消息；\n\n## 消费者（Consumer）\n\n订阅主题消息的客户端称为消费者，消费者用于处理生产者产生的消息；\n\n## 消费者群组\n\n由一个或者多个消费者组成的群体；\n\n## 偏移量（Consumer Offset）\n\n一种元数据，是一个不断递增的整数值，用来记录消费者发生重平衡的位置，以便用来恢复数据；\n\n## Broker\n\n一个独立的Kafka服务器称为Broker，Broker接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；\n\n## Broker集群\n\n是集群的组成部分，有一个或者多个broker组成，每个集群都有一个broker同时充当集群控制器的角色（自动从集群的活跃成员中选举出来）；\n\n## 副本（Replica）\n\nKafka中消息备份叫副本，副本数量可以配置，并且Kafka定义了两类副本：领导者副本和追随者副本；前者对外提供服务，后者被动跟随；\n\n## 重平衡（Rebalance）\n\n消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalalce是Kafka消费者实现高可用的重要手段；\n\n\n\n# 二、Kafka的特性（设计原则）\n\n+ **高吞吐、低延迟：**收发消息快，每秒可以处理几十万条信息，最低延迟只有几毫秒；\n+ **高伸缩性：**每个主题包含多个分区，主题中的分区可以分布在不同的主机中；\n+ **持久性、可靠性：**允许数据持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka底层的数据存储是基于Zookeeper存储；\n+ **容错性：**允许集群中的节点失败，某个节点宕机，Kafka集群能够正常工作；\n+ **高并发：**支持数千个客户端同时读写；\n\n\n\n# 三、使用场景\n\n+ **活动跟踪：**例如跟踪用户行为；\n+ **消息传递：**例如应用程序的发送通知，不需要关心消息格式，不需要关心数据如何发送；\n+ **度量指标：**记录运营监控数据，包括收集各种分布式应用数据，生产各种操作的集中反馈，例如报警和报告；\n+ **日志记录：**日志提交，例如可以把数据库更新发送到Kafka上，记录数据库更新时间，通过Kafka以统一接口服务的方式开放给各种consumer，例如Handoop，Hbase和Solr等；\n+ **流式处理：**这个不清楚\n+ **限流削峰：**某一时刻请求特别多，可以将请求写入Kafka中，避免直接请求后端程序导致服务崩溃；\n\n\n\n# 四、消息队列\n\n## 点对点模式\n\n一个生产者对一个消费者，就称为点对点模式\n\n![image-20220302144931640](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302144931640.png)\n\n## 发布订阅模式\n\n多个生产者对多个消费者的情况，就成为发布订阅模式的消息队列\n\n![image-20220302145010631](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145010631.png)\n\n# 五、Kafka系统架构\n\n![image-20220302145146617](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145146617.png)\n\n一个典型的Kafka集群包括：\n\n+ 若干个Producer（可以是Web前端的Page View，服务器日志，系统CPU，Memory等）；\n+ 若干个Broker（支持水平扩展，一般broker数量越多，集群吞吐率就越高）；\n+ 若干个Consumer Group：\n+ Zookeeper集群（选举leader，以及在Consumer Group发生变化时进行rebalalce）\n\n其中需要注意的是：Producer使用push模式推送消息，Consumer使用pull模式从broker订阅并消费消息；\n\n\n\n# 六、核心API\n\n有4个核心API，分别是：\n\n+ Producer API：允许应用程序向一个或者多个topics发送消息；\n+ Consumer API：允许应用程序向一个或多个topics并处理为其生成的记录流；\n+ Streams API：允许应用程序作为流处理器，从一个或多个主题中消费输入流并为其生成输出流，有效地将输入流转换为输出流；\n+ Connector API：允许构建和运行将Kafka主题连接到现有应用程序或数据系统的可用生产者和消费者；\n\n![image-20220302145817899](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145817899.png)\n\n\n\n# 七、Kafka为什么这么快\n\n实现了零拷贝原理来快速移动数据，避免内核之间的切换。Kafka将数据记录分批发送，从生产者到文件系统（Kafka主题日志）到消费者，可以端到端的查看这些批次的数据；\n\n总结下来就4个点：\n\n+ 顺序读写\n+ 零拷贝\n+ 消息压缩\n+ 分批发送\n\n","slug":"middleware/kafka-learning","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v8000s4f61e0og2n6v","content":"<h1 id=\"一、基本术语\"><a href=\"#一、基本术语\" class=\"headerlink\" title=\"一、基本术语\"></a>一、基本术语</h1><h2 id=\"消息（Message）\"><a href=\"#消息（Message）\" class=\"headerlink\" title=\"消息（Message）\"></a>消息（Message）</h2><p>Kafka中的数据单元称为<code>消息</code>，也被称为记录，可以把它看作数据库表中的某一行记录；</p>\n<h2 id=\"批次（Batch）\"><a href=\"#批次（Batch）\" class=\"headerlink\" title=\"批次（Batch）\"></a>批次（Batch）</h2><p>为了提高效率，消息会<code>分批次</code>写入Kafka，批次就代指的一组消息；</p>\n<h2 id=\"主题（Topic）\"><a href=\"#主题（Topic）\" class=\"headerlink\" title=\"主题（Topic）\"></a>主题（Topic）</h2><p>消息的种类为<code>主题</code>，可以说一个主题代表了一类消息。相当于对消息进行分类，主题就像数据库中的表；</p>\n<h2 id=\"分区（Partition）\"><a href=\"#分区（Partition）\" class=\"headerlink\" title=\"分区（Partition）\"></a>分区（Partition）</h2><p>主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现kafka的伸缩性，单一主题中的分区有序，但是无法保证主题中的所有分区有序；</p>\n<h2 id=\"生产者（Producer）\"><a href=\"#生产者（Producer）\" class=\"headerlink\" title=\"生产者（Producer）\"></a>生产者（Producer）</h2><p>向主题发布消息的客户端应用程序称为生产者，生产者用于持续不断的向某个主题发送消息；</p>\n<h2 id=\"消费者（Consumer）\"><a href=\"#消费者（Consumer）\" class=\"headerlink\" title=\"消费者（Consumer）\"></a>消费者（Consumer）</h2><p>订阅主题消息的客户端称为消费者，消费者用于处理生产者产生的消息；</p>\n<h2 id=\"消费者群组\"><a href=\"#消费者群组\" class=\"headerlink\" title=\"消费者群组\"></a>消费者群组</h2><p>由一个或者多个消费者组成的群体；</p>\n<h2 id=\"偏移量（Consumer-Offset）\"><a href=\"#偏移量（Consumer-Offset）\" class=\"headerlink\" title=\"偏移量（Consumer Offset）\"></a>偏移量（Consumer Offset）</h2><p>一种元数据，是一个不断递增的整数值，用来记录消费者发生重平衡的位置，以便用来恢复数据；</p>\n<h2 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h2><p>一个独立的Kafka服务器称为Broker，Broker接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；</p>\n<h2 id=\"Broker集群\"><a href=\"#Broker集群\" class=\"headerlink\" title=\"Broker集群\"></a>Broker集群</h2><p>是集群的组成部分，有一个或者多个broker组成，每个集群都有一个broker同时充当集群控制器的角色（自动从集群的活跃成员中选举出来）；</p>\n<h2 id=\"副本（Replica）\"><a href=\"#副本（Replica）\" class=\"headerlink\" title=\"副本（Replica）\"></a>副本（Replica）</h2><p>Kafka中消息备份叫副本，副本数量可以配置，并且Kafka定义了两类副本：领导者副本和追随者副本；前者对外提供服务，后者被动跟随；</p>\n<h2 id=\"重平衡（Rebalance）\"><a href=\"#重平衡（Rebalance）\" class=\"headerlink\" title=\"重平衡（Rebalance）\"></a>重平衡（Rebalance）</h2><p>消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalalce是Kafka消费者实现高可用的重要手段；</p>\n<h1 id=\"二、Kafka的特性（设计原则）\"><a href=\"#二、Kafka的特性（设计原则）\" class=\"headerlink\" title=\"二、Kafka的特性（设计原则）\"></a>二、Kafka的特性（设计原则）</h1><ul>\n<li><strong>高吞吐、低延迟：</strong>收发消息快，每秒可以处理几十万条信息，最低延迟只有几毫秒；</li>\n<li><strong>高伸缩性：</strong>每个主题包含多个分区，主题中的分区可以分布在不同的主机中；</li>\n<li><strong>持久性、可靠性：</strong>允许数据持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka底层的数据存储是基于Zookeeper存储；</li>\n<li><strong>容错性：</strong>允许集群中的节点失败，某个节点宕机，Kafka集群能够正常工作；</li>\n<li><strong>高并发：</strong>支持数千个客户端同时读写；</li>\n</ul>\n<h1 id=\"三、使用场景\"><a href=\"#三、使用场景\" class=\"headerlink\" title=\"三、使用场景\"></a>三、使用场景</h1><ul>\n<li><strong>活动跟踪：</strong>例如跟踪用户行为；</li>\n<li><strong>消息传递：</strong>例如应用程序的发送通知，不需要关心消息格式，不需要关心数据如何发送；</li>\n<li><strong>度量指标：</strong>记录运营监控数据，包括收集各种分布式应用数据，生产各种操作的集中反馈，例如报警和报告；</li>\n<li><strong>日志记录：</strong>日志提交，例如可以把数据库更新发送到Kafka上，记录数据库更新时间，通过Kafka以统一接口服务的方式开放给各种consumer，例如Handoop，Hbase和Solr等；</li>\n<li><strong>流式处理：</strong>这个不清楚</li>\n<li><strong>限流削峰：</strong>某一时刻请求特别多，可以将请求写入Kafka中，避免直接请求后端程序导致服务崩溃；</li>\n</ul>\n<h1 id=\"四、消息队列\"><a href=\"#四、消息队列\" class=\"headerlink\" title=\"四、消息队列\"></a>四、消息队列</h1><h2 id=\"点对点模式\"><a href=\"#点对点模式\" class=\"headerlink\" title=\"点对点模式\"></a>点对点模式</h2><p>一个生产者对一个消费者，就称为点对点模式</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302144931640.png\" alt=\"image-20220302144931640\"></p>\n<h2 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h2><p>多个生产者对多个消费者的情况，就成为发布订阅模式的消息队列</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145010631.png\" alt=\"image-20220302145010631\"></p>\n<h1 id=\"五、Kafka系统架构\"><a href=\"#五、Kafka系统架构\" class=\"headerlink\" title=\"五、Kafka系统架构\"></a>五、Kafka系统架构</h1><p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145146617.png\" alt=\"image-20220302145146617\"></p>\n<p>一个典型的Kafka集群包括：</p>\n<ul>\n<li>若干个Producer（可以是Web前端的Page View，服务器日志，系统CPU，Memory等）；</li>\n<li>若干个Broker（支持水平扩展，一般broker数量越多，集群吞吐率就越高）；</li>\n<li>若干个Consumer Group：</li>\n<li>Zookeeper集群（选举leader，以及在Consumer Group发生变化时进行rebalalce）</li>\n</ul>\n<p>其中需要注意的是：Producer使用push模式推送消息，Consumer使用pull模式从broker订阅并消费消息；</p>\n<h1 id=\"六、核心API\"><a href=\"#六、核心API\" class=\"headerlink\" title=\"六、核心API\"></a>六、核心API</h1><p>有4个核心API，分别是：</p>\n<ul>\n<li>Producer API：允许应用程序向一个或者多个topics发送消息；</li>\n<li>Consumer API：允许应用程序向一个或多个topics并处理为其生成的记录流；</li>\n<li>Streams API：允许应用程序作为流处理器，从一个或多个主题中消费输入流并为其生成输出流，有效地将输入流转换为输出流；</li>\n<li>Connector API：允许构建和运行将Kafka主题连接到现有应用程序或数据系统的可用生产者和消费者；</li>\n</ul>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145817899.png\" alt=\"image-20220302145817899\"></p>\n<h1 id=\"七、Kafka为什么这么快\"><a href=\"#七、Kafka为什么这么快\" class=\"headerlink\" title=\"七、Kafka为什么这么快\"></a>七、Kafka为什么这么快</h1><p>实现了零拷贝原理来快速移动数据，避免内核之间的切换。Kafka将数据记录分批发送，从生产者到文件系统（Kafka主题日志）到消费者，可以端到端的查看这些批次的数据；</p>\n<p>总结下来就4个点：</p>\n<ul>\n<li>顺序读写</li>\n<li>零拷贝</li>\n<li>消息压缩</li>\n<li>分批发送</li>\n</ul>\n","site":{"data":{}},"wordcount":1849,"excerpt":"","more":"<h1 id=\"一、基本术语\"><a href=\"#一、基本术语\" class=\"headerlink\" title=\"一、基本术语\"></a>一、基本术语</h1><h2 id=\"消息（Message）\"><a href=\"#消息（Message）\" class=\"headerlink\" title=\"消息（Message）\"></a>消息（Message）</h2><p>Kafka中的数据单元称为<code>消息</code>，也被称为记录，可以把它看作数据库表中的某一行记录；</p>\n<h2 id=\"批次（Batch）\"><a href=\"#批次（Batch）\" class=\"headerlink\" title=\"批次（Batch）\"></a>批次（Batch）</h2><p>为了提高效率，消息会<code>分批次</code>写入Kafka，批次就代指的一组消息；</p>\n<h2 id=\"主题（Topic）\"><a href=\"#主题（Topic）\" class=\"headerlink\" title=\"主题（Topic）\"></a>主题（Topic）</h2><p>消息的种类为<code>主题</code>，可以说一个主题代表了一类消息。相当于对消息进行分类，主题就像数据库中的表；</p>\n<h2 id=\"分区（Partition）\"><a href=\"#分区（Partition）\" class=\"headerlink\" title=\"分区（Partition）\"></a>分区（Partition）</h2><p>主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现kafka的伸缩性，单一主题中的分区有序，但是无法保证主题中的所有分区有序；</p>\n<h2 id=\"生产者（Producer）\"><a href=\"#生产者（Producer）\" class=\"headerlink\" title=\"生产者（Producer）\"></a>生产者（Producer）</h2><p>向主题发布消息的客户端应用程序称为生产者，生产者用于持续不断的向某个主题发送消息；</p>\n<h2 id=\"消费者（Consumer）\"><a href=\"#消费者（Consumer）\" class=\"headerlink\" title=\"消费者（Consumer）\"></a>消费者（Consumer）</h2><p>订阅主题消息的客户端称为消费者，消费者用于处理生产者产生的消息；</p>\n<h2 id=\"消费者群组\"><a href=\"#消费者群组\" class=\"headerlink\" title=\"消费者群组\"></a>消费者群组</h2><p>由一个或者多个消费者组成的群体；</p>\n<h2 id=\"偏移量（Consumer-Offset）\"><a href=\"#偏移量（Consumer-Offset）\" class=\"headerlink\" title=\"偏移量（Consumer Offset）\"></a>偏移量（Consumer Offset）</h2><p>一种元数据，是一个不断递增的整数值，用来记录消费者发生重平衡的位置，以便用来恢复数据；</p>\n<h2 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h2><p>一个独立的Kafka服务器称为Broker，Broker接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；</p>\n<h2 id=\"Broker集群\"><a href=\"#Broker集群\" class=\"headerlink\" title=\"Broker集群\"></a>Broker集群</h2><p>是集群的组成部分，有一个或者多个broker组成，每个集群都有一个broker同时充当集群控制器的角色（自动从集群的活跃成员中选举出来）；</p>\n<h2 id=\"副本（Replica）\"><a href=\"#副本（Replica）\" class=\"headerlink\" title=\"副本（Replica）\"></a>副本（Replica）</h2><p>Kafka中消息备份叫副本，副本数量可以配置，并且Kafka定义了两类副本：领导者副本和追随者副本；前者对外提供服务，后者被动跟随；</p>\n<h2 id=\"重平衡（Rebalance）\"><a href=\"#重平衡（Rebalance）\" class=\"headerlink\" title=\"重平衡（Rebalance）\"></a>重平衡（Rebalance）</h2><p>消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalalce是Kafka消费者实现高可用的重要手段；</p>\n<h1 id=\"二、Kafka的特性（设计原则）\"><a href=\"#二、Kafka的特性（设计原则）\" class=\"headerlink\" title=\"二、Kafka的特性（设计原则）\"></a>二、Kafka的特性（设计原则）</h1><ul>\n<li><strong>高吞吐、低延迟：</strong>收发消息快，每秒可以处理几十万条信息，最低延迟只有几毫秒；</li>\n<li><strong>高伸缩性：</strong>每个主题包含多个分区，主题中的分区可以分布在不同的主机中；</li>\n<li><strong>持久性、可靠性：</strong>允许数据持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka底层的数据存储是基于Zookeeper存储；</li>\n<li><strong>容错性：</strong>允许集群中的节点失败，某个节点宕机，Kafka集群能够正常工作；</li>\n<li><strong>高并发：</strong>支持数千个客户端同时读写；</li>\n</ul>\n<h1 id=\"三、使用场景\"><a href=\"#三、使用场景\" class=\"headerlink\" title=\"三、使用场景\"></a>三、使用场景</h1><ul>\n<li><strong>活动跟踪：</strong>例如跟踪用户行为；</li>\n<li><strong>消息传递：</strong>例如应用程序的发送通知，不需要关心消息格式，不需要关心数据如何发送；</li>\n<li><strong>度量指标：</strong>记录运营监控数据，包括收集各种分布式应用数据，生产各种操作的集中反馈，例如报警和报告；</li>\n<li><strong>日志记录：</strong>日志提交，例如可以把数据库更新发送到Kafka上，记录数据库更新时间，通过Kafka以统一接口服务的方式开放给各种consumer，例如Handoop，Hbase和Solr等；</li>\n<li><strong>流式处理：</strong>这个不清楚</li>\n<li><strong>限流削峰：</strong>某一时刻请求特别多，可以将请求写入Kafka中，避免直接请求后端程序导致服务崩溃；</li>\n</ul>\n<h1 id=\"四、消息队列\"><a href=\"#四、消息队列\" class=\"headerlink\" title=\"四、消息队列\"></a>四、消息队列</h1><h2 id=\"点对点模式\"><a href=\"#点对点模式\" class=\"headerlink\" title=\"点对点模式\"></a>点对点模式</h2><p>一个生产者对一个消费者，就称为点对点模式</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302144931640.png\" alt=\"image-20220302144931640\"></p>\n<h2 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h2><p>多个生产者对多个消费者的情况，就成为发布订阅模式的消息队列</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145010631.png\" alt=\"image-20220302145010631\"></p>\n<h1 id=\"五、Kafka系统架构\"><a href=\"#五、Kafka系统架构\" class=\"headerlink\" title=\"五、Kafka系统架构\"></a>五、Kafka系统架构</h1><p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145146617.png\" alt=\"image-20220302145146617\"></p>\n<p>一个典型的Kafka集群包括：</p>\n<ul>\n<li>若干个Producer（可以是Web前端的Page View，服务器日志，系统CPU，Memory等）；</li>\n<li>若干个Broker（支持水平扩展，一般broker数量越多，集群吞吐率就越高）；</li>\n<li>若干个Consumer Group：</li>\n<li>Zookeeper集群（选举leader，以及在Consumer Group发生变化时进行rebalalce）</li>\n</ul>\n<p>其中需要注意的是：Producer使用push模式推送消息，Consumer使用pull模式从broker订阅并消费消息；</p>\n<h1 id=\"六、核心API\"><a href=\"#六、核心API\" class=\"headerlink\" title=\"六、核心API\"></a>六、核心API</h1><p>有4个核心API，分别是：</p>\n<ul>\n<li>Producer API：允许应用程序向一个或者多个topics发送消息；</li>\n<li>Consumer API：允许应用程序向一个或多个topics并处理为其生成的记录流；</li>\n<li>Streams API：允许应用程序作为流处理器，从一个或多个主题中消费输入流并为其生成输出流，有效地将输入流转换为输出流；</li>\n<li>Connector API：允许构建和运行将Kafka主题连接到现有应用程序或数据系统的可用生产者和消费者；</li>\n</ul>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220302145817899.png\" alt=\"image-20220302145817899\"></p>\n<h1 id=\"七、Kafka为什么这么快\"><a href=\"#七、Kafka为什么这么快\" class=\"headerlink\" title=\"七、Kafka为什么这么快\"></a>七、Kafka为什么这么快</h1><p>实现了零拷贝原理来快速移动数据，避免内核之间的切换。Kafka将数据记录分批发送，从生产者到文件系统（Kafka主题日志）到消费者，可以端到端的查看这些批次的数据；</p>\n<p>总结下来就4个点：</p>\n<ul>\n<li>顺序读写</li>\n<li>零拷贝</li>\n<li>消息压缩</li>\n<li>分批发送</li>\n</ul>\n"},{"title":"Redis盘点梳理","date":"2022-02-21T13:41:10.000Z","updated":"2022-02-21T13:41:10.000Z","_content":"\n# Redis数据类型\n\n## 基础数据类型\n\n+ 字符串 String\n+ 列表 List\n+ 哈希 Hash\n+ 集合 Set\n+ 有序集合 Zset\n+ **Bitmaps**\n+ **HyperLogLogs**\n+ **GEO**\n\n## 底层数据类型\n\n+ 简单动态数组 SDS\n+ 链表\n+ 字典\n+ 跳跃链表\n+ 整数集合\n+ 压缩列表\n+ 对象\n\n![image-20220311151509865](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220311151509865.png)\n\nziplist压缩列表可以作为Zset、Hash、List三种数据类型的底层实现，其中Zset使用到了跳跃链表；\n\n# SDS (Simple Dynamic String)\n\n## 什么是SDS\n\nSDS是Redis中String类型数据的数据结构，Redis作者没有使用C字符串，而是自己设计了一种数据结构来存储字符串数据；\n\n```c\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n}\n```\n\n贴个图来展示SDS的数据结构：\n\n![image-20220312181132451](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312181132451.png)\n\n这里说一下flags，在Redis中当你给String赋值不同类型的字符，它所展示的数据类型是不同的；\n\n![image-20220312181513762](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312181513762.png)\n\n## SDS和C字符串的区别\n\n+ **获取字符串的长度：**O(1)，C字符串是O(N)；\n+ **缓冲区溢出：**API是安全的，不会造成缓冲区溢出，C字符串会；\n+ **惰性分配：**修改N次长度最多需要进行N次内存重分配；而C字符串是必然会进行N次内存分配；\n+ **数据存储：**C字符串只能存储文本数据，SDS既可以存储文本也可以存储二进制数据；\n\n## SDS的优点\n\n+ 常数获取字符串的复杂度，无需遍历；\n+ 杜绝缓冲区溢出；\n+ 减少修改字符串修改分配内存的次数；\n+ 二进制安全；\n+ 兼容部分C字符串；\n\n# 链表\n\n链表的数据结构在我们日常的使用中已经非常常见了，所以这里我稍微介绍一点Redis中所不同的概念：\n\n```C\ntypedef struct listNode {\n    // 前置节点\n    struct listNode* prev;\n    // 后置节点\n    struct listNode* next;\n    // 节点值\n    void* value;\n}listNode;\n\ntypedef struct list {\n    // 表头节点\n    listNode* head;\n    // 表尾节点\n    listNode* tail;\n    // 节点值复制函数\n    void* (*dup)(void* ptr);\n    // 节点值释放函数\n    void* (*free)(void* ptr);\n    // 节点值对比函数\n    void* (*match)(void* ptr);\n    // 链表包含的节点数量\n    unsigned long len;\n}list;\n```\n\n![image-20220312185100094](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312185100094.png)\n\n可以总结出Redis的链表存在下列特点：\n\n+ 存在prev和next指针，因此获取某个节点的前置和后置节点时间复杂度都是O(1)；\n+ 表头的prev指针和表尾的next指针都指向NULL，所以它一定是无环结构；\n+ 存在表头和表尾指针，因此获取链表的头节点和尾节点时间复杂度都是O(1)；\n+ 自带链表长度的计数器，获取链表长度的时间复杂度也是O(1)；\n+ 使用void*保存节点值，所以可以存储不同类型的数据；\n\n基于上述特点，我们可以发现链表广泛使用发布订阅、慢查询、监视器以及列表键。（为什么呢？）\n\n因为上述数据结构采用了空间换时间的概念，所以在数据量大的情况下使用链表能够很好的提高性能；而在数据量较小的时候，这种浪费就显得没有必要了，一般会使用压缩链表来实现；\n\n# 字典\n\n字典是一种用于保存键值对的抽象数据结构；字典中每个键都是独一无二的，程序可以在字典中根据键值查找与之相关联的值；同样C语言没有内置这种数据结构，Redis自己实现了字典；\n\n## 字典底层的数据结构\n\n字典使用了哈希表作为底层实现，一个哈希表可以有多个哈希节点，每个哈希表节点保存了字典的键值对；\n\n# Redis缓存\n\n## Redis缓存雪崩\n\n### 成因\n\n同一时间大批量数据失效导致Redis变成不存在，请求压力全部落到数据源导致系统压力增加；\n\n### 解决方案\n\n分布式部署，设置热点数据永不过期，有更新操作再刷新Redis缓存，或者是给Redis缓存key失效时间加随机值\n\n\n\n## Redis缓存击穿\n\n### 成因\n\n某个热点数据失效，大量针对这个数据的请求会穿透缓存到数据库\n\n### 解决方案\n\n可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。\n\n使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。\n\n针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。\n\n\n\n## Redis缓存穿透\n\n### 成因\n\n缓存和数据库中都没有的数据，用户不断发起请求，导致数据库的压力增大，从而搞垮系统；一般出现这种情况是因为没有对参数做校验导致。\n\n### 解决方案\n\n+ 对于不存在的用户，在缓存中保存一个空对象标记，防止相同ID再次访问DB；但是这个方法不能解决问题；\n\n+ 使用布隆过滤器，特点是数据的唯一性校验，存在为true，不存在为false，非常适合解决这些问题；\n\n\n\n# Redis持久化操作\n\nRDB：**RDB** 持久化机制，是对 **Redis** 中的数据执行**周期性**的持久化。\n\nAOF：**AOF** 机制对每条写入命令作为日志，以 **append-only** 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的**binlog**。\n\n## RDB\n\n\n\n## AOF\n","source":"_posts/middleware/redis-learning.md","raw":"---\ntitle: Redis盘点梳理\ndate: 2022-02-21 21:41:10\nupdated: 2022-02-21 21:41:10\ntags: Redis\ncategories: 消息中间件\n---\n\n# Redis数据类型\n\n## 基础数据类型\n\n+ 字符串 String\n+ 列表 List\n+ 哈希 Hash\n+ 集合 Set\n+ 有序集合 Zset\n+ **Bitmaps**\n+ **HyperLogLogs**\n+ **GEO**\n\n## 底层数据类型\n\n+ 简单动态数组 SDS\n+ 链表\n+ 字典\n+ 跳跃链表\n+ 整数集合\n+ 压缩列表\n+ 对象\n\n![image-20220311151509865](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220311151509865.png)\n\nziplist压缩列表可以作为Zset、Hash、List三种数据类型的底层实现，其中Zset使用到了跳跃链表；\n\n# SDS (Simple Dynamic String)\n\n## 什么是SDS\n\nSDS是Redis中String类型数据的数据结构，Redis作者没有使用C字符串，而是自己设计了一种数据结构来存储字符串数据；\n\n```c\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n}\n```\n\n贴个图来展示SDS的数据结构：\n\n![image-20220312181132451](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312181132451.png)\n\n这里说一下flags，在Redis中当你给String赋值不同类型的字符，它所展示的数据类型是不同的；\n\n![image-20220312181513762](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312181513762.png)\n\n## SDS和C字符串的区别\n\n+ **获取字符串的长度：**O(1)，C字符串是O(N)；\n+ **缓冲区溢出：**API是安全的，不会造成缓冲区溢出，C字符串会；\n+ **惰性分配：**修改N次长度最多需要进行N次内存重分配；而C字符串是必然会进行N次内存分配；\n+ **数据存储：**C字符串只能存储文本数据，SDS既可以存储文本也可以存储二进制数据；\n\n## SDS的优点\n\n+ 常数获取字符串的复杂度，无需遍历；\n+ 杜绝缓冲区溢出；\n+ 减少修改字符串修改分配内存的次数；\n+ 二进制安全；\n+ 兼容部分C字符串；\n\n# 链表\n\n链表的数据结构在我们日常的使用中已经非常常见了，所以这里我稍微介绍一点Redis中所不同的概念：\n\n```C\ntypedef struct listNode {\n    // 前置节点\n    struct listNode* prev;\n    // 后置节点\n    struct listNode* next;\n    // 节点值\n    void* value;\n}listNode;\n\ntypedef struct list {\n    // 表头节点\n    listNode* head;\n    // 表尾节点\n    listNode* tail;\n    // 节点值复制函数\n    void* (*dup)(void* ptr);\n    // 节点值释放函数\n    void* (*free)(void* ptr);\n    // 节点值对比函数\n    void* (*match)(void* ptr);\n    // 链表包含的节点数量\n    unsigned long len;\n}list;\n```\n\n![image-20220312185100094](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312185100094.png)\n\n可以总结出Redis的链表存在下列特点：\n\n+ 存在prev和next指针，因此获取某个节点的前置和后置节点时间复杂度都是O(1)；\n+ 表头的prev指针和表尾的next指针都指向NULL，所以它一定是无环结构；\n+ 存在表头和表尾指针，因此获取链表的头节点和尾节点时间复杂度都是O(1)；\n+ 自带链表长度的计数器，获取链表长度的时间复杂度也是O(1)；\n+ 使用void*保存节点值，所以可以存储不同类型的数据；\n\n基于上述特点，我们可以发现链表广泛使用发布订阅、慢查询、监视器以及列表键。（为什么呢？）\n\n因为上述数据结构采用了空间换时间的概念，所以在数据量大的情况下使用链表能够很好的提高性能；而在数据量较小的时候，这种浪费就显得没有必要了，一般会使用压缩链表来实现；\n\n# 字典\n\n字典是一种用于保存键值对的抽象数据结构；字典中每个键都是独一无二的，程序可以在字典中根据键值查找与之相关联的值；同样C语言没有内置这种数据结构，Redis自己实现了字典；\n\n## 字典底层的数据结构\n\n字典使用了哈希表作为底层实现，一个哈希表可以有多个哈希节点，每个哈希表节点保存了字典的键值对；\n\n# Redis缓存\n\n## Redis缓存雪崩\n\n### 成因\n\n同一时间大批量数据失效导致Redis变成不存在，请求压力全部落到数据源导致系统压力增加；\n\n### 解决方案\n\n分布式部署，设置热点数据永不过期，有更新操作再刷新Redis缓存，或者是给Redis缓存key失效时间加随机值\n\n\n\n## Redis缓存击穿\n\n### 成因\n\n某个热点数据失效，大量针对这个数据的请求会穿透缓存到数据库\n\n### 解决方案\n\n可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。\n\n使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。\n\n针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。\n\n\n\n## Redis缓存穿透\n\n### 成因\n\n缓存和数据库中都没有的数据，用户不断发起请求，导致数据库的压力增大，从而搞垮系统；一般出现这种情况是因为没有对参数做校验导致。\n\n### 解决方案\n\n+ 对于不存在的用户，在缓存中保存一个空对象标记，防止相同ID再次访问DB；但是这个方法不能解决问题；\n\n+ 使用布隆过滤器，特点是数据的唯一性校验，存在为true，不存在为false，非常适合解决这些问题；\n\n\n\n# Redis持久化操作\n\nRDB：**RDB** 持久化机制，是对 **Redis** 中的数据执行**周期性**的持久化。\n\nAOF：**AOF** 机制对每条写入命令作为日志，以 **append-only** 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的**binlog**。\n\n## RDB\n\n\n\n## AOF\n","slug":"middleware/redis-learning","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v9000w4f61gyuwahup","content":"<h1 id=\"Redis数据类型\"><a href=\"#Redis数据类型\" class=\"headerlink\" title=\"Redis数据类型\"></a>Redis数据类型</h1><h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><ul>\n<li>字符串 String</li>\n<li>列表 List</li>\n<li>哈希 Hash</li>\n<li>集合 Set</li>\n<li>有序集合 Zset</li>\n<li><strong>Bitmaps</strong></li>\n<li><strong>HyperLogLogs</strong></li>\n<li><strong>GEO</strong></li>\n</ul>\n<h2 id=\"底层数据类型\"><a href=\"#底层数据类型\" class=\"headerlink\" title=\"底层数据类型\"></a>底层数据类型</h2><ul>\n<li>简单动态数组 SDS</li>\n<li>链表</li>\n<li>字典</li>\n<li>跳跃链表</li>\n<li>整数集合</li>\n<li>压缩列表</li>\n<li>对象</li>\n</ul>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220311151509865.png\" alt=\"image-20220311151509865\"></p>\n<p>ziplist压缩列表可以作为Zset、Hash、List三种数据类型的底层实现，其中Zset使用到了跳跃链表；</p>\n<h1 id=\"SDS-Simple-Dynamic-String\"><a href=\"#SDS-Simple-Dynamic-String\" class=\"headerlink\" title=\"SDS (Simple Dynamic String)\"></a>SDS (Simple Dynamic String)</h1><h2 id=\"什么是SDS\"><a href=\"#什么是SDS\" class=\"headerlink\" title=\"什么是SDS\"></a>什么是SDS</h2><p>SDS是Redis中String类型数据的数据结构，Redis作者没有使用C字符串，而是自己设计了一种数据结构来存储字符串数据；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> __<span class=\"hljs-title\">attribute__</span> ((__<span class=\"hljs-title\">packed__</span>)) <span class=\"hljs-title\">sdshdr8</span> &#123;</span><br>    <span class=\"hljs-type\">uint8_t</span> len; <span class=\"hljs-comment\">/* used */</span><br>    <span class=\"hljs-type\">uint8_t</span> alloc; <span class=\"hljs-comment\">/* excluding the header and null terminator */</span><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> flags; <span class=\"hljs-comment\">/* 3 lsb of type, 5 unused bits */</span><br>    <span class=\"hljs-type\">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>贴个图来展示SDS的数据结构：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312181132451.png\" alt=\"image-20220312181132451\"></p>\n<p>这里说一下flags，在Redis中当你给String赋值不同类型的字符，它所展示的数据类型是不同的；</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312181513762.png\" alt=\"image-20220312181513762\"></p>\n<h2 id=\"SDS和C字符串的区别\"><a href=\"#SDS和C字符串的区别\" class=\"headerlink\" title=\"SDS和C字符串的区别\"></a>SDS和C字符串的区别</h2><ul>\n<li><strong>获取字符串的长度：</strong>O(1)，C字符串是O(N)；</li>\n<li><strong>缓冲区溢出：</strong>API是安全的，不会造成缓冲区溢出，C字符串会；</li>\n<li><strong>惰性分配：</strong>修改N次长度最多需要进行N次内存重分配；而C字符串是必然会进行N次内存分配；</li>\n<li><strong>数据存储：</strong>C字符串只能存储文本数据，SDS既可以存储文本也可以存储二进制数据；</li>\n</ul>\n<h2 id=\"SDS的优点\"><a href=\"#SDS的优点\" class=\"headerlink\" title=\"SDS的优点\"></a>SDS的优点</h2><ul>\n<li>常数获取字符串的复杂度，无需遍历；</li>\n<li>杜绝缓冲区溢出；</li>\n<li>减少修改字符串修改分配内存的次数；</li>\n<li>二进制安全；</li>\n<li>兼容部分C字符串；</li>\n</ul>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>链表的数据结构在我们日常的使用中已经非常常见了，所以这里我稍微介绍一点Redis中所不同的概念：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">listNode</span> &#123;</span><br>    <span class=\"hljs-comment\">// 前置节点</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">listNode</span>* <span class=\"hljs-title\">prev</span>;</span><br>    <span class=\"hljs-comment\">// 后置节点</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">listNode</span>* <span class=\"hljs-title\">next</span>;</span><br>    <span class=\"hljs-comment\">// 节点值</span><br>    <span class=\"hljs-type\">void</span>* value;<br>&#125;listNode;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list</span> &#123;</span><br>    <span class=\"hljs-comment\">// 表头节点</span><br>    listNode* head;<br>    <span class=\"hljs-comment\">// 表尾节点</span><br>    listNode* tail;<br>    <span class=\"hljs-comment\">// 节点值复制函数</span><br>    <span class=\"hljs-type\">void</span>* (*dup)(<span class=\"hljs-type\">void</span>* ptr);<br>    <span class=\"hljs-comment\">// 节点值释放函数</span><br>    <span class=\"hljs-type\">void</span>* (*<span class=\"hljs-built_in\">free</span>)(<span class=\"hljs-type\">void</span>* ptr);<br>    <span class=\"hljs-comment\">// 节点值对比函数</span><br>    <span class=\"hljs-type\">void</span>* (*match)(<span class=\"hljs-type\">void</span>* ptr);<br>    <span class=\"hljs-comment\">// 链表包含的节点数量</span><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> len;<br>&#125;<span class=\"hljs-built_in\">list</span>;<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312185100094.png\" alt=\"image-20220312185100094\"></p>\n<p>可以总结出Redis的链表存在下列特点：</p>\n<ul>\n<li>存在prev和next指针，因此获取某个节点的前置和后置节点时间复杂度都是O(1)；</li>\n<li>表头的prev指针和表尾的next指针都指向NULL，所以它一定是无环结构；</li>\n<li>存在表头和表尾指针，因此获取链表的头节点和尾节点时间复杂度都是O(1)；</li>\n<li>自带链表长度的计数器，获取链表长度的时间复杂度也是O(1)；</li>\n<li>使用void*保存节点值，所以可以存储不同类型的数据；</li>\n</ul>\n<p>基于上述特点，我们可以发现链表广泛使用发布订阅、慢查询、监视器以及列表键。（为什么呢？）</p>\n<p>因为上述数据结构采用了空间换时间的概念，所以在数据量大的情况下使用链表能够很好的提高性能；而在数据量较小的时候，这种浪费就显得没有必要了，一般会使用压缩链表来实现；</p>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><p>字典是一种用于保存键值对的抽象数据结构；字典中每个键都是独一无二的，程序可以在字典中根据键值查找与之相关联的值；同样C语言没有内置这种数据结构，Redis自己实现了字典；</p>\n<h2 id=\"字典底层的数据结构\"><a href=\"#字典底层的数据结构\" class=\"headerlink\" title=\"字典底层的数据结构\"></a>字典底层的数据结构</h2><p>字典使用了哈希表作为底层实现，一个哈希表可以有多个哈希节点，每个哈希表节点保存了字典的键值对；</p>\n<h1 id=\"Redis缓存\"><a href=\"#Redis缓存\" class=\"headerlink\" title=\"Redis缓存\"></a>Redis缓存</h1><h2 id=\"Redis缓存雪崩\"><a href=\"#Redis缓存雪崩\" class=\"headerlink\" title=\"Redis缓存雪崩\"></a>Redis缓存雪崩</h2><h3 id=\"成因\"><a href=\"#成因\" class=\"headerlink\" title=\"成因\"></a>成因</h3><p>同一时间大批量数据失效导致Redis变成不存在，请求压力全部落到数据源导致系统压力增加；</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>分布式部署，设置热点数据永不过期，有更新操作再刷新Redis缓存，或者是给Redis缓存key失效时间加随机值</p>\n<h2 id=\"Redis缓存击穿\"><a href=\"#Redis缓存击穿\" class=\"headerlink\" title=\"Redis缓存击穿\"></a>Redis缓存击穿</h2><h3 id=\"成因-1\"><a href=\"#成因-1\" class=\"headerlink\" title=\"成因\"></a>成因</h3><p>某个热点数据失效，大量针对这个数据的请求会穿透缓存到数据库</p>\n<h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。</p>\n<p>使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。</p>\n<p>针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。</p>\n<h2 id=\"Redis缓存穿透\"><a href=\"#Redis缓存穿透\" class=\"headerlink\" title=\"Redis缓存穿透\"></a>Redis缓存穿透</h2><h3 id=\"成因-2\"><a href=\"#成因-2\" class=\"headerlink\" title=\"成因\"></a>成因</h3><p>缓存和数据库中都没有的数据，用户不断发起请求，导致数据库的压力增大，从而搞垮系统；一般出现这种情况是因为没有对参数做校验导致。</p>\n<h3 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li><p>对于不存在的用户，在缓存中保存一个空对象标记，防止相同ID再次访问DB；但是这个方法不能解决问题；</p>\n</li>\n<li><p>使用布隆过滤器，特点是数据的唯一性校验，存在为true，不存在为false，非常适合解决这些问题；</p>\n</li>\n</ul>\n<h1 id=\"Redis持久化操作\"><a href=\"#Redis持久化操作\" class=\"headerlink\" title=\"Redis持久化操作\"></a>Redis持久化操作</h1><p>RDB：<strong>RDB</strong> 持久化机制，是对 <strong>Redis</strong> 中的数据执行<strong>周期性</strong>的持久化。</p>\n<p>AOF：<strong>AOF</strong> 机制对每条写入命令作为日志，以 <strong>append-only</strong> 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的<strong>binlog</strong>。</p>\n<h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2>","site":{"data":{}},"wordcount":2195,"excerpt":"","more":"<h1 id=\"Redis数据类型\"><a href=\"#Redis数据类型\" class=\"headerlink\" title=\"Redis数据类型\"></a>Redis数据类型</h1><h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><ul>\n<li>字符串 String</li>\n<li>列表 List</li>\n<li>哈希 Hash</li>\n<li>集合 Set</li>\n<li>有序集合 Zset</li>\n<li><strong>Bitmaps</strong></li>\n<li><strong>HyperLogLogs</strong></li>\n<li><strong>GEO</strong></li>\n</ul>\n<h2 id=\"底层数据类型\"><a href=\"#底层数据类型\" class=\"headerlink\" title=\"底层数据类型\"></a>底层数据类型</h2><ul>\n<li>简单动态数组 SDS</li>\n<li>链表</li>\n<li>字典</li>\n<li>跳跃链表</li>\n<li>整数集合</li>\n<li>压缩列表</li>\n<li>对象</li>\n</ul>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220311151509865.png\" alt=\"image-20220311151509865\"></p>\n<p>ziplist压缩列表可以作为Zset、Hash、List三种数据类型的底层实现，其中Zset使用到了跳跃链表；</p>\n<h1 id=\"SDS-Simple-Dynamic-String\"><a href=\"#SDS-Simple-Dynamic-String\" class=\"headerlink\" title=\"SDS (Simple Dynamic String)\"></a>SDS (Simple Dynamic String)</h1><h2 id=\"什么是SDS\"><a href=\"#什么是SDS\" class=\"headerlink\" title=\"什么是SDS\"></a>什么是SDS</h2><p>SDS是Redis中String类型数据的数据结构，Redis作者没有使用C字符串，而是自己设计了一种数据结构来存储字符串数据；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> __<span class=\"hljs-title\">attribute__</span> ((__<span class=\"hljs-title\">packed__</span>)) <span class=\"hljs-title\">sdshdr8</span> &#123;</span><br>    <span class=\"hljs-type\">uint8_t</span> len; <span class=\"hljs-comment\">/* used */</span><br>    <span class=\"hljs-type\">uint8_t</span> alloc; <span class=\"hljs-comment\">/* excluding the header and null terminator */</span><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> flags; <span class=\"hljs-comment\">/* 3 lsb of type, 5 unused bits */</span><br>    <span class=\"hljs-type\">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>贴个图来展示SDS的数据结构：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312181132451.png\" alt=\"image-20220312181132451\"></p>\n<p>这里说一下flags，在Redis中当你给String赋值不同类型的字符，它所展示的数据类型是不同的；</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312181513762.png\" alt=\"image-20220312181513762\"></p>\n<h2 id=\"SDS和C字符串的区别\"><a href=\"#SDS和C字符串的区别\" class=\"headerlink\" title=\"SDS和C字符串的区别\"></a>SDS和C字符串的区别</h2><ul>\n<li><strong>获取字符串的长度：</strong>O(1)，C字符串是O(N)；</li>\n<li><strong>缓冲区溢出：</strong>API是安全的，不会造成缓冲区溢出，C字符串会；</li>\n<li><strong>惰性分配：</strong>修改N次长度最多需要进行N次内存重分配；而C字符串是必然会进行N次内存分配；</li>\n<li><strong>数据存储：</strong>C字符串只能存储文本数据，SDS既可以存储文本也可以存储二进制数据；</li>\n</ul>\n<h2 id=\"SDS的优点\"><a href=\"#SDS的优点\" class=\"headerlink\" title=\"SDS的优点\"></a>SDS的优点</h2><ul>\n<li>常数获取字符串的复杂度，无需遍历；</li>\n<li>杜绝缓冲区溢出；</li>\n<li>减少修改字符串修改分配内存的次数；</li>\n<li>二进制安全；</li>\n<li>兼容部分C字符串；</li>\n</ul>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>链表的数据结构在我们日常的使用中已经非常常见了，所以这里我稍微介绍一点Redis中所不同的概念：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">listNode</span> &#123;</span><br>    <span class=\"hljs-comment\">// 前置节点</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">listNode</span>* <span class=\"hljs-title\">prev</span>;</span><br>    <span class=\"hljs-comment\">// 后置节点</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">listNode</span>* <span class=\"hljs-title\">next</span>;</span><br>    <span class=\"hljs-comment\">// 节点值</span><br>    <span class=\"hljs-type\">void</span>* value;<br>&#125;listNode;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list</span> &#123;</span><br>    <span class=\"hljs-comment\">// 表头节点</span><br>    listNode* head;<br>    <span class=\"hljs-comment\">// 表尾节点</span><br>    listNode* tail;<br>    <span class=\"hljs-comment\">// 节点值复制函数</span><br>    <span class=\"hljs-type\">void</span>* (*dup)(<span class=\"hljs-type\">void</span>* ptr);<br>    <span class=\"hljs-comment\">// 节点值释放函数</span><br>    <span class=\"hljs-type\">void</span>* (*<span class=\"hljs-built_in\">free</span>)(<span class=\"hljs-type\">void</span>* ptr);<br>    <span class=\"hljs-comment\">// 节点值对比函数</span><br>    <span class=\"hljs-type\">void</span>* (*match)(<span class=\"hljs-type\">void</span>* ptr);<br>    <span class=\"hljs-comment\">// 链表包含的节点数量</span><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> len;<br>&#125;<span class=\"hljs-built_in\">list</span>;<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220312185100094.png\" alt=\"image-20220312185100094\"></p>\n<p>可以总结出Redis的链表存在下列特点：</p>\n<ul>\n<li>存在prev和next指针，因此获取某个节点的前置和后置节点时间复杂度都是O(1)；</li>\n<li>表头的prev指针和表尾的next指针都指向NULL，所以它一定是无环结构；</li>\n<li>存在表头和表尾指针，因此获取链表的头节点和尾节点时间复杂度都是O(1)；</li>\n<li>自带链表长度的计数器，获取链表长度的时间复杂度也是O(1)；</li>\n<li>使用void*保存节点值，所以可以存储不同类型的数据；</li>\n</ul>\n<p>基于上述特点，我们可以发现链表广泛使用发布订阅、慢查询、监视器以及列表键。（为什么呢？）</p>\n<p>因为上述数据结构采用了空间换时间的概念，所以在数据量大的情况下使用链表能够很好的提高性能；而在数据量较小的时候，这种浪费就显得没有必要了，一般会使用压缩链表来实现；</p>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><p>字典是一种用于保存键值对的抽象数据结构；字典中每个键都是独一无二的，程序可以在字典中根据键值查找与之相关联的值；同样C语言没有内置这种数据结构，Redis自己实现了字典；</p>\n<h2 id=\"字典底层的数据结构\"><a href=\"#字典底层的数据结构\" class=\"headerlink\" title=\"字典底层的数据结构\"></a>字典底层的数据结构</h2><p>字典使用了哈希表作为底层实现，一个哈希表可以有多个哈希节点，每个哈希表节点保存了字典的键值对；</p>\n<h1 id=\"Redis缓存\"><a href=\"#Redis缓存\" class=\"headerlink\" title=\"Redis缓存\"></a>Redis缓存</h1><h2 id=\"Redis缓存雪崩\"><a href=\"#Redis缓存雪崩\" class=\"headerlink\" title=\"Redis缓存雪崩\"></a>Redis缓存雪崩</h2><h3 id=\"成因\"><a href=\"#成因\" class=\"headerlink\" title=\"成因\"></a>成因</h3><p>同一时间大批量数据失效导致Redis变成不存在，请求压力全部落到数据源导致系统压力增加；</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>分布式部署，设置热点数据永不过期，有更新操作再刷新Redis缓存，或者是给Redis缓存key失效时间加随机值</p>\n<h2 id=\"Redis缓存击穿\"><a href=\"#Redis缓存击穿\" class=\"headerlink\" title=\"Redis缓存击穿\"></a>Redis缓存击穿</h2><h3 id=\"成因-1\"><a href=\"#成因-1\" class=\"headerlink\" title=\"成因\"></a>成因</h3><p>某个热点数据失效，大量针对这个数据的请求会穿透缓存到数据库</p>\n<h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。</p>\n<p>使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。</p>\n<p>针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。</p>\n<h2 id=\"Redis缓存穿透\"><a href=\"#Redis缓存穿透\" class=\"headerlink\" title=\"Redis缓存穿透\"></a>Redis缓存穿透</h2><h3 id=\"成因-2\"><a href=\"#成因-2\" class=\"headerlink\" title=\"成因\"></a>成因</h3><p>缓存和数据库中都没有的数据，用户不断发起请求，导致数据库的压力增大，从而搞垮系统；一般出现这种情况是因为没有对参数做校验导致。</p>\n<h3 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li><p>对于不存在的用户，在缓存中保存一个空对象标记，防止相同ID再次访问DB；但是这个方法不能解决问题；</p>\n</li>\n<li><p>使用布隆过滤器，特点是数据的唯一性校验，存在为true，不存在为false，非常适合解决这些问题；</p>\n</li>\n</ul>\n<h1 id=\"Redis持久化操作\"><a href=\"#Redis持久化操作\" class=\"headerlink\" title=\"Redis持久化操作\"></a>Redis持久化操作</h1><p>RDB：<strong>RDB</strong> 持久化机制，是对 <strong>Redis</strong> 中的数据执行<strong>周期性</strong>的持久化。</p>\n<p>AOF：<strong>AOF</strong> 机制对每条写入命令作为日志，以 <strong>append-only</strong> 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的<strong>binlog</strong>。</p>\n<h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2>"},{"title":"ES6 数组扩展","date":"2022-02-17T07:06:02.000Z","updated":"2022-02-17T07:06:02.000Z","_content":"\n# 数组扩展\n\n## Array.from()\n\n用于将类似数组的对象和可遍历的对象（部署了Iterator接口）转换为数组。例子如下：\n\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5\nvar arr1 = [].slice.call(arrayLike);\n\n// ES6\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n\n实际应用中，常见的类似数组对象是DOM操作返回的NodeList集合以及函数内部arguments对象。Array.from都可以将它们转为真正的数组。\n\n```javascript\nlet ps = document.querySelectorAll('p');\nArray.from(ps).forEach(function (p) {\n    console.log(p);\n});\n\nfunction add(a, b) {\n    var args = Array.from(arguments);\n    console.log(args);\n    return a + b;\n}\n\nadd(1, 2);\n// [1, 2]\n// 3\n\n// 字符串和Set都部署了Iterator接口，所以可以用Array.from生成数组，这点和Java很像\nArray.from('hello'); // ['h', 'e', 'l', 'l', 'o']\nlet nameSet = new Set(['a', 'b']);\nArray.from(nameSet) // ['a', 'b']\n```\n\n除此之外，扩展运算符`...`也可以将某些数据结构转换为数组（注：扩展运算符跟Java中的多参数表达式功能类似）。扩展运算符背地也是调用Iterator接口，如果对象没有部署这个接口，则无法完成转换；\n\n```javascript\nfunction foo () {\n    var args = [...arguments];\n}\n\n[...document.querySelectorAll('div')]\n```\n\n## Array.of()\n\nArray.of用于将一组值，转换为数组；这个方法的主要目的是弥补Array()方法的不足。因为参数个数的不同，会导致Array()的行为有差异。\n\n```javascript\nArray.of(3, 11, 8); // [3, 11, 8]\nArray(3, 11, 8); // [3, 11, 8]\nArray(3); // [, , ,] 长度为3的空数组\nArray.of(3); // [3] 长度为1的数组，只有一个元素3\n```\n\n## 数组实例的copyWithin()\n\n在当前数组的内部，将指定位置的成员复制到其他位置，然后返回当前数组。也就是说该方法会修改当前数组。\n\n```javascript\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n// target（必需）：从该位置开始替换数据\n// start（可选）：从该位置开始读取数据，默认为0，如果为负值则表示倒数；\n// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数；\n\n[1, 2, 3, 4, 5].copyWithin(0, 3); // [4, 5, 3, 4, 5]\n```\n\n## 数组实例find()和findIndex()\n\n`find()`方法用于找出第一个符合条件的数组成员。其第一个参数是回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没找到符合条件的成员则返回`undefined`。\n\n`findIndex()`方法的作用与`find()`方法非常类似。这里就不再赘述。可以看出新增的两个方法极大地弥补了`indexOf()`方法的不足。\n\n```javascript\n[1, 4, -5. 10].find((n) => n < 0); // -5\n\n[1, 5, 10, 15].find(function(value, index, arr){\n    return value > 9;\n}); // 10\n\n[1, 5, 10, 15].findIndex(function(value, index, arr){\n    return value > 9;\n}) // 2（正好是元素10对应的数组索引）\n```\n\n## 数组实例fill()\n\n`fill()`可以使用给定值来填充数组，因此在初始化数组元素的过程中非常方便。\n\n初次之外，fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置\n\n```javascript\n['a', 'b', 'c'].fill(7); // [7, 7, 7]\n\nnew Array(3).fill(7); // [7, 7, 7]\n\n['a', 'b', 'c'].fill(7, 1, 2); // ['a', '7', 'c'] 用7填充，从1号位开始，到2号位结束\n```\n\n## 数组实例entries(), keys()和values()\n\nES6新增了上述的3个方法，英语遍历数组。它们都是返回一个遍历器对象，可以使用`for...of`循环遍历，唯一区别是`keys()`是对键名的遍历、`values()`是对键值得遍历，`entries()`是对键值对的遍历。\n\n```javascript\nfor (let index of ['a', 'b'].keys()) {\n    console.log(index)\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n    console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n    console.log(index, elem);\n}\n// 0 'a'\n// 1 'b'\n```\n\n## 数组实例includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否是否已经包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但是Babel转码器已经支持。\n\n```javascript\n[1, 2, 3].includes(2); // true\n[1, 2, 3].includes(4); // false\n[1, 2, NaN].includes(NaN); // true\n```\n\n该方法还有第二个参数表示搜索的起始位置，默认为0 ，如果为负数则表示倒数位置。\n\n## 数组的空位\n\n数组的某一个位置没有任何值。比如`Array`构造函数返回的数组都是空位。注意：空位不等于`undefined`\n\n```javascript\nvar arr = new Array(3);\n0 in arr // false\nundefined in arr // false\n\nvar arr = new Array(3).fill(undefined)\n0 in arr // true\n```\n\n在ES6中会明确将空位转换为`undefined`， `copyWithin()`会将空位一起拷贝，`fill()`会将空位当做正常位置，循环也会迭代空位。总之ES6中会保留空位。由于空位的处理规则不统一，因此应当避免出现空位。\n\n```javascript\n[...['a',,'b']]\n// ['a', undefined, 'b']\n```\n","source":"_posts/javascript/es6-array-expand.md","raw":"---\ntitle: ES6 数组扩展\ndate: 2022-02-17 15:06:02\nupdated: 2022-02-17 15:06:02\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 数组扩展\n\n## Array.from()\n\n用于将类似数组的对象和可遍历的对象（部署了Iterator接口）转换为数组。例子如下：\n\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5\nvar arr1 = [].slice.call(arrayLike);\n\n// ES6\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n\n实际应用中，常见的类似数组对象是DOM操作返回的NodeList集合以及函数内部arguments对象。Array.from都可以将它们转为真正的数组。\n\n```javascript\nlet ps = document.querySelectorAll('p');\nArray.from(ps).forEach(function (p) {\n    console.log(p);\n});\n\nfunction add(a, b) {\n    var args = Array.from(arguments);\n    console.log(args);\n    return a + b;\n}\n\nadd(1, 2);\n// [1, 2]\n// 3\n\n// 字符串和Set都部署了Iterator接口，所以可以用Array.from生成数组，这点和Java很像\nArray.from('hello'); // ['h', 'e', 'l', 'l', 'o']\nlet nameSet = new Set(['a', 'b']);\nArray.from(nameSet) // ['a', 'b']\n```\n\n除此之外，扩展运算符`...`也可以将某些数据结构转换为数组（注：扩展运算符跟Java中的多参数表达式功能类似）。扩展运算符背地也是调用Iterator接口，如果对象没有部署这个接口，则无法完成转换；\n\n```javascript\nfunction foo () {\n    var args = [...arguments];\n}\n\n[...document.querySelectorAll('div')]\n```\n\n## Array.of()\n\nArray.of用于将一组值，转换为数组；这个方法的主要目的是弥补Array()方法的不足。因为参数个数的不同，会导致Array()的行为有差异。\n\n```javascript\nArray.of(3, 11, 8); // [3, 11, 8]\nArray(3, 11, 8); // [3, 11, 8]\nArray(3); // [, , ,] 长度为3的空数组\nArray.of(3); // [3] 长度为1的数组，只有一个元素3\n```\n\n## 数组实例的copyWithin()\n\n在当前数组的内部，将指定位置的成员复制到其他位置，然后返回当前数组。也就是说该方法会修改当前数组。\n\n```javascript\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n// target（必需）：从该位置开始替换数据\n// start（可选）：从该位置开始读取数据，默认为0，如果为负值则表示倒数；\n// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数；\n\n[1, 2, 3, 4, 5].copyWithin(0, 3); // [4, 5, 3, 4, 5]\n```\n\n## 数组实例find()和findIndex()\n\n`find()`方法用于找出第一个符合条件的数组成员。其第一个参数是回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没找到符合条件的成员则返回`undefined`。\n\n`findIndex()`方法的作用与`find()`方法非常类似。这里就不再赘述。可以看出新增的两个方法极大地弥补了`indexOf()`方法的不足。\n\n```javascript\n[1, 4, -5. 10].find((n) => n < 0); // -5\n\n[1, 5, 10, 15].find(function(value, index, arr){\n    return value > 9;\n}); // 10\n\n[1, 5, 10, 15].findIndex(function(value, index, arr){\n    return value > 9;\n}) // 2（正好是元素10对应的数组索引）\n```\n\n## 数组实例fill()\n\n`fill()`可以使用给定值来填充数组，因此在初始化数组元素的过程中非常方便。\n\n初次之外，fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置\n\n```javascript\n['a', 'b', 'c'].fill(7); // [7, 7, 7]\n\nnew Array(3).fill(7); // [7, 7, 7]\n\n['a', 'b', 'c'].fill(7, 1, 2); // ['a', '7', 'c'] 用7填充，从1号位开始，到2号位结束\n```\n\n## 数组实例entries(), keys()和values()\n\nES6新增了上述的3个方法，英语遍历数组。它们都是返回一个遍历器对象，可以使用`for...of`循环遍历，唯一区别是`keys()`是对键名的遍历、`values()`是对键值得遍历，`entries()`是对键值对的遍历。\n\n```javascript\nfor (let index of ['a', 'b'].keys()) {\n    console.log(index)\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n    console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n    console.log(index, elem);\n}\n// 0 'a'\n// 1 'b'\n```\n\n## 数组实例includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否是否已经包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但是Babel转码器已经支持。\n\n```javascript\n[1, 2, 3].includes(2); // true\n[1, 2, 3].includes(4); // false\n[1, 2, NaN].includes(NaN); // true\n```\n\n该方法还有第二个参数表示搜索的起始位置，默认为0 ，如果为负数则表示倒数位置。\n\n## 数组的空位\n\n数组的某一个位置没有任何值。比如`Array`构造函数返回的数组都是空位。注意：空位不等于`undefined`\n\n```javascript\nvar arr = new Array(3);\n0 in arr // false\nundefined in arr // false\n\nvar arr = new Array(3).fill(undefined)\n0 in arr // true\n```\n\n在ES6中会明确将空位转换为`undefined`， `copyWithin()`会将空位一起拷贝，`fill()`会将空位当做正常位置，循环也会迭代空位。总之ES6中会保留空位。由于空位的处理规则不统一，因此应当避免出现空位。\n\n```javascript\n[...['a',,'b']]\n// ['a', undefined, 'b']\n```\n","slug":"javascript/es6-array-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6v9000z4f610o9acixi","content":"<h1 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h1><h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p>用于将类似数组的对象和可遍历的对象（部署了Iterator接口）转换为数组。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arrayLike = &#123;<br>    <span class=\"hljs-string\">&#x27;0&#x27;</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;1&#x27;</span>: <span class=\"hljs-string\">&#x27;b&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;2&#x27;</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>,<br>    <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">3</span><br>&#125;;<br><br><span class=\"hljs-comment\">// ES5</span><br><span class=\"hljs-keyword\">var</span> arr1 = [].<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(arrayLike);<br><br><span class=\"hljs-comment\">// ES6</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(arrayLike); <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>实际应用中，常见的类似数组对象是DOM操作返回的NodeList集合以及函数内部arguments对象。Array.from都可以将它们转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> ps = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;p&#x27;</span>);<br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(ps).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">p</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p);<br>&#125;);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(args);<br>    <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-comment\">// [1, 2]</span><br><span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// 字符串和Set都部署了Iterator接口，所以可以用Array.from生成数组，这点和Java很像</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>); <span class=\"hljs-comment\">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class=\"hljs-keyword\">let</span> nameSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(nameSet) <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>除此之外，扩展运算符<code>...</code>也可以将某些数据结构转换为数组（注：扩展运算符跟Java中的多参数表达式功能类似）。扩展运算符背地也是调用Iterator接口，如果对象没有部署这个接口，则无法完成转换；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;<br>    <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>];<br>&#125;<br><br>[...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)]<br></code></pre></td></tr></table></figure>\n<h2 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h2><p>Array.of用于将一组值，转换为数组；这个方法的主要目的是弥补Array()方法的不足。因为参数个数的不同，会导致Array()的行为有差异。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// [3, 11, 8]</span><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// [3, 11, 8]</span><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [, , ,] 长度为3的空数组</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [3] 长度为1的数组，只有一个元素3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例的copyWithin\"><a href=\"#数组实例的copyWithin\" class=\"headerlink\" title=\"数组实例的copyWithin()\"></a>数组实例的copyWithin()</h2><p>在当前数组的内部，将指定位置的成员复制到其他位置，然后返回当前数组。也就是说该方法会修改当前数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">copyWithin</span>(target, start = <span class=\"hljs-number\">0</span>, end = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">length</span>)<br><span class=\"hljs-comment\">// target（必需）：从该位置开始替换数据</span><br><span class=\"hljs-comment\">// start（可选）：从该位置开始读取数据，默认为0，如果为负值则表示倒数；</span><br><span class=\"hljs-comment\">// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数；</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [4, 5, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例find-和findIndex\"><a href=\"#数组实例find-和findIndex\" class=\"headerlink\" title=\"数组实例find()和findIndex()\"></a>数组实例find()和findIndex()</h2><p><code>find()</code>方法用于找出第一个符合条件的数组成员。其第一个参数是回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没找到符合条件的成员则返回<code>undefined</code>。</p>\n<p><code>findIndex()</code>方法的作用与<code>find()</code>方法非常类似。这里就不再赘述。可以看出新增的两个方法极大地弥补了<code>indexOf()</code>方法的不足。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">5.</span> <span class=\"hljs-number\">10</span>].<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> n &lt; <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -5</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>].<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, index, arr</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> value &gt; <span class=\"hljs-number\">9</span>;<br>&#125;); <span class=\"hljs-comment\">// 10</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>].<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, index, arr</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> value &gt; <span class=\"hljs-number\">9</span>;<br>&#125;) <span class=\"hljs-comment\">// 2（正好是元素10对应的数组索引）</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例fill\"><a href=\"#数组实例fill\" class=\"headerlink\" title=\"数组实例fill()\"></a>数组实例fill()</h2><p><code>fill()</code>可以使用给定值来填充数组，因此在初始化数组元素的过程中非常方便。</p>\n<p>初次之外，fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>].<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// [7, 7, 7]</span><br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// [7, 7, 7]</span><br><br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>].<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;7&#x27;, &#x27;c&#x27;] 用7填充，从1号位开始，到2号位结束</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例entries-keys-和values\"><a href=\"#数组实例entries-keys-和values\" class=\"headerlink\" title=\"数组实例entries(), keys()和values()\"></a>数组实例entries(), keys()和values()</h2><p>ES6新增了上述的3个方法，英语遍历数组。它们都是返回一个遍历器对象，可以使用<code>for...of</code>循环遍历，唯一区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值得遍历，<code>entries()</code>是对键值对的遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index)<br>&#125;<br><span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> elem <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(elem);<br>&#125;<br><span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [index, elem] <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index, elem);<br>&#125;<br><span class=\"hljs-comment\">// 0 &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// 1 &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例includes\"><a href=\"#数组实例includes\" class=\"headerlink\" title=\"数组实例includes()\"></a>数组实例includes()</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否是否已经包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但是Babel转码器已经支持。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// true</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// false</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">NaN</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>该方法还有第二个参数表示搜索的起始位置，默认为0 ，如果为负数则表示倒数位置。</p>\n<h2 id=\"数组的空位\"><a href=\"#数组的空位\" class=\"headerlink\" title=\"数组的空位\"></a>数组的空位</h2><p>数组的某一个位置没有任何值。比如<code>Array</code>构造函数返回的数组都是空位。注意：空位不等于<code>undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>);<br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-literal\">undefined</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-literal\">undefined</span>)<br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>在ES6中会明确将空位转换为<code>undefined</code>， <code>copyWithin()</code>会将空位一起拷贝，<code>fill()</code>会将空位当做正常位置，循环也会迭代空位。总之ES6中会保留空位。由于空位的处理规则不统一，因此应当避免出现空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[...[<span class=\"hljs-string\">&#x27;a&#x27;</span>,,<span class=\"hljs-string\">&#x27;b&#x27;</span>]]<br><span class=\"hljs-comment\">// [&#x27;a&#x27;, undefined, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":3331,"excerpt":"","more":"<h1 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h1><h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p>用于将类似数组的对象和可遍历的对象（部署了Iterator接口）转换为数组。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arrayLike = &#123;<br>    <span class=\"hljs-string\">&#x27;0&#x27;</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;1&#x27;</span>: <span class=\"hljs-string\">&#x27;b&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;2&#x27;</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>,<br>    <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">3</span><br>&#125;;<br><br><span class=\"hljs-comment\">// ES5</span><br><span class=\"hljs-keyword\">var</span> arr1 = [].<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(arrayLike);<br><br><span class=\"hljs-comment\">// ES6</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(arrayLike); <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>实际应用中，常见的类似数组对象是DOM操作返回的NodeList集合以及函数内部arguments对象。Array.from都可以将它们转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> ps = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;p&#x27;</span>);<br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(ps).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">p</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p);<br>&#125;);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(args);<br>    <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-comment\">// [1, 2]</span><br><span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// 字符串和Set都部署了Iterator接口，所以可以用Array.from生成数组，这点和Java很像</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>); <span class=\"hljs-comment\">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class=\"hljs-keyword\">let</span> nameSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(nameSet) <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>除此之外，扩展运算符<code>...</code>也可以将某些数据结构转换为数组（注：扩展运算符跟Java中的多参数表达式功能类似）。扩展运算符背地也是调用Iterator接口，如果对象没有部署这个接口，则无法完成转换；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;<br>    <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>];<br>&#125;<br><br>[...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)]<br></code></pre></td></tr></table></figure>\n<h2 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h2><p>Array.of用于将一组值，转换为数组；这个方法的主要目的是弥补Array()方法的不足。因为参数个数的不同，会导致Array()的行为有差异。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// [3, 11, 8]</span><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// [3, 11, 8]</span><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [, , ,] 长度为3的空数组</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [3] 长度为1的数组，只有一个元素3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例的copyWithin\"><a href=\"#数组实例的copyWithin\" class=\"headerlink\" title=\"数组实例的copyWithin()\"></a>数组实例的copyWithin()</h2><p>在当前数组的内部，将指定位置的成员复制到其他位置，然后返回当前数组。也就是说该方法会修改当前数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">copyWithin</span>(target, start = <span class=\"hljs-number\">0</span>, end = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">length</span>)<br><span class=\"hljs-comment\">// target（必需）：从该位置开始替换数据</span><br><span class=\"hljs-comment\">// start（可选）：从该位置开始读取数据，默认为0，如果为负值则表示倒数；</span><br><span class=\"hljs-comment\">// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数；</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [4, 5, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例find-和findIndex\"><a href=\"#数组实例find-和findIndex\" class=\"headerlink\" title=\"数组实例find()和findIndex()\"></a>数组实例find()和findIndex()</h2><p><code>find()</code>方法用于找出第一个符合条件的数组成员。其第一个参数是回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没找到符合条件的成员则返回<code>undefined</code>。</p>\n<p><code>findIndex()</code>方法的作用与<code>find()</code>方法非常类似。这里就不再赘述。可以看出新增的两个方法极大地弥补了<code>indexOf()</code>方法的不足。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">5.</span> <span class=\"hljs-number\">10</span>].<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> n &lt; <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -5</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>].<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, index, arr</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> value &gt; <span class=\"hljs-number\">9</span>;<br>&#125;); <span class=\"hljs-comment\">// 10</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>].<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, index, arr</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> value &gt; <span class=\"hljs-number\">9</span>;<br>&#125;) <span class=\"hljs-comment\">// 2（正好是元素10对应的数组索引）</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例fill\"><a href=\"#数组实例fill\" class=\"headerlink\" title=\"数组实例fill()\"></a>数组实例fill()</h2><p><code>fill()</code>可以使用给定值来填充数组，因此在初始化数组元素的过程中非常方便。</p>\n<p>初次之外，fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>].<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// [7, 7, 7]</span><br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// [7, 7, 7]</span><br><br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>].<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;7&#x27;, &#x27;c&#x27;] 用7填充，从1号位开始，到2号位结束</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例entries-keys-和values\"><a href=\"#数组实例entries-keys-和values\" class=\"headerlink\" title=\"数组实例entries(), keys()和values()\"></a>数组实例entries(), keys()和values()</h2><p>ES6新增了上述的3个方法，英语遍历数组。它们都是返回一个遍历器对象，可以使用<code>for...of</code>循环遍历，唯一区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值得遍历，<code>entries()</code>是对键值对的遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index)<br>&#125;<br><span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> elem <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(elem);<br>&#125;<br><span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [index, elem] <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index, elem);<br>&#125;<br><span class=\"hljs-comment\">// 0 &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// 1 &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例includes\"><a href=\"#数组实例includes\" class=\"headerlink\" title=\"数组实例includes()\"></a>数组实例includes()</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否是否已经包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但是Babel转码器已经支持。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// true</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// false</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">NaN</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>该方法还有第二个参数表示搜索的起始位置，默认为0 ，如果为负数则表示倒数位置。</p>\n<h2 id=\"数组的空位\"><a href=\"#数组的空位\" class=\"headerlink\" title=\"数组的空位\"></a>数组的空位</h2><p>数组的某一个位置没有任何值。比如<code>Array</code>构造函数返回的数组都是空位。注意：空位不等于<code>undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>);<br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-literal\">undefined</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-literal\">undefined</span>)<br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>在ES6中会明确将空位转换为<code>undefined</code>， <code>copyWithin()</code>会将空位一起拷贝，<code>fill()</code>会将空位当做正常位置，循环也会迭代空位。总之ES6中会保留空位。由于空位的处理规则不统一，因此应当避免出现空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[...[<span class=\"hljs-string\">&#x27;a&#x27;</span>,,<span class=\"hljs-string\">&#x27;b&#x27;</span>]]<br><span class=\"hljs-comment\">// [&#x27;a&#x27;, undefined, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 异步操作","date":"2022-02-17T14:23:01.000Z","updated":"2022-02-17T14:23:01.000Z","_content":"\n# 异步操作和Async函数\n\n## 基本概念\n\n前面提到，JavaScript本身是不支持异步编程的，但是不支持异步处理，那么处理速度会特别慢。因此引入异步编程的特性便迫在眉睫。\n\n按照前面章节提到的，JS在异步编程中实现的方式有下面几个：\n\n- 回调函数\n- Promise\n- Generator函数 + 协程\n\n## Thunk函数\n\n简单来说：所谓的“船名调用”实现：就是将参数方法放到一个临时函数中，再将这个临时函数传入函数体，这个临时函数就称作“Thunk函数”：\n\n```javascript\nvar thunk = function() {\n  return x + 5;\n}\n\nfunction (thunk) {\n  return thunk() * 2;\n}\n```\n\n在JavaScript中函数替换的不是表达式，而是多参数函数，将其替换程单参数的版本。且只接受回调函数作为参数。因此，任何函数只要有回调函数，就可以写成Thunk函数的形式。\n\n```javascript\nvar thunk = function(fn) {\n\treturn function (...args) {\n    return function(callback) {\n      return fn.call(this, ...args, callback);\n    }\n  }\n}\n```\n\n举一个具体的例子：\n\n```javascript\nfunction f(a, b) {\n  cb(a);\n}\nlet ft = Thunk(f);\n\nlet log = console.log.bind(console);\nft(1)(log) // 1\n```\n\n## Thunkify模块\n\n生产环境下转换器，可以使用Thunkify模块。使用`npm install thunkify`安装；\n\n```javascript\nvar thunkify = require('thunkify');\nvar fs = require('fs');\n\nvar read = thunkify(rs.readFile);\nread('package.json')(function(err, str){\n  // concrete code\n});\n```\n\n## 看到这你可能会问，这有什么用？\n\n因为ES6现在新增了Generator函数，因此结合Thunk以后可以很好地管理Generartor流程。例子如下：\n\n```javascript\nvar fs = require('fs');\nvar thunkify = require('thunkify');\nvar readFile = thunkify(fs.readFile);\n\nvar gen = function* () {\n  var r1 = yield readFile('/etc/fstab');\n  console.log(r1.toString());\n  var r2 = yield readFile('/etc/shells');\n  console.log(r2.toString());\n}\n```\n\n上面的代码：yield命令用于将程序的执行权移出Generator函数。Thunk函数正好可以完成这个需求。\n\n## 还没结束\n\n看完上面，你可能已经知道Thunk函数现在可以做到什么事情：没错，Thunk函数的真正威力是：可以自动执行Generator函数。\n\n```javascript\nfunction run(fn) {\n  var gen = fn();\n  \n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n  \n  next();\n}\n\nfunction* g() {\n  // ...\n}\n\nrun(g);\n```\n\n有了上面的执行器，那么下面执行Generator函数就简单了很多。不关内部有多少个异步操作，直接把Generator函数传入run函数即可。前提是每一个异步操作都必须是Thunk函数。\n\n```javascript\nvar g = function* () {\n  var f1 = yield readFile('fileA');\n  var f2 = yield readFile('fileB');\n  // ...\n  var fn = yield readFile('fileN');\n}\n\nrun(g);\n```\n\n## CO模块\n\nco模块是著名程序员TJ Holowaychuk发布一个小工具，用于Generator函数的自动执行。有了co模块，你可以不必自己编写Generator函数的执行器。\n\n```javascript\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\nvar co = require('co');\nco(gen).then(function() {\n  console.log('Generator execute success.')\n});\n```\n\nco支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。\n\n```javascript\n// 数组写法\nco(function* (){\n  var res = yield [\n    Promise.resolve(1),\n    Promise.resolve(2)\n  ];\n  console.log(res);\n}).catch(onerror);\n\n// 对象写法\nco(function* (){\n  var res = yield {\n    1: Promise.resolve(1),\n    2: Promise.resolve(2)\n  };\n  console.log(res);\n}).catch(onerror);\n```\n\n## async函数\n\nES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话：async函数就是Generator函数的语法糖。\n\n```javascript\nvar asyncReadFile = async function() {\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n语法上来看，跟Generator函数的使用基本类似，但是在其基础上还是有一点改进：\n\n- （1）内置执行器：因此async函数执行和普通函数一样，只需要一行即可；\n- （2）更好的语义，这个一目了然；\n- （3）更广的适用性：即可支持Promise，也可以支持普通对象；\n- （4）返回值是Promise，因此可以使用then指定下一步操作；\n\n如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的对象会被catch方法回调接收到。\n\n```javascript\nasync function f() {\n  throw new Error('Wrong');\n}\n\nf().then(\n\tv => console.log(v),\n  e => console.log(e)\n)\n```\n\n其次：async函数返回的Promise对象，必须等到所有的await命令的Promise对象执行完，才发发生改变。\n\n```javascript\nasync function getTitle(url) {\n\tlet response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\n\ngetTitle('https://github.com/Humphrey75432').then(console.log);\n```\n\n### 注意点\n\n（1）`await`命令后面的`Promise`对象，运行结果可能是`reject`，所以最好把`await`命令放入`try...catch`块中。\n\n```javascript\nasync function myFunction() {\n    try {\n        await somethingThatReturnsAPromise();\n    } catch (err) {\n        console.log(err);\n    }\n}\n\n// Another grammar\n\nasync function myFunction() {\n    await somethingThatReturnsAPromise()\n    \t.catch(function (err) {\n        console.log(err);\n    });\n}\n```\n\n（2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。这样会提升执行效率\n\n```javascript\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// second grammar\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n```\n\n（3）如果确实希望多个请求并发执行，可以使用`Promise.all`方法。\n\n```javascript\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n","source":"_posts/javascript/es6-async-operate.md","raw":"---\ntitle: ES6 异步操作\ndate: 2022-02-17 22:23:01\nupdated: 2022-02-17 22:23:01\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 异步操作和Async函数\n\n## 基本概念\n\n前面提到，JavaScript本身是不支持异步编程的，但是不支持异步处理，那么处理速度会特别慢。因此引入异步编程的特性便迫在眉睫。\n\n按照前面章节提到的，JS在异步编程中实现的方式有下面几个：\n\n- 回调函数\n- Promise\n- Generator函数 + 协程\n\n## Thunk函数\n\n简单来说：所谓的“船名调用”实现：就是将参数方法放到一个临时函数中，再将这个临时函数传入函数体，这个临时函数就称作“Thunk函数”：\n\n```javascript\nvar thunk = function() {\n  return x + 5;\n}\n\nfunction (thunk) {\n  return thunk() * 2;\n}\n```\n\n在JavaScript中函数替换的不是表达式，而是多参数函数，将其替换程单参数的版本。且只接受回调函数作为参数。因此，任何函数只要有回调函数，就可以写成Thunk函数的形式。\n\n```javascript\nvar thunk = function(fn) {\n\treturn function (...args) {\n    return function(callback) {\n      return fn.call(this, ...args, callback);\n    }\n  }\n}\n```\n\n举一个具体的例子：\n\n```javascript\nfunction f(a, b) {\n  cb(a);\n}\nlet ft = Thunk(f);\n\nlet log = console.log.bind(console);\nft(1)(log) // 1\n```\n\n## Thunkify模块\n\n生产环境下转换器，可以使用Thunkify模块。使用`npm install thunkify`安装；\n\n```javascript\nvar thunkify = require('thunkify');\nvar fs = require('fs');\n\nvar read = thunkify(rs.readFile);\nread('package.json')(function(err, str){\n  // concrete code\n});\n```\n\n## 看到这你可能会问，这有什么用？\n\n因为ES6现在新增了Generator函数，因此结合Thunk以后可以很好地管理Generartor流程。例子如下：\n\n```javascript\nvar fs = require('fs');\nvar thunkify = require('thunkify');\nvar readFile = thunkify(fs.readFile);\n\nvar gen = function* () {\n  var r1 = yield readFile('/etc/fstab');\n  console.log(r1.toString());\n  var r2 = yield readFile('/etc/shells');\n  console.log(r2.toString());\n}\n```\n\n上面的代码：yield命令用于将程序的执行权移出Generator函数。Thunk函数正好可以完成这个需求。\n\n## 还没结束\n\n看完上面，你可能已经知道Thunk函数现在可以做到什么事情：没错，Thunk函数的真正威力是：可以自动执行Generator函数。\n\n```javascript\nfunction run(fn) {\n  var gen = fn();\n  \n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n  \n  next();\n}\n\nfunction* g() {\n  // ...\n}\n\nrun(g);\n```\n\n有了上面的执行器，那么下面执行Generator函数就简单了很多。不关内部有多少个异步操作，直接把Generator函数传入run函数即可。前提是每一个异步操作都必须是Thunk函数。\n\n```javascript\nvar g = function* () {\n  var f1 = yield readFile('fileA');\n  var f2 = yield readFile('fileB');\n  // ...\n  var fn = yield readFile('fileN');\n}\n\nrun(g);\n```\n\n## CO模块\n\nco模块是著名程序员TJ Holowaychuk发布一个小工具，用于Generator函数的自动执行。有了co模块，你可以不必自己编写Generator函数的执行器。\n\n```javascript\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\nvar co = require('co');\nco(gen).then(function() {\n  console.log('Generator execute success.')\n});\n```\n\nco支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。\n\n```javascript\n// 数组写法\nco(function* (){\n  var res = yield [\n    Promise.resolve(1),\n    Promise.resolve(2)\n  ];\n  console.log(res);\n}).catch(onerror);\n\n// 对象写法\nco(function* (){\n  var res = yield {\n    1: Promise.resolve(1),\n    2: Promise.resolve(2)\n  };\n  console.log(res);\n}).catch(onerror);\n```\n\n## async函数\n\nES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话：async函数就是Generator函数的语法糖。\n\n```javascript\nvar asyncReadFile = async function() {\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n语法上来看，跟Generator函数的使用基本类似，但是在其基础上还是有一点改进：\n\n- （1）内置执行器：因此async函数执行和普通函数一样，只需要一行即可；\n- （2）更好的语义，这个一目了然；\n- （3）更广的适用性：即可支持Promise，也可以支持普通对象；\n- （4）返回值是Promise，因此可以使用then指定下一步操作；\n\n如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的对象会被catch方法回调接收到。\n\n```javascript\nasync function f() {\n  throw new Error('Wrong');\n}\n\nf().then(\n\tv => console.log(v),\n  e => console.log(e)\n)\n```\n\n其次：async函数返回的Promise对象，必须等到所有的await命令的Promise对象执行完，才发发生改变。\n\n```javascript\nasync function getTitle(url) {\n\tlet response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\n\ngetTitle('https://github.com/Humphrey75432').then(console.log);\n```\n\n### 注意点\n\n（1）`await`命令后面的`Promise`对象，运行结果可能是`reject`，所以最好把`await`命令放入`try...catch`块中。\n\n```javascript\nasync function myFunction() {\n    try {\n        await somethingThatReturnsAPromise();\n    } catch (err) {\n        console.log(err);\n    }\n}\n\n// Another grammar\n\nasync function myFunction() {\n    await somethingThatReturnsAPromise()\n    \t.catch(function (err) {\n        console.log(err);\n    });\n}\n```\n\n（2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。这样会提升执行效率\n\n```javascript\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// second grammar\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n```\n\n（3）如果确实希望多个请求并发执行，可以使用`Promise.all`方法。\n\n```javascript\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n","slug":"javascript/es6-async-operate","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6va00134f618rgl6pvn","content":"<h1 id=\"异步操作和Async函数\"><a href=\"#异步操作和Async函数\" class=\"headerlink\" title=\"异步操作和Async函数\"></a>异步操作和Async函数</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>前面提到，JavaScript本身是不支持异步编程的，但是不支持异步处理，那么处理速度会特别慢。因此引入异步编程的特性便迫在眉睫。</p>\n<p>按照前面章节提到的，JS在异步编程中实现的方式有下面几个：</p>\n<ul>\n<li>回调函数</li>\n<li>Promise</li>\n<li>Generator函数 + 协程</li>\n</ul>\n<h2 id=\"Thunk函数\"><a href=\"#Thunk函数\" class=\"headerlink\" title=\"Thunk函数\"></a>Thunk函数</h2><p>简单来说：所谓的“船名调用”实现：就是将参数方法放到一个临时函数中，再将这个临时函数传入函数体，这个临时函数就称作“Thunk函数”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunk = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">5</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thunk</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">thunk</span>() * <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在JavaScript中函数替换的不是表达式，而是多参数函数，将其替换程单参数的版本。且只接受回调函数作为参数。因此，任何函数只要有回调函数，就可以写成Thunk函数的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunk = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, ...args, callback);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>举一个具体的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-title function_\">cb</span>(a);<br>&#125;<br><span class=\"hljs-keyword\">let</span> ft = <span class=\"hljs-title class_\">Thunk</span>(f);<br><br><span class=\"hljs-keyword\">let</span> log = <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">console</span>);<br><span class=\"hljs-title function_\">ft</span>(<span class=\"hljs-number\">1</span>)(log) <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Thunkify模块\"><a href=\"#Thunkify模块\" class=\"headerlink\" title=\"Thunkify模块\"></a>Thunkify模块</h2><p>生产环境下转换器，可以使用Thunkify模块。使用<code>npm install thunkify</code>安装；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunkify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;thunkify&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><br><span class=\"hljs-keyword\">var</span> read = <span class=\"hljs-title function_\">thunkify</span>(rs.<span class=\"hljs-property\">readFile</span>);<br><span class=\"hljs-title function_\">read</span>(<span class=\"hljs-string\">&#x27;package.json&#x27;</span>)(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, str</span>)&#123;<br>  <span class=\"hljs-comment\">// concrete code</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"看到这你可能会问，这有什么用？\"><a href=\"#看到这你可能会问，这有什么用？\" class=\"headerlink\" title=\"看到这你可能会问，这有什么用？\"></a>看到这你可能会问，这有什么用？</h2><p>因为ES6现在新增了Generator函数，因此结合Thunk以后可以很好地管理Generartor流程。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> thunkify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;thunkify&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> readFile = <span class=\"hljs-title function_\">thunkify</span>(fs.<span class=\"hljs-property\">readFile</span>);<br><br><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> r1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-keyword\">var</span> r2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面的代码：yield命令用于将程序的执行权移出Generator函数。Thunk函数正好可以完成这个需求。</p>\n<h2 id=\"还没结束\"><a href=\"#还没结束\" class=\"headerlink\" title=\"还没结束\"></a>还没结束</h2><p>看完上面，你可能已经知道Thunk函数现在可以做到什么事情：没错，Thunk函数的真正威力是：可以自动执行Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-title function_\">fn</span>();<br>  <br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\">err, data</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = gen.<span class=\"hljs-title function_\">next</span>(data);<br>    <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">done</span>) <span class=\"hljs-keyword\">return</span>;<br>    result.<span class=\"hljs-title function_\">value</span>(next);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">next</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-title function_\">run</span>(g);<br></code></pre></td></tr></table></figure>\n<p>有了上面的执行器，那么下面执行Generator函数就简单了很多。不关内部有多少个异步操作，直接把Generator函数传入run函数即可。前提是每一个异步操作都必须是Thunk函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileA&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileB&#x27;</span>);<br>  <span class=\"hljs-comment\">// ...</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileN&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">run</span>(g);<br></code></pre></td></tr></table></figure>\n<h2 id=\"CO模块\"><a href=\"#CO模块\" class=\"headerlink\" title=\"CO模块\"></a>CO模块</h2><p>co模块是著名程序员TJ Holowaychuk发布一个小工具，用于Generator函数的自动执行。有了co模块，你可以不必自己编写Generator函数的执行器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> co = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;co&#x27;</span>);<br><span class=\"hljs-title function_\">co</span>(gen).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Generator execute success.&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 数组写法</span><br><span class=\"hljs-title function_\">co</span>(<span class=\"hljs-keyword\">function</span>* ()&#123;<br>  <span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-keyword\">yield</span> [<br>    <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>),<br>    <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">2</span>)<br>  ];<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);<br>&#125;).<span class=\"hljs-title function_\">catch</span>(onerror);<br><br><span class=\"hljs-comment\">// 对象写法</span><br><span class=\"hljs-title function_\">co</span>(<span class=\"hljs-keyword\">function</span>* ()&#123;<br>  <span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-keyword\">yield</span> &#123;<br>    <span class=\"hljs-number\">1</span>: <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>),<br>    <span class=\"hljs-number\">2</span>: <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">2</span>)<br>  &#125;;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);<br>&#125;).<span class=\"hljs-title function_\">catch</span>(onerror);<br></code></pre></td></tr></table></figure>\n<h2 id=\"async函数\"><a href=\"#async函数\" class=\"headerlink\" title=\"async函数\"></a>async函数</h2><p>ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话：async函数就是Generator函数的语法糖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> asyncReadFile = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>语法上来看，跟Generator函数的使用基本类似，但是在其基础上还是有一点改进：</p>\n<ul>\n<li>（1）内置执行器：因此async函数执行和普通函数一样，只需要一行即可；</li>\n<li>（2）更好的语义，这个一目了然；</li>\n<li>（3）更广的适用性：即可支持Promise，也可以支持普通对象；</li>\n<li>（4）返回值是Promise，因此可以使用then指定下一步操作；</li>\n</ul>\n<p>如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的对象会被catch方法回调接收到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Wrong&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>().<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v),<br>  <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e)<br>)<br></code></pre></td></tr></table></figure>\n<p>其次：async函数返回的Promise对象，必须等到所有的await命令的Promise对象执行完，才发发生改变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getTitle</span>(<span class=\"hljs-params\">url</span>) &#123;<br>\t<span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);<br>  <span class=\"hljs-keyword\">let</span> html = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">text</span>();<br>  <span class=\"hljs-keyword\">return</span> html.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"hljs-number\">1</span>];<br>&#125;<br><br><span class=\"hljs-title function_\">getTitle</span>(<span class=\"hljs-string\">&#x27;https://github.com/Humphrey75432&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>（1）<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>reject</code>，所以最好把<code>await</code>命令放入<code>try...catch</code>块中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">somethingThatReturnsAPromise</span>();<br>    &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// Another grammar</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">somethingThatReturnsAPromise</span>()<br>    \t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>（2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。这样会提升执行效率</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [foo, bar] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<span class=\"hljs-title function_\">getFoo</span>(), <span class=\"hljs-title function_\">getBar</span>()]);<br><br><span class=\"hljs-comment\">// second grammar</span><br><span class=\"hljs-keyword\">let</span> fooPromise = <span class=\"hljs-title function_\">getFoo</span>();<br><span class=\"hljs-keyword\">let</span> barPromise = <span class=\"hljs-title function_\">getBar</span>();<br><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-keyword\">await</span> fooPromise;<br><span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-keyword\">await</span> barPromise;<br></code></pre></td></tr></table></figure>\n<p>（3）如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dbFuc</span>(<span class=\"hljs-params\">db</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.<span class=\"hljs-title function_\">post</span>(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results);<br>&#125;<br><br><span class=\"hljs-comment\">// 或者使用下面的写法</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dbFuc</span>(<span class=\"hljs-params\">db</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.<span class=\"hljs-title function_\">post</span>(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = [];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> promise <span class=\"hljs-keyword\">of</span> promises) &#123;<br>    results.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-keyword\">await</span> promise);<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results);<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":4506,"excerpt":"","more":"<h1 id=\"异步操作和Async函数\"><a href=\"#异步操作和Async函数\" class=\"headerlink\" title=\"异步操作和Async函数\"></a>异步操作和Async函数</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>前面提到，JavaScript本身是不支持异步编程的，但是不支持异步处理，那么处理速度会特别慢。因此引入异步编程的特性便迫在眉睫。</p>\n<p>按照前面章节提到的，JS在异步编程中实现的方式有下面几个：</p>\n<ul>\n<li>回调函数</li>\n<li>Promise</li>\n<li>Generator函数 + 协程</li>\n</ul>\n<h2 id=\"Thunk函数\"><a href=\"#Thunk函数\" class=\"headerlink\" title=\"Thunk函数\"></a>Thunk函数</h2><p>简单来说：所谓的“船名调用”实现：就是将参数方法放到一个临时函数中，再将这个临时函数传入函数体，这个临时函数就称作“Thunk函数”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunk = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">5</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thunk</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">thunk</span>() * <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在JavaScript中函数替换的不是表达式，而是多参数函数，将其替换程单参数的版本。且只接受回调函数作为参数。因此，任何函数只要有回调函数，就可以写成Thunk函数的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunk = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, ...args, callback);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>举一个具体的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-title function_\">cb</span>(a);<br>&#125;<br><span class=\"hljs-keyword\">let</span> ft = <span class=\"hljs-title class_\">Thunk</span>(f);<br><br><span class=\"hljs-keyword\">let</span> log = <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">console</span>);<br><span class=\"hljs-title function_\">ft</span>(<span class=\"hljs-number\">1</span>)(log) <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Thunkify模块\"><a href=\"#Thunkify模块\" class=\"headerlink\" title=\"Thunkify模块\"></a>Thunkify模块</h2><p>生产环境下转换器，可以使用Thunkify模块。使用<code>npm install thunkify</code>安装；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunkify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;thunkify&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><br><span class=\"hljs-keyword\">var</span> read = <span class=\"hljs-title function_\">thunkify</span>(rs.<span class=\"hljs-property\">readFile</span>);<br><span class=\"hljs-title function_\">read</span>(<span class=\"hljs-string\">&#x27;package.json&#x27;</span>)(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, str</span>)&#123;<br>  <span class=\"hljs-comment\">// concrete code</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"看到这你可能会问，这有什么用？\"><a href=\"#看到这你可能会问，这有什么用？\" class=\"headerlink\" title=\"看到这你可能会问，这有什么用？\"></a>看到这你可能会问，这有什么用？</h2><p>因为ES6现在新增了Generator函数，因此结合Thunk以后可以很好地管理Generartor流程。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> thunkify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;thunkify&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> readFile = <span class=\"hljs-title function_\">thunkify</span>(fs.<span class=\"hljs-property\">readFile</span>);<br><br><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> r1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-keyword\">var</span> r2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面的代码：yield命令用于将程序的执行权移出Generator函数。Thunk函数正好可以完成这个需求。</p>\n<h2 id=\"还没结束\"><a href=\"#还没结束\" class=\"headerlink\" title=\"还没结束\"></a>还没结束</h2><p>看完上面，你可能已经知道Thunk函数现在可以做到什么事情：没错，Thunk函数的真正威力是：可以自动执行Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-title function_\">fn</span>();<br>  <br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\">err, data</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = gen.<span class=\"hljs-title function_\">next</span>(data);<br>    <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">done</span>) <span class=\"hljs-keyword\">return</span>;<br>    result.<span class=\"hljs-title function_\">value</span>(next);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">next</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-title function_\">run</span>(g);<br></code></pre></td></tr></table></figure>\n<p>有了上面的执行器，那么下面执行Generator函数就简单了很多。不关内部有多少个异步操作，直接把Generator函数传入run函数即可。前提是每一个异步操作都必须是Thunk函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileA&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileB&#x27;</span>);<br>  <span class=\"hljs-comment\">// ...</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileN&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">run</span>(g);<br></code></pre></td></tr></table></figure>\n<h2 id=\"CO模块\"><a href=\"#CO模块\" class=\"headerlink\" title=\"CO模块\"></a>CO模块</h2><p>co模块是著名程序员TJ Holowaychuk发布一个小工具，用于Generator函数的自动执行。有了co模块，你可以不必自己编写Generator函数的执行器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> co = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;co&#x27;</span>);<br><span class=\"hljs-title function_\">co</span>(gen).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Generator execute success.&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 数组写法</span><br><span class=\"hljs-title function_\">co</span>(<span class=\"hljs-keyword\">function</span>* ()&#123;<br>  <span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-keyword\">yield</span> [<br>    <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>),<br>    <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">2</span>)<br>  ];<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);<br>&#125;).<span class=\"hljs-title function_\">catch</span>(onerror);<br><br><span class=\"hljs-comment\">// 对象写法</span><br><span class=\"hljs-title function_\">co</span>(<span class=\"hljs-keyword\">function</span>* ()&#123;<br>  <span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-keyword\">yield</span> &#123;<br>    <span class=\"hljs-number\">1</span>: <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>),<br>    <span class=\"hljs-number\">2</span>: <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">2</span>)<br>  &#125;;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);<br>&#125;).<span class=\"hljs-title function_\">catch</span>(onerror);<br></code></pre></td></tr></table></figure>\n<h2 id=\"async函数\"><a href=\"#async函数\" class=\"headerlink\" title=\"async函数\"></a>async函数</h2><p>ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话：async函数就是Generator函数的语法糖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> asyncReadFile = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>语法上来看，跟Generator函数的使用基本类似，但是在其基础上还是有一点改进：</p>\n<ul>\n<li>（1）内置执行器：因此async函数执行和普通函数一样，只需要一行即可；</li>\n<li>（2）更好的语义，这个一目了然；</li>\n<li>（3）更广的适用性：即可支持Promise，也可以支持普通对象；</li>\n<li>（4）返回值是Promise，因此可以使用then指定下一步操作；</li>\n</ul>\n<p>如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的对象会被catch方法回调接收到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Wrong&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>().<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v),<br>  <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e)<br>)<br></code></pre></td></tr></table></figure>\n<p>其次：async函数返回的Promise对象，必须等到所有的await命令的Promise对象执行完，才发发生改变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getTitle</span>(<span class=\"hljs-params\">url</span>) &#123;<br>\t<span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);<br>  <span class=\"hljs-keyword\">let</span> html = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">text</span>();<br>  <span class=\"hljs-keyword\">return</span> html.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"hljs-number\">1</span>];<br>&#125;<br><br><span class=\"hljs-title function_\">getTitle</span>(<span class=\"hljs-string\">&#x27;https://github.com/Humphrey75432&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>（1）<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>reject</code>，所以最好把<code>await</code>命令放入<code>try...catch</code>块中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">somethingThatReturnsAPromise</span>();<br>    &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// Another grammar</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">somethingThatReturnsAPromise</span>()<br>    \t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>（2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。这样会提升执行效率</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [foo, bar] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<span class=\"hljs-title function_\">getFoo</span>(), <span class=\"hljs-title function_\">getBar</span>()]);<br><br><span class=\"hljs-comment\">// second grammar</span><br><span class=\"hljs-keyword\">let</span> fooPromise = <span class=\"hljs-title function_\">getFoo</span>();<br><span class=\"hljs-keyword\">let</span> barPromise = <span class=\"hljs-title function_\">getBar</span>();<br><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-keyword\">await</span> fooPromise;<br><span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-keyword\">await</span> barPromise;<br></code></pre></td></tr></table></figure>\n<p>（3）如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dbFuc</span>(<span class=\"hljs-params\">db</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.<span class=\"hljs-title function_\">post</span>(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results);<br>&#125;<br><br><span class=\"hljs-comment\">// 或者使用下面的写法</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dbFuc</span>(<span class=\"hljs-params\">db</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.<span class=\"hljs-title function_\">post</span>(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = [];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> promise <span class=\"hljs-keyword\">of</span> promises) &#123;<br>    results.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-keyword\">await</span> promise);<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results);<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 类","date":"2022-02-17T14:21:01.000Z","updated":"2022-02-17T14:21:01.000Z","_content":"\n# ES6 Class\n\n## 基本概念\n\nES6为了使JavaScript更接近C++、Java等面向对象的高级语言，引入了Class的概念。语法角度来说Class仅仅是一个语法糖，其绝大部分功能都是ES5的实现。所以是对编程人员友好而设计的。有个例子能充分说明这个问题。\n\n```javascript\n// ES5\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype.toString = function() {\n    return '(' + this.x + ', ' + this.y + ')';\n}\n\nvar p = new Point(1, 2);\n\n// ES6 更加符合面向对象语言的习惯\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    toString() {\n        return '(' + this.x + ', ' + this.y + ')';\n    }\n}\nvar p = new Point(1, 2);\n```\n\n可以看出，调用类的实例方法，实际上就是调用对象的原型方法。那么对Object的操作对于Class完全适用。例如我可以使用Object.assign方法给类新增很多方法。\n\n```javascript\nclass Point {\n    constructor() {\n        // ...\n    }\n}\n\nObject.assign(Point.prototype, {\n    toString() {},\n    toValue() {}\n});\n```\n\n## constructor方法\n\n对象的构造函数，会在对象创建的时候调用，可以用来初始化对象的属性。除此之外，和C++/Java等语言不同的是，constructor中完全可以指定返回另外一个对象。\n\n```javascript\nclass Foo {\n    constructor() {\n        return Object.create(null);\n    }\n}\n\nnew Foo() instanceof Foo // false\n```\n\n## 类的实例对象\n\n需要使用`new`关键字来生成。如果忘记使用new关键字而是直接像使用函数那样使用Class会报错。和ES5一样，除非属性显示定义在其本身，否则都是定义在原型上的。\n\n```javascript\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n## 不存在变量提升\n\nClass不存在变量提升，这一点和ES5完全不同：由于ES6不会把类的声明提升到代码头部。必须保证子类在父类之后定义。\n\n## Class表达式\n\n与函数一样，类也可以使用表达式的形式定义。需要注明的是`const`关键字后面的才是真正的类名，而`class`后面的仅仅是内部类名，可以使用`this`关键字指代。\n\n```javascript\nconst MyClass = class Me {\n    getClassName() {\n        return Me.name;\n    }\n};\n```\n\n使用Class表达式，可以立即写出执行的Class\n\n```javascript\nlet person = new class {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    sayName() {\n        console.log(this.name);\n    }\n}('ZhangSan');\n\nperson.sayName(); // 'ZhangSan'\n```\n\n## 私有方法\n\n利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值，从而达到私有方法和私有属性的效果。\n\n```javascript\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass {\n    foo(baz) {\n        this[bar](baz);\n    }\n    \n    [bar](baz) {\n        return this[snaf] = baz;\n    }\n    \n    // ...\n}\n```\n\n## this的指向\n\n类的方法内部如果含有this，默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。\n\n```javascript\nclass Logger {\n    printName(name = 'there') {\n        this.print(`Hello ${name}`);\n    }\n    \n    print(text) {\n        console.log(text);\n    }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n```\n\n将printName提取出来使用会报错，因为默认情况下this是指向Logger类的实例。但是一旦将该方法提起出来单独使用，this就会指向该方法运行时所在的环境。为了解决这个问题可以使用下面两种方法。\n\n```javascript\n// 在构造函数中重新自动this关键字的指向\nclass Logger {\n    constructor(){\n        this.printName = this.printName.bind(this);\n    }\n}\n\n// 使用箭头函数来改变this关键字的指向\nclass Logger {\n    constructor() {\n        this.printName = (name = 'there') => {\n            this.print(`Hello ${name}`);\n        };\n    }\n}\n```\n\n还有一种方法是使用Proxy，获取方法的时候自动绑定this.\n\n```javascript\nfunction selfish(target) {\n    const cache = new WeakMap();\n    const handler = {\n        get(target, key){\n            const value = Reflect.get(target, key);\n            if (typeof value !== 'function') {\n                return value;\n            }\n            if (!cache.has(value)) {\n                cache.set(value, value.bind(target));\n            }\n            return cache.get(value);\n        }\n    };\n    const proxy = new Proxy(target, handler);\n    return proxy;\n}\n\nconst logger = selfish(new Logger());\n```\n\n## 严格模式\n\n类和模块的内部默认使用的就是严格模式，所以不需要显式指定。\n\n## Class继承\n\n### 基本用法\n\n和其他高级编程语言（C++，Java）一样，ES6也提供了类似`extends`关键字来实现继承。\n\n```javascript\nclass ColorPoint extends Point {}\n```\n\n需要注意的是：在子类的构造函数中，只有调用`super`关键字以后才可以使用`this`关键字，否则会报错。这是因为子类实例的构建是基于对父类的加工，因此只有super方法才能但会父类实例。\n\n```javascript\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y);\n        ths.color = color;\n    }\n}\n```\n\n## 类的prototype属性和\\_\\_proto\\_\\_属性\n\nClass作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。\n\n（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类；\n\n（2）子类的prototype属性和`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。\n\n```javascript\nclass A {\n    \n}\n\nclass B extends A {\n    \n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n```\n\n因此可以这样理解：作为一个对象，子类B的原型(\\_\\_proto\\_\\_)是父类A；作为一个构造函数，子类B的原型(prototype.\\_\\_proto\\_\\_)是父类A的实例；\n\n## super关键字\n\n`super`既可以当函数使用，也可以当对象使用，两种情况下的使用方法完全不同；\n\n### 当函数使用\n\n这个很简单：作为函数调用时，代表的是父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数。\n\n### 当对象使用\n\nsuper作为对象时，指向的是父类的原型对象。例子如下：\n\n```javascript\nclass A {\n    p() {\n        return 2;\n    }\n}\n\nclass B extends A {\n    constructor() {\n        super();\n        console.log(super.p());\n    }\n}\n\nlet b = new B();\n```\n\n这个时候子类B当中的`super.p()`就是将super当做一个对象使用。所以`super`指向的是`A.prototype`，所以`super.p()`就相当于`A.prototype.p()`。需要注意的是：由于`super`指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过`super`调用的。\n\n```javascript\nclass A {\n    constructor() {\n        this.p = 2;\n    }\n}\n\nclass B extends A {\n    get m() {\n        return super.p;\n    }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n如果是定义在父类原型上，`super`就可以取到。\n\n```javascript\nclass A {}\nA.prototype.x = 2;\n\nclass B extends A {\n    constructor() {\n        super();\n        console.log(super.x) // 2\n    }\n}\n\nlet b = new B();\n```\n\n上面代码中，由于属性x是定义在A.prototype上面的，因此super.x就可以取到它的值。\n\n## Class的取值函数（getter）和存值函数（setter）\n\n和其他高级语言一样，可以使用get、set关键字，对某个属性设置存值和取值函数，拦截该属性的存取行为。\n\n```javascript\nclass MyClass {\n    constructor() {\n        // ...\n    }\n    \n    get prop() {\n        return 'getter';\n    }\n    \n    set prop(value) {\n        console.log('setter: ' + value);\n    }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n\ninst.prop // 123\n```\n\n## Class的Generator方法\n\n如果某个方法之前加上星号，就表示该方法是一个Generator函数。\n\n```javascript\nclass Foo {\n    constructor(...args) {\n        this.args = args;\n    }\n    \n    * [Symbol.iterator]() {\n        for (let arg of this.arg) {\n            yield arg;\n        }\n    }\n}\n\nfor (let x of new Foo('hello', 'world')) {\n    console.log(x);\n}\n// hello\n// world\n```\n\n## Class的静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称之为静态方法。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n\n父类的静态方法可以被子类继承。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod(); // 'hello'\n```\n\n## Class的静态属性和实例属性\n\n静态属性指的是Class本身的属性，即`Class.propname`，而不是定义在实例对象（`this`)上的属性。目前Babel转码器提供了这两种写法的支持。\n\n- 类的实例属性\n\n  类的实例属性可以用等式，写入类的定义之中\n\n  ```javascript\n  class ReactCounter extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        count: 0\n      };\n    }\n    state;\n  }\n  ```\n\n- 类的静态属性\n\n类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。\n\n```javascript\nclass MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myProp); // 42\n  }\n}\n```\n\n## new.target属性\n\n`new`是从构造函数生成实例的命令，ES6为了`new`命令引入了一个`new.target`属性，返回`new`命令作用于那个构造函数。如果构造函数不是通过`new`命令调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是如何调用的。\n\n```javascript\nfunction Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n\n## Mixin模式的实现\n\nMixin模式指的是，将多个类的接口“混入”另一个类，在ES6的实现如下。\n\n```javascript\nfunction mix(...mixins) {\n  class Mix {}\n\n  for (let mixin of mixins) {\n    copyProperties(Mix, mixin);\n    copyProperties(Mix.prototype, mixin.prototype);\n  }\n\n  return Mix;\n}\n\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if ( key !== \"constructor\"\n      && key !== \"prototype\"\n      && key !== \"name\"\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n```\n","source":"_posts/javascript/es6-class.md","raw":"---\ntitle: ES6 类\ndate: 2022-02-17 22:21:01\nupdated: 2022-02-17 22:21:01\ntags: ES6基础\ncategories: JavaScript\n---\n\n# ES6 Class\n\n## 基本概念\n\nES6为了使JavaScript更接近C++、Java等面向对象的高级语言，引入了Class的概念。语法角度来说Class仅仅是一个语法糖，其绝大部分功能都是ES5的实现。所以是对编程人员友好而设计的。有个例子能充分说明这个问题。\n\n```javascript\n// ES5\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype.toString = function() {\n    return '(' + this.x + ', ' + this.y + ')';\n}\n\nvar p = new Point(1, 2);\n\n// ES6 更加符合面向对象语言的习惯\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    toString() {\n        return '(' + this.x + ', ' + this.y + ')';\n    }\n}\nvar p = new Point(1, 2);\n```\n\n可以看出，调用类的实例方法，实际上就是调用对象的原型方法。那么对Object的操作对于Class完全适用。例如我可以使用Object.assign方法给类新增很多方法。\n\n```javascript\nclass Point {\n    constructor() {\n        // ...\n    }\n}\n\nObject.assign(Point.prototype, {\n    toString() {},\n    toValue() {}\n});\n```\n\n## constructor方法\n\n对象的构造函数，会在对象创建的时候调用，可以用来初始化对象的属性。除此之外，和C++/Java等语言不同的是，constructor中完全可以指定返回另外一个对象。\n\n```javascript\nclass Foo {\n    constructor() {\n        return Object.create(null);\n    }\n}\n\nnew Foo() instanceof Foo // false\n```\n\n## 类的实例对象\n\n需要使用`new`关键字来生成。如果忘记使用new关键字而是直接像使用函数那样使用Class会报错。和ES5一样，除非属性显示定义在其本身，否则都是定义在原型上的。\n\n```javascript\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n## 不存在变量提升\n\nClass不存在变量提升，这一点和ES5完全不同：由于ES6不会把类的声明提升到代码头部。必须保证子类在父类之后定义。\n\n## Class表达式\n\n与函数一样，类也可以使用表达式的形式定义。需要注明的是`const`关键字后面的才是真正的类名，而`class`后面的仅仅是内部类名，可以使用`this`关键字指代。\n\n```javascript\nconst MyClass = class Me {\n    getClassName() {\n        return Me.name;\n    }\n};\n```\n\n使用Class表达式，可以立即写出执行的Class\n\n```javascript\nlet person = new class {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    sayName() {\n        console.log(this.name);\n    }\n}('ZhangSan');\n\nperson.sayName(); // 'ZhangSan'\n```\n\n## 私有方法\n\n利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值，从而达到私有方法和私有属性的效果。\n\n```javascript\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass {\n    foo(baz) {\n        this[bar](baz);\n    }\n    \n    [bar](baz) {\n        return this[snaf] = baz;\n    }\n    \n    // ...\n}\n```\n\n## this的指向\n\n类的方法内部如果含有this，默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。\n\n```javascript\nclass Logger {\n    printName(name = 'there') {\n        this.print(`Hello ${name}`);\n    }\n    \n    print(text) {\n        console.log(text);\n    }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n```\n\n将printName提取出来使用会报错，因为默认情况下this是指向Logger类的实例。但是一旦将该方法提起出来单独使用，this就会指向该方法运行时所在的环境。为了解决这个问题可以使用下面两种方法。\n\n```javascript\n// 在构造函数中重新自动this关键字的指向\nclass Logger {\n    constructor(){\n        this.printName = this.printName.bind(this);\n    }\n}\n\n// 使用箭头函数来改变this关键字的指向\nclass Logger {\n    constructor() {\n        this.printName = (name = 'there') => {\n            this.print(`Hello ${name}`);\n        };\n    }\n}\n```\n\n还有一种方法是使用Proxy，获取方法的时候自动绑定this.\n\n```javascript\nfunction selfish(target) {\n    const cache = new WeakMap();\n    const handler = {\n        get(target, key){\n            const value = Reflect.get(target, key);\n            if (typeof value !== 'function') {\n                return value;\n            }\n            if (!cache.has(value)) {\n                cache.set(value, value.bind(target));\n            }\n            return cache.get(value);\n        }\n    };\n    const proxy = new Proxy(target, handler);\n    return proxy;\n}\n\nconst logger = selfish(new Logger());\n```\n\n## 严格模式\n\n类和模块的内部默认使用的就是严格模式，所以不需要显式指定。\n\n## Class继承\n\n### 基本用法\n\n和其他高级编程语言（C++，Java）一样，ES6也提供了类似`extends`关键字来实现继承。\n\n```javascript\nclass ColorPoint extends Point {}\n```\n\n需要注意的是：在子类的构造函数中，只有调用`super`关键字以后才可以使用`this`关键字，否则会报错。这是因为子类实例的构建是基于对父类的加工，因此只有super方法才能但会父类实例。\n\n```javascript\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y);\n        ths.color = color;\n    }\n}\n```\n\n## 类的prototype属性和\\_\\_proto\\_\\_属性\n\nClass作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。\n\n（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类；\n\n（2）子类的prototype属性和`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。\n\n```javascript\nclass A {\n    \n}\n\nclass B extends A {\n    \n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n```\n\n因此可以这样理解：作为一个对象，子类B的原型(\\_\\_proto\\_\\_)是父类A；作为一个构造函数，子类B的原型(prototype.\\_\\_proto\\_\\_)是父类A的实例；\n\n## super关键字\n\n`super`既可以当函数使用，也可以当对象使用，两种情况下的使用方法完全不同；\n\n### 当函数使用\n\n这个很简单：作为函数调用时，代表的是父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数。\n\n### 当对象使用\n\nsuper作为对象时，指向的是父类的原型对象。例子如下：\n\n```javascript\nclass A {\n    p() {\n        return 2;\n    }\n}\n\nclass B extends A {\n    constructor() {\n        super();\n        console.log(super.p());\n    }\n}\n\nlet b = new B();\n```\n\n这个时候子类B当中的`super.p()`就是将super当做一个对象使用。所以`super`指向的是`A.prototype`，所以`super.p()`就相当于`A.prototype.p()`。需要注意的是：由于`super`指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过`super`调用的。\n\n```javascript\nclass A {\n    constructor() {\n        this.p = 2;\n    }\n}\n\nclass B extends A {\n    get m() {\n        return super.p;\n    }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n如果是定义在父类原型上，`super`就可以取到。\n\n```javascript\nclass A {}\nA.prototype.x = 2;\n\nclass B extends A {\n    constructor() {\n        super();\n        console.log(super.x) // 2\n    }\n}\n\nlet b = new B();\n```\n\n上面代码中，由于属性x是定义在A.prototype上面的，因此super.x就可以取到它的值。\n\n## Class的取值函数（getter）和存值函数（setter）\n\n和其他高级语言一样，可以使用get、set关键字，对某个属性设置存值和取值函数，拦截该属性的存取行为。\n\n```javascript\nclass MyClass {\n    constructor() {\n        // ...\n    }\n    \n    get prop() {\n        return 'getter';\n    }\n    \n    set prop(value) {\n        console.log('setter: ' + value);\n    }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n\ninst.prop // 123\n```\n\n## Class的Generator方法\n\n如果某个方法之前加上星号，就表示该方法是一个Generator函数。\n\n```javascript\nclass Foo {\n    constructor(...args) {\n        this.args = args;\n    }\n    \n    * [Symbol.iterator]() {\n        for (let arg of this.arg) {\n            yield arg;\n        }\n    }\n}\n\nfor (let x of new Foo('hello', 'world')) {\n    console.log(x);\n}\n// hello\n// world\n```\n\n## Class的静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称之为静态方法。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n\n父类的静态方法可以被子类继承。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod(); // 'hello'\n```\n\n## Class的静态属性和实例属性\n\n静态属性指的是Class本身的属性，即`Class.propname`，而不是定义在实例对象（`this`)上的属性。目前Babel转码器提供了这两种写法的支持。\n\n- 类的实例属性\n\n  类的实例属性可以用等式，写入类的定义之中\n\n  ```javascript\n  class ReactCounter extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        count: 0\n      };\n    }\n    state;\n  }\n  ```\n\n- 类的静态属性\n\n类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。\n\n```javascript\nclass MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myProp); // 42\n  }\n}\n```\n\n## new.target属性\n\n`new`是从构造函数生成实例的命令，ES6为了`new`命令引入了一个`new.target`属性，返回`new`命令作用于那个构造函数。如果构造函数不是通过`new`命令调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是如何调用的。\n\n```javascript\nfunction Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n\n## Mixin模式的实现\n\nMixin模式指的是，将多个类的接口“混入”另一个类，在ES6的实现如下。\n\n```javascript\nfunction mix(...mixins) {\n  class Mix {}\n\n  for (let mixin of mixins) {\n    copyProperties(Mix, mixin);\n    copyProperties(Mix.prototype, mixin.prototype);\n  }\n\n  return Mix;\n}\n\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if ( key !== \"constructor\"\n      && key !== \"prototype\"\n      && key !== \"name\"\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n```\n","slug":"javascript/es6-class","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vc00164f619tzwae94","content":"<h1 id=\"ES6-Class\"><a href=\"#ES6-Class\" class=\"headerlink\" title=\"ES6 Class\"></a>ES6 Class</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>ES6为了使JavaScript更接近C++、Java等面向对象的高级语言，引入了Class的概念。语法角度来说Class仅仅是一个语法糖，其绝大部分功能都是ES5的实现。所以是对编程人员友好而设计的。有个例子能充分说明这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Point</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>&#125;<br><br><span class=\"hljs-title class_\">Point</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-comment\">// ES6 更加符合面向对象语言的习惯</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>可以看出，调用类的实例方法，实际上就是调用对象的原型方法。那么对Object的操作对于Class完全适用。例如我可以使用Object.assign方法给类新增很多方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">Point</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, &#123;<br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;&#125;,<br>    <span class=\"hljs-title function_\">toValue</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h2><p>对象的构造函数，会在对象创建的时候调用，可以用来初始化对象的属性。除此之外，和C++/Java等语言不同的是，constructor中完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Foo</span> <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"类的实例对象\"><a href=\"#类的实例对象\" class=\"headerlink\" title=\"类的实例对象\"></a>类的实例对象</h2><p>需要使用<code>new</code>关键字来生成。如果忘记使用new关键字而是直接像使用函数那样使用Class会报错。和ES5一样，除非属性显示定义在其本身，否则都是定义在原型上的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//定义类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>  &#125;<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> point = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><br>point.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// (2, 3)</span><br><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;y&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;toString&#x27;</span>) <span class=\"hljs-comment\">// false</span><br>point.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;toString&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h2><p>Class不存在变量提升，这一点和ES5完全不同：由于ES6不会把类的声明提升到代码头部。必须保证子类在父类之后定义。</p>\n<h2 id=\"Class表达式\"><a href=\"#Class表达式\" class=\"headerlink\" title=\"Class表达式\"></a>Class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。需要注明的是<code>const</code>关键字后面的才是真正的类名，而<code>class</code>后面的仅仅是内部类名，可以使用<code>this</code>关键字指代。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MyClass</span> = <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Me</span> &#123;<br>    <span class=\"hljs-title function_\">getClassName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Me</span>.<span class=\"hljs-property\">name</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>使用Class表达式，可以立即写出执行的Class</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">class</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">sayName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;<br>&#125;(<span class=\"hljs-string\">&#x27;ZhangSan&#x27;</span>);<br><br>person.<span class=\"hljs-title function_\">sayName</span>(); <span class=\"hljs-comment\">// &#x27;ZhangSan&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h2><p>利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值，从而达到私有方法和私有属性的效果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> snaf = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;snaf&#x27;</span>);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myClass</span> &#123;<br>    <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">baz</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[bar](baz);<br>    &#125;<br>    <br>    [bar](baz) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>[snaf] = baz;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p>类的方法内部如果含有this，默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">printName</span>(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&#x27;there&#x27;</span></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>);<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\">text</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(text);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>();<br><span class=\"hljs-keyword\">const</span> &#123; printName &#125; = logger;<br><span class=\"hljs-title function_\">printName</span>(); <span class=\"hljs-comment\">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span><br></code></pre></td></tr></table></figure>\n<p>将printName提取出来使用会报错，因为默认情况下this是指向Logger类的实例。但是一旦将该方法提起出来单独使用，this就会指向该方法运行时所在的环境。为了解决这个问题可以使用下面两种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 在构造函数中重新自动this关键字的指向</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用箭头函数来改变this关键字的指向</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&#x27;there&#x27;</span></span>) =&gt;</span> &#123;<br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>还有一种方法是使用Proxy，获取方法的时候自动绑定this.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">selfish</span>(<span class=\"hljs-params\">target</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br>    <span class=\"hljs-keyword\">const</span> handler = &#123;<br>        <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, key</span>)&#123;<br>            <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key);<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> value !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>                <span class=\"hljs-keyword\">return</span> value;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (!cache.<span class=\"hljs-title function_\">has</span>(value)) &#123;<br>                cache.<span class=\"hljs-title function_\">set</span>(value, value.<span class=\"hljs-title function_\">bind</span>(target));<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> cache.<span class=\"hljs-title function_\">get</span>(value);<br>        &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br>    <span class=\"hljs-keyword\">return</span> proxy;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-title function_\">selfish</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>());<br></code></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>类和模块的内部默认使用的就是严格模式，所以不需要显式指定。</p>\n<h2 id=\"Class继承\"><a href=\"#Class继承\" class=\"headerlink\" title=\"Class继承\"></a>Class继承</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>和其他高级编程语言（C++，Java）一样，ES6也提供了类似<code>extends</code>关键字来实现继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Point</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：在子类的构造函数中，只有调用<code>super</code>关键字以后才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建是基于对父类的加工，因此只有super方法才能但会父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y, color</span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>(x, y);<br>        ths.<span class=\"hljs-property\">color</span> = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"类的prototype属性和-proto-属性\"><a href=\"#类的prototype属性和-proto-属性\" class=\"headerlink\" title=\"类的prototype属性和__proto__属性\"></a>类的prototype属性和__proto__属性</h2><p>Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>\n<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类；</p>\n<p>（2）子类的prototype属性和<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <br>&#125;<br><br>B.<span class=\"hljs-property\">__proto__</span> === A <span class=\"hljs-comment\">// true</span><br>B.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> === A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>因此可以这样理解：作为一个对象，子类B的原型(__proto__)是父类A；作为一个构造函数，子类B的原型(prototype.__proto__)是父类A的实例；</p>\n<h2 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h2><p><code>super</code>既可以当函数使用，也可以当对象使用，两种情况下的使用方法完全不同；</p>\n<h3 id=\"当函数使用\"><a href=\"#当函数使用\" class=\"headerlink\" title=\"当函数使用\"></a>当函数使用</h3><p>这个很简单：作为函数调用时，代表的是父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数。</p>\n<h3 id=\"当对象使用\"><a href=\"#当对象使用\" class=\"headerlink\" title=\"当对象使用\"></a>当对象使用</h3><p>super作为对象时，指向的是父类的原型对象。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-title function_\">p</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>();<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">p</span>());<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br></code></pre></td></tr></table></figure>\n<p>这个时候子类B当中的<code>super.p()</code>就是将super当做一个对象使用。所以<code>super</code>指向的是<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。需要注意的是：由于<code>super</code>指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">p</span> = <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">m</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">p</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br>b.<span class=\"hljs-property\">m</span> <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>如果是定义在父类原型上，<code>super</code>就可以取到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;&#125;<br>A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">2</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>();<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">x</span>) <span class=\"hljs-comment\">// 2</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br></code></pre></td></tr></table></figure>\n<p>上面代码中，由于属性x是定义在A.prototype上面的，因此super.x就可以取到它的值。</p>\n<h2 id=\"Class的取值函数（getter）和存值函数（setter）\"><a href=\"#Class的取值函数（getter）和存值函数（setter）\" class=\"headerlink\" title=\"Class的取值函数（getter）和存值函数（setter）\"></a>Class的取值函数（getter）和存值函数（setter）</h2><p>和其他高级语言一样，可以使用get、set关键字，对某个属性设置存值和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">prop</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;getter&#x27;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-params\">value</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;setter: &#x27;</span> + value);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> inst = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClass</span>();<br><br>inst.<span class=\"hljs-property\">prop</span> = <span class=\"hljs-number\">123</span>;<br><br>inst.<span class=\"hljs-property\">prop</span> <span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的Generator方法\"><a href=\"#Class的Generator方法\" class=\"headerlink\" title=\"Class的Generator方法\"></a>Class的Generator方法</h2><p>如果某个方法之前加上星号，就表示该方法是一个Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">args</span> = args;<br>    &#125;<br>    <br>    * [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> arg <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">arg</span>) &#123;<br>            <span class=\"hljs-keyword\">yield</span> arg;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br><span class=\"hljs-comment\">// hello</span><br><span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的静态方法\"><a href=\"#Class的静态方法\" class=\"headerlink\" title=\"Class的静态方法\"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称之为静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">classMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-title class_\">Foo</span>.<span class=\"hljs-title function_\">classMethod</span>() <span class=\"hljs-comment\">// &#x27;hello&#x27;</span><br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>();<br>foo.<span class=\"hljs-title function_\">classMethod</span>()<br><span class=\"hljs-comment\">// TypeError: foo.classMethod is not a function</span><br></code></pre></td></tr></table></figure>\n<p>父类的静态方法可以被子类继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">classMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bar</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Foo</span> &#123;<br>&#125;<br><br><span class=\"hljs-title class_\">Bar</span>.<span class=\"hljs-title function_\">classMethod</span>(); <span class=\"hljs-comment\">// &#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的静态属性和实例属性\"><a href=\"#Class的静态属性和实例属性\" class=\"headerlink\" title=\"Class的静态属性和实例属性\"></a>Class的静态属性和实例属性</h2><p>静态属性指的是Class本身的属性，即<code>Class.propname</code>，而不是定义在实例对象（<code>this</code>)上的属性。目前Babel转码器提供了这两种写法的支持。</p>\n<ul>\n<li><p>类的实例属性</p>\n<p>类的实例属性可以用等式，写入类的定义之中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ReactCounter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props</span>) &#123;<br>    <span class=\"hljs-variable language_\">super</span>(props);<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;;<br>  &#125;<br>  state;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>类的静态属性</p>\n</li>\n</ul>\n<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> myStaticProp = <span class=\"hljs-number\">42</span>;<br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\">myProp</span>); <span class=\"hljs-comment\">// 42</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"new-target属性\"><a href=\"#new-target属性\" class=\"headerlink\" title=\"new.target属性\"></a>new.target属性</h2><p><code>new</code>是从构造函数生成实例的命令，ES6为了<code>new</code>命令引入了一个<code>new.target</code>属性，返回<code>new</code>命令作用于那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是如何调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span> !== <span class=\"hljs-literal\">undefined</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;必须使用new生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span> === <span class=\"hljs-title class_\">Person</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;必须使用new生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;张三&#x27;</span>); <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">var</span> notAPerson = <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(person, <span class=\"hljs-string\">&#x27;张三&#x27;</span>);  <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Mixin模式的实现\"><a href=\"#Mixin模式的实现\" class=\"headerlink\" title=\"Mixin模式的实现\"></a>Mixin模式的实现</h2><p>Mixin模式指的是，将多个类的接口“混入”另一个类，在ES6的实现如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mix</span>(<span class=\"hljs-params\">...mixins</span>) &#123;<br>  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mix</span> &#123;&#125;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> mixin <span class=\"hljs-keyword\">of</span> mixins) &#123;<br>    <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-title class_\">Mix</span>, mixin);<br>    <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-title class_\">Mix</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, mixin.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Mix</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-params\">target, source</span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(source)) &#123;<br>    <span class=\"hljs-keyword\">if</span> ( key !== <span class=\"hljs-string\">&quot;constructor&quot;</span><br>      &amp;&amp; key !== <span class=\"hljs-string\">&quot;prototype&quot;</span><br>      &amp;&amp; key !== <span class=\"hljs-string\">&quot;name&quot;</span><br>    ) &#123;<br>      <span class=\"hljs-keyword\">let</span> desc = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(source, key);<br>      <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, key, desc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":7570,"excerpt":"","more":"<h1 id=\"ES6-Class\"><a href=\"#ES6-Class\" class=\"headerlink\" title=\"ES6 Class\"></a>ES6 Class</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>ES6为了使JavaScript更接近C++、Java等面向对象的高级语言，引入了Class的概念。语法角度来说Class仅仅是一个语法糖，其绝大部分功能都是ES5的实现。所以是对编程人员友好而设计的。有个例子能充分说明这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Point</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>&#125;<br><br><span class=\"hljs-title class_\">Point</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-comment\">// ES6 更加符合面向对象语言的习惯</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>可以看出，调用类的实例方法，实际上就是调用对象的原型方法。那么对Object的操作对于Class完全适用。例如我可以使用Object.assign方法给类新增很多方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">Point</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, &#123;<br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;&#125;,<br>    <span class=\"hljs-title function_\">toValue</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h2><p>对象的构造函数，会在对象创建的时候调用，可以用来初始化对象的属性。除此之外，和C++/Java等语言不同的是，constructor中完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Foo</span> <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"类的实例对象\"><a href=\"#类的实例对象\" class=\"headerlink\" title=\"类的实例对象\"></a>类的实例对象</h2><p>需要使用<code>new</code>关键字来生成。如果忘记使用new关键字而是直接像使用函数那样使用Class会报错。和ES5一样，除非属性显示定义在其本身，否则都是定义在原型上的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//定义类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>  &#125;<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> point = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><br>point.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// (2, 3)</span><br><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;y&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;toString&#x27;</span>) <span class=\"hljs-comment\">// false</span><br>point.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;toString&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h2><p>Class不存在变量提升，这一点和ES5完全不同：由于ES6不会把类的声明提升到代码头部。必须保证子类在父类之后定义。</p>\n<h2 id=\"Class表达式\"><a href=\"#Class表达式\" class=\"headerlink\" title=\"Class表达式\"></a>Class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。需要注明的是<code>const</code>关键字后面的才是真正的类名，而<code>class</code>后面的仅仅是内部类名，可以使用<code>this</code>关键字指代。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MyClass</span> = <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Me</span> &#123;<br>    <span class=\"hljs-title function_\">getClassName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Me</span>.<span class=\"hljs-property\">name</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>使用Class表达式，可以立即写出执行的Class</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">class</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">sayName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;<br>&#125;(<span class=\"hljs-string\">&#x27;ZhangSan&#x27;</span>);<br><br>person.<span class=\"hljs-title function_\">sayName</span>(); <span class=\"hljs-comment\">// &#x27;ZhangSan&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h2><p>利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值，从而达到私有方法和私有属性的效果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> snaf = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;snaf&#x27;</span>);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myClass</span> &#123;<br>    <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">baz</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[bar](baz);<br>    &#125;<br>    <br>    [bar](baz) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>[snaf] = baz;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p>类的方法内部如果含有this，默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">printName</span>(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&#x27;there&#x27;</span></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>);<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\">text</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(text);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>();<br><span class=\"hljs-keyword\">const</span> &#123; printName &#125; = logger;<br><span class=\"hljs-title function_\">printName</span>(); <span class=\"hljs-comment\">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span><br></code></pre></td></tr></table></figure>\n<p>将printName提取出来使用会报错，因为默认情况下this是指向Logger类的实例。但是一旦将该方法提起出来单独使用，this就会指向该方法运行时所在的环境。为了解决这个问题可以使用下面两种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 在构造函数中重新自动this关键字的指向</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用箭头函数来改变this关键字的指向</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&#x27;there&#x27;</span></span>) =&gt;</span> &#123;<br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>还有一种方法是使用Proxy，获取方法的时候自动绑定this.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">selfish</span>(<span class=\"hljs-params\">target</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br>    <span class=\"hljs-keyword\">const</span> handler = &#123;<br>        <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, key</span>)&#123;<br>            <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key);<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> value !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>                <span class=\"hljs-keyword\">return</span> value;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (!cache.<span class=\"hljs-title function_\">has</span>(value)) &#123;<br>                cache.<span class=\"hljs-title function_\">set</span>(value, value.<span class=\"hljs-title function_\">bind</span>(target));<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> cache.<span class=\"hljs-title function_\">get</span>(value);<br>        &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br>    <span class=\"hljs-keyword\">return</span> proxy;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-title function_\">selfish</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>());<br></code></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>类和模块的内部默认使用的就是严格模式，所以不需要显式指定。</p>\n<h2 id=\"Class继承\"><a href=\"#Class继承\" class=\"headerlink\" title=\"Class继承\"></a>Class继承</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>和其他高级编程语言（C++，Java）一样，ES6也提供了类似<code>extends</code>关键字来实现继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Point</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：在子类的构造函数中，只有调用<code>super</code>关键字以后才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建是基于对父类的加工，因此只有super方法才能但会父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y, color</span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>(x, y);<br>        ths.<span class=\"hljs-property\">color</span> = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"类的prototype属性和-proto-属性\"><a href=\"#类的prototype属性和-proto-属性\" class=\"headerlink\" title=\"类的prototype属性和__proto__属性\"></a>类的prototype属性和__proto__属性</h2><p>Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>\n<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类；</p>\n<p>（2）子类的prototype属性和<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <br>&#125;<br><br>B.<span class=\"hljs-property\">__proto__</span> === A <span class=\"hljs-comment\">// true</span><br>B.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> === A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>因此可以这样理解：作为一个对象，子类B的原型(__proto__)是父类A；作为一个构造函数，子类B的原型(prototype.__proto__)是父类A的实例；</p>\n<h2 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h2><p><code>super</code>既可以当函数使用，也可以当对象使用，两种情况下的使用方法完全不同；</p>\n<h3 id=\"当函数使用\"><a href=\"#当函数使用\" class=\"headerlink\" title=\"当函数使用\"></a>当函数使用</h3><p>这个很简单：作为函数调用时，代表的是父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数。</p>\n<h3 id=\"当对象使用\"><a href=\"#当对象使用\" class=\"headerlink\" title=\"当对象使用\"></a>当对象使用</h3><p>super作为对象时，指向的是父类的原型对象。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-title function_\">p</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>();<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">p</span>());<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br></code></pre></td></tr></table></figure>\n<p>这个时候子类B当中的<code>super.p()</code>就是将super当做一个对象使用。所以<code>super</code>指向的是<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。需要注意的是：由于<code>super</code>指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">p</span> = <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">m</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">p</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br>b.<span class=\"hljs-property\">m</span> <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>如果是定义在父类原型上，<code>super</code>就可以取到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;&#125;<br>A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">2</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>();<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">x</span>) <span class=\"hljs-comment\">// 2</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br></code></pre></td></tr></table></figure>\n<p>上面代码中，由于属性x是定义在A.prototype上面的，因此super.x就可以取到它的值。</p>\n<h2 id=\"Class的取值函数（getter）和存值函数（setter）\"><a href=\"#Class的取值函数（getter）和存值函数（setter）\" class=\"headerlink\" title=\"Class的取值函数（getter）和存值函数（setter）\"></a>Class的取值函数（getter）和存值函数（setter）</h2><p>和其他高级语言一样，可以使用get、set关键字，对某个属性设置存值和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">prop</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;getter&#x27;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-params\">value</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;setter: &#x27;</span> + value);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> inst = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClass</span>();<br><br>inst.<span class=\"hljs-property\">prop</span> = <span class=\"hljs-number\">123</span>;<br><br>inst.<span class=\"hljs-property\">prop</span> <span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的Generator方法\"><a href=\"#Class的Generator方法\" class=\"headerlink\" title=\"Class的Generator方法\"></a>Class的Generator方法</h2><p>如果某个方法之前加上星号，就表示该方法是一个Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">args</span> = args;<br>    &#125;<br>    <br>    * [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> arg <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">arg</span>) &#123;<br>            <span class=\"hljs-keyword\">yield</span> arg;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br><span class=\"hljs-comment\">// hello</span><br><span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的静态方法\"><a href=\"#Class的静态方法\" class=\"headerlink\" title=\"Class的静态方法\"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称之为静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">classMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-title class_\">Foo</span>.<span class=\"hljs-title function_\">classMethod</span>() <span class=\"hljs-comment\">// &#x27;hello&#x27;</span><br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>();<br>foo.<span class=\"hljs-title function_\">classMethod</span>()<br><span class=\"hljs-comment\">// TypeError: foo.classMethod is not a function</span><br></code></pre></td></tr></table></figure>\n<p>父类的静态方法可以被子类继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">classMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bar</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Foo</span> &#123;<br>&#125;<br><br><span class=\"hljs-title class_\">Bar</span>.<span class=\"hljs-title function_\">classMethod</span>(); <span class=\"hljs-comment\">// &#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的静态属性和实例属性\"><a href=\"#Class的静态属性和实例属性\" class=\"headerlink\" title=\"Class的静态属性和实例属性\"></a>Class的静态属性和实例属性</h2><p>静态属性指的是Class本身的属性，即<code>Class.propname</code>，而不是定义在实例对象（<code>this</code>)上的属性。目前Babel转码器提供了这两种写法的支持。</p>\n<ul>\n<li><p>类的实例属性</p>\n<p>类的实例属性可以用等式，写入类的定义之中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ReactCounter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props</span>) &#123;<br>    <span class=\"hljs-variable language_\">super</span>(props);<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;;<br>  &#125;<br>  state;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>类的静态属性</p>\n</li>\n</ul>\n<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> myStaticProp = <span class=\"hljs-number\">42</span>;<br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\">myProp</span>); <span class=\"hljs-comment\">// 42</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"new-target属性\"><a href=\"#new-target属性\" class=\"headerlink\" title=\"new.target属性\"></a>new.target属性</h2><p><code>new</code>是从构造函数生成实例的命令，ES6为了<code>new</code>命令引入了一个<code>new.target</code>属性，返回<code>new</code>命令作用于那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是如何调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span> !== <span class=\"hljs-literal\">undefined</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;必须使用new生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span> === <span class=\"hljs-title class_\">Person</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;必须使用new生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;张三&#x27;</span>); <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">var</span> notAPerson = <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(person, <span class=\"hljs-string\">&#x27;张三&#x27;</span>);  <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Mixin模式的实现\"><a href=\"#Mixin模式的实现\" class=\"headerlink\" title=\"Mixin模式的实现\"></a>Mixin模式的实现</h2><p>Mixin模式指的是，将多个类的接口“混入”另一个类，在ES6的实现如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mix</span>(<span class=\"hljs-params\">...mixins</span>) &#123;<br>  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mix</span> &#123;&#125;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> mixin <span class=\"hljs-keyword\">of</span> mixins) &#123;<br>    <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-title class_\">Mix</span>, mixin);<br>    <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-title class_\">Mix</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, mixin.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Mix</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-params\">target, source</span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(source)) &#123;<br>    <span class=\"hljs-keyword\">if</span> ( key !== <span class=\"hljs-string\">&quot;constructor&quot;</span><br>      &amp;&amp; key !== <span class=\"hljs-string\">&quot;prototype&quot;</span><br>      &amp;&amp; key !== <span class=\"hljs-string\">&quot;name&quot;</span><br>    ) &#123;<br>      <span class=\"hljs-keyword\">let</span> desc = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(source, key);<br>      <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, key, desc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 函数扩展","date":"2022-02-17T07:07:14.000Z","updated":"2022-02-17T07:07:14.000Z","_content":"\n# 函数的扩展\n\n## 函数参数的默认值\n\nES6以前函数参数是不能有默认值的，而ES6中对这个规则进行了修改了，函数参数也可以带默认参数。即直接写在参数定义的后面。\n\n```javascript\nfunction log(x, y = 'World') {\n    console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n这样的写法有两个好处：一个是阅读代码的人可以立刻意识到哪些参数是可以省略的，不需要查看函数体；其次有利于代码将来的优化。即便在未来的版本对外接口中，彻底拿掉这个参数也不会导致原有代码无法运行。\n\n### 结合解构赋值\n\n参数默认值当然可以使用前面章节提到的解构特性进行赋值了。\n\n```javascript\nfunction foo({x, y = 5}) {\n    console.log(x, y);\n}\n\nfoo({}) // undefined, 5\nfoo({x: 1}) // 1, 5\nfoo({x: 1, y: 2}) // 1, 2\nfoo() // Error\n```\n\n### 参数默认值的位置\n\n一般情况下定义了默认值的参数应该是函数的尾部，这样比较容易看出来，如果是非尾部的参数设置默认值，实际上该参数是没法省略的。\n\n```javascript\nfunction (x = 1, y) {\n    return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined]\nf(, 1) // Error\nf(undefined, 1) // [1, 1]\n\nfunction (x, y = 5, z) {\n    return [x, y, z];\n}\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // Error\nf(1, undefinied, 2) // [1, 5, 2]\n```\n\n### length属性\n\n函数的length属性将返回没有指定默认值的参数个数。也就是说：指定了默认值后，length属性将失真；\n\n```javascript\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n```\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再记入后面的参数了。\n\n```javascript\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n```\n\n### 作用域\n\n如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。\n\n```javascript\nvar x = 1;\n\nfunction f(x, y = x) {\n    console.log(y);\n}\n\nf(2) // 2\n```\n\n如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域\n\n```javascript\nlet foo = 'outer';\n\n// func为一个默认匿名函数，返回值为变量foo\nfunction bar(func = x => foo) {\n    let foo = 'inner';\n    console.log(func());\n}\n\nbar(); // outer\n```\n\n### 默认参数的用途一目了然\n\n利用默认参数值，可以指定某一个参数不得省略，一旦省略就抛出一个错误；如果想省略这个参数，只要设置成`undefined`就行了。\n\n```javascript\nfunction throwIfMissing() {\n    throw new Error('Missing parameters');\n}\n\nfunction foo(mustBeProvided = throwIfMissing()) {\n    return mustBeProvided;\n}\n\nfoo(); // Error: Missing Parameters\n```\n\n### rest参数\n\n顾名思义：就是入参的个数是不确定的，跟Java中的多参数语法类似。这里就不再赘述了。\n\n```javascript\nfunction add(...values) {\n    let sum = 0;\n    \n    for (var val of values) {\n        sum += val;\n    }\n    \n    return sum;\n}\n\nadd(1, 2, 3, 4) // 10\n```\n\n## 扩展运算符\n\n扩展运算符为三个点`...`，是将一个数组转化为用逗号分隔的参数序列，是rest参数的逆运算。\n\n```javascript\nconsole.log(...[1, 2, 3]) // 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5\n\n[...document.querySelectorAll('div')] // [<div>, <div>, <div>]\n```\n\n该运算符主要用于函数调用\n\n```javascript\nfunction push(array, ...items) {\n    array.push(...items);\n}\n\nfunction add(x, y) {\n    return x + y;\n}\n\nvar numbers = [4, 38];\nadd(...numbers) // 42\n```\n\n### 扩展运算符的应用\n\n#### （1）合并数组\n\n```javascript\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['e', 'f'];\n\n[...arr1, ...arr2, ...arr3] // ['a', 'b', 'c', 'e', 'f']\n```\n\n#### （2） 与解构赋值结合\n\n```javascript\na = list[0], rest = list.slice(1)\n\n[a, ...rest] = list\n\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest // [2, 3, 4, 5]\n\nconst [first, ...rest] = []\nfirst // undefined\nrest // []\n\nconst [first, ...rest] = ['foo']\nfirst // foo\nrest // []\n```\n\n#### （3）函数返回值\n\nJavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种办法：\n\n```javascript\nvar dateFields = readDateFields(database);\nvar d = new Date(...dateFields);\n```\n\n#### （4）字符串\n\n可以将字符串转换为真正的数组。因为扩展运算符可以很好地识别Unicode字符，因此最好都用扩展运算符；\n\n```javascript\n[...'hello']\n// ['h', 'e', 'l', 'l', 'o']\n```\n\n#### （5）实现了Iterator接口的对象\n\n任何Iterator接口的对象，都可以用扩展运算符转换为真正的数组，之前已经提过了，这里不再赘述\n\n#### （6）Map和Set结构、Generator函数\n\n承接第（5）点，Map和Set也部署了Iterator接口，所以也可以使用扩展运算符，Generator函数运行后返回的是一个遍历器对象，因此也可以使用扩展运算符。\n\n```javascript\nvar go = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...go()] // [1, 2, 3]\n```\n\n## 严格模式\n\n从ES5开始，函数内部可以使用严格模式，在ES2016中做了一点修改。规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。\n\n这样规定的原因是：函数内部的严格模式同时适用于函数体和函数参数。但是函数执行时会先执行函数参数代码，再执行函数体代码。因此只有从函数体代码之中才能知道参数代码是否应该以严格模式执行，但是函数参数代码又要先于函数体执行。所以这就导致了不合理的存在。\n\n```javascript\nfunction doSomething(value = 070) { // value = 070 先执行\n    'use strict'; // 设置了严格模式\n    return value; // 后执行\n}\n// Illegal 'use strict' directive in function with non-simple parameter list\n```\n\n### 但是我想要用严格模式限定时该怎么办呢？\n\n```javascript\n'use strict' // 全局严格模式\n\nfunction doSomething(a, b = a) {}\n\n// 由于函数参数部分会先执行：那很简单，将函数包在一个无参数的立即执行函数中\nconst doSomething = (function(){\n    'use strict';\n    return function(value = 42) {\n        return value;\n    }\n});\n```\n\n## name属性\n\n函数的`name`属性返回的是函数的名称。如果是将匿名函数赋给一个变量，在ES5中会返回空串，但是在ES6中会将变量名作为函数的名称。\n\n```javascript\nfunction foo () {}\nfoo.name // 'foo'\n\nvar func1 = function () {}\n\n// ES5\nfunc1.name // \"\"\n\n// ES6\nfunc1.name // \"func1\"\n```\n\n## 箭头函数\n\nES6中允许使用箭头`=>`来定义函数，定义效果和你使用`function`创建函数是等价的。\n\n```javascript\nvar f = v => v;\n\n// 等同于\n\nvar f = function(v) {\n    return v;\n};\n```\n\n如果箭头函数不需要参数或者需要多个参数，就是用圆括号来代表参数部分。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () {return 5;}\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n```\n\n如果箭头函数的代码块部分超过一条语句，就是用大括号将它们围起来，必须在对象外面加上括号。\n\n```javascript\nvar sum = (num1, num2) => {return num1 + num2;}\n\n//大括号会解释为代码块，所以如果是用箭头函数返回对象，必须在对象外层加上大括号\nvar getTemplate = id => ({id: id, name: \"Temp\"});\n```\n\n箭头函数也可以与变量解构结合\n\n```javascript\nconst full = ({ first ,last }) => first + ' ' + last;\n// 等同于\nfunction full(person) {\n    return person.first + ' ' + person.last;\n}\n```\n\n使用箭头函数需要注意几个地方：\n\n- 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象；\n- 不可以当做构造函数；（`this`对象的指向是可变的，而在箭头函数中是固定的）\n- 不可以使用`arguments`对象，如果要用，可以使用Rest参数代替；\n- 不可以使用`yield`命令，因此箭头函数不可以用作Generator函数\n\n```javascript\nfunction foo() {\n    setTimeout(() => {\n        console.log('id:', this.id);\n    }, 100);\n}\n\nvar id = 21;\nfoo.call({ id: 42 });\n// id: 42\n```\n\n## 绑定this\n\n箭头函数可以绑定`this`对象，因此大大减少了显式绑定`this`对象的写法（`apply`、`call`、`bind`）。但是见图函数并不适用于任何场合，因此ES7提出了函数绑定运算符。语法为两个并排的冒号：`::`。双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境，绑定到右边的函数上面。\n\n```javascript\nfoo::bar // bar.bind(foo)\n\nfoo::bar(...arguments); // bar.bind(foo, arguments)\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n    return obj::hasOwnProperty(key);\n}\n```\n\n如果双冒号左边为空（对需要绑定的对象为空），则等于将该方法绑定在对象上面。\n\n```javascript\nvar method = obj::obj.foo;\n// 等同于\nvar method = ::obj.foo;\n\nlet log = ::console.log;\n// 等同于\nvar log = console.log.bind(console);\n```\n\n由于双冒号运算符返回的还是原对象，因此可以采用链式写法。\n\n```javascript\nimport { map, takeWhile, forEach } from \"iterlib\";\n\n// 例1\ngetPlayers()\n::map(x => x.character())\n::takeWhile(x => x.strength > 100)\n::forEach(x => console.log(x));\n\n// 例2\nlet { find, html } = jake;\ndocument.querySelectorAll(\"div.myClass\");\n::find(\"p\")\n::html(\"hahahh\");\n```\n\n## 尾调用优化\n\n尾调用是函数式编程中的一个重要概念：就是指某个函数的最后一步调用是另一个函数。例如下面的例子：函数f的最后一步是调用函数g。尾调用优化只在严格模式下才生效。\n\n```javascript\nfunction f(x) {\n    return g(x);\n}\n```\n\n下面三种情况都不属于尾调用：\n\n```javascript\nfunction f(x) {\n    let y = g(x);\n    return y;\n}\n\nfunction f(x) {\n    return g(x) + 1;\n}\n\nfunction f(x) {\n    g(x);\n    return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可：\n\n```javascript\nfunction (x) {\n    if (x > 0) {\n        return m(x);\n    }\n    return n(x);\n}\n```\n\n通常来说：函数调用会在内存中形成一个“调用记录”，也称为调用帧。保存调用位置和内部变量等信息。\n\n由于尾调用是函数最后一步操作，因此不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧即可。\n\n这里有一个前提条件：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾部调用优化”；\n\n```javascript\nfunction f() {\n    let m = 1;\n    let n = 2;\n    return g(m + n);\n}\nf()\n\n// 等同于\nfunction f() {\n    return g(3)\n}\nf();\n\n// 等同于\ng(3)\n```\n\n### 尾递归\n\n基于上述尾部调用优化的特性：因此对于尾递归来说，由于只存在一个调用帧，因此永远也不会发生“栈溢出”错误。（注：将函数的多参数转换为单参数的范式成为”柯里化“）\n\n```javascript\n// 非尾递归写法\nfunction factorial(n) {\n    if (n === 1) return 1;\n    return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n\n// 尾递归写法\nfunction factorial(n, total = 1) {\n    if (n === 1) return total;\n    return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n```\n\n还有斐波那契数列的例子：\n\n```javascript\n// 非尾递归写法\nfunction Fibonacci(n) {\n    if (n <= 1) { return 1 };\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\nFibonacci(10); // 89\nFibonacci(1000); // 运行很慢\n\n// 尾递归写法\nfunction Fibonacci(n, ac1 = 1, ac2 = 1) {\n    if (n <= 1) { return ac2; }\n    return Fibonacci(n - 1. ac2, ac1 + ac2);\n}\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\n```\n\n可以看出“尾部调用优化”对于“尾递归\"的意义重大，所以一些函数式编程语言将其写入了语言规格。换句话来说只要使用尾递归来实现就不会发生栈溢出，从而节省内存。\n\n### 蹦床函数\n\n由于尾部递归只能在严格模式下生效，理由如下：\n\n正常模式下函数有两个变量，可以用于跟踪和记录函数调用：\n\n- `func.arguments`：返回调用时的函数参数；\n- `func.caller`：返回调用当前的函数；\n\n尾部调用发生时，调用栈的记录会被改写，因此上面两个变量就会失真。而在严格模式下会禁用上面两个变量，因此尾部调用只能在严格模式下生效。\n\n那么，如果我现在正常模式下实现尾部递归的写法又该如何做呢？可以将递归转换为循环执行。也就是俗称的“蹦床函数”：如下所示：`sum`函数每执行一次，都会返回自身的另一个版本。\n\n```javascript\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n\nfunction sum(x, y) {\n    if (y > 0) {\n        return sum.bind(null, x + 1, y - 1);\n    } else {\n        return x;\n    }\n}\n\ntrampoline(sum(1, 100000)); // 100001\n```\n\n但是上面的蹦床函数并不是真正的尾调用优化。下面这段代码来自官网教程。细细品位。\n\n```javascript\nfunction tco(f) {\n    var value;\n    var active = false; // 默认情况下该变量不激活\n    var accumulated = [];\n    \n    return function accumulator() {\n        accumulated.push(arguments);\n        if (!active) {\n            active = true; // 进入尾调用函数后激活\n            while(accumulated.length) {\n                value = f.apply(this, accumulated.shift());\n            }\n            active = false; // 调用完毕后关闭\n            return value;\n        }\n    };\n}\n\nvar sum = tco(function (x, y){\n    if (y > 0) {\n        return sum(x + 1, y - 1)\n    } else {\n        return x;\n    }\n});\n\nsum(1, 10000) // 10001\n```\n\n## 函数参数的尾逗号\n\nES7将允许函数的最后一个参数有尾逗号。在此之前，不允许最后一个参数携带逗号;\n\n```javascript\nfunction clownsEveryWhere(\n param1,\n param2,\n) {}\n```\n","source":"_posts/javascript/es6-function-expand.md","raw":"---\ntitle: ES6 函数扩展\ndate: 2022-02-17 15:07:14\nupdated: 2022-02-17 15:07:14\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 函数的扩展\n\n## 函数参数的默认值\n\nES6以前函数参数是不能有默认值的，而ES6中对这个规则进行了修改了，函数参数也可以带默认参数。即直接写在参数定义的后面。\n\n```javascript\nfunction log(x, y = 'World') {\n    console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n这样的写法有两个好处：一个是阅读代码的人可以立刻意识到哪些参数是可以省略的，不需要查看函数体；其次有利于代码将来的优化。即便在未来的版本对外接口中，彻底拿掉这个参数也不会导致原有代码无法运行。\n\n### 结合解构赋值\n\n参数默认值当然可以使用前面章节提到的解构特性进行赋值了。\n\n```javascript\nfunction foo({x, y = 5}) {\n    console.log(x, y);\n}\n\nfoo({}) // undefined, 5\nfoo({x: 1}) // 1, 5\nfoo({x: 1, y: 2}) // 1, 2\nfoo() // Error\n```\n\n### 参数默认值的位置\n\n一般情况下定义了默认值的参数应该是函数的尾部，这样比较容易看出来，如果是非尾部的参数设置默认值，实际上该参数是没法省略的。\n\n```javascript\nfunction (x = 1, y) {\n    return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined]\nf(, 1) // Error\nf(undefined, 1) // [1, 1]\n\nfunction (x, y = 5, z) {\n    return [x, y, z];\n}\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // Error\nf(1, undefinied, 2) // [1, 5, 2]\n```\n\n### length属性\n\n函数的length属性将返回没有指定默认值的参数个数。也就是说：指定了默认值后，length属性将失真；\n\n```javascript\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n```\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再记入后面的参数了。\n\n```javascript\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n```\n\n### 作用域\n\n如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。\n\n```javascript\nvar x = 1;\n\nfunction f(x, y = x) {\n    console.log(y);\n}\n\nf(2) // 2\n```\n\n如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域\n\n```javascript\nlet foo = 'outer';\n\n// func为一个默认匿名函数，返回值为变量foo\nfunction bar(func = x => foo) {\n    let foo = 'inner';\n    console.log(func());\n}\n\nbar(); // outer\n```\n\n### 默认参数的用途一目了然\n\n利用默认参数值，可以指定某一个参数不得省略，一旦省略就抛出一个错误；如果想省略这个参数，只要设置成`undefined`就行了。\n\n```javascript\nfunction throwIfMissing() {\n    throw new Error('Missing parameters');\n}\n\nfunction foo(mustBeProvided = throwIfMissing()) {\n    return mustBeProvided;\n}\n\nfoo(); // Error: Missing Parameters\n```\n\n### rest参数\n\n顾名思义：就是入参的个数是不确定的，跟Java中的多参数语法类似。这里就不再赘述了。\n\n```javascript\nfunction add(...values) {\n    let sum = 0;\n    \n    for (var val of values) {\n        sum += val;\n    }\n    \n    return sum;\n}\n\nadd(1, 2, 3, 4) // 10\n```\n\n## 扩展运算符\n\n扩展运算符为三个点`...`，是将一个数组转化为用逗号分隔的参数序列，是rest参数的逆运算。\n\n```javascript\nconsole.log(...[1, 2, 3]) // 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5\n\n[...document.querySelectorAll('div')] // [<div>, <div>, <div>]\n```\n\n该运算符主要用于函数调用\n\n```javascript\nfunction push(array, ...items) {\n    array.push(...items);\n}\n\nfunction add(x, y) {\n    return x + y;\n}\n\nvar numbers = [4, 38];\nadd(...numbers) // 42\n```\n\n### 扩展运算符的应用\n\n#### （1）合并数组\n\n```javascript\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['e', 'f'];\n\n[...arr1, ...arr2, ...arr3] // ['a', 'b', 'c', 'e', 'f']\n```\n\n#### （2） 与解构赋值结合\n\n```javascript\na = list[0], rest = list.slice(1)\n\n[a, ...rest] = list\n\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest // [2, 3, 4, 5]\n\nconst [first, ...rest] = []\nfirst // undefined\nrest // []\n\nconst [first, ...rest] = ['foo']\nfirst // foo\nrest // []\n```\n\n#### （3）函数返回值\n\nJavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种办法：\n\n```javascript\nvar dateFields = readDateFields(database);\nvar d = new Date(...dateFields);\n```\n\n#### （4）字符串\n\n可以将字符串转换为真正的数组。因为扩展运算符可以很好地识别Unicode字符，因此最好都用扩展运算符；\n\n```javascript\n[...'hello']\n// ['h', 'e', 'l', 'l', 'o']\n```\n\n#### （5）实现了Iterator接口的对象\n\n任何Iterator接口的对象，都可以用扩展运算符转换为真正的数组，之前已经提过了，这里不再赘述\n\n#### （6）Map和Set结构、Generator函数\n\n承接第（5）点，Map和Set也部署了Iterator接口，所以也可以使用扩展运算符，Generator函数运行后返回的是一个遍历器对象，因此也可以使用扩展运算符。\n\n```javascript\nvar go = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...go()] // [1, 2, 3]\n```\n\n## 严格模式\n\n从ES5开始，函数内部可以使用严格模式，在ES2016中做了一点修改。规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。\n\n这样规定的原因是：函数内部的严格模式同时适用于函数体和函数参数。但是函数执行时会先执行函数参数代码，再执行函数体代码。因此只有从函数体代码之中才能知道参数代码是否应该以严格模式执行，但是函数参数代码又要先于函数体执行。所以这就导致了不合理的存在。\n\n```javascript\nfunction doSomething(value = 070) { // value = 070 先执行\n    'use strict'; // 设置了严格模式\n    return value; // 后执行\n}\n// Illegal 'use strict' directive in function with non-simple parameter list\n```\n\n### 但是我想要用严格模式限定时该怎么办呢？\n\n```javascript\n'use strict' // 全局严格模式\n\nfunction doSomething(a, b = a) {}\n\n// 由于函数参数部分会先执行：那很简单，将函数包在一个无参数的立即执行函数中\nconst doSomething = (function(){\n    'use strict';\n    return function(value = 42) {\n        return value;\n    }\n});\n```\n\n## name属性\n\n函数的`name`属性返回的是函数的名称。如果是将匿名函数赋给一个变量，在ES5中会返回空串，但是在ES6中会将变量名作为函数的名称。\n\n```javascript\nfunction foo () {}\nfoo.name // 'foo'\n\nvar func1 = function () {}\n\n// ES5\nfunc1.name // \"\"\n\n// ES6\nfunc1.name // \"func1\"\n```\n\n## 箭头函数\n\nES6中允许使用箭头`=>`来定义函数，定义效果和你使用`function`创建函数是等价的。\n\n```javascript\nvar f = v => v;\n\n// 等同于\n\nvar f = function(v) {\n    return v;\n};\n```\n\n如果箭头函数不需要参数或者需要多个参数，就是用圆括号来代表参数部分。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () {return 5;}\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n```\n\n如果箭头函数的代码块部分超过一条语句，就是用大括号将它们围起来，必须在对象外面加上括号。\n\n```javascript\nvar sum = (num1, num2) => {return num1 + num2;}\n\n//大括号会解释为代码块，所以如果是用箭头函数返回对象，必须在对象外层加上大括号\nvar getTemplate = id => ({id: id, name: \"Temp\"});\n```\n\n箭头函数也可以与变量解构结合\n\n```javascript\nconst full = ({ first ,last }) => first + ' ' + last;\n// 等同于\nfunction full(person) {\n    return person.first + ' ' + person.last;\n}\n```\n\n使用箭头函数需要注意几个地方：\n\n- 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象；\n- 不可以当做构造函数；（`this`对象的指向是可变的，而在箭头函数中是固定的）\n- 不可以使用`arguments`对象，如果要用，可以使用Rest参数代替；\n- 不可以使用`yield`命令，因此箭头函数不可以用作Generator函数\n\n```javascript\nfunction foo() {\n    setTimeout(() => {\n        console.log('id:', this.id);\n    }, 100);\n}\n\nvar id = 21;\nfoo.call({ id: 42 });\n// id: 42\n```\n\n## 绑定this\n\n箭头函数可以绑定`this`对象，因此大大减少了显式绑定`this`对象的写法（`apply`、`call`、`bind`）。但是见图函数并不适用于任何场合，因此ES7提出了函数绑定运算符。语法为两个并排的冒号：`::`。双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境，绑定到右边的函数上面。\n\n```javascript\nfoo::bar // bar.bind(foo)\n\nfoo::bar(...arguments); // bar.bind(foo, arguments)\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n    return obj::hasOwnProperty(key);\n}\n```\n\n如果双冒号左边为空（对需要绑定的对象为空），则等于将该方法绑定在对象上面。\n\n```javascript\nvar method = obj::obj.foo;\n// 等同于\nvar method = ::obj.foo;\n\nlet log = ::console.log;\n// 等同于\nvar log = console.log.bind(console);\n```\n\n由于双冒号运算符返回的还是原对象，因此可以采用链式写法。\n\n```javascript\nimport { map, takeWhile, forEach } from \"iterlib\";\n\n// 例1\ngetPlayers()\n::map(x => x.character())\n::takeWhile(x => x.strength > 100)\n::forEach(x => console.log(x));\n\n// 例2\nlet { find, html } = jake;\ndocument.querySelectorAll(\"div.myClass\");\n::find(\"p\")\n::html(\"hahahh\");\n```\n\n## 尾调用优化\n\n尾调用是函数式编程中的一个重要概念：就是指某个函数的最后一步调用是另一个函数。例如下面的例子：函数f的最后一步是调用函数g。尾调用优化只在严格模式下才生效。\n\n```javascript\nfunction f(x) {\n    return g(x);\n}\n```\n\n下面三种情况都不属于尾调用：\n\n```javascript\nfunction f(x) {\n    let y = g(x);\n    return y;\n}\n\nfunction f(x) {\n    return g(x) + 1;\n}\n\nfunction f(x) {\n    g(x);\n    return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可：\n\n```javascript\nfunction (x) {\n    if (x > 0) {\n        return m(x);\n    }\n    return n(x);\n}\n```\n\n通常来说：函数调用会在内存中形成一个“调用记录”，也称为调用帧。保存调用位置和内部变量等信息。\n\n由于尾调用是函数最后一步操作，因此不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧即可。\n\n这里有一个前提条件：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾部调用优化”；\n\n```javascript\nfunction f() {\n    let m = 1;\n    let n = 2;\n    return g(m + n);\n}\nf()\n\n// 等同于\nfunction f() {\n    return g(3)\n}\nf();\n\n// 等同于\ng(3)\n```\n\n### 尾递归\n\n基于上述尾部调用优化的特性：因此对于尾递归来说，由于只存在一个调用帧，因此永远也不会发生“栈溢出”错误。（注：将函数的多参数转换为单参数的范式成为”柯里化“）\n\n```javascript\n// 非尾递归写法\nfunction factorial(n) {\n    if (n === 1) return 1;\n    return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n\n// 尾递归写法\nfunction factorial(n, total = 1) {\n    if (n === 1) return total;\n    return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n```\n\n还有斐波那契数列的例子：\n\n```javascript\n// 非尾递归写法\nfunction Fibonacci(n) {\n    if (n <= 1) { return 1 };\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\nFibonacci(10); // 89\nFibonacci(1000); // 运行很慢\n\n// 尾递归写法\nfunction Fibonacci(n, ac1 = 1, ac2 = 1) {\n    if (n <= 1) { return ac2; }\n    return Fibonacci(n - 1. ac2, ac1 + ac2);\n}\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\n```\n\n可以看出“尾部调用优化”对于“尾递归\"的意义重大，所以一些函数式编程语言将其写入了语言规格。换句话来说只要使用尾递归来实现就不会发生栈溢出，从而节省内存。\n\n### 蹦床函数\n\n由于尾部递归只能在严格模式下生效，理由如下：\n\n正常模式下函数有两个变量，可以用于跟踪和记录函数调用：\n\n- `func.arguments`：返回调用时的函数参数；\n- `func.caller`：返回调用当前的函数；\n\n尾部调用发生时，调用栈的记录会被改写，因此上面两个变量就会失真。而在严格模式下会禁用上面两个变量，因此尾部调用只能在严格模式下生效。\n\n那么，如果我现在正常模式下实现尾部递归的写法又该如何做呢？可以将递归转换为循环执行。也就是俗称的“蹦床函数”：如下所示：`sum`函数每执行一次，都会返回自身的另一个版本。\n\n```javascript\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n\nfunction sum(x, y) {\n    if (y > 0) {\n        return sum.bind(null, x + 1, y - 1);\n    } else {\n        return x;\n    }\n}\n\ntrampoline(sum(1, 100000)); // 100001\n```\n\n但是上面的蹦床函数并不是真正的尾调用优化。下面这段代码来自官网教程。细细品位。\n\n```javascript\nfunction tco(f) {\n    var value;\n    var active = false; // 默认情况下该变量不激活\n    var accumulated = [];\n    \n    return function accumulator() {\n        accumulated.push(arguments);\n        if (!active) {\n            active = true; // 进入尾调用函数后激活\n            while(accumulated.length) {\n                value = f.apply(this, accumulated.shift());\n            }\n            active = false; // 调用完毕后关闭\n            return value;\n        }\n    };\n}\n\nvar sum = tco(function (x, y){\n    if (y > 0) {\n        return sum(x + 1, y - 1)\n    } else {\n        return x;\n    }\n});\n\nsum(1, 10000) // 10001\n```\n\n## 函数参数的尾逗号\n\nES7将允许函数的最后一个参数有尾逗号。在此之前，不允许最后一个参数携带逗号;\n\n```javascript\nfunction clownsEveryWhere(\n param1,\n param2,\n) {}\n```\n","slug":"javascript/es6-function-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vd001a4f618msx38y6","content":"<h1 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h1><h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><p>ES6以前函数参数是不能有默认值的，而ES6中对这个规则进行了修改了，函数参数也可以带默认参数。即直接写在参数定义的后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">x, y = <span class=\"hljs-string\">&#x27;World&#x27;</span></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y);<br>&#125;<br><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>) <span class=\"hljs-comment\">// Hello World</span><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;China&#x27;</span>) <span class=\"hljs-comment\">// Hello China</span><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n<p>这样的写法有两个好处：一个是阅读代码的人可以立刻意识到哪些参数是可以省略的，不需要查看函数体；其次有利于代码将来的优化。即便在未来的版本对外接口中，彻底拿掉这个参数也不会导致原有代码无法运行。</p>\n<h3 id=\"结合解构赋值\"><a href=\"#结合解构赋值\" class=\"headerlink\" title=\"结合解构赋值\"></a>结合解构赋值</h3><p>参数默认值当然可以使用前面章节提到的解构特性进行赋值了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">&#123;x, y = <span class=\"hljs-number\">5</span>&#125;</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y);<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(&#123;&#125;) <span class=\"hljs-comment\">// undefined, 5</span><br><span class=\"hljs-title function_\">foo</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// 1, 5</span><br><span class=\"hljs-title function_\">foo</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>&#125;) <span class=\"hljs-comment\">// 1, 2</span><br><span class=\"hljs-title function_\">foo</span>() <span class=\"hljs-comment\">// Error</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"参数默认值的位置\"><a href=\"#参数默认值的位置\" class=\"headerlink\" title=\"参数默认值的位置\"></a>参数默认值的位置</h3><p>一般情况下定义了默认值的参数应该是函数的尾部，这样比较容易看出来，如果是非尾部的参数设置默认值，实际上该参数是没法省略的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x = <span class=\"hljs-number\">1</span>, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>() <span class=\"hljs-comment\">// [1, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [2, undefined]</span><br><span class=\"hljs-title function_\">f</span>(, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Error</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [1, 1]</span><br><br><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y = <span class=\"hljs-number\">5</span>, z</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [x, y, z];<br>&#125;<br><span class=\"hljs-title function_\">f</span>() <span class=\"hljs-comment\">// [undefined, 5, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [1, 5, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, ,<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// Error</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, undefinied, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [1, 5, 2]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"length属性\"><a href=\"#length属性\" class=\"headerlink\" title=\"length属性\"></a>length属性</h3><p>函数的length属性将返回没有指定默认值的参数个数。也就是说：指定了默认值后，length属性将失真；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 1</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a = <span class=\"hljs-number\">5</span></span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 0</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b, c = <span class=\"hljs-number\">5</span></span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<p>如果设置了默认值的参数不是尾参数，那么length属性也不再记入后面的参数了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a = <span class=\"hljs-number\">0</span>, b, c</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 0</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b = <span class=\"hljs-number\">1</span>, c</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x, y = x</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(y);<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<p>如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&#x27;outer&#x27;</span>;<br><br><span class=\"hljs-comment\">// func为一个默认匿名函数，返回值为变量foo</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\">func = x =&gt; foo</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&#x27;inner&#x27;</span>;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">func</span>());<br>&#125;<br><br><span class=\"hljs-title function_\">bar</span>(); <span class=\"hljs-comment\">// outer</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"默认参数的用途一目了然\"><a href=\"#默认参数的用途一目了然\" class=\"headerlink\" title=\"默认参数的用途一目了然\"></a>默认参数的用途一目了然</h3><p>利用默认参数值，可以指定某一个参数不得省略，一旦省略就抛出一个错误；如果想省略这个参数，只要设置成<code>undefined</code>就行了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throwIfMissing</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Missing parameters&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">mustBeProvided = throwIfMissing()</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> mustBeProvided;<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">// Error: Missing Parameters</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h3><p>顾名思义：就是入参的个数是不确定的，跟Java中的多参数语法类似。这里就不再赘述了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">...values</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> val <span class=\"hljs-keyword\">of</span> values) &#123;<br>        sum += val;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 10</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><p>扩展运算符为三个点<code>...</code>，是将一个数组转化为用逗号分隔的参数序列，是rest参数的逆运算。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(...[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]) <span class=\"hljs-comment\">// 1 2 3</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>, ...[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>], <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 1 2 3 4 5</span><br><br>[...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)] <span class=\"hljs-comment\">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></code></pre></td></tr></table></figure>\n<p>该运算符主要用于函数调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-params\">array, ...items</span>) &#123;<br>    array.<span class=\"hljs-title function_\">push</span>(...items);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">38</span>];<br><span class=\"hljs-title function_\">add</span>(...numbers) <span class=\"hljs-comment\">// 42</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符的应用\"><a href=\"#扩展运算符的应用\" class=\"headerlink\" title=\"扩展运算符的应用\"></a>扩展运算符的应用</h3><h4 id=\"（1）合并数组\"><a href=\"#（1）合并数组\" class=\"headerlink\" title=\"（1）合并数组\"></a>（1）合并数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> arr3 = [<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>];<br><br>[...arr1, ...arr2, ...arr3] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（2）-与解构赋值结合\"><a href=\"#（2）-与解构赋值结合\" class=\"headerlink\" title=\"（2） 与解构赋值结合\"></a>（2） 与解构赋值结合</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = list[<span class=\"hljs-number\">0</span>], rest = list.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)<br><br>[a, ...rest] = list<br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br>first <span class=\"hljs-comment\">// 1</span><br>rest <span class=\"hljs-comment\">// [2, 3, 4, 5]</span><br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = []<br>first <span class=\"hljs-comment\">// undefined</span><br>rest <span class=\"hljs-comment\">// []</span><br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = [<span class=\"hljs-string\">&#x27;foo&#x27;</span>]<br>first <span class=\"hljs-comment\">// foo</span><br>rest <span class=\"hljs-comment\">// []</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（3）函数返回值\"><a href=\"#（3）函数返回值\" class=\"headerlink\" title=\"（3）函数返回值\"></a>（3）函数返回值</h4><p>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种办法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> dateFields = <span class=\"hljs-title function_\">readDateFields</span>(database);<br><span class=\"hljs-keyword\">var</span> d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(...dateFields);<br></code></pre></td></tr></table></figure>\n<h4 id=\"（4）字符串\"><a href=\"#（4）字符串\" class=\"headerlink\" title=\"（4）字符串\"></a>（4）字符串</h4><p>可以将字符串转换为真正的数组。因为扩展运算符可以很好地识别Unicode字符，因此最好都用扩展运算符；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[...<span class=\"hljs-string\">&#x27;hello&#x27;</span>]<br><span class=\"hljs-comment\">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（5）实现了Iterator接口的对象\"><a href=\"#（5）实现了Iterator接口的对象\" class=\"headerlink\" title=\"（5）实现了Iterator接口的对象\"></a>（5）实现了Iterator接口的对象</h4><p>任何Iterator接口的对象，都可以用扩展运算符转换为真正的数组，之前已经提过了，这里不再赘述</p>\n<h4 id=\"（6）Map和Set结构、Generator函数\"><a href=\"#（6）Map和Set结构、Generator函数\" class=\"headerlink\" title=\"（6）Map和Set结构、Generator函数\"></a>（6）Map和Set结构、Generator函数</h4><p>承接第（5）点，Map和Set也部署了Iterator接口，所以也可以使用扩展运算符，Generator函数运行后返回的是一个遍历器对象，因此也可以使用扩展运算符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> go = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...<span class=\"hljs-title function_\">go</span>()] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>从ES5开始，函数内部可以使用严格模式，在ES2016中做了一点修改。规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。</p>\n<p>这样规定的原因是：函数内部的严格模式同时适用于函数体和函数参数。但是函数执行时会先执行函数参数代码，再执行函数体代码。因此只有从函数体代码之中才能知道参数代码是否应该以严格模式执行，但是函数参数代码又要先于函数体执行。所以这就导致了不合理的存在。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\">value = <span class=\"hljs-number\">070</span></span>) &#123; <span class=\"hljs-comment\">// value = 070 先执行</span><br>    <span class=\"hljs-string\">&#x27;use strict&#x27;</span>; <span class=\"hljs-comment\">// 设置了严格模式</span><br>    <span class=\"hljs-keyword\">return</span> value; <span class=\"hljs-comment\">// 后执行</span><br>&#125;<br><span class=\"hljs-comment\">// Illegal &#x27;use strict&#x27; directive in function with non-simple parameter list</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"但是我想要用严格模式限定时该怎么办呢？\"><a href=\"#但是我想要用严格模式限定时该怎么办呢？\" class=\"headerlink\" title=\"但是我想要用严格模式限定时该怎么办呢？\"></a>但是我想要用严格模式限定时该怎么办呢？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-meta\">&#x27;use strict&#x27;</span> <span class=\"hljs-comment\">// 全局严格模式</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\">a, b = a</span>) &#123;&#125;<br><br><span class=\"hljs-comment\">// 由于函数参数部分会先执行：那很简单，将函数包在一个无参数的立即执行函数中</span><br><span class=\"hljs-keyword\">const</span> doSomething = (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-string\">&#x27;use strict&#x27;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value = <span class=\"hljs-number\">42</span></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h2><p>函数的<code>name</code>属性返回的是函数的名称。如果是将匿名函数赋给一个变量，在ES5中会返回空串，但是在ES6中会将变量名作为函数的名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;&#125;<br>foo.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &#x27;foo&#x27;</span><br><br><span class=\"hljs-keyword\">var</span> func1 = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><br><span class=\"hljs-comment\">// ES5</span><br>func1.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &quot;&quot;</span><br><br><span class=\"hljs-comment\">// ES6</span><br>func1.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &quot;func1&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6中允许使用箭头<code>=&gt;</code>来定义函数，定义效果和你使用<code>function</code>创建函数是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">f</span> = v =&gt; v;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> v;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>如果箭头函数不需要参数或者需要多个参数，就是用圆括号来代表参数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>;&#125;<br><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">num1, num2</span>) =&gt; num1 + num2;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">num1, num2</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> num1 + num2;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果箭头函数的代码块部分超过一条语句，就是用大括号将它们围起来，必须在对象外面加上括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">num1, num2</span>) =&gt; &#123;<span class=\"hljs-keyword\">return</span> num1 + num2;&#125;<br><br><span class=\"hljs-comment\">//大括号会解释为代码块，所以如果是用箭头函数返回对象，必须在对象外层加上大括号</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">getTemplate</span> = id =&gt; (&#123;<span class=\"hljs-attr\">id</span>: id, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Temp&quot;</span>&#125;);<br></code></pre></td></tr></table></figure>\n<p>箭头函数也可以与变量解构结合</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">full</span> = (<span class=\"hljs-params\">&#123; first ,last &#125;</span>) =&gt; first + <span class=\"hljs-string\">&#x27; &#x27;</span> + last;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">full</span>(<span class=\"hljs-params\">person</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> person.<span class=\"hljs-property\">first</span> + <span class=\"hljs-string\">&#x27; &#x27;</span> + person.<span class=\"hljs-property\">last</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用箭头函数需要注意几个地方：</p>\n<ul>\n<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象；</li>\n<li>不可以当做构造函数；（<code>this</code>对象的指向是可变的，而在箭头函数中是固定的）</li>\n<li>不可以使用<code>arguments</code>对象，如果要用，可以使用Rest参数代替；</li>\n<li>不可以使用<code>yield</code>命令，因此箭头函数不可以用作Generator函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;id:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>);<br>    &#125;, <span class=\"hljs-number\">100</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-number\">21</span>;<br>foo.<span class=\"hljs-title function_\">call</span>(&#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">42</span> &#125;);<br><span class=\"hljs-comment\">// id: 42</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"绑定this\"><a href=\"#绑定this\" class=\"headerlink\" title=\"绑定this\"></a>绑定this</h2><p>箭头函数可以绑定<code>this</code>对象，因此大大减少了显式绑定<code>this</code>对象的写法（<code>apply</code>、<code>call</code>、<code>bind</code>）。但是见图函数并不适用于任何场合，因此ES7提出了函数绑定运算符。语法为两个并排的冒号：<code>::</code>。双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境，绑定到右边的函数上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">foo</span>::bar <span class=\"hljs-comment\">// bar.bind(foo)</span><br><br><span class=\"hljs-attr\">foo</span>::<span class=\"hljs-title function_\">bar</span>(...<span class=\"hljs-variable language_\">arguments</span>); <span class=\"hljs-comment\">// bar.bind(foo, arguments)</span><br><br><span class=\"hljs-keyword\">const</span> hasOwnProperty = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hasOwnProperty</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hasOwn</span>(<span class=\"hljs-params\">obj, key</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-attr\">obj</span>::<span class=\"hljs-title function_\">hasOwnProperty</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果双冒号左边为空（对需要绑定的对象为空），则等于将该方法绑定在对象上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> method = <span class=\"hljs-attr\">obj</span>::obj.<span class=\"hljs-property\">foo</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> method = ::obj.<span class=\"hljs-property\">foo</span>;<br><br><span class=\"hljs-keyword\">let</span> log = ::<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> log = <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">console</span>);<br></code></pre></td></tr></table></figure>\n<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; map, takeWhile, forEach &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;iterlib&quot;</span>;<br><br><span class=\"hljs-comment\">// 例1</span><br><span class=\"hljs-title function_\">getPlayers</span>()<br>::<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-title function_\">character</span>())<br>::<span class=\"hljs-title function_\">takeWhile</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-property\">strength</span> &gt; <span class=\"hljs-number\">100</span>)<br>::<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x));<br><br><span class=\"hljs-comment\">// 例2</span><br><span class=\"hljs-keyword\">let</span> &#123; find, html &#125; = jake;<br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&quot;div.myClass&quot;</span>);<br>::<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-string\">&quot;p&quot;</span>)<br>::<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-string\">&quot;hahahh&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><p>尾调用是函数式编程中的一个重要概念：就是指某个函数的最后一步调用是另一个函数。例如下面的例子：函数f的最后一步是调用函数g。尾调用优化只在严格模式下才生效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>下面三种情况都不属于尾调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-title function_\">g</span>(x);<br>    <span class=\"hljs-keyword\">return</span> y;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(x) + <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-title function_\">g</span>(x);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">m</span>(x);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">n</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通常来说：函数调用会在内存中形成一个“调用记录”，也称为调用帧。保存调用位置和内部变量等信息。</p>\n<p>由于尾调用是函数最后一步操作，因此不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧即可。</p>\n<p>这里有一个前提条件：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾部调用优化”；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> m = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">let</span> n = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(m + n);<br>&#125;<br><span class=\"hljs-title function_\">f</span>()<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-number\">3</span>)<br>&#125;<br><span class=\"hljs-title function_\">f</span>();<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-title function_\">g</span>(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>基于上述尾部调用优化的特性：因此对于尾递归来说，由于只存在一个调用帧，因此永远也不会发生“栈溢出”错误。（注：将函数的多参数转换为单参数的范式成为”柯里化“）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 非尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> n * <span class=\"hljs-title function_\">factorial</span>(n - <span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span><br><br><span class=\"hljs-comment\">// 尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n, total = <span class=\"hljs-number\">1</span></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> total;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">factorial</span>(n - <span class=\"hljs-number\">1</span>, n * total);<br>&#125;<br><br><span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span><br></code></pre></td></tr></table></figure>\n<p>还有斐波那契数列的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 非尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fibonacci</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> &#125;;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">1</span>) + <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">2</span>);<br>&#125;<br><span class=\"hljs-title class_\">Fibonacci</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 89</span><br><span class=\"hljs-title class_\">Fibonacci</span>(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 运行很慢</span><br><br><span class=\"hljs-comment\">// 尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fibonacci</span>(<span class=\"hljs-params\">n, ac1 = <span class=\"hljs-number\">1</span>, ac2 = <span class=\"hljs-number\">1</span></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-keyword\">return</span> ac2; &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">1.</span> ac2, ac1 + ac2);<br>&#125;<br><br><span class=\"hljs-title class_\">Fibonacci2</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 573147844013817200000</span><br><span class=\"hljs-title class_\">Fibonacci2</span>(<span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 7.0330367711422765e+208</span><br></code></pre></td></tr></table></figure>\n<p>可以看出“尾部调用优化”对于“尾递归”的意义重大，所以一些函数式编程语言将其写入了语言规格。换句话来说只要使用尾递归来实现就不会发生栈溢出，从而节省内存。</p>\n<h3 id=\"蹦床函数\"><a href=\"#蹦床函数\" class=\"headerlink\" title=\"蹦床函数\"></a>蹦床函数</h3><p>由于尾部递归只能在严格模式下生效，理由如下：</p>\n<p>正常模式下函数有两个变量，可以用于跟踪和记录函数调用：</p>\n<ul>\n<li><code>func.arguments</code>：返回调用时的函数参数；</li>\n<li><code>func.caller</code>：返回调用当前的函数；</li>\n</ul>\n<p>尾部调用发生时，调用栈的记录会被改写，因此上面两个变量就会失真。而在严格模式下会禁用上面两个变量，因此尾部调用只能在严格模式下生效。</p>\n<p>那么，如果我现在正常模式下实现尾部递归的写法又该如何做呢？可以将递归转换为循环执行。也就是俗称的“蹦床函数”：如下所示：<code>sum</code>函数每执行一次，都会返回自身的另一个版本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trampoline</span>(<span class=\"hljs-params\">f</span>) &#123;<br>    <span class=\"hljs-keyword\">while</span> (f &amp;&amp; f <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Function</span>) &#123;<br>        f = <span class=\"hljs-title function_\">f</span>();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> f;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> sum.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">trampoline</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">100000</span>)); <span class=\"hljs-comment\">// 100001</span><br></code></pre></td></tr></table></figure>\n<p>但是上面的蹦床函数并不是真正的尾调用优化。下面这段代码来自官网教程。细细品位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">tco</span>(<span class=\"hljs-params\">f</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> value;<br>    <span class=\"hljs-keyword\">var</span> active = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 默认情况下该变量不激活</span><br>    <span class=\"hljs-keyword\">var</span> accumulated = [];<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">accumulator</span>(<span class=\"hljs-params\"></span>) &#123;<br>        accumulated.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>        <span class=\"hljs-keyword\">if</span> (!active) &#123;<br>            active = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 进入尾调用函数后激活</span><br>            <span class=\"hljs-keyword\">while</span>(accumulated.<span class=\"hljs-property\">length</span>) &#123;<br>                value = f.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, accumulated.<span class=\"hljs-title function_\">shift</span>());<br>            &#125;<br>            active = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 调用完毕后关闭</span><br>            <span class=\"hljs-keyword\">return</span> value;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-title function_\">tco</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">sum</span>(x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10000</span>) <span class=\"hljs-comment\">// 10001</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数参数的尾逗号\"><a href=\"#函数参数的尾逗号\" class=\"headerlink\" title=\"函数参数的尾逗号\"></a>函数参数的尾逗号</h2><p>ES7将允许函数的最后一个参数有尾逗号。在此之前，不允许最后一个参数携带逗号;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clownsEveryWhere</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\"> param1,</span><br><span class=\"hljs-params\"> param2,</span><br><span class=\"hljs-params\"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":8590,"excerpt":"","more":"<h1 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h1><h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><p>ES6以前函数参数是不能有默认值的，而ES6中对这个规则进行了修改了，函数参数也可以带默认参数。即直接写在参数定义的后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">x, y = <span class=\"hljs-string\">&#x27;World&#x27;</span></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y);<br>&#125;<br><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>) <span class=\"hljs-comment\">// Hello World</span><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;China&#x27;</span>) <span class=\"hljs-comment\">// Hello China</span><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n<p>这样的写法有两个好处：一个是阅读代码的人可以立刻意识到哪些参数是可以省略的，不需要查看函数体；其次有利于代码将来的优化。即便在未来的版本对外接口中，彻底拿掉这个参数也不会导致原有代码无法运行。</p>\n<h3 id=\"结合解构赋值\"><a href=\"#结合解构赋值\" class=\"headerlink\" title=\"结合解构赋值\"></a>结合解构赋值</h3><p>参数默认值当然可以使用前面章节提到的解构特性进行赋值了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">&#123;x, y = <span class=\"hljs-number\">5</span>&#125;</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y);<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(&#123;&#125;) <span class=\"hljs-comment\">// undefined, 5</span><br><span class=\"hljs-title function_\">foo</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// 1, 5</span><br><span class=\"hljs-title function_\">foo</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>&#125;) <span class=\"hljs-comment\">// 1, 2</span><br><span class=\"hljs-title function_\">foo</span>() <span class=\"hljs-comment\">// Error</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"参数默认值的位置\"><a href=\"#参数默认值的位置\" class=\"headerlink\" title=\"参数默认值的位置\"></a>参数默认值的位置</h3><p>一般情况下定义了默认值的参数应该是函数的尾部，这样比较容易看出来，如果是非尾部的参数设置默认值，实际上该参数是没法省略的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x = <span class=\"hljs-number\">1</span>, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>() <span class=\"hljs-comment\">// [1, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [2, undefined]</span><br><span class=\"hljs-title function_\">f</span>(, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Error</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [1, 1]</span><br><br><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y = <span class=\"hljs-number\">5</span>, z</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [x, y, z];<br>&#125;<br><span class=\"hljs-title function_\">f</span>() <span class=\"hljs-comment\">// [undefined, 5, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [1, 5, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, ,<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// Error</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, undefinied, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [1, 5, 2]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"length属性\"><a href=\"#length属性\" class=\"headerlink\" title=\"length属性\"></a>length属性</h3><p>函数的length属性将返回没有指定默认值的参数个数。也就是说：指定了默认值后，length属性将失真；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 1</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a = <span class=\"hljs-number\">5</span></span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 0</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b, c = <span class=\"hljs-number\">5</span></span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<p>如果设置了默认值的参数不是尾参数，那么length属性也不再记入后面的参数了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a = <span class=\"hljs-number\">0</span>, b, c</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 0</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b = <span class=\"hljs-number\">1</span>, c</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x, y = x</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(y);<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<p>如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&#x27;outer&#x27;</span>;<br><br><span class=\"hljs-comment\">// func为一个默认匿名函数，返回值为变量foo</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\">func = x =&gt; foo</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&#x27;inner&#x27;</span>;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">func</span>());<br>&#125;<br><br><span class=\"hljs-title function_\">bar</span>(); <span class=\"hljs-comment\">// outer</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"默认参数的用途一目了然\"><a href=\"#默认参数的用途一目了然\" class=\"headerlink\" title=\"默认参数的用途一目了然\"></a>默认参数的用途一目了然</h3><p>利用默认参数值，可以指定某一个参数不得省略，一旦省略就抛出一个错误；如果想省略这个参数，只要设置成<code>undefined</code>就行了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throwIfMissing</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Missing parameters&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">mustBeProvided = throwIfMissing()</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> mustBeProvided;<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">// Error: Missing Parameters</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h3><p>顾名思义：就是入参的个数是不确定的，跟Java中的多参数语法类似。这里就不再赘述了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">...values</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> val <span class=\"hljs-keyword\">of</span> values) &#123;<br>        sum += val;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 10</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><p>扩展运算符为三个点<code>...</code>，是将一个数组转化为用逗号分隔的参数序列，是rest参数的逆运算。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(...[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]) <span class=\"hljs-comment\">// 1 2 3</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>, ...[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>], <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 1 2 3 4 5</span><br><br>[...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)] <span class=\"hljs-comment\">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></code></pre></td></tr></table></figure>\n<p>该运算符主要用于函数调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-params\">array, ...items</span>) &#123;<br>    array.<span class=\"hljs-title function_\">push</span>(...items);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">38</span>];<br><span class=\"hljs-title function_\">add</span>(...numbers) <span class=\"hljs-comment\">// 42</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符的应用\"><a href=\"#扩展运算符的应用\" class=\"headerlink\" title=\"扩展运算符的应用\"></a>扩展运算符的应用</h3><h4 id=\"（1）合并数组\"><a href=\"#（1）合并数组\" class=\"headerlink\" title=\"（1）合并数组\"></a>（1）合并数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> arr3 = [<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>];<br><br>[...arr1, ...arr2, ...arr3] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（2）-与解构赋值结合\"><a href=\"#（2）-与解构赋值结合\" class=\"headerlink\" title=\"（2） 与解构赋值结合\"></a>（2） 与解构赋值结合</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = list[<span class=\"hljs-number\">0</span>], rest = list.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)<br><br>[a, ...rest] = list<br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br>first <span class=\"hljs-comment\">// 1</span><br>rest <span class=\"hljs-comment\">// [2, 3, 4, 5]</span><br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = []<br>first <span class=\"hljs-comment\">// undefined</span><br>rest <span class=\"hljs-comment\">// []</span><br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = [<span class=\"hljs-string\">&#x27;foo&#x27;</span>]<br>first <span class=\"hljs-comment\">// foo</span><br>rest <span class=\"hljs-comment\">// []</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（3）函数返回值\"><a href=\"#（3）函数返回值\" class=\"headerlink\" title=\"（3）函数返回值\"></a>（3）函数返回值</h4><p>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种办法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> dateFields = <span class=\"hljs-title function_\">readDateFields</span>(database);<br><span class=\"hljs-keyword\">var</span> d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(...dateFields);<br></code></pre></td></tr></table></figure>\n<h4 id=\"（4）字符串\"><a href=\"#（4）字符串\" class=\"headerlink\" title=\"（4）字符串\"></a>（4）字符串</h4><p>可以将字符串转换为真正的数组。因为扩展运算符可以很好地识别Unicode字符，因此最好都用扩展运算符；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[...<span class=\"hljs-string\">&#x27;hello&#x27;</span>]<br><span class=\"hljs-comment\">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（5）实现了Iterator接口的对象\"><a href=\"#（5）实现了Iterator接口的对象\" class=\"headerlink\" title=\"（5）实现了Iterator接口的对象\"></a>（5）实现了Iterator接口的对象</h4><p>任何Iterator接口的对象，都可以用扩展运算符转换为真正的数组，之前已经提过了，这里不再赘述</p>\n<h4 id=\"（6）Map和Set结构、Generator函数\"><a href=\"#（6）Map和Set结构、Generator函数\" class=\"headerlink\" title=\"（6）Map和Set结构、Generator函数\"></a>（6）Map和Set结构、Generator函数</h4><p>承接第（5）点，Map和Set也部署了Iterator接口，所以也可以使用扩展运算符，Generator函数运行后返回的是一个遍历器对象，因此也可以使用扩展运算符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> go = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...<span class=\"hljs-title function_\">go</span>()] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>从ES5开始，函数内部可以使用严格模式，在ES2016中做了一点修改。规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。</p>\n<p>这样规定的原因是：函数内部的严格模式同时适用于函数体和函数参数。但是函数执行时会先执行函数参数代码，再执行函数体代码。因此只有从函数体代码之中才能知道参数代码是否应该以严格模式执行，但是函数参数代码又要先于函数体执行。所以这就导致了不合理的存在。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\">value = <span class=\"hljs-number\">070</span></span>) &#123; <span class=\"hljs-comment\">// value = 070 先执行</span><br>    <span class=\"hljs-string\">&#x27;use strict&#x27;</span>; <span class=\"hljs-comment\">// 设置了严格模式</span><br>    <span class=\"hljs-keyword\">return</span> value; <span class=\"hljs-comment\">// 后执行</span><br>&#125;<br><span class=\"hljs-comment\">// Illegal &#x27;use strict&#x27; directive in function with non-simple parameter list</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"但是我想要用严格模式限定时该怎么办呢？\"><a href=\"#但是我想要用严格模式限定时该怎么办呢？\" class=\"headerlink\" title=\"但是我想要用严格模式限定时该怎么办呢？\"></a>但是我想要用严格模式限定时该怎么办呢？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-meta\">&#x27;use strict&#x27;</span> <span class=\"hljs-comment\">// 全局严格模式</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\">a, b = a</span>) &#123;&#125;<br><br><span class=\"hljs-comment\">// 由于函数参数部分会先执行：那很简单，将函数包在一个无参数的立即执行函数中</span><br><span class=\"hljs-keyword\">const</span> doSomething = (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-string\">&#x27;use strict&#x27;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value = <span class=\"hljs-number\">42</span></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h2><p>函数的<code>name</code>属性返回的是函数的名称。如果是将匿名函数赋给一个变量，在ES5中会返回空串，但是在ES6中会将变量名作为函数的名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;&#125;<br>foo.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &#x27;foo&#x27;</span><br><br><span class=\"hljs-keyword\">var</span> func1 = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><br><span class=\"hljs-comment\">// ES5</span><br>func1.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &quot;&quot;</span><br><br><span class=\"hljs-comment\">// ES6</span><br>func1.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &quot;func1&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6中允许使用箭头<code>=&gt;</code>来定义函数，定义效果和你使用<code>function</code>创建函数是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">f</span> = v =&gt; v;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> v;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>如果箭头函数不需要参数或者需要多个参数，就是用圆括号来代表参数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>;&#125;<br><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">num1, num2</span>) =&gt; num1 + num2;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">num1, num2</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> num1 + num2;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果箭头函数的代码块部分超过一条语句，就是用大括号将它们围起来，必须在对象外面加上括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">num1, num2</span>) =&gt; &#123;<span class=\"hljs-keyword\">return</span> num1 + num2;&#125;<br><br><span class=\"hljs-comment\">//大括号会解释为代码块，所以如果是用箭头函数返回对象，必须在对象外层加上大括号</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">getTemplate</span> = id =&gt; (&#123;<span class=\"hljs-attr\">id</span>: id, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Temp&quot;</span>&#125;);<br></code></pre></td></tr></table></figure>\n<p>箭头函数也可以与变量解构结合</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">full</span> = (<span class=\"hljs-params\">&#123; first ,last &#125;</span>) =&gt; first + <span class=\"hljs-string\">&#x27; &#x27;</span> + last;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">full</span>(<span class=\"hljs-params\">person</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> person.<span class=\"hljs-property\">first</span> + <span class=\"hljs-string\">&#x27; &#x27;</span> + person.<span class=\"hljs-property\">last</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用箭头函数需要注意几个地方：</p>\n<ul>\n<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象；</li>\n<li>不可以当做构造函数；（<code>this</code>对象的指向是可变的，而在箭头函数中是固定的）</li>\n<li>不可以使用<code>arguments</code>对象，如果要用，可以使用Rest参数代替；</li>\n<li>不可以使用<code>yield</code>命令，因此箭头函数不可以用作Generator函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;id:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>);<br>    &#125;, <span class=\"hljs-number\">100</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-number\">21</span>;<br>foo.<span class=\"hljs-title function_\">call</span>(&#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">42</span> &#125;);<br><span class=\"hljs-comment\">// id: 42</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"绑定this\"><a href=\"#绑定this\" class=\"headerlink\" title=\"绑定this\"></a>绑定this</h2><p>箭头函数可以绑定<code>this</code>对象，因此大大减少了显式绑定<code>this</code>对象的写法（<code>apply</code>、<code>call</code>、<code>bind</code>）。但是见图函数并不适用于任何场合，因此ES7提出了函数绑定运算符。语法为两个并排的冒号：<code>::</code>。双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境，绑定到右边的函数上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">foo</span>::bar <span class=\"hljs-comment\">// bar.bind(foo)</span><br><br><span class=\"hljs-attr\">foo</span>::<span class=\"hljs-title function_\">bar</span>(...<span class=\"hljs-variable language_\">arguments</span>); <span class=\"hljs-comment\">// bar.bind(foo, arguments)</span><br><br><span class=\"hljs-keyword\">const</span> hasOwnProperty = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hasOwnProperty</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hasOwn</span>(<span class=\"hljs-params\">obj, key</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-attr\">obj</span>::<span class=\"hljs-title function_\">hasOwnProperty</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果双冒号左边为空（对需要绑定的对象为空），则等于将该方法绑定在对象上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> method = <span class=\"hljs-attr\">obj</span>::obj.<span class=\"hljs-property\">foo</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> method = ::obj.<span class=\"hljs-property\">foo</span>;<br><br><span class=\"hljs-keyword\">let</span> log = ::<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> log = <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">console</span>);<br></code></pre></td></tr></table></figure>\n<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; map, takeWhile, forEach &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;iterlib&quot;</span>;<br><br><span class=\"hljs-comment\">// 例1</span><br><span class=\"hljs-title function_\">getPlayers</span>()<br>::<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-title function_\">character</span>())<br>::<span class=\"hljs-title function_\">takeWhile</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-property\">strength</span> &gt; <span class=\"hljs-number\">100</span>)<br>::<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x));<br><br><span class=\"hljs-comment\">// 例2</span><br><span class=\"hljs-keyword\">let</span> &#123; find, html &#125; = jake;<br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&quot;div.myClass&quot;</span>);<br>::<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-string\">&quot;p&quot;</span>)<br>::<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-string\">&quot;hahahh&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><p>尾调用是函数式编程中的一个重要概念：就是指某个函数的最后一步调用是另一个函数。例如下面的例子：函数f的最后一步是调用函数g。尾调用优化只在严格模式下才生效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>下面三种情况都不属于尾调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-title function_\">g</span>(x);<br>    <span class=\"hljs-keyword\">return</span> y;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(x) + <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-title function_\">g</span>(x);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">m</span>(x);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">n</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通常来说：函数调用会在内存中形成一个“调用记录”，也称为调用帧。保存调用位置和内部变量等信息。</p>\n<p>由于尾调用是函数最后一步操作，因此不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧即可。</p>\n<p>这里有一个前提条件：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾部调用优化”；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> m = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">let</span> n = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(m + n);<br>&#125;<br><span class=\"hljs-title function_\">f</span>()<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-number\">3</span>)<br>&#125;<br><span class=\"hljs-title function_\">f</span>();<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-title function_\">g</span>(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>基于上述尾部调用优化的特性：因此对于尾递归来说，由于只存在一个调用帧，因此永远也不会发生“栈溢出”错误。（注：将函数的多参数转换为单参数的范式成为”柯里化“）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 非尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> n * <span class=\"hljs-title function_\">factorial</span>(n - <span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span><br><br><span class=\"hljs-comment\">// 尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n, total = <span class=\"hljs-number\">1</span></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> total;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">factorial</span>(n - <span class=\"hljs-number\">1</span>, n * total);<br>&#125;<br><br><span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span><br></code></pre></td></tr></table></figure>\n<p>还有斐波那契数列的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 非尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fibonacci</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> &#125;;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">1</span>) + <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">2</span>);<br>&#125;<br><span class=\"hljs-title class_\">Fibonacci</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 89</span><br><span class=\"hljs-title class_\">Fibonacci</span>(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 运行很慢</span><br><br><span class=\"hljs-comment\">// 尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fibonacci</span>(<span class=\"hljs-params\">n, ac1 = <span class=\"hljs-number\">1</span>, ac2 = <span class=\"hljs-number\">1</span></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-keyword\">return</span> ac2; &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">1.</span> ac2, ac1 + ac2);<br>&#125;<br><br><span class=\"hljs-title class_\">Fibonacci2</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 573147844013817200000</span><br><span class=\"hljs-title class_\">Fibonacci2</span>(<span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 7.0330367711422765e+208</span><br></code></pre></td></tr></table></figure>\n<p>可以看出“尾部调用优化”对于“尾递归”的意义重大，所以一些函数式编程语言将其写入了语言规格。换句话来说只要使用尾递归来实现就不会发生栈溢出，从而节省内存。</p>\n<h3 id=\"蹦床函数\"><a href=\"#蹦床函数\" class=\"headerlink\" title=\"蹦床函数\"></a>蹦床函数</h3><p>由于尾部递归只能在严格模式下生效，理由如下：</p>\n<p>正常模式下函数有两个变量，可以用于跟踪和记录函数调用：</p>\n<ul>\n<li><code>func.arguments</code>：返回调用时的函数参数；</li>\n<li><code>func.caller</code>：返回调用当前的函数；</li>\n</ul>\n<p>尾部调用发生时，调用栈的记录会被改写，因此上面两个变量就会失真。而在严格模式下会禁用上面两个变量，因此尾部调用只能在严格模式下生效。</p>\n<p>那么，如果我现在正常模式下实现尾部递归的写法又该如何做呢？可以将递归转换为循环执行。也就是俗称的“蹦床函数”：如下所示：<code>sum</code>函数每执行一次，都会返回自身的另一个版本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trampoline</span>(<span class=\"hljs-params\">f</span>) &#123;<br>    <span class=\"hljs-keyword\">while</span> (f &amp;&amp; f <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Function</span>) &#123;<br>        f = <span class=\"hljs-title function_\">f</span>();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> f;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> sum.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">trampoline</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">100000</span>)); <span class=\"hljs-comment\">// 100001</span><br></code></pre></td></tr></table></figure>\n<p>但是上面的蹦床函数并不是真正的尾调用优化。下面这段代码来自官网教程。细细品位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">tco</span>(<span class=\"hljs-params\">f</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> value;<br>    <span class=\"hljs-keyword\">var</span> active = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 默认情况下该变量不激活</span><br>    <span class=\"hljs-keyword\">var</span> accumulated = [];<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">accumulator</span>(<span class=\"hljs-params\"></span>) &#123;<br>        accumulated.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>        <span class=\"hljs-keyword\">if</span> (!active) &#123;<br>            active = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 进入尾调用函数后激活</span><br>            <span class=\"hljs-keyword\">while</span>(accumulated.<span class=\"hljs-property\">length</span>) &#123;<br>                value = f.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, accumulated.<span class=\"hljs-title function_\">shift</span>());<br>            &#125;<br>            active = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 调用完毕后关闭</span><br>            <span class=\"hljs-keyword\">return</span> value;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-title function_\">tco</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">sum</span>(x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10000</span>) <span class=\"hljs-comment\">// 10001</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数参数的尾逗号\"><a href=\"#函数参数的尾逗号\" class=\"headerlink\" title=\"函数参数的尾逗号\"></a>函数参数的尾逗号</h2><p>ES7将允许函数的最后一个参数有尾逗号。在此之前，不允许最后一个参数携带逗号;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clownsEveryWhere</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\"> param1,</span><br><span class=\"hljs-params\"> param2,</span><br><span class=\"hljs-params\"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 Generator函数","date":"2022-02-17T14:20:37.000Z","updated":"2022-02-17T14:20:37.000Z","_content":"\n# Generator函数\n\n## 基本概念\n\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\nGenerator函数有多种理解角度：从语法上：可以将其理解成状态机，封装了多个内部状态；其次：执行Generator函数会返回一个遍历器对象。\n\n形式上，Generator函数是个普通函数，但是有两个特征。一是`function`关键字和函数名之间多了一个星号；二是函数体内部使用了`yield`语句，定义了不同的内部状态。\n\n```javascript\nfunction* hello() {\n    yield 'hello';\n    yield 'world';\n    return 'ending';\n}\n\nvar hello = hello();\nhello.next() // hello - 1\nhello.next() // world - 2\nhello.next() // ending - 3\nhello.next() //undefined - 4\n```\n\n## yield语句\n\n可以看出，只有显式调用next()方法才会继续遍历到下一个状态，所以其实提供了一种可以暂停执行的函数。其中yield就是暂停标识。如果Generator函数不使用yield语句，这时就变成了一个单纯地暂缓执行函数。注意：yield不能用在普通函数中。\n\n```javascript\nfunction* f() {\n    console.log('Executed!');\n}\n\nvar generator = f();\nsetTimeout(function() {\n    generator.next();\n}, 2000);\n```\n\n## 与Iterator接口的关系\n\n由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable] // [1, 2, 3]\n```\n\n## next()方法的参数\n\n`yield`语句本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。\n\n```javascript\nfunction* f() {\n    for (var i = 0; true; i++) {\n        var reset = yield i;\n        if (reset) {i = -1;}\n    }\n}\n\nvar g = f();\n\ng.next()\ng.next()\ng.next(true)\n```\n\n上面这个例子有一个很有意思的特性：可以通过在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而来调整函数的行为。\n\n## for...of循环\n\n`for...of`循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。\n\n```javascript\nfunction* foo() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n    yield 5;\n    return 6;\n}\n\nfor (let v of foo()) {\n    console.log(v);\n}\n// 1 2 3 4 5\n```\n\n需要注意的是：一旦next方法的返回对象的done属性为true，for...of循环就会终止，且不包含该返回对象。下面再举一个解斐波那契数列的例子。\n\n```javascript\nfunction* fibonacci() {\n    let [prev, curr] = [0, 1];\n    for (;;) { // 内部自动会取下一个yield语句\n        [prev, curr] = [curr, prev + curr];\n        yield curr;\n    }\n}\n\nfor (let n of fibonacci()) {\n    if (n > 1000) break;\n    console.log(n);\n}\n```\n\n利用`for...of`循环可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用`for...of`循环，通过Generator函数为它加上这个接口，就可以使用了。\n\n```javascript\nfunction* objectEntries() {\n    let propKeys = Reflect.ownKeys(obj);\n    \n    for (let propKey of propKeys) {\n        yield [propKey, obj[propKey]];\n    }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n    console.log(`${key}: ${value}`);\n}\n\n// 另一种写法是将Generator函数加入到Symbol.iterator属性中.\njane[Symbol.iterator] = objectEntries;\n```\n\n## Generator.prototype.throw()\n\nGenerator函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。切记：不要混淆遍历器对象的throw方法和全局throw命令。因此：如果Generator函数内部没有部署`try...catch`代码块，那么`throw`方法抛出的错误，将被外部`try...catch`代码块捕获。\n\n```javascript\nvar g = function* () {\n    try {\n        yield;\n    } catch (e) {\n        console.log('Inner catch', e);\n    }\n};\n\nvar i = g();\ni.next();\ni.throw(new Error('Error occurs!'));\n```\n\n如果Generator函数内部和外部都没有部署`try...catch`代码块，那么程序将直接报错并且中断运行。\n\n```javascript\nvar gen = function* gen() {\n    yield console.log('hello');\n    yield console.log('world');\n}\n\nvar g = gen();\ng.next();\ng.throw();\n```\n\n如果Generator函数内部部署了`try-...catch`代码块，就不会影响下一次yield语句的执行。throw方法在被捕获以后会顺带执行下一条yield语句。\n\n```javascript\nvar gen = function* gen() {\n    try {\n        yield console.log('a');\n    } catch (e) {\n        // ...\n    }\n    yield console.log('b');\n    yield console.log('c');\n}\n\nvar g = gen();\ng.next();\ng.throw();\ng.next();\n```\n\n## Generator.prototype.return()\n\nGenerator函数的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。\n\n```javascript\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nvar g = gen();\n\ng.next(); // {value:1, done: false}\ng.return('foo'); // {value: 'foo', done: true}\ng.next(); // {value: undefined, done: true}\n```\n\n如果`return`方法调用时，不提供参数，则返回的`value`值为`undefined`;\n\n```javascript\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nvar g = gen();\n\ng.next(); // {value: 1, done: false}\ng.return(); // {value: undefined, done: true}\n```\n\n如果Generator函数内部有`try...finally`代码块，那么`return`方法将会推迟到`finally`代码块执行完再执行。\n\n```javascript\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers()\ng.next() // { done: false, value: 1 }\ng.next() // { done: false, value: 2 }\ng.return(7) // { done: false, value: 4 }\ng.next() // { done: false, value: 5 }\ng.next() // { done: true, value: 7 }\n```\n\n## yield* 语句\n\n该语句是用来在一个Generator函数中执行另外一个Generator函数的。从语法的角度上看：如果yield语句后面跟着一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。\n\n```javascript\nfunction* bar() {\n    yield 'x';\n    yield* foo();\n    yield 'y';\n}\n\nfunction* foo() {\n    yield 'a';\n    yield 'b';\n}\n```\n\n## Generator函数的this\n\nGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的`prototype`对象上的方法。\n\n```javascript\nfunction* g() {}\n\ng.prototype.hello = function() {\n    return 'hi!';\n};\n\nlet obj = g();\n\nobj instanceof g;\nobj.hello(); // 'hi!'\n```\n\n默认情况下，Generator函数是不可以使用new关键字生成的，但是我们可以用下面这种方式来生成一个空的Generator实例。\n\n```javascript\nfunction* F() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar obj = {};\nvar f = F.call(F.prototype);\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n\n```\n\n再将F改造成构造函数，就可以使用new命令来创建对象了；\n\n```javascript\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n```\n\n## Generator函数的应用\n\n### （1）异步操作的同步化表达\n\n基于Generator函数暂停执行的效果，意味着可以把异步写到yield语句中。等到next方法时再往后执行。这实际上等同于不需要再写回调函数了，因为异步操作的后续可以放在yield语句的下面。具体例子前面已经有涉及到了，所以这里就不再演示了。\n\n### （2）控制流管理\n\n如果一个多步操作非常耗时，可以使用Generator函数进一步改善代码的运作流程。不过这种写法只适合同步操作。\n\n```javascript\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n\nscheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) {\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) {\n    task.value = taskObj.value\n    scheduler(task);\n  }\n}\n```\n\n### （3）部署Iterator接口\n\n利用Generator函数的特性，可以在任意对象上部署Iterator接口。\n\n```javascript\nfunction* iterEntries(obj) {\n  let keys = Object.keys(obj);\n  for (let i=0; i < keys.length; i++) {\n    let key = keys[i];\n    yield [key, obj[key]];\n  }\n}\n\nlet myObj = { foo: 3, bar: 7 };\n\nfor (let [key, value] of iterEntries(myObj)) {\n  console.log(key, value);\n}\n\n// foo 3\n// bar 7\n```\n\n### （4）作为数据结构\n\nGenerator可以看作数据结构，更确切的说是一种数组结构，因为Generator函数可以返回一系列的值。这意味着它可以对任意表达式，提供类似数组的接口。\n\n```javascript\nfunction *doStuff() {\n  yield fs.readFile.bind(null, 'hello.txt');\n  yield fs.readFile.bind(null, 'world.txt');\n  yield fs.readFile.bind(null, 'and-such.txt');\n}\n```\n","source":"_posts/javascript/es6-generator-function.md","raw":"---\ntitle: ES6 Generator函数\ndate: 2022-02-17 22:20:37\nupdated: 2022-02-17 22:20:37\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Generator函数\n\n## 基本概念\n\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\nGenerator函数有多种理解角度：从语法上：可以将其理解成状态机，封装了多个内部状态；其次：执行Generator函数会返回一个遍历器对象。\n\n形式上，Generator函数是个普通函数，但是有两个特征。一是`function`关键字和函数名之间多了一个星号；二是函数体内部使用了`yield`语句，定义了不同的内部状态。\n\n```javascript\nfunction* hello() {\n    yield 'hello';\n    yield 'world';\n    return 'ending';\n}\n\nvar hello = hello();\nhello.next() // hello - 1\nhello.next() // world - 2\nhello.next() // ending - 3\nhello.next() //undefined - 4\n```\n\n## yield语句\n\n可以看出，只有显式调用next()方法才会继续遍历到下一个状态，所以其实提供了一种可以暂停执行的函数。其中yield就是暂停标识。如果Generator函数不使用yield语句，这时就变成了一个单纯地暂缓执行函数。注意：yield不能用在普通函数中。\n\n```javascript\nfunction* f() {\n    console.log('Executed!');\n}\n\nvar generator = f();\nsetTimeout(function() {\n    generator.next();\n}, 2000);\n```\n\n## 与Iterator接口的关系\n\n由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable] // [1, 2, 3]\n```\n\n## next()方法的参数\n\n`yield`语句本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。\n\n```javascript\nfunction* f() {\n    for (var i = 0; true; i++) {\n        var reset = yield i;\n        if (reset) {i = -1;}\n    }\n}\n\nvar g = f();\n\ng.next()\ng.next()\ng.next(true)\n```\n\n上面这个例子有一个很有意思的特性：可以通过在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而来调整函数的行为。\n\n## for...of循环\n\n`for...of`循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。\n\n```javascript\nfunction* foo() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n    yield 5;\n    return 6;\n}\n\nfor (let v of foo()) {\n    console.log(v);\n}\n// 1 2 3 4 5\n```\n\n需要注意的是：一旦next方法的返回对象的done属性为true，for...of循环就会终止，且不包含该返回对象。下面再举一个解斐波那契数列的例子。\n\n```javascript\nfunction* fibonacci() {\n    let [prev, curr] = [0, 1];\n    for (;;) { // 内部自动会取下一个yield语句\n        [prev, curr] = [curr, prev + curr];\n        yield curr;\n    }\n}\n\nfor (let n of fibonacci()) {\n    if (n > 1000) break;\n    console.log(n);\n}\n```\n\n利用`for...of`循环可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用`for...of`循环，通过Generator函数为它加上这个接口，就可以使用了。\n\n```javascript\nfunction* objectEntries() {\n    let propKeys = Reflect.ownKeys(obj);\n    \n    for (let propKey of propKeys) {\n        yield [propKey, obj[propKey]];\n    }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n    console.log(`${key}: ${value}`);\n}\n\n// 另一种写法是将Generator函数加入到Symbol.iterator属性中.\njane[Symbol.iterator] = objectEntries;\n```\n\n## Generator.prototype.throw()\n\nGenerator函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。切记：不要混淆遍历器对象的throw方法和全局throw命令。因此：如果Generator函数内部没有部署`try...catch`代码块，那么`throw`方法抛出的错误，将被外部`try...catch`代码块捕获。\n\n```javascript\nvar g = function* () {\n    try {\n        yield;\n    } catch (e) {\n        console.log('Inner catch', e);\n    }\n};\n\nvar i = g();\ni.next();\ni.throw(new Error('Error occurs!'));\n```\n\n如果Generator函数内部和外部都没有部署`try...catch`代码块，那么程序将直接报错并且中断运行。\n\n```javascript\nvar gen = function* gen() {\n    yield console.log('hello');\n    yield console.log('world');\n}\n\nvar g = gen();\ng.next();\ng.throw();\n```\n\n如果Generator函数内部部署了`try-...catch`代码块，就不会影响下一次yield语句的执行。throw方法在被捕获以后会顺带执行下一条yield语句。\n\n```javascript\nvar gen = function* gen() {\n    try {\n        yield console.log('a');\n    } catch (e) {\n        // ...\n    }\n    yield console.log('b');\n    yield console.log('c');\n}\n\nvar g = gen();\ng.next();\ng.throw();\ng.next();\n```\n\n## Generator.prototype.return()\n\nGenerator函数的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。\n\n```javascript\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nvar g = gen();\n\ng.next(); // {value:1, done: false}\ng.return('foo'); // {value: 'foo', done: true}\ng.next(); // {value: undefined, done: true}\n```\n\n如果`return`方法调用时，不提供参数，则返回的`value`值为`undefined`;\n\n```javascript\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nvar g = gen();\n\ng.next(); // {value: 1, done: false}\ng.return(); // {value: undefined, done: true}\n```\n\n如果Generator函数内部有`try...finally`代码块，那么`return`方法将会推迟到`finally`代码块执行完再执行。\n\n```javascript\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers()\ng.next() // { done: false, value: 1 }\ng.next() // { done: false, value: 2 }\ng.return(7) // { done: false, value: 4 }\ng.next() // { done: false, value: 5 }\ng.next() // { done: true, value: 7 }\n```\n\n## yield* 语句\n\n该语句是用来在一个Generator函数中执行另外一个Generator函数的。从语法的角度上看：如果yield语句后面跟着一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。\n\n```javascript\nfunction* bar() {\n    yield 'x';\n    yield* foo();\n    yield 'y';\n}\n\nfunction* foo() {\n    yield 'a';\n    yield 'b';\n}\n```\n\n## Generator函数的this\n\nGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的`prototype`对象上的方法。\n\n```javascript\nfunction* g() {}\n\ng.prototype.hello = function() {\n    return 'hi!';\n};\n\nlet obj = g();\n\nobj instanceof g;\nobj.hello(); // 'hi!'\n```\n\n默认情况下，Generator函数是不可以使用new关键字生成的，但是我们可以用下面这种方式来生成一个空的Generator实例。\n\n```javascript\nfunction* F() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar obj = {};\nvar f = F.call(F.prototype);\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n\n```\n\n再将F改造成构造函数，就可以使用new命令来创建对象了；\n\n```javascript\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n```\n\n## Generator函数的应用\n\n### （1）异步操作的同步化表达\n\n基于Generator函数暂停执行的效果，意味着可以把异步写到yield语句中。等到next方法时再往后执行。这实际上等同于不需要再写回调函数了，因为异步操作的后续可以放在yield语句的下面。具体例子前面已经有涉及到了，所以这里就不再演示了。\n\n### （2）控制流管理\n\n如果一个多步操作非常耗时，可以使用Generator函数进一步改善代码的运作流程。不过这种写法只适合同步操作。\n\n```javascript\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n\nscheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) {\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) {\n    task.value = taskObj.value\n    scheduler(task);\n  }\n}\n```\n\n### （3）部署Iterator接口\n\n利用Generator函数的特性，可以在任意对象上部署Iterator接口。\n\n```javascript\nfunction* iterEntries(obj) {\n  let keys = Object.keys(obj);\n  for (let i=0; i < keys.length; i++) {\n    let key = keys[i];\n    yield [key, obj[key]];\n  }\n}\n\nlet myObj = { foo: 3, bar: 7 };\n\nfor (let [key, value] of iterEntries(myObj)) {\n  console.log(key, value);\n}\n\n// foo 3\n// bar 7\n```\n\n### （4）作为数据结构\n\nGenerator可以看作数据结构，更确切的说是一种数组结构，因为Generator函数可以返回一系列的值。这意味着它可以对任意表达式，提供类似数组的接口。\n\n```javascript\nfunction *doStuff() {\n  yield fs.readFile.bind(null, 'hello.txt');\n  yield fs.readFile.bind(null, 'world.txt');\n  yield fs.readFile.bind(null, 'and-such.txt');\n}\n```\n","slug":"javascript/es6-generator-function","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6ve001c4f61dvsye45p","content":"<h1 id=\"Generator函数\"><a href=\"#Generator函数\" class=\"headerlink\" title=\"Generator函数\"></a>Generator函数</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>\n<p>Generator函数有多种理解角度：从语法上：可以将其理解成状态机，封装了多个内部状态；其次：执行Generator函数会返回一个遍历器对象。</p>\n<p>形式上，Generator函数是个普通函数，但是有两个特征。一是<code>function</code>关键字和函数名之间多了一个星号；二是函数体内部使用了<code>yield</code>语句，定义了不同的内部状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">hello</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;world&#x27;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;ending&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> hello = <span class=\"hljs-title function_\">hello</span>();<br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// hello - 1</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// world - 2</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// ending - 3</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">//undefined - 4</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"yield语句\"><a href=\"#yield语句\" class=\"headerlink\" title=\"yield语句\"></a>yield语句</h2><p>可以看出，只有显式调用next()方法才会继续遍历到下一个状态，所以其实提供了一种可以暂停执行的函数。其中yield就是暂停标识。如果Generator函数不使用yield语句，这时就变成了一个单纯地暂缓执行函数。注意：yield不能用在普通函数中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Executed!&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> generator = <span class=\"hljs-title function_\">f</span>();<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    generator.<span class=\"hljs-title function_\">next</span>();<br>&#125;, <span class=\"hljs-number\">2000</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"与Iterator接口的关系\"><a href=\"#与Iterator接口的关系\" class=\"headerlink\" title=\"与Iterator接口的关系\"></a>与Iterator接口的关系</h2><p>由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"next-方法的参数\"><a href=\"#next-方法的参数\" class=\"headerlink\" title=\"next()方法的参数\"></a>next()方法的参数</h2><p><code>yield</code>语句本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; <span class=\"hljs-literal\">true</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">var</span> reset = <span class=\"hljs-keyword\">yield</span> i;<br>        <span class=\"hljs-keyword\">if</span> (reset) &#123;i = -<span class=\"hljs-number\">1</span>;&#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">f</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>()<br>g.<span class=\"hljs-title function_\">next</span>()<br>g.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-literal\">true</span>)<br></code></pre></td></tr></table></figure>\n<p>上面这个例子有一个很有意思的特性：可以通过在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而来调整函数的行为。</p>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p><code>for...of</code>循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">6</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">foo</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br><span class=\"hljs-comment\">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure>\n<p>需要注意的是：一旦next方法的返回对象的done属性为true，for…of循环就会终止，且不包含该返回对象。下面再举一个解斐波那契数列的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibonacci</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> [prev, curr] = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123; <span class=\"hljs-comment\">// 内部自动会取下一个yield语句</span><br>        [prev, curr] = [curr, prev + curr];<br>        <span class=\"hljs-keyword\">yield</span> curr;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> n <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">fibonacci</span>()) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &gt; <span class=\"hljs-number\">1000</span>) <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>利用<code>for...of</code>循环可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用<code>for...of</code>循环，通过Generator函数为它加上这个接口，就可以使用了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">objectEntries</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> propKeys = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(obj);<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> propKey <span class=\"hljs-keyword\">of</span> propKeys) &#123;<br>        <span class=\"hljs-keyword\">yield</span> [propKey, obj[propKey]];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> jane = &#123; <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;Jane&#x27;</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">objectEntries</span>(jane)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法是将Generator函数加入到Symbol.iterator属性中.</span><br>jane[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = objectEntries;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-throw\"><a href=\"#Generator-prototype-throw\" class=\"headerlink\" title=\"Generator.prototype.throw()\"></a>Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。切记：不要混淆遍历器对象的throw方法和全局throw命令。因此：如果Generator函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">yield</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Inner catch&#x27;</span>, e);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-title function_\">g</span>();<br>i.<span class=\"hljs-title function_\">next</span>();<br>i.<span class=\"hljs-keyword\">throw</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Error occurs!&#x27;</span>));<br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部和外部都没有部署<code>try...catch</code>代码块，那么程序将直接报错并且中断运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;world&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br>g.<span class=\"hljs-keyword\">throw</span>();<br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部部署了<code>try-...catch</code>代码块，就不会影响下一次yield语句的执行。throw方法在被捕获以后会顺带执行下一条yield语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br>g.<span class=\"hljs-keyword\">throw</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-return\"><a href=\"#Generator-prototype-return\" class=\"headerlink\" title=\"Generator.prototype.return()\"></a>Generator.prototype.return()</h2><p>Generator函数的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value:1, done: false&#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>); <span class=\"hljs-comment\">// &#123;value: &#x27;foo&#x27;, done: true&#125;</span><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>return</code>方法调用时，不提供参数，则返回的<code>value</code>值为<code>undefined</code>;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value: 1, done: false&#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(); <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部有<code>try...finally</code>代码块，那么<code>return</code>方法将会推迟到<code>finally</code>代码块执行完再执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* numbers () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>  &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">6</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">numbers</span>()<br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 1 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 2 &#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-number\">7</span>) <span class=\"hljs-comment\">// &#123; done: false, value: 4 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 5 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: true, value: 7 &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"yield-语句\"><a href=\"#yield-语句\" class=\"headerlink\" title=\"yield* 语句\"></a>yield* 语句</h2><p>该语句是用来在一个Generator函数中执行另外一个Generator函数的。从语法的角度上看：如果yield语句后面跟着一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;x&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-title function_\">foo</span>();<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;y&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;b&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator函数的this\"><a href=\"#Generator函数的this\" class=\"headerlink\" title=\"Generator函数的this\"></a>Generator函数的this</h2><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><br>g.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hello</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hi!&#x27;</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-title function_\">g</span>();<br><br>obj <span class=\"hljs-keyword\">instanceof</span> g;<br>obj.<span class=\"hljs-title function_\">hello</span>(); <span class=\"hljs-comment\">// &#x27;hi!&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>默认情况下，Generator函数是不可以使用new关键字生成的，但是我们可以用下面这种方式来生成一个空的Generator实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span> = <span class=\"hljs-number\">3</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> f = F.<span class=\"hljs-title function_\">call</span>(F.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 2, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 3, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: undefined, done: true&#125;</span><br><br>obj.<span class=\"hljs-property\">a</span> <span class=\"hljs-comment\">// 1</span><br>obj.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br>obj.<span class=\"hljs-property\">c</span> <span class=\"hljs-comment\">// 3</span><br><br></code></pre></td></tr></table></figure>\n<p>再将F改造成构造函数，就可以使用new命令来创建对象了；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span> = <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> gen.<span class=\"hljs-title function_\">call</span>(gen.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 2, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 3, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: undefined, done: true&#125;</span><br><br>f.<span class=\"hljs-property\">a</span> <span class=\"hljs-comment\">// 1</span><br>f.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br>f.<span class=\"hljs-property\">c</span> <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator函数的应用\"><a href=\"#Generator函数的应用\" class=\"headerlink\" title=\"Generator函数的应用\"></a>Generator函数的应用</h2><h3 id=\"（1）异步操作的同步化表达\"><a href=\"#（1）异步操作的同步化表达\" class=\"headerlink\" title=\"（1）异步操作的同步化表达\"></a>（1）异步操作的同步化表达</h3><p>基于Generator函数暂停执行的效果，意味着可以把异步写到yield语句中。等到next方法时再往后执行。这实际上等同于不需要再写回调函数了，因为异步操作的后续可以放在yield语句的下面。具体例子前面已经有涉及到了，所以这里就不再演示了。</p>\n<h3 id=\"（2）控制流管理\"><a href=\"#（2）控制流管理\" class=\"headerlink\" title=\"（2）控制流管理\"></a>（2）控制流管理</h3><p>如果一个多步操作非常耗时，可以使用Generator函数进一步改善代码的运作流程。不过这种写法只适合同步操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">longRunningTask</span>(<span class=\"hljs-params\">value1</span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> value2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step1</span>(value1);<br>    <span class=\"hljs-keyword\">var</span> value3 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step2</span>(value2);<br>    <span class=\"hljs-keyword\">var</span> value4 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step3</span>(value3);<br>    <span class=\"hljs-keyword\">var</span> value5 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step4</span>(value4);<br>    <span class=\"hljs-comment\">// Do something with value4</span><br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-comment\">// Handle any error from step1 through step4</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">scheduler</span>(<span class=\"hljs-title function_\">longRunningTask</span>(initialValue));<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">scheduler</span>(<span class=\"hljs-params\">task</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> taskObj = task.<span class=\"hljs-title function_\">next</span>(task.<span class=\"hljs-property\">value</span>);<br>  <span class=\"hljs-comment\">// 如果Generator函数未结束，就继续调用</span><br>  <span class=\"hljs-keyword\">if</span> (!taskObj.<span class=\"hljs-property\">done</span>) &#123;<br>    task.<span class=\"hljs-property\">value</span> = taskObj.<span class=\"hljs-property\">value</span><br>    <span class=\"hljs-title function_\">scheduler</span>(task);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（3）部署Iterator接口\"><a href=\"#（3）部署Iterator接口\" class=\"headerlink\" title=\"（3）部署Iterator接口\"></a>（3）部署Iterator接口</h3><p>利用Generator函数的特性，可以在任意对象上部署Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">iterEntries</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> keys = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj);<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i &lt; keys.<span class=\"hljs-property\">length</span>; i++) &#123;<br>    <span class=\"hljs-keyword\">let</span> key = keys[i];<br>    <span class=\"hljs-keyword\">yield</span> [key, obj[key]];<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myObj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">7</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">iterEntries</span>(myObj)) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value);<br>&#125;<br><br><span class=\"hljs-comment\">// foo 3</span><br><span class=\"hljs-comment\">// bar 7</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）作为数据结构\"><a href=\"#（4）作为数据结构\" class=\"headerlink\" title=\"（4）作为数据结构\"></a>（4）作为数据结构</h3><p>Generator可以看作数据结构，更确切的说是一种数组结构，因为Generator函数可以返回一系列的值。这意味着它可以对任意表达式，提供类似数组的接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title function_\">doStuff</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;hello.txt&#x27;</span>);<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;world.txt&#x27;</span>);<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;and-such.txt&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":6562,"excerpt":"","more":"<h1 id=\"Generator函数\"><a href=\"#Generator函数\" class=\"headerlink\" title=\"Generator函数\"></a>Generator函数</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>\n<p>Generator函数有多种理解角度：从语法上：可以将其理解成状态机，封装了多个内部状态；其次：执行Generator函数会返回一个遍历器对象。</p>\n<p>形式上，Generator函数是个普通函数，但是有两个特征。一是<code>function</code>关键字和函数名之间多了一个星号；二是函数体内部使用了<code>yield</code>语句，定义了不同的内部状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">hello</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;world&#x27;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;ending&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> hello = <span class=\"hljs-title function_\">hello</span>();<br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// hello - 1</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// world - 2</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// ending - 3</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">//undefined - 4</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"yield语句\"><a href=\"#yield语句\" class=\"headerlink\" title=\"yield语句\"></a>yield语句</h2><p>可以看出，只有显式调用next()方法才会继续遍历到下一个状态，所以其实提供了一种可以暂停执行的函数。其中yield就是暂停标识。如果Generator函数不使用yield语句，这时就变成了一个单纯地暂缓执行函数。注意：yield不能用在普通函数中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Executed!&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> generator = <span class=\"hljs-title function_\">f</span>();<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    generator.<span class=\"hljs-title function_\">next</span>();<br>&#125;, <span class=\"hljs-number\">2000</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"与Iterator接口的关系\"><a href=\"#与Iterator接口的关系\" class=\"headerlink\" title=\"与Iterator接口的关系\"></a>与Iterator接口的关系</h2><p>由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"next-方法的参数\"><a href=\"#next-方法的参数\" class=\"headerlink\" title=\"next()方法的参数\"></a>next()方法的参数</h2><p><code>yield</code>语句本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; <span class=\"hljs-literal\">true</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">var</span> reset = <span class=\"hljs-keyword\">yield</span> i;<br>        <span class=\"hljs-keyword\">if</span> (reset) &#123;i = -<span class=\"hljs-number\">1</span>;&#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">f</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>()<br>g.<span class=\"hljs-title function_\">next</span>()<br>g.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-literal\">true</span>)<br></code></pre></td></tr></table></figure>\n<p>上面这个例子有一个很有意思的特性：可以通过在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而来调整函数的行为。</p>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p><code>for...of</code>循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">6</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">foo</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br><span class=\"hljs-comment\">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure>\n<p>需要注意的是：一旦next方法的返回对象的done属性为true，for…of循环就会终止，且不包含该返回对象。下面再举一个解斐波那契数列的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibonacci</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> [prev, curr] = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123; <span class=\"hljs-comment\">// 内部自动会取下一个yield语句</span><br>        [prev, curr] = [curr, prev + curr];<br>        <span class=\"hljs-keyword\">yield</span> curr;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> n <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">fibonacci</span>()) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &gt; <span class=\"hljs-number\">1000</span>) <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>利用<code>for...of</code>循环可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用<code>for...of</code>循环，通过Generator函数为它加上这个接口，就可以使用了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">objectEntries</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> propKeys = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(obj);<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> propKey <span class=\"hljs-keyword\">of</span> propKeys) &#123;<br>        <span class=\"hljs-keyword\">yield</span> [propKey, obj[propKey]];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> jane = &#123; <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;Jane&#x27;</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">objectEntries</span>(jane)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法是将Generator函数加入到Symbol.iterator属性中.</span><br>jane[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = objectEntries;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-throw\"><a href=\"#Generator-prototype-throw\" class=\"headerlink\" title=\"Generator.prototype.throw()\"></a>Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。切记：不要混淆遍历器对象的throw方法和全局throw命令。因此：如果Generator函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">yield</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Inner catch&#x27;</span>, e);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-title function_\">g</span>();<br>i.<span class=\"hljs-title function_\">next</span>();<br>i.<span class=\"hljs-keyword\">throw</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Error occurs!&#x27;</span>));<br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部和外部都没有部署<code>try...catch</code>代码块，那么程序将直接报错并且中断运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;world&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br>g.<span class=\"hljs-keyword\">throw</span>();<br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部部署了<code>try-...catch</code>代码块，就不会影响下一次yield语句的执行。throw方法在被捕获以后会顺带执行下一条yield语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br>g.<span class=\"hljs-keyword\">throw</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-return\"><a href=\"#Generator-prototype-return\" class=\"headerlink\" title=\"Generator.prototype.return()\"></a>Generator.prototype.return()</h2><p>Generator函数的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value:1, done: false&#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>); <span class=\"hljs-comment\">// &#123;value: &#x27;foo&#x27;, done: true&#125;</span><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>return</code>方法调用时，不提供参数，则返回的<code>value</code>值为<code>undefined</code>;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value: 1, done: false&#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(); <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部有<code>try...finally</code>代码块，那么<code>return</code>方法将会推迟到<code>finally</code>代码块执行完再执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* numbers () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>  &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">6</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">numbers</span>()<br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 1 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 2 &#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-number\">7</span>) <span class=\"hljs-comment\">// &#123; done: false, value: 4 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 5 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: true, value: 7 &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"yield-语句\"><a href=\"#yield-语句\" class=\"headerlink\" title=\"yield* 语句\"></a>yield* 语句</h2><p>该语句是用来在一个Generator函数中执行另外一个Generator函数的。从语法的角度上看：如果yield语句后面跟着一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;x&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-title function_\">foo</span>();<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;y&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;b&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator函数的this\"><a href=\"#Generator函数的this\" class=\"headerlink\" title=\"Generator函数的this\"></a>Generator函数的this</h2><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><br>g.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hello</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hi!&#x27;</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-title function_\">g</span>();<br><br>obj <span class=\"hljs-keyword\">instanceof</span> g;<br>obj.<span class=\"hljs-title function_\">hello</span>(); <span class=\"hljs-comment\">// &#x27;hi!&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>默认情况下，Generator函数是不可以使用new关键字生成的，但是我们可以用下面这种方式来生成一个空的Generator实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span> = <span class=\"hljs-number\">3</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> f = F.<span class=\"hljs-title function_\">call</span>(F.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 2, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 3, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: undefined, done: true&#125;</span><br><br>obj.<span class=\"hljs-property\">a</span> <span class=\"hljs-comment\">// 1</span><br>obj.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br>obj.<span class=\"hljs-property\">c</span> <span class=\"hljs-comment\">// 3</span><br><br></code></pre></td></tr></table></figure>\n<p>再将F改造成构造函数，就可以使用new命令来创建对象了；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span> = <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> gen.<span class=\"hljs-title function_\">call</span>(gen.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 2, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 3, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: undefined, done: true&#125;</span><br><br>f.<span class=\"hljs-property\">a</span> <span class=\"hljs-comment\">// 1</span><br>f.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br>f.<span class=\"hljs-property\">c</span> <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator函数的应用\"><a href=\"#Generator函数的应用\" class=\"headerlink\" title=\"Generator函数的应用\"></a>Generator函数的应用</h2><h3 id=\"（1）异步操作的同步化表达\"><a href=\"#（1）异步操作的同步化表达\" class=\"headerlink\" title=\"（1）异步操作的同步化表达\"></a>（1）异步操作的同步化表达</h3><p>基于Generator函数暂停执行的效果，意味着可以把异步写到yield语句中。等到next方法时再往后执行。这实际上等同于不需要再写回调函数了，因为异步操作的后续可以放在yield语句的下面。具体例子前面已经有涉及到了，所以这里就不再演示了。</p>\n<h3 id=\"（2）控制流管理\"><a href=\"#（2）控制流管理\" class=\"headerlink\" title=\"（2）控制流管理\"></a>（2）控制流管理</h3><p>如果一个多步操作非常耗时，可以使用Generator函数进一步改善代码的运作流程。不过这种写法只适合同步操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">longRunningTask</span>(<span class=\"hljs-params\">value1</span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> value2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step1</span>(value1);<br>    <span class=\"hljs-keyword\">var</span> value3 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step2</span>(value2);<br>    <span class=\"hljs-keyword\">var</span> value4 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step3</span>(value3);<br>    <span class=\"hljs-keyword\">var</span> value5 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step4</span>(value4);<br>    <span class=\"hljs-comment\">// Do something with value4</span><br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-comment\">// Handle any error from step1 through step4</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">scheduler</span>(<span class=\"hljs-title function_\">longRunningTask</span>(initialValue));<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">scheduler</span>(<span class=\"hljs-params\">task</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> taskObj = task.<span class=\"hljs-title function_\">next</span>(task.<span class=\"hljs-property\">value</span>);<br>  <span class=\"hljs-comment\">// 如果Generator函数未结束，就继续调用</span><br>  <span class=\"hljs-keyword\">if</span> (!taskObj.<span class=\"hljs-property\">done</span>) &#123;<br>    task.<span class=\"hljs-property\">value</span> = taskObj.<span class=\"hljs-property\">value</span><br>    <span class=\"hljs-title function_\">scheduler</span>(task);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（3）部署Iterator接口\"><a href=\"#（3）部署Iterator接口\" class=\"headerlink\" title=\"（3）部署Iterator接口\"></a>（3）部署Iterator接口</h3><p>利用Generator函数的特性，可以在任意对象上部署Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">iterEntries</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> keys = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj);<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i &lt; keys.<span class=\"hljs-property\">length</span>; i++) &#123;<br>    <span class=\"hljs-keyword\">let</span> key = keys[i];<br>    <span class=\"hljs-keyword\">yield</span> [key, obj[key]];<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myObj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">7</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">iterEntries</span>(myObj)) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value);<br>&#125;<br><br><span class=\"hljs-comment\">// foo 3</span><br><span class=\"hljs-comment\">// bar 7</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）作为数据结构\"><a href=\"#（4）作为数据结构\" class=\"headerlink\" title=\"（4）作为数据结构\"></a>（4）作为数据结构</h3><p>Generator可以看作数据结构，更确切的说是一种数组结构，因为Generator函数可以返回一系列的值。这意味着它可以对任意表达式，提供类似数组的接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title function_\">doStuff</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;hello.txt&#x27;</span>);<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;world.txt&#x27;</span>);<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;and-such.txt&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"初识 ES6","date":"2022-02-17T02:48:32.000Z","updated":"2022-02-17T02:48:32.000Z","_content":"\n# ES6历史\n\n ES6全程ECMAScript 6.0，也叫ES2015。ECMA是国际标准化组织，推出这个标准是为了希望此种编程语言能够成为国际标准。因此我们常说的JavaScript实际上是ES的一种实现形式，而ES是JavaScript的规范草案。很多人在一开始学习JavaScript的时候一看到Java就会把它和Sun（Oracle）公司的框架联结起来，实际上两者并没有什么关系。\n\n# 查看Node支持的ES特性\n\n打开终端，前提是需要装好node（为了方便切换node版本你可以安装NVM），然后在控制台输入下列语句：(不同版本的node显示的结果不相同)\n\n```shell\n$ node --v8-options | grep harmony\n\n--es-staging (enable test-worthy harmony features (for internal use only))\n  --harmony (enable all completed harmony features)\n  --harmony-shipping (enable all shipped harmony features)\n  --harmony-private-methods (enable \"harmony private methods in class literals\" (in progress))\n  --harmony-regexp-sequence (enable \"RegExp Unicode sequence properties\" (in progress))\n  --harmony-weak-refs (enable \"harmony weak references\" (in progress))\n  --harmony-intl-dateformat-quarter (enable \"Add quarter option to DateTimeFormat\" (in progress))\n  --harmony-intl-add-calendar-numbering-system (enable \"Add calendar and numberingSystem to DateTimeFormat\")\n  --harmony-intl-dateformat-day-period (enable \"Add dayPeriod option to DateTimeFormat\")\n```\n\n# 使用Babel完成ES6解码\n\n 因为ES6草案还在不断完善，而且由于不同平台环境的差异，导致支持ES6的情况都不相同。这个时候Babel可以将我们旧的ES5语法转换成ES6语法，这样在写程序的时候就不用关心底层的环境了。\n\n```javascript\n// 转码前语法\ninput.map(item => item + 1);\n\n// 转码后\ninput.map(function (item){\n  return item + 1;\n});\n```\n\n## 配置Babel\n\n核心文件就是.babelrc文件，一般在引入Babel后都可以看到这个文件，细则可以去看Babel的官方文档，这里就不扯了。\n","source":"_posts/javascript/es6-getting-started.md","raw":"---\ntitle: 初识 ES6\ndate: 2022-02-17 10:48:32\nupdated: 2022-02-17 10:48:32\ntags: ES6基础\ncategories: JavaScript\n---\n\n# ES6历史\n\n ES6全程ECMAScript 6.0，也叫ES2015。ECMA是国际标准化组织，推出这个标准是为了希望此种编程语言能够成为国际标准。因此我们常说的JavaScript实际上是ES的一种实现形式，而ES是JavaScript的规范草案。很多人在一开始学习JavaScript的时候一看到Java就会把它和Sun（Oracle）公司的框架联结起来，实际上两者并没有什么关系。\n\n# 查看Node支持的ES特性\n\n打开终端，前提是需要装好node（为了方便切换node版本你可以安装NVM），然后在控制台输入下列语句：(不同版本的node显示的结果不相同)\n\n```shell\n$ node --v8-options | grep harmony\n\n--es-staging (enable test-worthy harmony features (for internal use only))\n  --harmony (enable all completed harmony features)\n  --harmony-shipping (enable all shipped harmony features)\n  --harmony-private-methods (enable \"harmony private methods in class literals\" (in progress))\n  --harmony-regexp-sequence (enable \"RegExp Unicode sequence properties\" (in progress))\n  --harmony-weak-refs (enable \"harmony weak references\" (in progress))\n  --harmony-intl-dateformat-quarter (enable \"Add quarter option to DateTimeFormat\" (in progress))\n  --harmony-intl-add-calendar-numbering-system (enable \"Add calendar and numberingSystem to DateTimeFormat\")\n  --harmony-intl-dateformat-day-period (enable \"Add dayPeriod option to DateTimeFormat\")\n```\n\n# 使用Babel完成ES6解码\n\n 因为ES6草案还在不断完善，而且由于不同平台环境的差异，导致支持ES6的情况都不相同。这个时候Babel可以将我们旧的ES5语法转换成ES6语法，这样在写程序的时候就不用关心底层的环境了。\n\n```javascript\n// 转码前语法\ninput.map(item => item + 1);\n\n// 转码后\ninput.map(function (item){\n  return item + 1;\n});\n```\n\n## 配置Babel\n\n核心文件就是.babelrc文件，一般在引入Babel后都可以看到这个文件，细则可以去看Babel的官方文档，这里就不扯了。\n","slug":"javascript/es6-getting-started","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vf001g4f6123ko1hak","content":"<h1 id=\"ES6历史\"><a href=\"#ES6历史\" class=\"headerlink\" title=\"ES6历史\"></a>ES6历史</h1><p> ES6全程ECMAScript 6.0，也叫ES2015。ECMA是国际标准化组织，推出这个标准是为了希望此种编程语言能够成为国际标准。因此我们常说的JavaScript实际上是ES的一种实现形式，而ES是JavaScript的规范草案。很多人在一开始学习JavaScript的时候一看到Java就会把它和Sun（Oracle）公司的框架联结起来，实际上两者并没有什么关系。</p>\n<h1 id=\"查看Node支持的ES特性\"><a href=\"#查看Node支持的ES特性\" class=\"headerlink\" title=\"查看Node支持的ES特性\"></a>查看Node支持的ES特性</h1><p>打开终端，前提是需要装好node（为了方便切换node版本你可以安装NVM），然后在控制台输入下列语句：(不同版本的node显示的结果不相同)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">node --v8-options | grep harmony</span><br><br>--es-staging (enable test-worthy harmony features (for internal use only))<br>  --harmony (enable all completed harmony features)<br>  --harmony-shipping (enable all shipped harmony features)<br>  --harmony-private-methods (enable &quot;harmony private methods in class literals&quot; (in progress))<br>  --harmony-regexp-sequence (enable &quot;RegExp Unicode sequence properties&quot; (in progress))<br>  --harmony-weak-refs (enable &quot;harmony weak references&quot; (in progress))<br>  --harmony-intl-dateformat-quarter (enable &quot;Add quarter option to DateTimeFormat&quot; (in progress))<br>  --harmony-intl-add-calendar-numbering-system (enable &quot;Add calendar and numberingSystem to DateTimeFormat&quot;)<br>  --harmony-intl-dateformat-day-period (enable &quot;Add dayPeriod option to DateTimeFormat&quot;)<br></code></pre></td></tr></table></figure>\n<h1 id=\"使用Babel完成ES6解码\"><a href=\"#使用Babel完成ES6解码\" class=\"headerlink\" title=\"使用Babel完成ES6解码\"></a>使用Babel完成ES6解码</h1><p> 因为ES6草案还在不断完善，而且由于不同平台环境的差异，导致支持ES6的情况都不相同。这个时候Babel可以将我们旧的ES5语法转换成ES6语法，这样在写程序的时候就不用关心底层的环境了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 转码前语法</span><br>input.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-comment\">// 转码后</span><br>input.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>)&#123;<br>  <span class=\"hljs-keyword\">return</span> item + <span class=\"hljs-number\">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置Babel\"><a href=\"#配置Babel\" class=\"headerlink\" title=\"配置Babel\"></a>配置Babel</h2><p>核心文件就是.babelrc文件，一般在引入Babel后都可以看到这个文件，细则可以去看Babel的官方文档，这里就不扯了。</p>\n","site":{"data":{}},"wordcount":1301,"excerpt":"","more":"<h1 id=\"ES6历史\"><a href=\"#ES6历史\" class=\"headerlink\" title=\"ES6历史\"></a>ES6历史</h1><p> ES6全程ECMAScript 6.0，也叫ES2015。ECMA是国际标准化组织，推出这个标准是为了希望此种编程语言能够成为国际标准。因此我们常说的JavaScript实际上是ES的一种实现形式，而ES是JavaScript的规范草案。很多人在一开始学习JavaScript的时候一看到Java就会把它和Sun（Oracle）公司的框架联结起来，实际上两者并没有什么关系。</p>\n<h1 id=\"查看Node支持的ES特性\"><a href=\"#查看Node支持的ES特性\" class=\"headerlink\" title=\"查看Node支持的ES特性\"></a>查看Node支持的ES特性</h1><p>打开终端，前提是需要装好node（为了方便切换node版本你可以安装NVM），然后在控制台输入下列语句：(不同版本的node显示的结果不相同)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">node --v8-options | grep harmony</span><br><br>--es-staging (enable test-worthy harmony features (for internal use only))<br>  --harmony (enable all completed harmony features)<br>  --harmony-shipping (enable all shipped harmony features)<br>  --harmony-private-methods (enable &quot;harmony private methods in class literals&quot; (in progress))<br>  --harmony-regexp-sequence (enable &quot;RegExp Unicode sequence properties&quot; (in progress))<br>  --harmony-weak-refs (enable &quot;harmony weak references&quot; (in progress))<br>  --harmony-intl-dateformat-quarter (enable &quot;Add quarter option to DateTimeFormat&quot; (in progress))<br>  --harmony-intl-add-calendar-numbering-system (enable &quot;Add calendar and numberingSystem to DateTimeFormat&quot;)<br>  --harmony-intl-dateformat-day-period (enable &quot;Add dayPeriod option to DateTimeFormat&quot;)<br></code></pre></td></tr></table></figure>\n<h1 id=\"使用Babel完成ES6解码\"><a href=\"#使用Babel完成ES6解码\" class=\"headerlink\" title=\"使用Babel完成ES6解码\"></a>使用Babel完成ES6解码</h1><p> 因为ES6草案还在不断完善，而且由于不同平台环境的差异，导致支持ES6的情况都不相同。这个时候Babel可以将我们旧的ES5语法转换成ES6语法，这样在写程序的时候就不用关心底层的环境了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 转码前语法</span><br>input.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-comment\">// 转码后</span><br>input.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>)&#123;<br>  <span class=\"hljs-keyword\">return</span> item + <span class=\"hljs-number\">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置Babel\"><a href=\"#配置Babel\" class=\"headerlink\" title=\"配置Babel\"></a>配置Babel</h2><p>核心文件就是.babelrc文件，一般在引入Babel后都可以看到这个文件，细则可以去看Babel的官方文档，这里就不扯了。</p>\n"},{"title":"ES6 迭代","date":"2022-02-17T07:27:58.000Z","updated":"2022-02-17T07:27:58.000Z","_content":"\n# Iterator和for...of循环\n\n## Iterator\n\n### 基本概念\n\n遍历器是是一种机制：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。\n\n### 数据结构的默认Iterator接口\n\n目的在于为所有数据结构，提供一种统一的访问机制，即`for...of`循环。因此一种数据结构只要部署了Iterator接口，我们就可以成为该数据结构是可遍历的。\n\nES6规定：默认的Iterator接口部署在数据结构的`Symbol.iterator`属性，也就是说：一个数据结构只要具有该属性，就可以认为是可遍历的。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。例子如下：\n\n```javascript\nconst obj = {\n    [Symbol.iterator] : function() {\n        return {\n            next: function() {\n                return {\n                    value: 1,\n                    done: true\n                };\n            }\n        };\n    }\n};\n\n// obj对象是可遍历的，因为具有Symbol.iterator属性。\n```\n\n一个对象如果想要在`for...of`循环上调用Iterator接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法。\n\n```javascript\nclass RangeIterator {\n    constructor(start, stop) {\n        this.value = start;\n        this.stop = stop;\n    }\n\n    [Symbol.iterator]() { return this; }\n\n    next() {\n        var value = this.value;\n        if (value < this.stop) {\n            this.value ++;\n            return {done: false, value: value};\n        } else {\n            return {done: true, value: undefined};\n        }\n    }\n}\n\nfunction range(start ,stop) {\n    return new RangeIterator(start, stop);\n}\n\nfor (var value of range(0, 3)) {\n    console.log(value);\n}\n// 0\n// 1\n// 2\n```\n\n## 调用Iterator接口的场合\n\n### （1）解构赋值\n\n对数组和Set结构进行解构赋值时，会默认调用`Symbol.iterator`方法。\n\n```javascript\nlet set = new Set().add('a').add('b').add('c');\n\nlet [x, y] = set;\n\nlet [first, ...rest] = set;\n```\n\n### （2）扩展运算符\n\n扩展运算符默认也会调用`Symbol.iterator`接口，前面章节已经有很多例子，这里就不再展示了。\n\n### （3）yield*\n\nyield* 后面跟的也是一个可遍历结构，它会调用该结构的遍历器接口\n\n```javascript\nlet generator = function* () {\n    yield 1;\n    yield* [2, 3, 4];\n    yield 5;\n};\n\nvar iterator = generator();\n\niterator.next()\n{ value: 1, done: false }\n\niterator.next()\n{ value: 2, done: false }\n\niterator.next()\n{ value: 3, done: false }\n\niterator.next()\n{ value: 4, done: false }\n\niterator.next()\n{ value: 5, done: false }\n\niterator.next()\n{ value: undefined, done: true }\n```\n\n### （4）其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都是调用了遍历器接口的。\n\n## 字符串的Iterator接口\n\n字符串是一个类似数组的对象，也原生具有Iterator接口。\n\n```javascript\nvar someString = \"hi\";\ntypeof someString[Symbol.iterator]\n// \"function\"\n\nvar iterator = someString[Symbol.iterator]();\n\niterator.next()  // { value: \"h\", done: false }\niterator.next()  // { value: \"i\", done: false }\niterator.next()  // { value: undefined, done: true }\n```\n\n## Iterator接口与Generator函数\n\n```javascript\nvar myIterable = {};\n\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n[...myIterable] // [1, 2, 3]\n\n// 或者采用下面的简洁写法\n\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n\nfor (let x of obj) {\n  console.log(x);\n}\n// hello\n// world\n```\n\n## 遍历器对象的return()，throw()\n\n遍历器除了有`next`方法以外，还可以拥有`return`和`throw`方法。其中`next`方法是必须部署的，而`return`和`throw`却是可选的。\n\n`return`方法的使用场景是：如果一个对象要在完成遍历前，需要清理或者释放资源，就需要部署。\n\n`throw`方法主要结合Generator函数使用。这里不做过多解释。\n\n```javascript\nfunction readLinesSync(file) {\n  return {\n    next() {\n      if (file.isAtEndOfFile()) {\n        file.close();\n        return { done: true };\n      }\n    },\n    return() {\n      file.close();\n      return { done: true };\n    },\n  };\n}\n```\n\n## for...of循环\n\n一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有iterator接口，就可以使用`for...of`循环遍历。也就是说`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。\n\n### 数组\n\n数组具备iterator接口，可以通过下面的代码证明：\n\n```javascript\nconst arr = ['red', 'gree', 'blue'];\n\nfor (let v of arr) {\n    console.log(v);\n}\n\nconst obj = {};\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n\nfor (let v of obj) {\n    console.log(v);\n}\n```\n\n### Set和Map结构\n\nSet和Map结构也原生具有Iterator接口，可以直接使用`for...of`循环。前面有例子演示过，不再赘述。\n\n### 类似数组的对象\n\n类似数组的对象，包括：DON NodeList对象，arguments对象。都可以使用`for...of`来循环遍历。\n\n```javascript\n// 字符串\nlet str = \"hello\";\n\nfor (let s of str) {\n  console.log(s); // h e l l o\n}\n\n// DOM NodeList对象\nlet paras = document.querySelectorAll(\"p\");\n\nfor (let p of paras) {\n  p.classList.add(\"test\");\n}\n\n// arguments对象\nfunction printArgs() {\n  for (let x of arguments) {\n    console.log(x);\n  }\n}\nprintArgs('a', 'b');\n// 'a'\n// 'b'\n```\n\n### 对象\n\n对于普通对象，`for...of`不能直接使用，会报错；必须部署了iterator接口后才能使用。但是即便是这样：`for...of`依旧可以用来遍历键名。\n\n```javascript\nvar es6 = {\n  edition: 6,\n  committee: \"TC39\",\n  standard: \"ECMA-262\"\n};\n\nfor (let e in es6) {\n  console.log(e);\n}\n// edition\n// committee\n// standard\n\nfor (let e of es6) {\n  console.log(e);\n}\n// TypeError: es6 is not iterable\n```\n\n## `for...in`循环的缺点\n\n`for...in`循环也是有缺点的：\n\n- 数组的键名是数字，但是`for...in`循环是字符串作为键名的；\n- 除了循环数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；\n- 某些情况下，`for...in`循环会以任何顺序遍历键名；\n\n## `for...of`循环的优点\n\n- 有着和for...in循环一样简洁的语法，但是没有for...in那些缺点；\n- 不同于forEach方法，可以结合return, continue和break使用；\n- 提供了遍历所有数据结构的统一操作接口；\n","source":"_posts/javascript/es6-iterator.md","raw":"---\ntitle: ES6 迭代\ndate: 2022-02-17 15:27:58\nupdated: 2022-02-17 15:27:58\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Iterator和for...of循环\n\n## Iterator\n\n### 基本概念\n\n遍历器是是一种机制：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。\n\n### 数据结构的默认Iterator接口\n\n目的在于为所有数据结构，提供一种统一的访问机制，即`for...of`循环。因此一种数据结构只要部署了Iterator接口，我们就可以成为该数据结构是可遍历的。\n\nES6规定：默认的Iterator接口部署在数据结构的`Symbol.iterator`属性，也就是说：一个数据结构只要具有该属性，就可以认为是可遍历的。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。例子如下：\n\n```javascript\nconst obj = {\n    [Symbol.iterator] : function() {\n        return {\n            next: function() {\n                return {\n                    value: 1,\n                    done: true\n                };\n            }\n        };\n    }\n};\n\n// obj对象是可遍历的，因为具有Symbol.iterator属性。\n```\n\n一个对象如果想要在`for...of`循环上调用Iterator接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法。\n\n```javascript\nclass RangeIterator {\n    constructor(start, stop) {\n        this.value = start;\n        this.stop = stop;\n    }\n\n    [Symbol.iterator]() { return this; }\n\n    next() {\n        var value = this.value;\n        if (value < this.stop) {\n            this.value ++;\n            return {done: false, value: value};\n        } else {\n            return {done: true, value: undefined};\n        }\n    }\n}\n\nfunction range(start ,stop) {\n    return new RangeIterator(start, stop);\n}\n\nfor (var value of range(0, 3)) {\n    console.log(value);\n}\n// 0\n// 1\n// 2\n```\n\n## 调用Iterator接口的场合\n\n### （1）解构赋值\n\n对数组和Set结构进行解构赋值时，会默认调用`Symbol.iterator`方法。\n\n```javascript\nlet set = new Set().add('a').add('b').add('c');\n\nlet [x, y] = set;\n\nlet [first, ...rest] = set;\n```\n\n### （2）扩展运算符\n\n扩展运算符默认也会调用`Symbol.iterator`接口，前面章节已经有很多例子，这里就不再展示了。\n\n### （3）yield*\n\nyield* 后面跟的也是一个可遍历结构，它会调用该结构的遍历器接口\n\n```javascript\nlet generator = function* () {\n    yield 1;\n    yield* [2, 3, 4];\n    yield 5;\n};\n\nvar iterator = generator();\n\niterator.next()\n{ value: 1, done: false }\n\niterator.next()\n{ value: 2, done: false }\n\niterator.next()\n{ value: 3, done: false }\n\niterator.next()\n{ value: 4, done: false }\n\niterator.next()\n{ value: 5, done: false }\n\niterator.next()\n{ value: undefined, done: true }\n```\n\n### （4）其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都是调用了遍历器接口的。\n\n## 字符串的Iterator接口\n\n字符串是一个类似数组的对象，也原生具有Iterator接口。\n\n```javascript\nvar someString = \"hi\";\ntypeof someString[Symbol.iterator]\n// \"function\"\n\nvar iterator = someString[Symbol.iterator]();\n\niterator.next()  // { value: \"h\", done: false }\niterator.next()  // { value: \"i\", done: false }\niterator.next()  // { value: undefined, done: true }\n```\n\n## Iterator接口与Generator函数\n\n```javascript\nvar myIterable = {};\n\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n[...myIterable] // [1, 2, 3]\n\n// 或者采用下面的简洁写法\n\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n\nfor (let x of obj) {\n  console.log(x);\n}\n// hello\n// world\n```\n\n## 遍历器对象的return()，throw()\n\n遍历器除了有`next`方法以外，还可以拥有`return`和`throw`方法。其中`next`方法是必须部署的，而`return`和`throw`却是可选的。\n\n`return`方法的使用场景是：如果一个对象要在完成遍历前，需要清理或者释放资源，就需要部署。\n\n`throw`方法主要结合Generator函数使用。这里不做过多解释。\n\n```javascript\nfunction readLinesSync(file) {\n  return {\n    next() {\n      if (file.isAtEndOfFile()) {\n        file.close();\n        return { done: true };\n      }\n    },\n    return() {\n      file.close();\n      return { done: true };\n    },\n  };\n}\n```\n\n## for...of循环\n\n一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有iterator接口，就可以使用`for...of`循环遍历。也就是说`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。\n\n### 数组\n\n数组具备iterator接口，可以通过下面的代码证明：\n\n```javascript\nconst arr = ['red', 'gree', 'blue'];\n\nfor (let v of arr) {\n    console.log(v);\n}\n\nconst obj = {};\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n\nfor (let v of obj) {\n    console.log(v);\n}\n```\n\n### Set和Map结构\n\nSet和Map结构也原生具有Iterator接口，可以直接使用`for...of`循环。前面有例子演示过，不再赘述。\n\n### 类似数组的对象\n\n类似数组的对象，包括：DON NodeList对象，arguments对象。都可以使用`for...of`来循环遍历。\n\n```javascript\n// 字符串\nlet str = \"hello\";\n\nfor (let s of str) {\n  console.log(s); // h e l l o\n}\n\n// DOM NodeList对象\nlet paras = document.querySelectorAll(\"p\");\n\nfor (let p of paras) {\n  p.classList.add(\"test\");\n}\n\n// arguments对象\nfunction printArgs() {\n  for (let x of arguments) {\n    console.log(x);\n  }\n}\nprintArgs('a', 'b');\n// 'a'\n// 'b'\n```\n\n### 对象\n\n对于普通对象，`for...of`不能直接使用，会报错；必须部署了iterator接口后才能使用。但是即便是这样：`for...of`依旧可以用来遍历键名。\n\n```javascript\nvar es6 = {\n  edition: 6,\n  committee: \"TC39\",\n  standard: \"ECMA-262\"\n};\n\nfor (let e in es6) {\n  console.log(e);\n}\n// edition\n// committee\n// standard\n\nfor (let e of es6) {\n  console.log(e);\n}\n// TypeError: es6 is not iterable\n```\n\n## `for...in`循环的缺点\n\n`for...in`循环也是有缺点的：\n\n- 数组的键名是数字，但是`for...in`循环是字符串作为键名的；\n- 除了循环数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；\n- 某些情况下，`for...in`循环会以任何顺序遍历键名；\n\n## `for...of`循环的优点\n\n- 有着和for...in循环一样简洁的语法，但是没有for...in那些缺点；\n- 不同于forEach方法，可以结合return, continue和break使用；\n- 提供了遍历所有数据结构的统一操作接口；\n","slug":"javascript/es6-iterator","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vf001i4f61gqk7f5ek","content":"<h1 id=\"Iterator和for…of循环\"><a href=\"#Iterator和for…of循环\" class=\"headerlink\" title=\"Iterator和for…of循环\"></a>Iterator和for…of循环</h1><h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>遍历器是是一种机制：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。</p>\n<h3 id=\"数据结构的默认Iterator接口\"><a href=\"#数据结构的默认Iterator接口\" class=\"headerlink\" title=\"数据结构的默认Iterator接口\"></a>数据结构的默认Iterator接口</h3><p>目的在于为所有数据结构，提供一种统一的访问机制，即<code>for...of</code>循环。因此一种数据结构只要部署了Iterator接口，我们就可以成为该数据结构是可遍历的。</p>\n<p>ES6规定：默认的Iterator接口部署在数据结构的<code>Symbol.iterator</code>属性，也就是说：一个数据结构只要具有该属性，就可以认为是可遍历的。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] : <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<br>            <span class=\"hljs-attr\">next</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>                <span class=\"hljs-keyword\">return</span> &#123;<br>                    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>,<br>                    <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span><br>                &#125;;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// obj对象是可遍历的，因为具有Symbol.iterator属性。</span><br></code></pre></td></tr></table></figure>\n<p>一个对象如果想要在<code>for...of</code>循环上调用Iterator接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RangeIterator</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">start, stop</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = start;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span> = stop;<br>    &#125;<br><br>    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>; &#125;<br><br>    <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>;<br>        <span class=\"hljs-keyword\">if</span> (value &lt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span>) &#123;<br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> ++;<br>            <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">value</span>: value&#125;;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-params\">start ,stop</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeIterator</span>(start, stop);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> value <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"调用Iterator接口的场合\"><a href=\"#调用Iterator接口的场合\" class=\"headerlink\" title=\"调用Iterator接口的场合\"></a>调用Iterator接口的场合</h2><h3 id=\"（1）解构赋值\"><a href=\"#（1）解构赋值\" class=\"headerlink\" title=\"（1）解构赋值\"></a>（1）解构赋值</h3><p>对数组和Set结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>().<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br><br><span class=\"hljs-keyword\">let</span> [x, y] = set;<br><br><span class=\"hljs-keyword\">let</span> [first, ...rest] = set;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（2）扩展运算符\"><a href=\"#（2）扩展运算符\" class=\"headerlink\" title=\"（2）扩展运算符\"></a>（2）扩展运算符</h3><p>扩展运算符默认也会调用<code>Symbol.iterator</code>接口，前面章节已经有很多例子，这里就不再展示了。</p>\n<h3 id=\"（3）yield\"><a href=\"#（3）yield\" class=\"headerlink\" title=\"（3）yield*\"></a>（3）yield*</h3><p>yield* 后面跟的也是一个可遍历结构，它会调用该结构的遍历器接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> generator = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span>* [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> iterator = <span class=\"hljs-title function_\">generator</span>();<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）其他场合\"><a href=\"#（4）其他场合\" class=\"headerlink\" title=\"（4）其他场合\"></a>（4）其他场合</h3><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都是调用了遍历器接口的。</p>\n<h2 id=\"字符串的Iterator接口\"><a href=\"#字符串的Iterator接口\" class=\"headerlink\" title=\"字符串的Iterator接口\"></a>字符串的Iterator接口</h2><p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> someString = <span class=\"hljs-string\">&quot;hi&quot;</span>;<br><span class=\"hljs-keyword\">typeof</span> someString[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]<br><span class=\"hljs-comment\">// &quot;function&quot;</span><br><br><span class=\"hljs-keyword\">var</span> iterator = someString[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: &quot;h&quot;, done: false &#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: &quot;i&quot;, done: false &#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Iterator接口与Generator函数\"><a href=\"#Iterator接口与Generator函数\" class=\"headerlink\" title=\"Iterator接口与Generator函数\"></a>Iterator接口与Generator函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br><br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br><br><span class=\"hljs-comment\">// 或者采用下面的简洁写法</span><br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>  * [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;world&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> obj) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br><span class=\"hljs-comment\">// hello</span><br><span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"遍历器对象的return-，throw\"><a href=\"#遍历器对象的return-，throw\" class=\"headerlink\" title=\"遍历器对象的return()，throw()\"></a>遍历器对象的return()，throw()</h2><p>遍历器除了有<code>next</code>方法以外，还可以拥有<code>return</code>和<code>throw</code>方法。其中<code>next</code>方法是必须部署的，而<code>return</code>和<code>throw</code>却是可选的。</p>\n<p><code>return</code>方法的使用场景是：如果一个对象要在完成遍历前，需要清理或者释放资源，就需要部署。</p>\n<p><code>throw</code>方法主要结合Generator函数使用。这里不做过多解释。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">readLinesSync</span>(<span class=\"hljs-params\">file</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-keyword\">if</span> (file.<span class=\"hljs-title function_\">isAtEndOfFile</span>()) &#123;<br>        file.<span class=\"hljs-title function_\">close</span>();<br>        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>      &#125;<br>    &#125;,<br>    <span class=\"hljs-keyword\">return</span>() &#123;<br>      file.<span class=\"hljs-title function_\">close</span>();<br>      <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>    &#125;,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有iterator接口，就可以使用<code>for...of</code>循环遍历。也就是说<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组具备iterator接口，可以通过下面的代码证明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;gree&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> arr) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;;<br>obj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = arr[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>].<span class=\"hljs-title function_\">bind</span>(arr);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> obj) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Set和Map结构\"><a href=\"#Set和Map结构\" class=\"headerlink\" title=\"Set和Map结构\"></a>Set和Map结构</h3><p>Set和Map结构也原生具有Iterator接口，可以直接使用<code>for...of</code>循环。前面有例子演示过，不再赘述。</p>\n<h3 id=\"类似数组的对象\"><a href=\"#类似数组的对象\" class=\"headerlink\" title=\"类似数组的对象\"></a>类似数组的对象</h3><p>类似数组的对象，包括：DON NodeList对象，arguments对象。都可以使用<code>for...of</code>来循环遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 字符串</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> s <span class=\"hljs-keyword\">of</span> str) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s); <span class=\"hljs-comment\">// h e l l o</span><br>&#125;<br><br><span class=\"hljs-comment\">// DOM NodeList对象</span><br><span class=\"hljs-keyword\">let</span> paras = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&quot;p&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> paras) &#123;<br>  p.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&quot;test&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// arguments对象</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printArgs</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable language_\">arguments</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>  &#125;<br>&#125;<br><span class=\"hljs-title function_\">printArgs</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>);<br><span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对于普通对象，<code>for...of</code>不能直接使用，会报错；必须部署了iterator接口后才能使用。但是即便是这样：<code>for...of</code>依旧可以用来遍历键名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> es6 = &#123;<br>  <span class=\"hljs-attr\">edition</span>: <span class=\"hljs-number\">6</span>,<br>  <span class=\"hljs-attr\">committee</span>: <span class=\"hljs-string\">&quot;TC39&quot;</span>,<br>  <span class=\"hljs-attr\">standard</span>: <span class=\"hljs-string\">&quot;ECMA-262&quot;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> e <span class=\"hljs-keyword\">in</span> es6) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);<br>&#125;<br><span class=\"hljs-comment\">// edition</span><br><span class=\"hljs-comment\">// committee</span><br><span class=\"hljs-comment\">// standard</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> e <span class=\"hljs-keyword\">of</span> es6) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);<br>&#125;<br><span class=\"hljs-comment\">// TypeError: es6 is not iterable</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"for-in循环的缺点\"><a href=\"#for-in循环的缺点\" class=\"headerlink\" title=\"for...in循环的缺点\"></a><code>for...in</code>循环的缺点</h2><p><code>for...in</code>循环也是有缺点的：</p>\n<ul>\n<li>数组的键名是数字，但是<code>for...in</code>循环是字符串作为键名的；</li>\n<li>除了循环数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；</li>\n<li>某些情况下，<code>for...in</code>循环会以任何顺序遍历键名；</li>\n</ul>\n<h2 id=\"for-of循环的优点\"><a href=\"#for-of循环的优点\" class=\"headerlink\" title=\"for...of循环的优点\"></a><code>for...of</code>循环的优点</h2><ul>\n<li>有着和for…in循环一样简洁的语法，但是没有for…in那些缺点；</li>\n<li>不同于forEach方法，可以结合return, continue和break使用；</li>\n<li>提供了遍历所有数据结构的统一操作接口；</li>\n</ul>\n","site":{"data":{}},"wordcount":4395,"excerpt":"","more":"<h1 id=\"Iterator和for…of循环\"><a href=\"#Iterator和for…of循环\" class=\"headerlink\" title=\"Iterator和for…of循环\"></a>Iterator和for…of循环</h1><h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>遍历器是是一种机制：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。</p>\n<h3 id=\"数据结构的默认Iterator接口\"><a href=\"#数据结构的默认Iterator接口\" class=\"headerlink\" title=\"数据结构的默认Iterator接口\"></a>数据结构的默认Iterator接口</h3><p>目的在于为所有数据结构，提供一种统一的访问机制，即<code>for...of</code>循环。因此一种数据结构只要部署了Iterator接口，我们就可以成为该数据结构是可遍历的。</p>\n<p>ES6规定：默认的Iterator接口部署在数据结构的<code>Symbol.iterator</code>属性，也就是说：一个数据结构只要具有该属性，就可以认为是可遍历的。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] : <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<br>            <span class=\"hljs-attr\">next</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>                <span class=\"hljs-keyword\">return</span> &#123;<br>                    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>,<br>                    <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span><br>                &#125;;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// obj对象是可遍历的，因为具有Symbol.iterator属性。</span><br></code></pre></td></tr></table></figure>\n<p>一个对象如果想要在<code>for...of</code>循环上调用Iterator接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RangeIterator</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">start, stop</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = start;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span> = stop;<br>    &#125;<br><br>    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>; &#125;<br><br>    <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>;<br>        <span class=\"hljs-keyword\">if</span> (value &lt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span>) &#123;<br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> ++;<br>            <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">value</span>: value&#125;;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-params\">start ,stop</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeIterator</span>(start, stop);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> value <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"调用Iterator接口的场合\"><a href=\"#调用Iterator接口的场合\" class=\"headerlink\" title=\"调用Iterator接口的场合\"></a>调用Iterator接口的场合</h2><h3 id=\"（1）解构赋值\"><a href=\"#（1）解构赋值\" class=\"headerlink\" title=\"（1）解构赋值\"></a>（1）解构赋值</h3><p>对数组和Set结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>().<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br><br><span class=\"hljs-keyword\">let</span> [x, y] = set;<br><br><span class=\"hljs-keyword\">let</span> [first, ...rest] = set;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（2）扩展运算符\"><a href=\"#（2）扩展运算符\" class=\"headerlink\" title=\"（2）扩展运算符\"></a>（2）扩展运算符</h3><p>扩展运算符默认也会调用<code>Symbol.iterator</code>接口，前面章节已经有很多例子，这里就不再展示了。</p>\n<h3 id=\"（3）yield\"><a href=\"#（3）yield\" class=\"headerlink\" title=\"（3）yield*\"></a>（3）yield*</h3><p>yield* 后面跟的也是一个可遍历结构，它会调用该结构的遍历器接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> generator = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span>* [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> iterator = <span class=\"hljs-title function_\">generator</span>();<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）其他场合\"><a href=\"#（4）其他场合\" class=\"headerlink\" title=\"（4）其他场合\"></a>（4）其他场合</h3><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都是调用了遍历器接口的。</p>\n<h2 id=\"字符串的Iterator接口\"><a href=\"#字符串的Iterator接口\" class=\"headerlink\" title=\"字符串的Iterator接口\"></a>字符串的Iterator接口</h2><p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> someString = <span class=\"hljs-string\">&quot;hi&quot;</span>;<br><span class=\"hljs-keyword\">typeof</span> someString[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]<br><span class=\"hljs-comment\">// &quot;function&quot;</span><br><br><span class=\"hljs-keyword\">var</span> iterator = someString[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: &quot;h&quot;, done: false &#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: &quot;i&quot;, done: false &#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Iterator接口与Generator函数\"><a href=\"#Iterator接口与Generator函数\" class=\"headerlink\" title=\"Iterator接口与Generator函数\"></a>Iterator接口与Generator函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br><br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br><br><span class=\"hljs-comment\">// 或者采用下面的简洁写法</span><br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>  * [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;world&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> obj) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br><span class=\"hljs-comment\">// hello</span><br><span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"遍历器对象的return-，throw\"><a href=\"#遍历器对象的return-，throw\" class=\"headerlink\" title=\"遍历器对象的return()，throw()\"></a>遍历器对象的return()，throw()</h2><p>遍历器除了有<code>next</code>方法以外，还可以拥有<code>return</code>和<code>throw</code>方法。其中<code>next</code>方法是必须部署的，而<code>return</code>和<code>throw</code>却是可选的。</p>\n<p><code>return</code>方法的使用场景是：如果一个对象要在完成遍历前，需要清理或者释放资源，就需要部署。</p>\n<p><code>throw</code>方法主要结合Generator函数使用。这里不做过多解释。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">readLinesSync</span>(<span class=\"hljs-params\">file</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-keyword\">if</span> (file.<span class=\"hljs-title function_\">isAtEndOfFile</span>()) &#123;<br>        file.<span class=\"hljs-title function_\">close</span>();<br>        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>      &#125;<br>    &#125;,<br>    <span class=\"hljs-keyword\">return</span>() &#123;<br>      file.<span class=\"hljs-title function_\">close</span>();<br>      <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>    &#125;,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有iterator接口，就可以使用<code>for...of</code>循环遍历。也就是说<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组具备iterator接口，可以通过下面的代码证明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;gree&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> arr) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;;<br>obj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = arr[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>].<span class=\"hljs-title function_\">bind</span>(arr);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> obj) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Set和Map结构\"><a href=\"#Set和Map结构\" class=\"headerlink\" title=\"Set和Map结构\"></a>Set和Map结构</h3><p>Set和Map结构也原生具有Iterator接口，可以直接使用<code>for...of</code>循环。前面有例子演示过，不再赘述。</p>\n<h3 id=\"类似数组的对象\"><a href=\"#类似数组的对象\" class=\"headerlink\" title=\"类似数组的对象\"></a>类似数组的对象</h3><p>类似数组的对象，包括：DON NodeList对象，arguments对象。都可以使用<code>for...of</code>来循环遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 字符串</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> s <span class=\"hljs-keyword\">of</span> str) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s); <span class=\"hljs-comment\">// h e l l o</span><br>&#125;<br><br><span class=\"hljs-comment\">// DOM NodeList对象</span><br><span class=\"hljs-keyword\">let</span> paras = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&quot;p&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> paras) &#123;<br>  p.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&quot;test&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// arguments对象</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printArgs</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable language_\">arguments</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>  &#125;<br>&#125;<br><span class=\"hljs-title function_\">printArgs</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>);<br><span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对于普通对象，<code>for...of</code>不能直接使用，会报错；必须部署了iterator接口后才能使用。但是即便是这样：<code>for...of</code>依旧可以用来遍历键名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> es6 = &#123;<br>  <span class=\"hljs-attr\">edition</span>: <span class=\"hljs-number\">6</span>,<br>  <span class=\"hljs-attr\">committee</span>: <span class=\"hljs-string\">&quot;TC39&quot;</span>,<br>  <span class=\"hljs-attr\">standard</span>: <span class=\"hljs-string\">&quot;ECMA-262&quot;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> e <span class=\"hljs-keyword\">in</span> es6) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);<br>&#125;<br><span class=\"hljs-comment\">// edition</span><br><span class=\"hljs-comment\">// committee</span><br><span class=\"hljs-comment\">// standard</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> e <span class=\"hljs-keyword\">of</span> es6) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);<br>&#125;<br><span class=\"hljs-comment\">// TypeError: es6 is not iterable</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"for-in循环的缺点\"><a href=\"#for-in循环的缺点\" class=\"headerlink\" title=\"for...in循环的缺点\"></a><code>for...in</code>循环的缺点</h2><p><code>for...in</code>循环也是有缺点的：</p>\n<ul>\n<li>数组的键名是数字，但是<code>for...in</code>循环是字符串作为键名的；</li>\n<li>除了循环数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；</li>\n<li>某些情况下，<code>for...in</code>循环会以任何顺序遍历键名；</li>\n</ul>\n<h2 id=\"for-of循环的优点\"><a href=\"#for-of循环的优点\" class=\"headerlink\" title=\"for...of循环的优点\"></a><code>for...of</code>循环的优点</h2><ul>\n<li>有着和for…in循环一样简洁的语法，但是没有for…in那些缺点；</li>\n<li>不同于forEach方法，可以结合return, continue和break使用；</li>\n<li>提供了遍历所有数据结构的统一操作接口；</li>\n</ul>\n"},{"title":"ES6 let和const的区别","date":"2022-02-17T02:50:28.000Z","updated":"2022-02-17T02:50:28.000Z","_content":"\n# let和const命令\n\n## 基本用法\n\n跟`var`的用法类似，都是用于定义变量，但是与`var`不同的是：`let`声明的变量仅在定义的区域起作用。如果你在IDE中使用`let`关键字必须先声明再使用，否则会直接报错无法通过ESLint编译。\n\n```javascript\n{\n  let a = 123; // 变量a仅在这个代码区块有效\n  var b = 'hello';\n}\n\na // Undefined\nb // hello\n```\n\n## 这有什么好处？\n\n由于`let`声明的变量不会被覆盖，因此很适合在迭代器中做指针，看看下面这两段程序的结果会怎么样？\n\n使用`var`做循环指针：每次迭代过程中指针`i`的值都会被覆盖\n\n```javascript\nvar a = [];\n\nfor (var i = 0; i < 10; i++) {\n  a[i] = function() {\n    console.log(i);\n  };\n}\n\na[6](); // 10\n```\n\n使用`let`做循环指针：每次迭代过程中指针`i`的值都会指向当前值\n\n```javascript\nvar a = [];\n\nfor (let i = 0; i < 10; i++) {\n  a[i] = function() {\n    cosole.log(i);\n  };\n}\n\na[6](); // 6\n```\n\n## 暂时性死区（Temporary Dead Zone）\n\n只要块级作用域内存在`let`关键字，那么所声明的变量就与作用域牢牢地绑定在了一块。\n\n```javascript\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // 由于块区存在let绑定变量，因此这里报错显示变量未定义\n  let tmp;\n}\n```\n\n## 块级作用域\n\nES6中规定在块级作用域定义的变量只在所在块内才有效。块级可以嵌套。内层和外层可以定义同名的变量；\n\n```javascript\n{\n  let name = 'hello' // 因为处在不同的块，所以不会报错\n  {\n    let name = 'world' // 内层定义跟外层不冲突\n  }\n}\n```\n\n## DO表达式\n\n将块级作用域转换为表达式，这样就可以取到返回值，使用如下：如果不使用do表达式那么块内变量t在外层将无法取到；\n\n```javascript\nlet x = do {\n  let t = f();\n  t * t + 1;\n}\n```\n\n## 冻结对象\n\n使用`const`关键字定义的变量跟`let`一样需要先定义再使用。但是常量并不意味着变量不能修改。看看下面的程序。\n\n```javascript\nconst a = [];\n\na.push('Hello');\na // Hello\n\na.length = 0;\na // []\n\na = ['David'] // TypeError: Assignment to constant variable\n```\n\n如果需要冻结一个对象，可以使用`Object.freeze(obj)`，除了冻结对象，还需要冻结其属性。代码如下：\n\n```javascript\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach((key, value) => {\n    if (typeof obj[key] === 'object') {\n      constantize(obj[key]);\n    }\n  });\n};\n```\n","source":"_posts/javascript/es6-let-const.md","raw":"---\ntitle: ES6 let和const的区别\ndate: 2022-02-17 10:50:28\nupdated: 2022-02-17 10:50:28\ntags:\ncategories:\n---\n\n# let和const命令\n\n## 基本用法\n\n跟`var`的用法类似，都是用于定义变量，但是与`var`不同的是：`let`声明的变量仅在定义的区域起作用。如果你在IDE中使用`let`关键字必须先声明再使用，否则会直接报错无法通过ESLint编译。\n\n```javascript\n{\n  let a = 123; // 变量a仅在这个代码区块有效\n  var b = 'hello';\n}\n\na // Undefined\nb // hello\n```\n\n## 这有什么好处？\n\n由于`let`声明的变量不会被覆盖，因此很适合在迭代器中做指针，看看下面这两段程序的结果会怎么样？\n\n使用`var`做循环指针：每次迭代过程中指针`i`的值都会被覆盖\n\n```javascript\nvar a = [];\n\nfor (var i = 0; i < 10; i++) {\n  a[i] = function() {\n    console.log(i);\n  };\n}\n\na[6](); // 10\n```\n\n使用`let`做循环指针：每次迭代过程中指针`i`的值都会指向当前值\n\n```javascript\nvar a = [];\n\nfor (let i = 0; i < 10; i++) {\n  a[i] = function() {\n    cosole.log(i);\n  };\n}\n\na[6](); // 6\n```\n\n## 暂时性死区（Temporary Dead Zone）\n\n只要块级作用域内存在`let`关键字，那么所声明的变量就与作用域牢牢地绑定在了一块。\n\n```javascript\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // 由于块区存在let绑定变量，因此这里报错显示变量未定义\n  let tmp;\n}\n```\n\n## 块级作用域\n\nES6中规定在块级作用域定义的变量只在所在块内才有效。块级可以嵌套。内层和外层可以定义同名的变量；\n\n```javascript\n{\n  let name = 'hello' // 因为处在不同的块，所以不会报错\n  {\n    let name = 'world' // 内层定义跟外层不冲突\n  }\n}\n```\n\n## DO表达式\n\n将块级作用域转换为表达式，这样就可以取到返回值，使用如下：如果不使用do表达式那么块内变量t在外层将无法取到；\n\n```javascript\nlet x = do {\n  let t = f();\n  t * t + 1;\n}\n```\n\n## 冻结对象\n\n使用`const`关键字定义的变量跟`let`一样需要先定义再使用。但是常量并不意味着变量不能修改。看看下面的程序。\n\n```javascript\nconst a = [];\n\na.push('Hello');\na // Hello\n\na.length = 0;\na // []\n\na = ['David'] // TypeError: Assignment to constant variable\n```\n\n如果需要冻结一个对象，可以使用`Object.freeze(obj)`，除了冻结对象，还需要冻结其属性。代码如下：\n\n```javascript\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach((key, value) => {\n    if (typeof obj[key] === 'object') {\n      constantize(obj[key]);\n    }\n  });\n};\n```\n","slug":"javascript/es6-let-const","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vg001l4f6124191qlo","content":"<h1 id=\"let和const命令\"><a href=\"#let和const命令\" class=\"headerlink\" title=\"let和const命令\"></a>let和const命令</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>跟<code>var</code>的用法类似，都是用于定义变量，但是与<code>var</code>不同的是：<code>let</code>声明的变量仅在定义的区域起作用。如果你在IDE中使用<code>let</code>关键字必须先声明再使用，否则会直接报错无法通过ESLint编译。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 变量a仅在这个代码区块有效</span><br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>&#125;<br><br>a <span class=\"hljs-comment\">// Undefined</span><br>b <span class=\"hljs-comment\">// hello</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"这有什么好处？\"><a href=\"#这有什么好处？\" class=\"headerlink\" title=\"这有什么好处？\"></a>这有什么好处？</h2><p>由于<code>let</code>声明的变量不会被覆盖，因此很适合在迭代器中做指针，看看下面这两段程序的结果会怎么样？</p>\n<p>使用<code>var</code>做循环指针：每次迭代过程中指针<code>i</code>的值都会被覆盖</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  a[i] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>  &#125;;<br>&#125;<br><br>a[<span class=\"hljs-number\">6</span>](); <span class=\"hljs-comment\">// 10</span><br></code></pre></td></tr></table></figure>\n<p>使用<code>let</code>做循环指针：每次迭代过程中指针<code>i</code>的值都会指向当前值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  a[i] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    cosole.<span class=\"hljs-title function_\">log</span>(i);<br>  &#125;;<br>&#125;<br><br>a[<span class=\"hljs-number\">6</span>](); <span class=\"hljs-comment\">// 6</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"暂时性死区（Temporary-Dead-Zone）\"><a href=\"#暂时性死区（Temporary-Dead-Zone）\" class=\"headerlink\" title=\"暂时性死区（Temporary Dead Zone）\"></a>暂时性死区（Temporary Dead Zone）</h2><p>只要块级作用域内存在<code>let</code>关键字，那么所声明的变量就与作用域牢牢地绑定在了一块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> tmp = <span class=\"hljs-number\">123</span>;<br><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>  tmp = <span class=\"hljs-string\">&#x27;abc&#x27;</span>; <span class=\"hljs-comment\">// 由于块区存在let绑定变量，因此这里报错显示变量未定义</span><br>  <span class=\"hljs-keyword\">let</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>ES6中规定在块级作用域定义的变量只在所在块内才有效。块级可以嵌套。内层和外层可以定义同名的变量；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;hello&#x27;</span> <span class=\"hljs-comment\">// 因为处在不同的块，所以不会报错</span><br>  &#123;<br>    <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;world&#x27;</span> <span class=\"hljs-comment\">// 内层定义跟外层不冲突</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"DO表达式\"><a href=\"#DO表达式\" class=\"headerlink\" title=\"DO表达式\"></a>DO表达式</h2><p>将块级作用域转换为表达式，这样就可以取到返回值，使用如下：如果不使用do表达式那么块内变量t在外层将无法取到；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-keyword\">do</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-title function_\">f</span>();<br>  t * t + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"冻结对象\"><a href=\"#冻结对象\" class=\"headerlink\" title=\"冻结对象\"></a>冻结对象</h2><p>使用<code>const</code>关键字定义的变量跟<code>let</code>一样需要先定义再使用。但是常量并不意味着变量不能修改。看看下面的程序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> a = [];<br><br>a.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);<br>a <span class=\"hljs-comment\">// Hello</span><br><br>a.<span class=\"hljs-property\">length</span> = <span class=\"hljs-number\">0</span>;<br>a <span class=\"hljs-comment\">// []</span><br><br>a = [<span class=\"hljs-string\">&#x27;David&#x27;</span>] <span class=\"hljs-comment\">// TypeError: Assignment to constant variable</span><br></code></pre></td></tr></table></figure>\n<p>如果需要冻结一个对象，可以使用<code>Object.freeze(obj)</code>，除了冻结对象，还需要冻结其属性。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">constantize</span> = (<span class=\"hljs-params\">obj</span>) =&gt; &#123;<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">freeze</span>(obj);<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key, value</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj[key] === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      <span class=\"hljs-title function_\">constantize</span>(obj[key]);<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1371,"excerpt":"","more":"<h1 id=\"let和const命令\"><a href=\"#let和const命令\" class=\"headerlink\" title=\"let和const命令\"></a>let和const命令</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>跟<code>var</code>的用法类似，都是用于定义变量，但是与<code>var</code>不同的是：<code>let</code>声明的变量仅在定义的区域起作用。如果你在IDE中使用<code>let</code>关键字必须先声明再使用，否则会直接报错无法通过ESLint编译。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 变量a仅在这个代码区块有效</span><br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>&#125;<br><br>a <span class=\"hljs-comment\">// Undefined</span><br>b <span class=\"hljs-comment\">// hello</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"这有什么好处？\"><a href=\"#这有什么好处？\" class=\"headerlink\" title=\"这有什么好处？\"></a>这有什么好处？</h2><p>由于<code>let</code>声明的变量不会被覆盖，因此很适合在迭代器中做指针，看看下面这两段程序的结果会怎么样？</p>\n<p>使用<code>var</code>做循环指针：每次迭代过程中指针<code>i</code>的值都会被覆盖</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  a[i] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>  &#125;;<br>&#125;<br><br>a[<span class=\"hljs-number\">6</span>](); <span class=\"hljs-comment\">// 10</span><br></code></pre></td></tr></table></figure>\n<p>使用<code>let</code>做循环指针：每次迭代过程中指针<code>i</code>的值都会指向当前值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  a[i] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    cosole.<span class=\"hljs-title function_\">log</span>(i);<br>  &#125;;<br>&#125;<br><br>a[<span class=\"hljs-number\">6</span>](); <span class=\"hljs-comment\">// 6</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"暂时性死区（Temporary-Dead-Zone）\"><a href=\"#暂时性死区（Temporary-Dead-Zone）\" class=\"headerlink\" title=\"暂时性死区（Temporary Dead Zone）\"></a>暂时性死区（Temporary Dead Zone）</h2><p>只要块级作用域内存在<code>let</code>关键字，那么所声明的变量就与作用域牢牢地绑定在了一块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> tmp = <span class=\"hljs-number\">123</span>;<br><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>  tmp = <span class=\"hljs-string\">&#x27;abc&#x27;</span>; <span class=\"hljs-comment\">// 由于块区存在let绑定变量，因此这里报错显示变量未定义</span><br>  <span class=\"hljs-keyword\">let</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>ES6中规定在块级作用域定义的变量只在所在块内才有效。块级可以嵌套。内层和外层可以定义同名的变量；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;hello&#x27;</span> <span class=\"hljs-comment\">// 因为处在不同的块，所以不会报错</span><br>  &#123;<br>    <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;world&#x27;</span> <span class=\"hljs-comment\">// 内层定义跟外层不冲突</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"DO表达式\"><a href=\"#DO表达式\" class=\"headerlink\" title=\"DO表达式\"></a>DO表达式</h2><p>将块级作用域转换为表达式，这样就可以取到返回值，使用如下：如果不使用do表达式那么块内变量t在外层将无法取到；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-keyword\">do</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-title function_\">f</span>();<br>  t * t + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"冻结对象\"><a href=\"#冻结对象\" class=\"headerlink\" title=\"冻结对象\"></a>冻结对象</h2><p>使用<code>const</code>关键字定义的变量跟<code>let</code>一样需要先定义再使用。但是常量并不意味着变量不能修改。看看下面的程序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> a = [];<br><br>a.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);<br>a <span class=\"hljs-comment\">// Hello</span><br><br>a.<span class=\"hljs-property\">length</span> = <span class=\"hljs-number\">0</span>;<br>a <span class=\"hljs-comment\">// []</span><br><br>a = [<span class=\"hljs-string\">&#x27;David&#x27;</span>] <span class=\"hljs-comment\">// TypeError: Assignment to constant variable</span><br></code></pre></td></tr></table></figure>\n<p>如果需要冻结一个对象，可以使用<code>Object.freeze(obj)</code>，除了冻结对象，还需要冻结其属性。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">constantize</span> = (<span class=\"hljs-params\">obj</span>) =&gt; &#123;<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">freeze</span>(obj);<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key, value</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj[key] === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      <span class=\"hljs-title function_\">constantize</span>(obj[key]);<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 数值扩展","date":"2022-02-17T07:05:52.000Z","updated":"2022-02-17T07:05:52.000Z","_content":"\n# 数值扩展\n\n## 二进制和八进制数的表示方法\n\nES6提供了二进制和八进制数值的写法。二进制必须用`0b/0B`表示；八进制必须用`0o/0O`表示。示例如下：\n\n```javascript\n0B11111011 === 503 // true\n0o767 === 503 // true\n```\n\n如果要将二进制/八进制数转换为十进制，需要使用`Number`方法：\n\n```javascript\nNumber('0b111'); // 7\nNumber('0o10'); // 8\n```\n\n## 无穷数表示\n\nES6在原有Number的基础上新增了`Number.isFinite()`和`Number.isNaN()`两个方法。前者用于检查一个数值是否为有限数，后者检验一个数是否为`NaN`。例子如下：\n\n```javascript\nNumber.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\n\nNumber.isNan(NaN) // true\nNumber.isNan(15) // false\nNumber.isNan('15') // false\nNumber.isNan(9/NaN) // true\n```\n\n## `Number.parseInt()`和`Number.parseFloat()`\n\nES6将全局方法`parseInt()`和`parseFloat()`移植到Number对象上面，行为完全保持不变。\n\n```javascript\nNumber.parseInt('12.34'); // 12\nNumber.parseFloat('123.45#'); // 123.45\n```\n\n## `Number.isInteger()`和`Number.EPSILON`\n\n`Number.isInteger()`方法返回一个整型，因为JavaScript内部整数和浮点数使用的是同样的存储方法，因此3.0和3返回的都是整型3。\n\n除此之外，ES6还新增了一个极小的常量`Number.EPSILON`。引入这个量的目的是判断当前浮点数计算的结果是不是我们期望的。由于浮点数计算存在精度误差，因此如果这个误差能够小于`Number.EPSILON`，我们就认为得到了正确结果。例子如下：\n\n```javascript\nfunction withInErrorMargin(left, right) {\n    return Math.abs(left - right) < Number.EPSILON;\n}\n\nwithInErrorMargin(0.1 + 0.2, 0.3) // true\nwithInErrorMargin(0.1 + 0.2, 0.3) // false\n```\n\n## 安全整数和`Number.isSafeInteger()`\n\nJavaScript能够准确地表示的整数范围在 `-2^53` 至 `2^53` 之间（不包括两个端点），因此ES6中引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`两个常量，用来表示这个范围的上下限。\n\n```shell\n> Number.isSafeInteger(9007199254740993);\nfalse\n> Number.isSafeInteger(990);\ntrue\n> Number.isSafeInteger(9007199254740993 - 990);\ntrue\n>\n```\n\n所以在涉及大整型计算的过程中，需要同时校验运算数和运算结果是否为安全整型。例子如下：\n\n```javascript\nfunction trusty(left, right, result) {\n    if (Number.isSafeInteger(left) &&\n       Number.isSafeInteger(right) &&\n       Number.isSafeInteger(result)) {\n        return result;\n    }\n    throw new RangeError('Operation cannot be trusted!');\n}\n\ntrusty(9007199254740993, 990, 9007199254740993 - 990)\n// Operation cannot be trusted!\n\ntrusty(1, 2, 3);\n// 3\n```\n\n## Math对象的扩展\n\n### `Math.trunc()`\n\n该方法用于去除一个数的小数部分，返回整数部分；对于非数值，会先将其转换为数值，再进行比较：\n\n```javascript\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n```\n\n### `Math.sign()`\n\n该方法用来判断一个数到底为正数、负数还是零。\n\n```javascript\nMath.sign(-5); // -1\nMath.sign(5); // +1\nMath.sign(0); // +0\nMath.sign(-0); // -0\nMath.sign(NaN); // NaN\nMath.sign('foo'); // NaN\nMath.sign(); // NaN\n```\n\n### `Math.cbrt()`\n\n该方法用于计算一个数的立方根\n\n```javascript\nMath.cbrt(-1); // -1\nMath.cbrt(0); // 0\nMath.cbrt(1); // 1\nMath.cbrt(2); // 1.2599210498948732\n```\n\n### `Math.clz32()`\n\nJavaScript的整数使用32位二进制形式表示，`Math.clz32`方法返回一个数的32位无符号整数形式有多少个前导0。\n\n```shell\n> Math.clz32(0)\n32\n> Math.clz32(1)\n31\n>\n> Math.clz32(1000)\n22\n> Math.clz32(1000)  \n```\n\n### `Math.imul()`\n\n该方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号数。\n\n```javascript\nMath.imul(2, 4) // 8\nMath.imul(-1, 8) // -8\nMath.imul(-2, 2) // 4\n```\n\n### `Math.fround()`\n\n该方法返回一个数的单精度浮点数形式。对于整数来说该方法没有任何效果，但是对于无法使用64个二进制位精确表示的小数，该方法会返回最接近这个小数的单精度浮点数。\n\n```javascript\nMath.fround(0) // 0\nMath.fround(1) // 1\nMath.fround(1.337) // 1.3370000123977661\nMath.fround(1.5) // 1.5\nMath.fround(NaN) // NaN\n```\n\n### `Math.hypot()`\n\n该方法返回所有参数的平方和的平方根。例如注明的勾股定理（勾三股四弦五）\n\n```javascript\nMath.hypot(3, 4); // 5\nMath.hypot(a, b, c); // sqrt(3^2 + 4^2 + 5^2);\n```\n\n### 对数方法\n\nES6新增了4个对数方法\n\n- Math.expm1(x): 返回`e^x - 1`\n- Math.log1p(x): 返回`1 + x`的自然对数，如果`x`小于-1， 返回`NaN`；\n- Math.log10(): 返回以10为底的x的对数。如果`x`小于0，则返回`NaN`；\n- Math.log2()：返回以2为底的x的对数。如果`x`小于0，则返回`NaN`;\n\n### 三角函数方法\n\nES6新增了6个三角函数方法。\n\n- Math.sinh(x)：返回`x`的双曲正弦\n- Math.cosh(x)：返回`x`的双曲余弦\n- Math.tanh(x)：返回`x`的双曲正切\n- Math.asinh(x)：返回`x`的反双曲正弦\n- Math.acosh(x)：返回`x`的反双曲余弦\n- Math.atanh(x)：返回`x`的反双曲正切\n\n### 指数运算\n\nES7新增了一个指数运算符`**`，目前Babel转码已经支持。这里不再赘述。\n","source":"_posts/javascript/es6-num-expand.md","raw":"---\ntitle: ES6 数值扩展\ndate: 2022-02-17 15:05:52\nupdated: 2022-02-17 15:05:52\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 数值扩展\n\n## 二进制和八进制数的表示方法\n\nES6提供了二进制和八进制数值的写法。二进制必须用`0b/0B`表示；八进制必须用`0o/0O`表示。示例如下：\n\n```javascript\n0B11111011 === 503 // true\n0o767 === 503 // true\n```\n\n如果要将二进制/八进制数转换为十进制，需要使用`Number`方法：\n\n```javascript\nNumber('0b111'); // 7\nNumber('0o10'); // 8\n```\n\n## 无穷数表示\n\nES6在原有Number的基础上新增了`Number.isFinite()`和`Number.isNaN()`两个方法。前者用于检查一个数值是否为有限数，后者检验一个数是否为`NaN`。例子如下：\n\n```javascript\nNumber.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\n\nNumber.isNan(NaN) // true\nNumber.isNan(15) // false\nNumber.isNan('15') // false\nNumber.isNan(9/NaN) // true\n```\n\n## `Number.parseInt()`和`Number.parseFloat()`\n\nES6将全局方法`parseInt()`和`parseFloat()`移植到Number对象上面，行为完全保持不变。\n\n```javascript\nNumber.parseInt('12.34'); // 12\nNumber.parseFloat('123.45#'); // 123.45\n```\n\n## `Number.isInteger()`和`Number.EPSILON`\n\n`Number.isInteger()`方法返回一个整型，因为JavaScript内部整数和浮点数使用的是同样的存储方法，因此3.0和3返回的都是整型3。\n\n除此之外，ES6还新增了一个极小的常量`Number.EPSILON`。引入这个量的目的是判断当前浮点数计算的结果是不是我们期望的。由于浮点数计算存在精度误差，因此如果这个误差能够小于`Number.EPSILON`，我们就认为得到了正确结果。例子如下：\n\n```javascript\nfunction withInErrorMargin(left, right) {\n    return Math.abs(left - right) < Number.EPSILON;\n}\n\nwithInErrorMargin(0.1 + 0.2, 0.3) // true\nwithInErrorMargin(0.1 + 0.2, 0.3) // false\n```\n\n## 安全整数和`Number.isSafeInteger()`\n\nJavaScript能够准确地表示的整数范围在 `-2^53` 至 `2^53` 之间（不包括两个端点），因此ES6中引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`两个常量，用来表示这个范围的上下限。\n\n```shell\n> Number.isSafeInteger(9007199254740993);\nfalse\n> Number.isSafeInteger(990);\ntrue\n> Number.isSafeInteger(9007199254740993 - 990);\ntrue\n>\n```\n\n所以在涉及大整型计算的过程中，需要同时校验运算数和运算结果是否为安全整型。例子如下：\n\n```javascript\nfunction trusty(left, right, result) {\n    if (Number.isSafeInteger(left) &&\n       Number.isSafeInteger(right) &&\n       Number.isSafeInteger(result)) {\n        return result;\n    }\n    throw new RangeError('Operation cannot be trusted!');\n}\n\ntrusty(9007199254740993, 990, 9007199254740993 - 990)\n// Operation cannot be trusted!\n\ntrusty(1, 2, 3);\n// 3\n```\n\n## Math对象的扩展\n\n### `Math.trunc()`\n\n该方法用于去除一个数的小数部分，返回整数部分；对于非数值，会先将其转换为数值，再进行比较：\n\n```javascript\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n```\n\n### `Math.sign()`\n\n该方法用来判断一个数到底为正数、负数还是零。\n\n```javascript\nMath.sign(-5); // -1\nMath.sign(5); // +1\nMath.sign(0); // +0\nMath.sign(-0); // -0\nMath.sign(NaN); // NaN\nMath.sign('foo'); // NaN\nMath.sign(); // NaN\n```\n\n### `Math.cbrt()`\n\n该方法用于计算一个数的立方根\n\n```javascript\nMath.cbrt(-1); // -1\nMath.cbrt(0); // 0\nMath.cbrt(1); // 1\nMath.cbrt(2); // 1.2599210498948732\n```\n\n### `Math.clz32()`\n\nJavaScript的整数使用32位二进制形式表示，`Math.clz32`方法返回一个数的32位无符号整数形式有多少个前导0。\n\n```shell\n> Math.clz32(0)\n32\n> Math.clz32(1)\n31\n>\n> Math.clz32(1000)\n22\n> Math.clz32(1000)  \n```\n\n### `Math.imul()`\n\n该方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号数。\n\n```javascript\nMath.imul(2, 4) // 8\nMath.imul(-1, 8) // -8\nMath.imul(-2, 2) // 4\n```\n\n### `Math.fround()`\n\n该方法返回一个数的单精度浮点数形式。对于整数来说该方法没有任何效果，但是对于无法使用64个二进制位精确表示的小数，该方法会返回最接近这个小数的单精度浮点数。\n\n```javascript\nMath.fround(0) // 0\nMath.fround(1) // 1\nMath.fround(1.337) // 1.3370000123977661\nMath.fround(1.5) // 1.5\nMath.fround(NaN) // NaN\n```\n\n### `Math.hypot()`\n\n该方法返回所有参数的平方和的平方根。例如注明的勾股定理（勾三股四弦五）\n\n```javascript\nMath.hypot(3, 4); // 5\nMath.hypot(a, b, c); // sqrt(3^2 + 4^2 + 5^2);\n```\n\n### 对数方法\n\nES6新增了4个对数方法\n\n- Math.expm1(x): 返回`e^x - 1`\n- Math.log1p(x): 返回`1 + x`的自然对数，如果`x`小于-1， 返回`NaN`；\n- Math.log10(): 返回以10为底的x的对数。如果`x`小于0，则返回`NaN`；\n- Math.log2()：返回以2为底的x的对数。如果`x`小于0，则返回`NaN`;\n\n### 三角函数方法\n\nES6新增了6个三角函数方法。\n\n- Math.sinh(x)：返回`x`的双曲正弦\n- Math.cosh(x)：返回`x`的双曲余弦\n- Math.tanh(x)：返回`x`的双曲正切\n- Math.asinh(x)：返回`x`的反双曲正弦\n- Math.acosh(x)：返回`x`的反双曲余弦\n- Math.atanh(x)：返回`x`的反双曲正切\n\n### 指数运算\n\nES7新增了一个指数运算符`**`，目前Babel转码已经支持。这里不再赘述。\n","slug":"javascript/es6-num-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vg001o4f615jk350ts","content":"<h1 id=\"数值扩展\"><a href=\"#数值扩展\" class=\"headerlink\" title=\"数值扩展\"></a>数值扩展</h1><h2 id=\"二进制和八进制数的表示方法\"><a href=\"#二进制和八进制数的表示方法\" class=\"headerlink\" title=\"二进制和八进制数的表示方法\"></a>二进制和八进制数的表示方法</h2><p>ES6提供了二进制和八进制数值的写法。二进制必须用<code>0b/0B</code>表示；八进制必须用<code>0o/0O</code>表示。示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">0B11111011</span> === <span class=\"hljs-number\">503</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-number\">0o767</span> === <span class=\"hljs-number\">503</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>如果要将二进制/八进制数转换为十进制，需要使用<code>Number</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&#x27;0b111&#x27;</span>); <span class=\"hljs-comment\">// 7</span><br><span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&#x27;0o10&#x27;</span>); <span class=\"hljs-comment\">// 8</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"无穷数表示\"><a href=\"#无穷数表示\" class=\"headerlink\" title=\"无穷数表示\"></a>无穷数表示</h2><p>ES6在原有Number的基础上新增了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。前者用于检查一个数值是否为有限数，后者检验一个数是否为<code>NaN</code>。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-number\">15</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-number\">0.8</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(-<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-number\">15</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-string\">&#x27;15&#x27;</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-number\">9</span>/<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Number-parseInt-和Number-parseFloat\"><a href=\"#Number-parseInt-和Number-parseFloat\" class=\"headerlink\" title=\"Number.parseInt()和Number.parseFloat()\"></a><code>Number.parseInt()</code>和<code>Number.parseFloat()</code></h2><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>移植到Number对象上面，行为完全保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;12.34&#x27;</span>); <span class=\"hljs-comment\">// 12</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">parseFloat</span>(<span class=\"hljs-string\">&#x27;123.45#&#x27;</span>); <span class=\"hljs-comment\">// 123.45</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Number-isInteger-和Number-EPSILON\"><a href=\"#Number-isInteger-和Number-EPSILON\" class=\"headerlink\" title=\"Number.isInteger()和Number.EPSILON\"></a><code>Number.isInteger()</code>和<code>Number.EPSILON</code></h2><p><code>Number.isInteger()</code>方法返回一个整型，因为JavaScript内部整数和浮点数使用的是同样的存储方法，因此3.0和3返回的都是整型3。</p>\n<p>除此之外，ES6还新增了一个极小的常量<code>Number.EPSILON</code>。引入这个量的目的是判断当前浮点数计算的结果是不是我们期望的。由于浮点数计算存在精度误差，因此如果这个误差能够小于<code>Number.EPSILON</code>，我们就认为得到了正确结果。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-params\">left, right</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">abs</span>(left - right) &lt; <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-property\">EPSILON</span>;<br>&#125;<br><br><span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-number\">0.1</span> + <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-number\">0.1</span> + <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"安全整数和Number-isSafeInteger\"><a href=\"#安全整数和Number-isSafeInteger\" class=\"headerlink\" title=\"安全整数和Number.isSafeInteger()\"></a>安全整数和<code>Number.isSafeInteger()</code></h2><p>JavaScript能够准确地表示的整数范围在 <code>-2^53</code> 至 <code>2^53</code> 之间（不包括两个端点），因此ES6中引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>两个常量，用来表示这个范围的上下限。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(9007199254740993);</span><br>false<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(990);</span><br>true<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(9007199254740993 - 990);</span><br>true<br><span class=\"hljs-meta\">&gt;</span><br></code></pre></td></tr></table></figure>\n<p>所以在涉及大整型计算的过程中，需要同时校验运算数和运算结果是否为安全整型。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-params\">left, right, result</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(left) &amp;&amp;<br>       <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(right) &amp;&amp;<br>       <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(result)) &#123;<br>        <span class=\"hljs-keyword\">return</span> result;<br>    &#125;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeError</span>(<span class=\"hljs-string\">&#x27;Operation cannot be trusted!&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-number\">9007199254740993</span>, <span class=\"hljs-number\">990</span>, <span class=\"hljs-number\">9007199254740993</span> - <span class=\"hljs-number\">990</span>)<br><span class=\"hljs-comment\">// Operation cannot be trusted!</span><br><br><span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Math对象的扩展\"><a href=\"#Math对象的扩展\" class=\"headerlink\" title=\"Math对象的扩展\"></a>Math对象的扩展</h2><h3 id=\"Math-trunc\"><a href=\"#Math-trunc\" class=\"headerlink\" title=\"Math.trunc()\"></a><code>Math.trunc()</code></h3><p>该方法用于去除一个数的小数部分，返回整数部分；对于非数值，会先将其转换为数值，再进行比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(<span class=\"hljs-number\">4.1</span>) <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(<span class=\"hljs-number\">4.9</span>) <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">4.1</span>) <span class=\"hljs-comment\">// -4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">4.9</span>) <span class=\"hljs-comment\">// -4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">0.1234</span>) <span class=\"hljs-comment\">// -0</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-sign\"><a href=\"#Math-sign\" class=\"headerlink\" title=\"Math.sign()\"></a><code>Math.sign()</code></h3><p>该方法用来判断一个数到底为正数、负数还是零。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(-<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// +1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// +0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(-<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// NaN</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>); <span class=\"hljs-comment\">// NaN</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(); <span class=\"hljs-comment\">// NaN</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-cbrt\"><a href=\"#Math-cbrt\" class=\"headerlink\" title=\"Math.cbrt()\"></a><code>Math.cbrt()</code></h3><p>该方法用于计算一个数的立方根</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 1.2599210498948732</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-clz32\"><a href=\"#Math-clz32\" class=\"headerlink\" title=\"Math.clz32()\"></a><code>Math.clz32()</code></h3><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式有多少个前导0。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(0)</span><br>32<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(1)</span><br>31<br><span class=\"hljs-meta\">&gt;</span><span class=\"language-bash\"></span><br><span class=\"language-bash\">&gt; Math.clz32(1000)</span><br>22<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(1000)</span>  <br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-imul\"><a href=\"#Math-imul\" class=\"headerlink\" title=\"Math.imul()\"></a><code>Math.imul()</code></h3><p>该方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 8</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>) <span class=\"hljs-comment\">// -8</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(-<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 4</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-fround\"><a href=\"#Math-fround\" class=\"headerlink\" title=\"Math.fround()\"></a><code>Math.fround()</code></h3><p>该方法返回一个数的单精度浮点数形式。对于整数来说该方法没有任何效果，但是对于无法使用64个二进制位精确表示的小数，该方法会返回最接近这个小数的单精度浮点数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1.337</span>) <span class=\"hljs-comment\">// 1.3370000123977661</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1.5</span>) <span class=\"hljs-comment\">// 1.5</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// NaN</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-hypot\"><a href=\"#Math-hypot\" class=\"headerlink\" title=\"Math.hypot()\"></a><code>Math.hypot()</code></h3><p>该方法返回所有参数的平方和的平方根。例如注明的勾股定理（勾三股四弦五）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">hypot</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 5</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">hypot</span>(a, b, c); <span class=\"hljs-comment\">// sqrt(3^2 + 4^2 + 5^2);</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"对数方法\"><a href=\"#对数方法\" class=\"headerlink\" title=\"对数方法\"></a>对数方法</h3><p>ES6新增了4个对数方法</p>\n<ul>\n<li>Math.expm1(x): 返回<code>e^x - 1</code></li>\n<li>Math.log1p(x): 返回<code>1 + x</code>的自然对数，如果<code>x</code>小于-1， 返回<code>NaN</code>；</li>\n<li>Math.log10(): 返回以10为底的x的对数。如果<code>x</code>小于0，则返回<code>NaN</code>；</li>\n<li>Math.log2()：返回以2为底的x的对数。如果<code>x</code>小于0，则返回<code>NaN</code>;</li>\n</ul>\n<h3 id=\"三角函数方法\"><a href=\"#三角函数方法\" class=\"headerlink\" title=\"三角函数方法\"></a>三角函数方法</h3><p>ES6新增了6个三角函数方法。</p>\n<ul>\n<li>Math.sinh(x)：返回<code>x</code>的双曲正弦</li>\n<li>Math.cosh(x)：返回<code>x</code>的双曲余弦</li>\n<li>Math.tanh(x)：返回<code>x</code>的双曲正切</li>\n<li>Math.asinh(x)：返回<code>x</code>的反双曲正弦</li>\n<li>Math.acosh(x)：返回<code>x</code>的反双曲余弦</li>\n<li>Math.atanh(x)：返回<code>x</code>的反双曲正切</li>\n</ul>\n<h3 id=\"指数运算\"><a href=\"#指数运算\" class=\"headerlink\" title=\"指数运算\"></a>指数运算</h3><p>ES7新增了一个指数运算符<code>**</code>，目前Babel转码已经支持。这里不再赘述。</p>\n","site":{"data":{}},"wordcount":3223,"excerpt":"","more":"<h1 id=\"数值扩展\"><a href=\"#数值扩展\" class=\"headerlink\" title=\"数值扩展\"></a>数值扩展</h1><h2 id=\"二进制和八进制数的表示方法\"><a href=\"#二进制和八进制数的表示方法\" class=\"headerlink\" title=\"二进制和八进制数的表示方法\"></a>二进制和八进制数的表示方法</h2><p>ES6提供了二进制和八进制数值的写法。二进制必须用<code>0b/0B</code>表示；八进制必须用<code>0o/0O</code>表示。示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">0B11111011</span> === <span class=\"hljs-number\">503</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-number\">0o767</span> === <span class=\"hljs-number\">503</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>如果要将二进制/八进制数转换为十进制，需要使用<code>Number</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&#x27;0b111&#x27;</span>); <span class=\"hljs-comment\">// 7</span><br><span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&#x27;0o10&#x27;</span>); <span class=\"hljs-comment\">// 8</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"无穷数表示\"><a href=\"#无穷数表示\" class=\"headerlink\" title=\"无穷数表示\"></a>无穷数表示</h2><p>ES6在原有Number的基础上新增了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。前者用于检查一个数值是否为有限数，后者检验一个数是否为<code>NaN</code>。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-number\">15</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-number\">0.8</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(-<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-number\">15</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-string\">&#x27;15&#x27;</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-number\">9</span>/<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Number-parseInt-和Number-parseFloat\"><a href=\"#Number-parseInt-和Number-parseFloat\" class=\"headerlink\" title=\"Number.parseInt()和Number.parseFloat()\"></a><code>Number.parseInt()</code>和<code>Number.parseFloat()</code></h2><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>移植到Number对象上面，行为完全保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;12.34&#x27;</span>); <span class=\"hljs-comment\">// 12</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">parseFloat</span>(<span class=\"hljs-string\">&#x27;123.45#&#x27;</span>); <span class=\"hljs-comment\">// 123.45</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Number-isInteger-和Number-EPSILON\"><a href=\"#Number-isInteger-和Number-EPSILON\" class=\"headerlink\" title=\"Number.isInteger()和Number.EPSILON\"></a><code>Number.isInteger()</code>和<code>Number.EPSILON</code></h2><p><code>Number.isInteger()</code>方法返回一个整型，因为JavaScript内部整数和浮点数使用的是同样的存储方法，因此3.0和3返回的都是整型3。</p>\n<p>除此之外，ES6还新增了一个极小的常量<code>Number.EPSILON</code>。引入这个量的目的是判断当前浮点数计算的结果是不是我们期望的。由于浮点数计算存在精度误差，因此如果这个误差能够小于<code>Number.EPSILON</code>，我们就认为得到了正确结果。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-params\">left, right</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">abs</span>(left - right) &lt; <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-property\">EPSILON</span>;<br>&#125;<br><br><span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-number\">0.1</span> + <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-number\">0.1</span> + <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"安全整数和Number-isSafeInteger\"><a href=\"#安全整数和Number-isSafeInteger\" class=\"headerlink\" title=\"安全整数和Number.isSafeInteger()\"></a>安全整数和<code>Number.isSafeInteger()</code></h2><p>JavaScript能够准确地表示的整数范围在 <code>-2^53</code> 至 <code>2^53</code> 之间（不包括两个端点），因此ES6中引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>两个常量，用来表示这个范围的上下限。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(9007199254740993);</span><br>false<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(990);</span><br>true<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(9007199254740993 - 990);</span><br>true<br><span class=\"hljs-meta\">&gt;</span><br></code></pre></td></tr></table></figure>\n<p>所以在涉及大整型计算的过程中，需要同时校验运算数和运算结果是否为安全整型。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-params\">left, right, result</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(left) &amp;&amp;<br>       <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(right) &amp;&amp;<br>       <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(result)) &#123;<br>        <span class=\"hljs-keyword\">return</span> result;<br>    &#125;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeError</span>(<span class=\"hljs-string\">&#x27;Operation cannot be trusted!&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-number\">9007199254740993</span>, <span class=\"hljs-number\">990</span>, <span class=\"hljs-number\">9007199254740993</span> - <span class=\"hljs-number\">990</span>)<br><span class=\"hljs-comment\">// Operation cannot be trusted!</span><br><br><span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Math对象的扩展\"><a href=\"#Math对象的扩展\" class=\"headerlink\" title=\"Math对象的扩展\"></a>Math对象的扩展</h2><h3 id=\"Math-trunc\"><a href=\"#Math-trunc\" class=\"headerlink\" title=\"Math.trunc()\"></a><code>Math.trunc()</code></h3><p>该方法用于去除一个数的小数部分，返回整数部分；对于非数值，会先将其转换为数值，再进行比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(<span class=\"hljs-number\">4.1</span>) <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(<span class=\"hljs-number\">4.9</span>) <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">4.1</span>) <span class=\"hljs-comment\">// -4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">4.9</span>) <span class=\"hljs-comment\">// -4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">0.1234</span>) <span class=\"hljs-comment\">// -0</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-sign\"><a href=\"#Math-sign\" class=\"headerlink\" title=\"Math.sign()\"></a><code>Math.sign()</code></h3><p>该方法用来判断一个数到底为正数、负数还是零。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(-<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// +1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// +0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(-<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// NaN</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>); <span class=\"hljs-comment\">// NaN</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(); <span class=\"hljs-comment\">// NaN</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-cbrt\"><a href=\"#Math-cbrt\" class=\"headerlink\" title=\"Math.cbrt()\"></a><code>Math.cbrt()</code></h3><p>该方法用于计算一个数的立方根</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 1.2599210498948732</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-clz32\"><a href=\"#Math-clz32\" class=\"headerlink\" title=\"Math.clz32()\"></a><code>Math.clz32()</code></h3><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式有多少个前导0。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(0)</span><br>32<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(1)</span><br>31<br><span class=\"hljs-meta\">&gt;</span><span class=\"language-bash\"></span><br><span class=\"language-bash\">&gt; Math.clz32(1000)</span><br>22<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(1000)</span>  <br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-imul\"><a href=\"#Math-imul\" class=\"headerlink\" title=\"Math.imul()\"></a><code>Math.imul()</code></h3><p>该方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 8</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>) <span class=\"hljs-comment\">// -8</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(-<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 4</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-fround\"><a href=\"#Math-fround\" class=\"headerlink\" title=\"Math.fround()\"></a><code>Math.fround()</code></h3><p>该方法返回一个数的单精度浮点数形式。对于整数来说该方法没有任何效果，但是对于无法使用64个二进制位精确表示的小数，该方法会返回最接近这个小数的单精度浮点数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1.337</span>) <span class=\"hljs-comment\">// 1.3370000123977661</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1.5</span>) <span class=\"hljs-comment\">// 1.5</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// NaN</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-hypot\"><a href=\"#Math-hypot\" class=\"headerlink\" title=\"Math.hypot()\"></a><code>Math.hypot()</code></h3><p>该方法返回所有参数的平方和的平方根。例如注明的勾股定理（勾三股四弦五）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">hypot</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 5</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">hypot</span>(a, b, c); <span class=\"hljs-comment\">// sqrt(3^2 + 4^2 + 5^2);</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"对数方法\"><a href=\"#对数方法\" class=\"headerlink\" title=\"对数方法\"></a>对数方法</h3><p>ES6新增了4个对数方法</p>\n<ul>\n<li>Math.expm1(x): 返回<code>e^x - 1</code></li>\n<li>Math.log1p(x): 返回<code>1 + x</code>的自然对数，如果<code>x</code>小于-1， 返回<code>NaN</code>；</li>\n<li>Math.log10(): 返回以10为底的x的对数。如果<code>x</code>小于0，则返回<code>NaN</code>；</li>\n<li>Math.log2()：返回以2为底的x的对数。如果<code>x</code>小于0，则返回<code>NaN</code>;</li>\n</ul>\n<h3 id=\"三角函数方法\"><a href=\"#三角函数方法\" class=\"headerlink\" title=\"三角函数方法\"></a>三角函数方法</h3><p>ES6新增了6个三角函数方法。</p>\n<ul>\n<li>Math.sinh(x)：返回<code>x</code>的双曲正弦</li>\n<li>Math.cosh(x)：返回<code>x</code>的双曲余弦</li>\n<li>Math.tanh(x)：返回<code>x</code>的双曲正切</li>\n<li>Math.asinh(x)：返回<code>x</code>的反双曲正弦</li>\n<li>Math.acosh(x)：返回<code>x</code>的反双曲余弦</li>\n<li>Math.atanh(x)：返回<code>x</code>的反双曲正切</li>\n</ul>\n<h3 id=\"指数运算\"><a href=\"#指数运算\" class=\"headerlink\" title=\"指数运算\"></a>指数运算</h3><p>ES7新增了一个指数运算符<code>**</code>，目前Babel转码已经支持。这里不再赘述。</p>\n"},{"title":"ES6 对象扩展","date":"2022-02-17T07:08:22.000Z","updated":"2022-02-17T07:08:22.000Z","_content":"\n# 对象扩展\n\n## 属性的简洁表示法\n\nES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更加简洁。\n\n```javascript\nvar foo = 'bar';\nvar baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nvar baz = {foo: foo};\n```\n\n除了属性可以简写，方法也可以简写\n\n```javascript\nvar o = {\n    method() {\n        return \"Hello\";\n    }\n};\n\n// 等同于\n\nvar o = {\n    method: function() {\n        return \"Hello\";\n    }\n};\n```\n\n适用于函数返回值，写起来会非常简洁和方便\n\n```javascript\nfunction getPoint() {\n    var x = 1;\n    var y = 10;\n    return {x, y};\n}\n\ngetPoint() // {x: 1, y: 10}\n```\n\n在使用Common JS中，输出的代码非常适合使用这种简洁写法\n\n```javascript\nvar ms = {};\n\nfunction getItem(key) {\n    return key in ms ? ms[key] : null;\n}\n\nfunction setItem(key, value) {\n    ms[key] = value;\n}\n\nfunction clear() {\n    ms = {};\n}\n\nmodule.exports = { getItem, setItem, clear }\n// 等同于\nmodule.exports = {\n    getItem: getItem,\n    setItem: setItem,\n    clear: clear\n}\n```\n\n## 属性名表达式\n\nJavaScript语言定义对象的属性，有如下种方法。\n\n```javascript\nobj.foo = true; // 直接使用标识符作为属性名\n\nobj['a' + 'bc'] = 123; // 使用表达式作为属性名\n```\n\nES6允许字面量定义对象时，用方法二作为对象的属性名，即将表达式放在括号内\n\n```javascript\nlet propKey = 'foo';\n\nlet obj = {\n    [propKey]: true,\n    ['a' + 'bc']: 123\n}\n```\n\n这里再举一个例子：\n\n```javascript\nvar lastWord = 'last word';\n\nvar a = {\n    'first word': 'hello',\n    [lastWord]: 'world'\n};\n\na['first Word'] // hello\na[lastWord] // World\na['last word'] // World\n```\n\n注意：属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串。因此属性名表达式和简洁表示法不可以同时使用。一定要注意。\n\n## 方法的`name`属性\n\n函数的`name`属性返回函数名。对象方法也是函数，因此也有`name`属性。\n\n```javascript\nvar person = {\n    sayName() {\n        console.log(this.name);\n    },\n    // get为取值函数，存值用set\n    get firstName() {\n        return \"Nicholas\";\n    }\n};\n\nperson.sayName.name // sayName\nperson.firstName.name // get firstName\n```\n\n有两个特例：如果是`bind`函数，函数名返回`bound` + 函数名称；如果是`function`关键字构造的函数（匿名函数），`name`属性值返回`anonymous`。\n\n## `Object.is()`\n\n该方法用来比较两个值是否严格相等，与严格比较运算符`===`的作用一致。不同之处有两个：+0不等于-0；另一个是NaN等于自身。\n\n```javascript\n+0 === -0 // true\nNaN === NaN // false\n\nObject.is(+0, -0); // false\nObject.is(NaN, NaN) // true\n```\n\n## `Object.assign()`\n\n### 基本用法\n\n用于将对象合并，将源对象的所有可枚举属性赋值到目标对象。如果目标对象与源对象由同名属性，或多个源对象由同名属性，则后面的属性会覆盖前面的属性。\n\n```javascript\nvar target = { a: 1 };\n\nvar source1 = { b: 2 };\nvar source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // { a: 1, b: 2, c: 3 }\n```\n\n如果只有一个参数，会直接返回该参数；如果该参数不是对象，会先转换为对象，然后返回。由于`undefined`和`null`无法转换为对象，所以将它们作为参数传入会报错。\n\n```javascript\nvar obj = { a: 1};\nObject.assign(obj) === obj // true\n\ntypeof Object.assign(2) // object\n\nObject.assign(undefined) // error\nObject.assign(null) // error\n```\n\n如果`undefined`和`null`出现在非首参数，首先会尝试着转换为对象，如果转换失败会直接跳过。这意味着只要首参数可以转换为对象，就不会报错。\n\n```javascript\nlet obj = { a: 1};\n\nObject.assign(a, undefined) === obj // true\nObject.assign(a, null) === obj // true\n```\n\n其他类型的值中，只有字符串会以数组的形式拷贝至对象中，其他值都不会产生效果；\n\n```javascript\nvar v1 = 'abc';\nvar v2 = true;\nvar v3 = 10;\n\nvar obj = Object.assign({}, v1, v2, v3);\nconsole.log(obj); // {'0': 'a', '1': 'b', '2': 'c'}\n```\n\n`Object.assign()`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）。\n\n```javascript\nObject.assign({b: 'c'}, Object.defineProperty({}, 'invisible', {\n    \tenumerable: false,\n    \tvalue: 'hello'\n\t})\n)\n// {b: 'c'}\n```\n\n值得注意的是：`Object.assign()`执行的是浅拷贝，而不是深拷贝。如果源对象某个属性的值是对象，那么目标对象拷贝得到的仅仅是这个对象的引用。\n\n```javascript\nvar obj1 = {a: {b: 1}};\nvar obj2 = Object.assign({}, obj1);\n\nobj1.a.b = 2;\nobj2.a.b // 2\n```\n\n### Object.assign()方法有哪些用途呢？\n\n#### 为对象添加属性\n\n```javascript\nclass Point {\n    constructor(x, y) {\n        Object.assign(this, {x, y})\n    }\n}\n```\n\n#### 为对象添加方法\n\n```javascript\nObject.assign(SomeClass.prototype, {\n    someMethod(arg1, arg2) {\n        ...\n    },\n    anotherMethod() {\n        ...\n    }\n});\n        \n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) { ... };\nSomeClass.prototype.anotherMethod = function () { ... };\n```\n\n#### 克隆对象\n\n```javascript\n// 将原始对象拷贝到空对象中\nfunction clone (origin) {\n    return Object.assign({}, origin);\n}\n\n// 将原始对象和其继承的值拷贝到新对象中\nfunction clone (origin) {\n    let originProto = Object.getPrototypeOf(origin);\n    return Object.assign(Object.create(originProto), origin);\n}\n```\n\n#### 合并多个对象\n\n```javascript\n// 将多个对象合并到某个对象\nconst merge = (target, ...source) => Object.assign(target, ...source);\n\n// 合并后返回一个新对象\nconst merge = (...source) => Object.assign({}, ...source);\n```\n\n#### 为属性指定默认值\n\n```javascript\nconst DEFAULTS = {\n    logLevel: 0,\n    outputFormat: 'html'\n};\n\nfunction processContent(options) {\n    options = Object.assign({}, DEFAULTS, options)\n}\n```\n\n## 属性的可枚举性\n\n`Object.getOwnPropertyDescriptor(obj, 'foo')`方法可以获取该属性的描述对象，其中描述对象有一个`enumerable`属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。\n\nES6中有下面4个操作会忽略`enumerable`为false的属性。\n\n- `for ... in` 循环：只遍历对象自身的和继承的可枚举属性；\n- `Object.keys()`：返回对象自身的所有可枚举的属性键名；\n- `JSON.stringify()`：只串行化对象自身的可枚举属性；\n- `Object.assign()`：只拷贝对象自身的可枚举属性；\n\n上面4个操作中，只有`for ... in`会返回继承的属性。实际上引入`enumerable`的最初目的，就是让某些可以规避掉`for...in`的操作。\n\n```javascript\nObject.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable // false\n\nObject.getOwnPropertyDescriptor([], 'length').enumerable // false\n```\n\n另外ES6规定，所有Class的原型方法都是不可枚举的：\n\n```javascript\nObject.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable\n```\n\n## 属性的遍历\n\nES6中一共有5种方法可以遍历对象的属性\n\n#### （1）for...in\n\n遍历对象自身和继承的可枚举属性\n\n#### （2）Object.keys(obj)\n\n返回一个数组，包括对象自身的（不含继承）所有可枚举属性（不包括Symbol属性）\n\n#### （3）Object.getOwnPropertyNames(obj)\n\n返回一个数组，包含对象自身的所有属性（不包括Symbol属性）\n\n#### （4）Object.getOwnPropertySymbols(obj)\n\n返回一个数组，包含对象自身的所有Symbol属性\n\n#### （5）Reflect.ownKeys(obj)\n\n返回一个数组，包含对象自身的所有属性，不管是属性名还是Symbol还是字符串，也不管是否可枚举。\n\n上面5种方法遍历对象属性，都遵循同样的属性遍历的次序规则。\n\n- 首先遍历所有属性名为数值的字符的属性，按照数字排序；\n- 其次遍历所有属性名为字符串的属性，按照生成时间排序；\n- 最后遍历所有属性名为Symbol值得属性，按照生成时间排序；\n\n一句话概括：遍历规则为数值 > 字符串 > Symbol；数值排序规则为数字，剩下两个排序规则为生成顺序；\n\n## `__proto__`属性，`Objects.setPrototypeOf()`, `Object.getPrototypeOf()`\n\n#### `__proto__`属性\n\n用来读取或设置当前对象的`prototype`对象。目前所有浏览器都支持这个特性。\n\n```javascript\nvar obj = {\n    method: function () {...}\n};\nobj.__proto__ = someOtherObj;\n\nvar obj = Object.create(someOtherObj);\nobj.method = function () {...};\n```\n\n这里和Python一样，使用双下划线标注的属性内部属性，而不是一个正式对外的API。因此在正式使用时不建议显示的设置。而是用`Object.setPrototypeOf()`、`Object.getPrototypeOf()`、`Object.create()`代替。\n\n#### `Object.setPrototypeOf()`\n\n用来设置对象的`prototype`对象。是ES6推荐的设置原型对象的方法。\n\n```javascript\nlet proto = {};\nlet obj = { x: 10};\nObject.setPrototypeOf(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nconsole.log(obj.x) // 10\nconsole.log(obj.y) // 20\nconsole.log(obj.z) // 40\n```\n\n#### `Object.getPrototypeOf()`\n\n与上面的set方法相反，用来获取一个对象的prototype对象。\n\n```javascript\nfunction Rectangle () {\n\n}\n\nvar rec = new Rectangle();\n\nObject.getPrototypeOf(rec) === Rectangle.prototype; // true\n\nObject.setPrototypeOf(rec, Object.prototype);\nObject.getPrototypeOf(rec) === Rectangle.prototype; // false\n```\n\n## `Object.values()`, `Object.entries()`\n\n#### `Object.keys()`\n\n返回一个数组，成员是参数对象自身的所有可遍历属性的键名（不含继承）\n\n```javascript\nvar obj = { foo: \"bar\", baz: 42 };\nObject.keys(obj)\n// [\"foo\", \"baz\"]\n```\n\n目前ES7有一个新提案，引入了跟`Object.keys()`配套的`Object.values`和`Object.entries`。\n\n```javascript\nlet { keys, values, entries } = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key  of keys(obj)) {\n    console.log(key);\n}\n// 'a', 'b', 'c'\n\nfor (let value of values(obj)) {\n    console.log(value);\n}\n// 1, 2, 3\n\nfor (let [key, value] of entries(obj)) {\n    console.log([key, value]);\n}\n//['a', 1], ['b', 2], ['c', 3]\n```\n\n#### `Object.values()`\n\n返回一个数组，成员是参数对象自身的（不含继承）所有可遍历（enumerable）属性的键值。\n\n```javascript\nvar obj = { foo: \"bar\", baz: 42 };\nObject.values(obj);\n// ['baz', 42]\n```\n\n#### `Object.entries`\n\n返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。\n\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.entries(obj);\n// [ [ 'foo', 'bar' ], [ 'baz', 42 ] ]\n```\n\n基本用途为遍历对象的属性，也可以将对象转换为Map\n\n```javascript\nlet obj = { one: 1, two: 2 };\nfor (let [k, v] of Object.entries(obj)) {\n    console.log(`${JSON.stringify(k)} : ${JSON.stringify(v)}`)\n}\n// \"one\": 1\n// \"two\": 2\n\n// 另一个用途是将对象转换为Map\nvar obj = { foo: 'bar', baz: 42 };\nvar map = new Map(Object.entries(obj));\nmap // Map {foo: \"bar\", baz: 42 }\n```\n\n## 对象的扩展运算符\n\n之前提到过扩展运算符（`...`），在对象中也有运用。\n\n#### 解构赋值\n\n对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到指定的对象上。所有的键和值，都会拷贝到新对象上。\n\n```javascript\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n```\n\n解构必须是最后一个参数，否则会报错，这和Java是完全一样的。注意一点：解构赋值时浅拷贝，如果一个键的值是复合类型的值（数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n\n```javascript\nlet obj = { a: { b: 1 }};\nlet {...x} = obj;\nobj.a.b = 2;\nx.a.b // 2 (浅拷贝无疑了)\n```\n\n另外解构赋值不会拷贝继承自原型对象的属性。下面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。\n\n解构赋值的一个用处，是扩展某个函数的参数，引入其他操作：\n\n```javascript\nfunction baseFunction ({a, b}) {\n    // ...\n}\n\nfunction wrapperFunction ({x, y, ...restConfig}) {\n    return baseFunction(restConfig);\n}\n```\n\n扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n```javascript\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n```\n\n还可以用于合并两个对象。\n\n```javascript\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = Object.assign({}, a, b);\n```\n\n## `Object.getOwnPropertyDescriptors()`\n\n前面提到了：这个方法是用来返回某个对象属性的描述对象的。ES7有个提案：返回指定对象所有自身属性（非继承性——的描述对象。\n\n```javascript\nconst obj = {\n    foo: 123,\n    get bar() { return 'abc' }\n};\n\nObject.getOwnPropertyDescription(obj)\n\n// 返回结果如下\n{\n  foo: { value: 123, writable: true, enumerable: true, configurable: true },\n  bar: {\n    get: [Function: get bar],\n    set: undefined,\n    enumerable: true,\n    configurable: true\n  }\n}\n```\n\n该方法实现的目的：主要是为了解决`Object.assing()`无法正确拷贝`get`属性和`set`属性的问题。结合`Object.defineProperties`方法就可以实现正确拷贝。\n\n```javascript\nconst source = {\n    set foo (value) {\n        console.log(value);\n    }\n};\n\nconst target2 = {};\nObject.defineProperties(target2, Object.getOwnPropertyDescriptors(source));\nObject.getOwnPropertyDescriptor(target2, 'foo')\n\n// 返回结果\n{                           \n  get: undefined,           \n  set: [Function: set foo], \n  enumerable: true,         \n  configurable: true        \n}                           \n```\n\n将上面两部分代码合并起来，就是这样。是不是突然觉得眼熟悉？（就是React Thunk的使用方法）\n\n```javascript\nconst shallowMerge = (target, source) => Object.defineProperties(\n\ttarget,\n    Object.getOwnPropertyDescriptors(source)\n);\n\n// 浅拷贝对象\nconst clone = Object.create(Object.getPrototypeOf(obj),\n                           Object.getOwnPropertyDescriptors(obj));\nconst shallowClone = (obj) => Object.create(\n\tObject.getPrototypeOf(obj),\n    Object.getOwnPropertyDescriptors(obj)\n);\n```\n","source":"_posts/javascript/es6-object-expand.md","raw":"---\ntitle: ES6 对象扩展\ndate: 2022-02-17 15:08:22\nupdated: 2022-02-17 15:08:22\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 对象扩展\n\n## 属性的简洁表示法\n\nES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更加简洁。\n\n```javascript\nvar foo = 'bar';\nvar baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nvar baz = {foo: foo};\n```\n\n除了属性可以简写，方法也可以简写\n\n```javascript\nvar o = {\n    method() {\n        return \"Hello\";\n    }\n};\n\n// 等同于\n\nvar o = {\n    method: function() {\n        return \"Hello\";\n    }\n};\n```\n\n适用于函数返回值，写起来会非常简洁和方便\n\n```javascript\nfunction getPoint() {\n    var x = 1;\n    var y = 10;\n    return {x, y};\n}\n\ngetPoint() // {x: 1, y: 10}\n```\n\n在使用Common JS中，输出的代码非常适合使用这种简洁写法\n\n```javascript\nvar ms = {};\n\nfunction getItem(key) {\n    return key in ms ? ms[key] : null;\n}\n\nfunction setItem(key, value) {\n    ms[key] = value;\n}\n\nfunction clear() {\n    ms = {};\n}\n\nmodule.exports = { getItem, setItem, clear }\n// 等同于\nmodule.exports = {\n    getItem: getItem,\n    setItem: setItem,\n    clear: clear\n}\n```\n\n## 属性名表达式\n\nJavaScript语言定义对象的属性，有如下种方法。\n\n```javascript\nobj.foo = true; // 直接使用标识符作为属性名\n\nobj['a' + 'bc'] = 123; // 使用表达式作为属性名\n```\n\nES6允许字面量定义对象时，用方法二作为对象的属性名，即将表达式放在括号内\n\n```javascript\nlet propKey = 'foo';\n\nlet obj = {\n    [propKey]: true,\n    ['a' + 'bc']: 123\n}\n```\n\n这里再举一个例子：\n\n```javascript\nvar lastWord = 'last word';\n\nvar a = {\n    'first word': 'hello',\n    [lastWord]: 'world'\n};\n\na['first Word'] // hello\na[lastWord] // World\na['last word'] // World\n```\n\n注意：属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串。因此属性名表达式和简洁表示法不可以同时使用。一定要注意。\n\n## 方法的`name`属性\n\n函数的`name`属性返回函数名。对象方法也是函数，因此也有`name`属性。\n\n```javascript\nvar person = {\n    sayName() {\n        console.log(this.name);\n    },\n    // get为取值函数，存值用set\n    get firstName() {\n        return \"Nicholas\";\n    }\n};\n\nperson.sayName.name // sayName\nperson.firstName.name // get firstName\n```\n\n有两个特例：如果是`bind`函数，函数名返回`bound` + 函数名称；如果是`function`关键字构造的函数（匿名函数），`name`属性值返回`anonymous`。\n\n## `Object.is()`\n\n该方法用来比较两个值是否严格相等，与严格比较运算符`===`的作用一致。不同之处有两个：+0不等于-0；另一个是NaN等于自身。\n\n```javascript\n+0 === -0 // true\nNaN === NaN // false\n\nObject.is(+0, -0); // false\nObject.is(NaN, NaN) // true\n```\n\n## `Object.assign()`\n\n### 基本用法\n\n用于将对象合并，将源对象的所有可枚举属性赋值到目标对象。如果目标对象与源对象由同名属性，或多个源对象由同名属性，则后面的属性会覆盖前面的属性。\n\n```javascript\nvar target = { a: 1 };\n\nvar source1 = { b: 2 };\nvar source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // { a: 1, b: 2, c: 3 }\n```\n\n如果只有一个参数，会直接返回该参数；如果该参数不是对象，会先转换为对象，然后返回。由于`undefined`和`null`无法转换为对象，所以将它们作为参数传入会报错。\n\n```javascript\nvar obj = { a: 1};\nObject.assign(obj) === obj // true\n\ntypeof Object.assign(2) // object\n\nObject.assign(undefined) // error\nObject.assign(null) // error\n```\n\n如果`undefined`和`null`出现在非首参数，首先会尝试着转换为对象，如果转换失败会直接跳过。这意味着只要首参数可以转换为对象，就不会报错。\n\n```javascript\nlet obj = { a: 1};\n\nObject.assign(a, undefined) === obj // true\nObject.assign(a, null) === obj // true\n```\n\n其他类型的值中，只有字符串会以数组的形式拷贝至对象中，其他值都不会产生效果；\n\n```javascript\nvar v1 = 'abc';\nvar v2 = true;\nvar v3 = 10;\n\nvar obj = Object.assign({}, v1, v2, v3);\nconsole.log(obj); // {'0': 'a', '1': 'b', '2': 'c'}\n```\n\n`Object.assign()`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）。\n\n```javascript\nObject.assign({b: 'c'}, Object.defineProperty({}, 'invisible', {\n    \tenumerable: false,\n    \tvalue: 'hello'\n\t})\n)\n// {b: 'c'}\n```\n\n值得注意的是：`Object.assign()`执行的是浅拷贝，而不是深拷贝。如果源对象某个属性的值是对象，那么目标对象拷贝得到的仅仅是这个对象的引用。\n\n```javascript\nvar obj1 = {a: {b: 1}};\nvar obj2 = Object.assign({}, obj1);\n\nobj1.a.b = 2;\nobj2.a.b // 2\n```\n\n### Object.assign()方法有哪些用途呢？\n\n#### 为对象添加属性\n\n```javascript\nclass Point {\n    constructor(x, y) {\n        Object.assign(this, {x, y})\n    }\n}\n```\n\n#### 为对象添加方法\n\n```javascript\nObject.assign(SomeClass.prototype, {\n    someMethod(arg1, arg2) {\n        ...\n    },\n    anotherMethod() {\n        ...\n    }\n});\n        \n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) { ... };\nSomeClass.prototype.anotherMethod = function () { ... };\n```\n\n#### 克隆对象\n\n```javascript\n// 将原始对象拷贝到空对象中\nfunction clone (origin) {\n    return Object.assign({}, origin);\n}\n\n// 将原始对象和其继承的值拷贝到新对象中\nfunction clone (origin) {\n    let originProto = Object.getPrototypeOf(origin);\n    return Object.assign(Object.create(originProto), origin);\n}\n```\n\n#### 合并多个对象\n\n```javascript\n// 将多个对象合并到某个对象\nconst merge = (target, ...source) => Object.assign(target, ...source);\n\n// 合并后返回一个新对象\nconst merge = (...source) => Object.assign({}, ...source);\n```\n\n#### 为属性指定默认值\n\n```javascript\nconst DEFAULTS = {\n    logLevel: 0,\n    outputFormat: 'html'\n};\n\nfunction processContent(options) {\n    options = Object.assign({}, DEFAULTS, options)\n}\n```\n\n## 属性的可枚举性\n\n`Object.getOwnPropertyDescriptor(obj, 'foo')`方法可以获取该属性的描述对象，其中描述对象有一个`enumerable`属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。\n\nES6中有下面4个操作会忽略`enumerable`为false的属性。\n\n- `for ... in` 循环：只遍历对象自身的和继承的可枚举属性；\n- `Object.keys()`：返回对象自身的所有可枚举的属性键名；\n- `JSON.stringify()`：只串行化对象自身的可枚举属性；\n- `Object.assign()`：只拷贝对象自身的可枚举属性；\n\n上面4个操作中，只有`for ... in`会返回继承的属性。实际上引入`enumerable`的最初目的，就是让某些可以规避掉`for...in`的操作。\n\n```javascript\nObject.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable // false\n\nObject.getOwnPropertyDescriptor([], 'length').enumerable // false\n```\n\n另外ES6规定，所有Class的原型方法都是不可枚举的：\n\n```javascript\nObject.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable\n```\n\n## 属性的遍历\n\nES6中一共有5种方法可以遍历对象的属性\n\n#### （1）for...in\n\n遍历对象自身和继承的可枚举属性\n\n#### （2）Object.keys(obj)\n\n返回一个数组，包括对象自身的（不含继承）所有可枚举属性（不包括Symbol属性）\n\n#### （3）Object.getOwnPropertyNames(obj)\n\n返回一个数组，包含对象自身的所有属性（不包括Symbol属性）\n\n#### （4）Object.getOwnPropertySymbols(obj)\n\n返回一个数组，包含对象自身的所有Symbol属性\n\n#### （5）Reflect.ownKeys(obj)\n\n返回一个数组，包含对象自身的所有属性，不管是属性名还是Symbol还是字符串，也不管是否可枚举。\n\n上面5种方法遍历对象属性，都遵循同样的属性遍历的次序规则。\n\n- 首先遍历所有属性名为数值的字符的属性，按照数字排序；\n- 其次遍历所有属性名为字符串的属性，按照生成时间排序；\n- 最后遍历所有属性名为Symbol值得属性，按照生成时间排序；\n\n一句话概括：遍历规则为数值 > 字符串 > Symbol；数值排序规则为数字，剩下两个排序规则为生成顺序；\n\n## `__proto__`属性，`Objects.setPrototypeOf()`, `Object.getPrototypeOf()`\n\n#### `__proto__`属性\n\n用来读取或设置当前对象的`prototype`对象。目前所有浏览器都支持这个特性。\n\n```javascript\nvar obj = {\n    method: function () {...}\n};\nobj.__proto__ = someOtherObj;\n\nvar obj = Object.create(someOtherObj);\nobj.method = function () {...};\n```\n\n这里和Python一样，使用双下划线标注的属性内部属性，而不是一个正式对外的API。因此在正式使用时不建议显示的设置。而是用`Object.setPrototypeOf()`、`Object.getPrototypeOf()`、`Object.create()`代替。\n\n#### `Object.setPrototypeOf()`\n\n用来设置对象的`prototype`对象。是ES6推荐的设置原型对象的方法。\n\n```javascript\nlet proto = {};\nlet obj = { x: 10};\nObject.setPrototypeOf(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nconsole.log(obj.x) // 10\nconsole.log(obj.y) // 20\nconsole.log(obj.z) // 40\n```\n\n#### `Object.getPrototypeOf()`\n\n与上面的set方法相反，用来获取一个对象的prototype对象。\n\n```javascript\nfunction Rectangle () {\n\n}\n\nvar rec = new Rectangle();\n\nObject.getPrototypeOf(rec) === Rectangle.prototype; // true\n\nObject.setPrototypeOf(rec, Object.prototype);\nObject.getPrototypeOf(rec) === Rectangle.prototype; // false\n```\n\n## `Object.values()`, `Object.entries()`\n\n#### `Object.keys()`\n\n返回一个数组，成员是参数对象自身的所有可遍历属性的键名（不含继承）\n\n```javascript\nvar obj = { foo: \"bar\", baz: 42 };\nObject.keys(obj)\n// [\"foo\", \"baz\"]\n```\n\n目前ES7有一个新提案，引入了跟`Object.keys()`配套的`Object.values`和`Object.entries`。\n\n```javascript\nlet { keys, values, entries } = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key  of keys(obj)) {\n    console.log(key);\n}\n// 'a', 'b', 'c'\n\nfor (let value of values(obj)) {\n    console.log(value);\n}\n// 1, 2, 3\n\nfor (let [key, value] of entries(obj)) {\n    console.log([key, value]);\n}\n//['a', 1], ['b', 2], ['c', 3]\n```\n\n#### `Object.values()`\n\n返回一个数组，成员是参数对象自身的（不含继承）所有可遍历（enumerable）属性的键值。\n\n```javascript\nvar obj = { foo: \"bar\", baz: 42 };\nObject.values(obj);\n// ['baz', 42]\n```\n\n#### `Object.entries`\n\n返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。\n\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.entries(obj);\n// [ [ 'foo', 'bar' ], [ 'baz', 42 ] ]\n```\n\n基本用途为遍历对象的属性，也可以将对象转换为Map\n\n```javascript\nlet obj = { one: 1, two: 2 };\nfor (let [k, v] of Object.entries(obj)) {\n    console.log(`${JSON.stringify(k)} : ${JSON.stringify(v)}`)\n}\n// \"one\": 1\n// \"two\": 2\n\n// 另一个用途是将对象转换为Map\nvar obj = { foo: 'bar', baz: 42 };\nvar map = new Map(Object.entries(obj));\nmap // Map {foo: \"bar\", baz: 42 }\n```\n\n## 对象的扩展运算符\n\n之前提到过扩展运算符（`...`），在对象中也有运用。\n\n#### 解构赋值\n\n对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到指定的对象上。所有的键和值，都会拷贝到新对象上。\n\n```javascript\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n```\n\n解构必须是最后一个参数，否则会报错，这和Java是完全一样的。注意一点：解构赋值时浅拷贝，如果一个键的值是复合类型的值（数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n\n```javascript\nlet obj = { a: { b: 1 }};\nlet {...x} = obj;\nobj.a.b = 2;\nx.a.b // 2 (浅拷贝无疑了)\n```\n\n另外解构赋值不会拷贝继承自原型对象的属性。下面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。\n\n解构赋值的一个用处，是扩展某个函数的参数，引入其他操作：\n\n```javascript\nfunction baseFunction ({a, b}) {\n    // ...\n}\n\nfunction wrapperFunction ({x, y, ...restConfig}) {\n    return baseFunction(restConfig);\n}\n```\n\n扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n```javascript\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n```\n\n还可以用于合并两个对象。\n\n```javascript\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = Object.assign({}, a, b);\n```\n\n## `Object.getOwnPropertyDescriptors()`\n\n前面提到了：这个方法是用来返回某个对象属性的描述对象的。ES7有个提案：返回指定对象所有自身属性（非继承性——的描述对象。\n\n```javascript\nconst obj = {\n    foo: 123,\n    get bar() { return 'abc' }\n};\n\nObject.getOwnPropertyDescription(obj)\n\n// 返回结果如下\n{\n  foo: { value: 123, writable: true, enumerable: true, configurable: true },\n  bar: {\n    get: [Function: get bar],\n    set: undefined,\n    enumerable: true,\n    configurable: true\n  }\n}\n```\n\n该方法实现的目的：主要是为了解决`Object.assing()`无法正确拷贝`get`属性和`set`属性的问题。结合`Object.defineProperties`方法就可以实现正确拷贝。\n\n```javascript\nconst source = {\n    set foo (value) {\n        console.log(value);\n    }\n};\n\nconst target2 = {};\nObject.defineProperties(target2, Object.getOwnPropertyDescriptors(source));\nObject.getOwnPropertyDescriptor(target2, 'foo')\n\n// 返回结果\n{                           \n  get: undefined,           \n  set: [Function: set foo], \n  enumerable: true,         \n  configurable: true        \n}                           \n```\n\n将上面两部分代码合并起来，就是这样。是不是突然觉得眼熟悉？（就是React Thunk的使用方法）\n\n```javascript\nconst shallowMerge = (target, source) => Object.defineProperties(\n\ttarget,\n    Object.getOwnPropertyDescriptors(source)\n);\n\n// 浅拷贝对象\nconst clone = Object.create(Object.getPrototypeOf(obj),\n                           Object.getOwnPropertyDescriptors(obj));\nconst shallowClone = (obj) => Object.create(\n\tObject.getPrototypeOf(obj),\n    Object.getOwnPropertyDescriptors(obj)\n);\n```\n","slug":"javascript/es6-object-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vh001p4f618xyodr6v","content":"<h1 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h1><h2 id=\"属性的简洁表示法\"><a href=\"#属性的简洁表示法\" class=\"headerlink\" title=\"属性的简洁表示法\"></a>属性的简洁表示法</h2><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更加简洁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> baz = &#123;foo&#125;;<br>baz <span class=\"hljs-comment\">// &#123;foo: &quot;bar&quot;&#125;</span><br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> baz = &#123;<span class=\"hljs-attr\">foo</span>: foo&#125;;<br></code></pre></td></tr></table></figure>\n<p>除了属性可以简写，方法也可以简写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> o = &#123;<br>    <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-keyword\">var</span> o = &#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>适用于函数返回值，写起来会非常简洁和方便</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPoint</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">return</span> &#123;x, y&#125;;<br>&#125;<br><br><span class=\"hljs-title function_\">getPoint</span>() <span class=\"hljs-comment\">// &#123;x: 1, y: 10&#125;</span><br></code></pre></td></tr></table></figure>\n<p>在使用Common JS中，输出的代码非常适合使用这种简洁写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> ms = &#123;&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-params\">key</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> key <span class=\"hljs-keyword\">in</span> ms ? ms[key] : <span class=\"hljs-literal\">null</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setItem</span>(<span class=\"hljs-params\">key, value</span>) &#123;<br>    ms[key] = value;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clear</span>(<span class=\"hljs-params\"></span>) &#123;<br>    ms = &#123;&#125;;<br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123; getItem, setItem, clear &#125;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>    <span class=\"hljs-attr\">getItem</span>: getItem,<br>    <span class=\"hljs-attr\">setItem</span>: setItem,<br>    <span class=\"hljs-attr\">clear</span>: clear<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"属性名表达式\"><a href=\"#属性名表达式\" class=\"headerlink\" title=\"属性名表达式\"></a>属性名表达式</h2><p>JavaScript语言定义对象的属性，有如下种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 直接使用标识符作为属性名</span><br><br>obj[<span class=\"hljs-string\">&#x27;a&#x27;</span> + <span class=\"hljs-string\">&#x27;bc&#x27;</span>] = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 使用表达式作为属性名</span><br></code></pre></td></tr></table></figure>\n<p>ES6允许字面量定义对象时，用方法二作为对象的属性名，即将表达式放在括号内</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> propKey = <span class=\"hljs-string\">&#x27;foo&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>    [propKey]: <span class=\"hljs-literal\">true</span>,<br>    [<span class=\"hljs-string\">&#x27;a&#x27;</span> + <span class=\"hljs-string\">&#x27;bc&#x27;</span>]: <span class=\"hljs-number\">123</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> lastWord = <span class=\"hljs-string\">&#x27;last word&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;<br>    <span class=\"hljs-string\">&#x27;first word&#x27;</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>,<br>    [lastWord]: <span class=\"hljs-string\">&#x27;world&#x27;</span><br>&#125;;<br><br>a[<span class=\"hljs-string\">&#x27;first Word&#x27;</span>] <span class=\"hljs-comment\">// hello</span><br>a[lastWord] <span class=\"hljs-comment\">// World</span><br>a[<span class=\"hljs-string\">&#x27;last word&#x27;</span>] <span class=\"hljs-comment\">// World</span><br></code></pre></td></tr></table></figure>\n<p>注意：属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串。因此属性名表达式和简洁表示法不可以同时使用。一定要注意。</p>\n<h2 id=\"方法的name属性\"><a href=\"#方法的name属性\" class=\"headerlink\" title=\"方法的name属性\"></a>方法的<code>name</code>属性</h2><p>函数的<code>name</code>属性返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-title function_\">sayName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;,<br>    <span class=\"hljs-comment\">// get为取值函数，存值用set</span><br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">firstName</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Nicholas&quot;</span>;<br>    &#125;<br>&#125;;<br><br>person.<span class=\"hljs-property\">sayName</span>.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// sayName</span><br>person.<span class=\"hljs-property\">firstName</span>.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// get firstName</span><br></code></pre></td></tr></table></figure>\n<p>有两个特例：如果是<code>bind</code>函数，函数名返回<code>bound</code> + 函数名称；如果是<code>function</code>关键字构造的函数（匿名函数），<code>name</code>属性值返回<code>anonymous</code>。</p>\n<h2 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a><code>Object.is()</code></h2><p>该方法用来比较两个值是否严格相等，与严格比较运算符<code>===</code>的作用一致。不同之处有两个：+0不等于-0；另一个是NaN等于自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">+<span class=\"hljs-number\">0</span> === -<span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">NaN</span> === <span class=\"hljs-title class_\">NaN</span> <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(+<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(<span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a><code>Object.assign()</code></h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>用于将对象合并，将源对象的所有可枚举属性赋值到目标对象。如果目标对象与源对象由同名属性，或多个源对象由同名属性，则后面的属性会覆盖前面的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;;<br><br><span class=\"hljs-keyword\">var</span> source1 = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">var</span> source2 = &#123; <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, source1, source2);<br>target <span class=\"hljs-comment\">// &#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果只有一个参数，会直接返回该参数；如果该参数不是对象，会先转换为对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转换为对象，所以将它们作为参数传入会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(obj) === obj <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// object</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// error</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// error</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>undefined</code>和<code>null</code>出现在非首参数，首先会尝试着转换为对象，如果转换失败会直接跳过。这意味着只要首参数可以转换为对象，就不会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, <span class=\"hljs-literal\">undefined</span>) === obj <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, <span class=\"hljs-literal\">null</span>) === obj <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>其他类型的值中，只有字符串会以数组的形式拷贝至对象中，其他值都不会产生效果；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> v1 = <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> v2 = <span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">var</span> v3 = <span class=\"hljs-number\">10</span>;<br><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, v1, v2, v3);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj); <span class=\"hljs-comment\">// &#123;&#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n<p><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>&#125;, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(&#123;&#125;, <span class=\"hljs-string\">&#x27;invisible&#x27;</span>, &#123;<br>    \t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span>,<br>    \t<span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span><br>\t&#125;)<br>)<br><span class=\"hljs-comment\">// &#123;b: &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n<p>值得注意的是：<code>Object.assign()</code>执行的是浅拷贝，而不是深拷贝。如果源对象某个属性的值是对象，那么目标对象拷贝得到的仅仅是这个对象的引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<span class=\"hljs-attr\">a</span>: &#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>&#125;&#125;;<br><span class=\"hljs-keyword\">var</span> obj2 = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, obj1);<br><br>obj1.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>obj2.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Object-assign-方法有哪些用途呢？\"><a href=\"#Object-assign-方法有哪些用途呢？\" class=\"headerlink\" title=\"Object.assign()方法有哪些用途呢？\"></a>Object.assign()方法有哪些用途呢？</h3><h4 id=\"为对象添加属性\"><a href=\"#为对象添加属性\" class=\"headerlink\" title=\"为对象添加属性\"></a>为对象添加属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-variable language_\">this</span>, &#123;x, y&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"为对象添加方法\"><a href=\"#为对象添加方法\" class=\"headerlink\" title=\"为对象添加方法\"></a>为对象添加方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, &#123;<br>    <span class=\"hljs-title function_\">someMethod</span>(<span class=\"hljs-params\">arg1, arg2</span>) &#123;<br>        ...<br>    &#125;,<br>    <span class=\"hljs-title function_\">anotherMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>        ...<br>    &#125;<br>&#125;);<br>        <br><span class=\"hljs-comment\">// 等同于下面的写法</span><br><span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">someMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arg1, arg2</span>) &#123; ... &#125;;<br><span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">anotherMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; ... &#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"克隆对象\"><a href=\"#克隆对象\" class=\"headerlink\" title=\"克隆对象\"></a>克隆对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 将原始对象拷贝到空对象中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone</span> (origin) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, origin);<br>&#125;<br><br><span class=\"hljs-comment\">// 将原始对象和其继承的值拷贝到新对象中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone</span> (origin) &#123;<br>    <span class=\"hljs-keyword\">let</span> originProto = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(origin);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(originProto), origin);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"合并多个对象\"><a href=\"#合并多个对象\" class=\"headerlink\" title=\"合并多个对象\"></a>合并多个对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 将多个对象合并到某个对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">merge</span> = (<span class=\"hljs-params\">target, ...source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, ...source);<br><br><span class=\"hljs-comment\">// 合并后返回一个新对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">merge</span> = (<span class=\"hljs-params\">...source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, ...source);<br></code></pre></td></tr></table></figure>\n<h4 id=\"为属性指定默认值\"><a href=\"#为属性指定默认值\" class=\"headerlink\" title=\"为属性指定默认值\"></a>为属性指定默认值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">DEFAULTS</span> = &#123;<br>    <span class=\"hljs-attr\">logLevel</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">outputFormat</span>: <span class=\"hljs-string\">&#x27;html&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processContent</span>(<span class=\"hljs-params\">options</span>) &#123;<br>    options = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, <span class=\"hljs-variable constant_\">DEFAULTS</span>, options)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"属性的可枚举性\"><a href=\"#属性的可枚举性\" class=\"headerlink\" title=\"属性的可枚举性\"></a>属性的可枚举性</h2><p><code>Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)</code>方法可以获取该属性的描述对象，其中描述对象有一个<code>enumerable</code>属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</p>\n<p>ES6中有下面4个操作会忽略<code>enumerable</code>为false的属性。</p>\n<ul>\n<li><code>for ... in</code> 循环：只遍历对象自身的和继承的可枚举属性；</li>\n<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性键名；</li>\n<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举属性；</li>\n<li><code>Object.assign()</code>：只拷贝对象自身的可枚举属性；</li>\n</ul>\n<p>上面4个操作中，只有<code>for ... in</code>会返回继承的属性。实际上引入<code>enumerable</code>的最初目的，就是让某些可以规避掉<code>for...in</code>的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;toString&#x27;</span>).<span class=\"hljs-property\">enumerable</span> <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>([], <span class=\"hljs-string\">&#x27;length&#x27;</span>).<span class=\"hljs-property\">enumerable</span> <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<p>另外ES6规定，所有Class的原型方法都是不可枚举的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(<span class=\"hljs-keyword\">class</span> &#123;<span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;&#125;&#125;.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;foo&#x27;</span>).<span class=\"hljs-property\">enumerable</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"属性的遍历\"><a href=\"#属性的遍历\" class=\"headerlink\" title=\"属性的遍历\"></a>属性的遍历</h2><p>ES6中一共有5种方法可以遍历对象的属性</p>\n<h4 id=\"（1）for…in\"><a href=\"#（1）for…in\" class=\"headerlink\" title=\"（1）for…in\"></a>（1）for…in</h4><p>遍历对象自身和继承的可枚举属性</p>\n<h4 id=\"（2）Object-keys-obj\"><a href=\"#（2）Object-keys-obj\" class=\"headerlink\" title=\"（2）Object.keys(obj)\"></a>（2）Object.keys(obj)</h4><p>返回一个数组，包括对象自身的（不含继承）所有可枚举属性（不包括Symbol属性）</p>\n<h4 id=\"（3）Object-getOwnPropertyNames-obj\"><a href=\"#（3）Object-getOwnPropertyNames-obj\" class=\"headerlink\" title=\"（3）Object.getOwnPropertyNames(obj)\"></a>（3）Object.getOwnPropertyNames(obj)</h4><p>返回一个数组，包含对象自身的所有属性（不包括Symbol属性）</p>\n<h4 id=\"（4）Object-getOwnPropertySymbols-obj\"><a href=\"#（4）Object-getOwnPropertySymbols-obj\" class=\"headerlink\" title=\"（4）Object.getOwnPropertySymbols(obj)\"></a>（4）Object.getOwnPropertySymbols(obj)</h4><p>返回一个数组，包含对象自身的所有Symbol属性</p>\n<h4 id=\"（5）Reflect-ownKeys-obj\"><a href=\"#（5）Reflect-ownKeys-obj\" class=\"headerlink\" title=\"（5）Reflect.ownKeys(obj)\"></a>（5）Reflect.ownKeys(obj)</h4><p>返回一个数组，包含对象自身的所有属性，不管是属性名还是Symbol还是字符串，也不管是否可枚举。</p>\n<p>上面5种方法遍历对象属性，都遵循同样的属性遍历的次序规则。</p>\n<ul>\n<li>首先遍历所有属性名为数值的字符的属性，按照数字排序；</li>\n<li>其次遍历所有属性名为字符串的属性，按照生成时间排序；</li>\n<li>最后遍历所有属性名为Symbol值得属性，按照生成时间排序；</li>\n</ul>\n<p>一句话概括：遍历规则为数值 &gt; 字符串 &gt; Symbol；数值排序规则为数字，剩下两个排序规则为生成顺序；</p>\n<h2 id=\"proto-属性，Objects-setPrototypeOf-Object-getPrototypeOf\"><a href=\"#proto-属性，Objects-setPrototypeOf-Object-getPrototypeOf\" class=\"headerlink\" title=\"__proto__属性，Objects.setPrototypeOf(), Object.getPrototypeOf()\"></a><code>__proto__</code>属性，<code>Objects.setPrototypeOf()</code>, <code>Object.getPrototypeOf()</code></h2><h4 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__属性\"></a><code>__proto__</code>属性</h4><p>用来读取或设置当前对象的<code>prototype</code>对象。目前所有浏览器都支持这个特性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;...&#125;<br>&#125;;<br>obj.<span class=\"hljs-property\">__proto__</span> = someOtherObj;<br><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(someOtherObj);<br>obj.<span class=\"hljs-property\">method</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;...&#125;;<br></code></pre></td></tr></table></figure>\n<p>这里和Python一样，使用双下划线标注的属性内部属性，而不是一个正式对外的API。因此在正式使用时不建议显示的设置。而是用<code>Object.setPrototypeOf()</code>、<code>Object.getPrototypeOf()</code>、<code>Object.create()</code>代替。</p>\n<h4 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a><code>Object.setPrototypeOf()</code></h4><p>用来设置对象的<code>prototype</code>对象。是ES6推荐的设置原型对象的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> proto = &#123;&#125;;<br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">10</span>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(obj, proto);<br><br>proto.<span class=\"hljs-property\">y</span> = <span class=\"hljs-number\">20</span>;<br>proto.<span class=\"hljs-property\">z</span> = <span class=\"hljs-number\">40</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">x</span>) <span class=\"hljs-comment\">// 10</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">y</span>) <span class=\"hljs-comment\">// 20</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">z</span>) <span class=\"hljs-comment\">// 40</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a><code>Object.getPrototypeOf()</code></h4><p>与上面的set方法相反，用来获取一个对象的prototype对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Rectangle</span> () &#123;<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> rec = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Rectangle</span>();<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(rec) === <span class=\"hljs-title class_\">Rectangle</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(rec, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(rec) === <span class=\"hljs-title class_\">Rectangle</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-values-Object-entries\"><a href=\"#Object-values-Object-entries\" class=\"headerlink\" title=\"Object.values(), Object.entries()\"></a><code>Object.values()</code>, <code>Object.entries()</code></h2><h4 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a><code>Object.keys()</code></h4><p>返回一个数组，成员是参数对象自身的所有可遍历属性的键名（不含继承）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)<br><span class=\"hljs-comment\">// [&quot;foo&quot;, &quot;baz&quot;]</span><br></code></pre></td></tr></table></figure>\n<p>目前ES7有一个新提案，引入了跟<code>Object.keys()</code>配套的<code>Object.values</code>和<code>Object.entries</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123; keys, values, entries &#125; = <span class=\"hljs-title class_\">Object</span>;<br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key  <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">keys</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">values</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><span class=\"hljs-comment\">// 1, 2, 3</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([key, value]);<br>&#125;<br><span class=\"hljs-comment\">//[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-values\"><a href=\"#Object-values\" class=\"headerlink\" title=\"Object.values()\"></a><code>Object.values()</code></h4><p>返回一个数组，成员是参数对象自身的（不含继承）所有可遍历（enumerable）属性的键值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(obj);<br><span class=\"hljs-comment\">// [&#x27;baz&#x27;, 42]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-entries\"><a href=\"#Object-entries\" class=\"headerlink\" title=\"Object.entries\"></a><code>Object.entries</code></h4><p>返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj);<br><span class=\"hljs-comment\">// [ [ &#x27;foo&#x27;, &#x27;bar&#x27; ], [ &#x27;baz&#x27;, 42 ] ]</span><br></code></pre></td></tr></table></figure>\n<p>基本用途为遍历对象的属性，也可以将对象转换为Map</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">one</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">two</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k, v] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(k)&#125;</span> : <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(v)&#125;</span>`</span>)<br>&#125;<br><span class=\"hljs-comment\">// &quot;one&quot;: 1</span><br><span class=\"hljs-comment\">// &quot;two&quot;: 2</span><br><br><span class=\"hljs-comment\">// 另一个用途是将对象转换为Map</span><br><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj));<br>map <span class=\"hljs-comment\">// Map &#123;foo: &quot;bar&quot;, baz: 42 &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"对象的扩展运算符\"><a href=\"#对象的扩展运算符\" class=\"headerlink\" title=\"对象的扩展运算符\"></a>对象的扩展运算符</h2><p>之前提到过扩展运算符（<code>...</code>），在对象中也有运用。</p>\n<h4 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到指定的对象上。所有的键和值，都会拷贝到新对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123; x, y, ...z &#125; = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">4</span> &#125;;<br>x <span class=\"hljs-comment\">// 1</span><br>y <span class=\"hljs-comment\">// 2</span><br>z <span class=\"hljs-comment\">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>解构必须是最后一个参数，否则会报错，这和Java是完全一样的。注意一点：解构赋值时浅拷贝，如果一个键的值是复合类型的值（数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span> &#125;&#125;;<br><span class=\"hljs-keyword\">let</span> &#123;...x&#125; = obj;<br>obj.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>x.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2 (浅拷贝无疑了)</span><br></code></pre></td></tr></table></figure>\n<p>另外解构赋值不会拷贝继承自原型对象的属性。下面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>\n<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">baseFunction</span> (&#123;a, b&#125;) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">wrapperFunction</span> (&#123;x, y, ...restConfig&#125;) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">baseFunction</span>(restConfig);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> z = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">4</span> &#125;;<br><span class=\"hljs-keyword\">let</span> n = &#123; ...z &#125;;<br>n <span class=\"hljs-comment\">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>还可以用于合并两个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> ab = &#123; ...a, ...b &#125;;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">let</span> ab = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, a, b);<br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors()\"></a><code>Object.getOwnPropertyDescriptors()</code></h2><p>前面提到了：这个方法是用来返回某个对象属性的描述对象的。ES7有个提案：返回指定对象所有自身属性（非继承性——的描述对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">123</span>,<br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">bar</span>() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span> &#125;<br>&#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescription</span>(obj)<br><br><span class=\"hljs-comment\">// 返回结果如下</span><br>&#123;<br>  <span class=\"hljs-attr\">foo</span>: &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">123</span>, <span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span> &#125;,<br>  <span class=\"hljs-attr\">bar</span>: &#123;<br>    <span class=\"hljs-attr\">get</span>: [<span class=\"hljs-title class_\">Function</span>: get bar],<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-literal\">undefined</span>,<br>    <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>该方法实现的目的：主要是为了解决<code>Object.assing()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。结合<code>Object.defineProperties</code>方法就可以实现正确拷贝。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> source = &#123;<br>    set foo (value) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> target2 = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperties</span>(target2, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(source));<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target2, <span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><br><span class=\"hljs-comment\">// 返回结果</span><br>&#123;                           <br>  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-literal\">undefined</span>,           <br>  <span class=\"hljs-attr\">set</span>: [<span class=\"hljs-title class_\">Function</span>: set foo], <br>  <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,         <br>  <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span>        <br>&#125;                           <br></code></pre></td></tr></table></figure>\n<p>将上面两部分代码合并起来，就是这样。是不是突然觉得眼熟悉？（就是React Thunk的使用方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shallowMerge</span> = (<span class=\"hljs-params\">target, source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperties</span>(<br>\ttarget,<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(source)<br>);<br><br><span class=\"hljs-comment\">// 浅拷贝对象</span><br><span class=\"hljs-keyword\">const</span> clone = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),<br>                           <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shallowClone</span> = (<span class=\"hljs-params\">obj</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<br>\t<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj)<br>);<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":9564,"excerpt":"","more":"<h1 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h1><h2 id=\"属性的简洁表示法\"><a href=\"#属性的简洁表示法\" class=\"headerlink\" title=\"属性的简洁表示法\"></a>属性的简洁表示法</h2><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更加简洁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> baz = &#123;foo&#125;;<br>baz <span class=\"hljs-comment\">// &#123;foo: &quot;bar&quot;&#125;</span><br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> baz = &#123;<span class=\"hljs-attr\">foo</span>: foo&#125;;<br></code></pre></td></tr></table></figure>\n<p>除了属性可以简写，方法也可以简写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> o = &#123;<br>    <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-keyword\">var</span> o = &#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>适用于函数返回值，写起来会非常简洁和方便</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPoint</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">return</span> &#123;x, y&#125;;<br>&#125;<br><br><span class=\"hljs-title function_\">getPoint</span>() <span class=\"hljs-comment\">// &#123;x: 1, y: 10&#125;</span><br></code></pre></td></tr></table></figure>\n<p>在使用Common JS中，输出的代码非常适合使用这种简洁写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> ms = &#123;&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-params\">key</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> key <span class=\"hljs-keyword\">in</span> ms ? ms[key] : <span class=\"hljs-literal\">null</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setItem</span>(<span class=\"hljs-params\">key, value</span>) &#123;<br>    ms[key] = value;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clear</span>(<span class=\"hljs-params\"></span>) &#123;<br>    ms = &#123;&#125;;<br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123; getItem, setItem, clear &#125;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>    <span class=\"hljs-attr\">getItem</span>: getItem,<br>    <span class=\"hljs-attr\">setItem</span>: setItem,<br>    <span class=\"hljs-attr\">clear</span>: clear<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"属性名表达式\"><a href=\"#属性名表达式\" class=\"headerlink\" title=\"属性名表达式\"></a>属性名表达式</h2><p>JavaScript语言定义对象的属性，有如下种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 直接使用标识符作为属性名</span><br><br>obj[<span class=\"hljs-string\">&#x27;a&#x27;</span> + <span class=\"hljs-string\">&#x27;bc&#x27;</span>] = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 使用表达式作为属性名</span><br></code></pre></td></tr></table></figure>\n<p>ES6允许字面量定义对象时，用方法二作为对象的属性名，即将表达式放在括号内</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> propKey = <span class=\"hljs-string\">&#x27;foo&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>    [propKey]: <span class=\"hljs-literal\">true</span>,<br>    [<span class=\"hljs-string\">&#x27;a&#x27;</span> + <span class=\"hljs-string\">&#x27;bc&#x27;</span>]: <span class=\"hljs-number\">123</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> lastWord = <span class=\"hljs-string\">&#x27;last word&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;<br>    <span class=\"hljs-string\">&#x27;first word&#x27;</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>,<br>    [lastWord]: <span class=\"hljs-string\">&#x27;world&#x27;</span><br>&#125;;<br><br>a[<span class=\"hljs-string\">&#x27;first Word&#x27;</span>] <span class=\"hljs-comment\">// hello</span><br>a[lastWord] <span class=\"hljs-comment\">// World</span><br>a[<span class=\"hljs-string\">&#x27;last word&#x27;</span>] <span class=\"hljs-comment\">// World</span><br></code></pre></td></tr></table></figure>\n<p>注意：属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串。因此属性名表达式和简洁表示法不可以同时使用。一定要注意。</p>\n<h2 id=\"方法的name属性\"><a href=\"#方法的name属性\" class=\"headerlink\" title=\"方法的name属性\"></a>方法的<code>name</code>属性</h2><p>函数的<code>name</code>属性返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-title function_\">sayName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;,<br>    <span class=\"hljs-comment\">// get为取值函数，存值用set</span><br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">firstName</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Nicholas&quot;</span>;<br>    &#125;<br>&#125;;<br><br>person.<span class=\"hljs-property\">sayName</span>.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// sayName</span><br>person.<span class=\"hljs-property\">firstName</span>.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// get firstName</span><br></code></pre></td></tr></table></figure>\n<p>有两个特例：如果是<code>bind</code>函数，函数名返回<code>bound</code> + 函数名称；如果是<code>function</code>关键字构造的函数（匿名函数），<code>name</code>属性值返回<code>anonymous</code>。</p>\n<h2 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a><code>Object.is()</code></h2><p>该方法用来比较两个值是否严格相等，与严格比较运算符<code>===</code>的作用一致。不同之处有两个：+0不等于-0；另一个是NaN等于自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">+<span class=\"hljs-number\">0</span> === -<span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">NaN</span> === <span class=\"hljs-title class_\">NaN</span> <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(+<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(<span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a><code>Object.assign()</code></h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>用于将对象合并，将源对象的所有可枚举属性赋值到目标对象。如果目标对象与源对象由同名属性，或多个源对象由同名属性，则后面的属性会覆盖前面的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;;<br><br><span class=\"hljs-keyword\">var</span> source1 = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">var</span> source2 = &#123; <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, source1, source2);<br>target <span class=\"hljs-comment\">// &#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果只有一个参数，会直接返回该参数；如果该参数不是对象，会先转换为对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转换为对象，所以将它们作为参数传入会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(obj) === obj <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// object</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// error</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// error</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>undefined</code>和<code>null</code>出现在非首参数，首先会尝试着转换为对象，如果转换失败会直接跳过。这意味着只要首参数可以转换为对象，就不会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, <span class=\"hljs-literal\">undefined</span>) === obj <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, <span class=\"hljs-literal\">null</span>) === obj <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>其他类型的值中，只有字符串会以数组的形式拷贝至对象中，其他值都不会产生效果；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> v1 = <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> v2 = <span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">var</span> v3 = <span class=\"hljs-number\">10</span>;<br><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, v1, v2, v3);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj); <span class=\"hljs-comment\">// &#123;&#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n<p><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>&#125;, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(&#123;&#125;, <span class=\"hljs-string\">&#x27;invisible&#x27;</span>, &#123;<br>    \t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span>,<br>    \t<span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span><br>\t&#125;)<br>)<br><span class=\"hljs-comment\">// &#123;b: &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n<p>值得注意的是：<code>Object.assign()</code>执行的是浅拷贝，而不是深拷贝。如果源对象某个属性的值是对象，那么目标对象拷贝得到的仅仅是这个对象的引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<span class=\"hljs-attr\">a</span>: &#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>&#125;&#125;;<br><span class=\"hljs-keyword\">var</span> obj2 = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, obj1);<br><br>obj1.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>obj2.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Object-assign-方法有哪些用途呢？\"><a href=\"#Object-assign-方法有哪些用途呢？\" class=\"headerlink\" title=\"Object.assign()方法有哪些用途呢？\"></a>Object.assign()方法有哪些用途呢？</h3><h4 id=\"为对象添加属性\"><a href=\"#为对象添加属性\" class=\"headerlink\" title=\"为对象添加属性\"></a>为对象添加属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-variable language_\">this</span>, &#123;x, y&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"为对象添加方法\"><a href=\"#为对象添加方法\" class=\"headerlink\" title=\"为对象添加方法\"></a>为对象添加方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, &#123;<br>    <span class=\"hljs-title function_\">someMethod</span>(<span class=\"hljs-params\">arg1, arg2</span>) &#123;<br>        ...<br>    &#125;,<br>    <span class=\"hljs-title function_\">anotherMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>        ...<br>    &#125;<br>&#125;);<br>        <br><span class=\"hljs-comment\">// 等同于下面的写法</span><br><span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">someMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arg1, arg2</span>) &#123; ... &#125;;<br><span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">anotherMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; ... &#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"克隆对象\"><a href=\"#克隆对象\" class=\"headerlink\" title=\"克隆对象\"></a>克隆对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 将原始对象拷贝到空对象中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone</span> (origin) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, origin);<br>&#125;<br><br><span class=\"hljs-comment\">// 将原始对象和其继承的值拷贝到新对象中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone</span> (origin) &#123;<br>    <span class=\"hljs-keyword\">let</span> originProto = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(origin);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(originProto), origin);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"合并多个对象\"><a href=\"#合并多个对象\" class=\"headerlink\" title=\"合并多个对象\"></a>合并多个对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 将多个对象合并到某个对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">merge</span> = (<span class=\"hljs-params\">target, ...source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, ...source);<br><br><span class=\"hljs-comment\">// 合并后返回一个新对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">merge</span> = (<span class=\"hljs-params\">...source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, ...source);<br></code></pre></td></tr></table></figure>\n<h4 id=\"为属性指定默认值\"><a href=\"#为属性指定默认值\" class=\"headerlink\" title=\"为属性指定默认值\"></a>为属性指定默认值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">DEFAULTS</span> = &#123;<br>    <span class=\"hljs-attr\">logLevel</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">outputFormat</span>: <span class=\"hljs-string\">&#x27;html&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processContent</span>(<span class=\"hljs-params\">options</span>) &#123;<br>    options = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, <span class=\"hljs-variable constant_\">DEFAULTS</span>, options)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"属性的可枚举性\"><a href=\"#属性的可枚举性\" class=\"headerlink\" title=\"属性的可枚举性\"></a>属性的可枚举性</h2><p><code>Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)</code>方法可以获取该属性的描述对象，其中描述对象有一个<code>enumerable</code>属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</p>\n<p>ES6中有下面4个操作会忽略<code>enumerable</code>为false的属性。</p>\n<ul>\n<li><code>for ... in</code> 循环：只遍历对象自身的和继承的可枚举属性；</li>\n<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性键名；</li>\n<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举属性；</li>\n<li><code>Object.assign()</code>：只拷贝对象自身的可枚举属性；</li>\n</ul>\n<p>上面4个操作中，只有<code>for ... in</code>会返回继承的属性。实际上引入<code>enumerable</code>的最初目的，就是让某些可以规避掉<code>for...in</code>的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;toString&#x27;</span>).<span class=\"hljs-property\">enumerable</span> <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>([], <span class=\"hljs-string\">&#x27;length&#x27;</span>).<span class=\"hljs-property\">enumerable</span> <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<p>另外ES6规定，所有Class的原型方法都是不可枚举的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(<span class=\"hljs-keyword\">class</span> &#123;<span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;&#125;&#125;.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;foo&#x27;</span>).<span class=\"hljs-property\">enumerable</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"属性的遍历\"><a href=\"#属性的遍历\" class=\"headerlink\" title=\"属性的遍历\"></a>属性的遍历</h2><p>ES6中一共有5种方法可以遍历对象的属性</p>\n<h4 id=\"（1）for…in\"><a href=\"#（1）for…in\" class=\"headerlink\" title=\"（1）for…in\"></a>（1）for…in</h4><p>遍历对象自身和继承的可枚举属性</p>\n<h4 id=\"（2）Object-keys-obj\"><a href=\"#（2）Object-keys-obj\" class=\"headerlink\" title=\"（2）Object.keys(obj)\"></a>（2）Object.keys(obj)</h4><p>返回一个数组，包括对象自身的（不含继承）所有可枚举属性（不包括Symbol属性）</p>\n<h4 id=\"（3）Object-getOwnPropertyNames-obj\"><a href=\"#（3）Object-getOwnPropertyNames-obj\" class=\"headerlink\" title=\"（3）Object.getOwnPropertyNames(obj)\"></a>（3）Object.getOwnPropertyNames(obj)</h4><p>返回一个数组，包含对象自身的所有属性（不包括Symbol属性）</p>\n<h4 id=\"（4）Object-getOwnPropertySymbols-obj\"><a href=\"#（4）Object-getOwnPropertySymbols-obj\" class=\"headerlink\" title=\"（4）Object.getOwnPropertySymbols(obj)\"></a>（4）Object.getOwnPropertySymbols(obj)</h4><p>返回一个数组，包含对象自身的所有Symbol属性</p>\n<h4 id=\"（5）Reflect-ownKeys-obj\"><a href=\"#（5）Reflect-ownKeys-obj\" class=\"headerlink\" title=\"（5）Reflect.ownKeys(obj)\"></a>（5）Reflect.ownKeys(obj)</h4><p>返回一个数组，包含对象自身的所有属性，不管是属性名还是Symbol还是字符串，也不管是否可枚举。</p>\n<p>上面5种方法遍历对象属性，都遵循同样的属性遍历的次序规则。</p>\n<ul>\n<li>首先遍历所有属性名为数值的字符的属性，按照数字排序；</li>\n<li>其次遍历所有属性名为字符串的属性，按照生成时间排序；</li>\n<li>最后遍历所有属性名为Symbol值得属性，按照生成时间排序；</li>\n</ul>\n<p>一句话概括：遍历规则为数值 &gt; 字符串 &gt; Symbol；数值排序规则为数字，剩下两个排序规则为生成顺序；</p>\n<h2 id=\"proto-属性，Objects-setPrototypeOf-Object-getPrototypeOf\"><a href=\"#proto-属性，Objects-setPrototypeOf-Object-getPrototypeOf\" class=\"headerlink\" title=\"__proto__属性，Objects.setPrototypeOf(), Object.getPrototypeOf()\"></a><code>__proto__</code>属性，<code>Objects.setPrototypeOf()</code>, <code>Object.getPrototypeOf()</code></h2><h4 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__属性\"></a><code>__proto__</code>属性</h4><p>用来读取或设置当前对象的<code>prototype</code>对象。目前所有浏览器都支持这个特性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;...&#125;<br>&#125;;<br>obj.<span class=\"hljs-property\">__proto__</span> = someOtherObj;<br><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(someOtherObj);<br>obj.<span class=\"hljs-property\">method</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;...&#125;;<br></code></pre></td></tr></table></figure>\n<p>这里和Python一样，使用双下划线标注的属性内部属性，而不是一个正式对外的API。因此在正式使用时不建议显示的设置。而是用<code>Object.setPrototypeOf()</code>、<code>Object.getPrototypeOf()</code>、<code>Object.create()</code>代替。</p>\n<h4 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a><code>Object.setPrototypeOf()</code></h4><p>用来设置对象的<code>prototype</code>对象。是ES6推荐的设置原型对象的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> proto = &#123;&#125;;<br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">10</span>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(obj, proto);<br><br>proto.<span class=\"hljs-property\">y</span> = <span class=\"hljs-number\">20</span>;<br>proto.<span class=\"hljs-property\">z</span> = <span class=\"hljs-number\">40</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">x</span>) <span class=\"hljs-comment\">// 10</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">y</span>) <span class=\"hljs-comment\">// 20</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">z</span>) <span class=\"hljs-comment\">// 40</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a><code>Object.getPrototypeOf()</code></h4><p>与上面的set方法相反，用来获取一个对象的prototype对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Rectangle</span> () &#123;<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> rec = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Rectangle</span>();<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(rec) === <span class=\"hljs-title class_\">Rectangle</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(rec, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(rec) === <span class=\"hljs-title class_\">Rectangle</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-values-Object-entries\"><a href=\"#Object-values-Object-entries\" class=\"headerlink\" title=\"Object.values(), Object.entries()\"></a><code>Object.values()</code>, <code>Object.entries()</code></h2><h4 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a><code>Object.keys()</code></h4><p>返回一个数组，成员是参数对象自身的所有可遍历属性的键名（不含继承）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)<br><span class=\"hljs-comment\">// [&quot;foo&quot;, &quot;baz&quot;]</span><br></code></pre></td></tr></table></figure>\n<p>目前ES7有一个新提案，引入了跟<code>Object.keys()</code>配套的<code>Object.values</code>和<code>Object.entries</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123; keys, values, entries &#125; = <span class=\"hljs-title class_\">Object</span>;<br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key  <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">keys</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">values</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><span class=\"hljs-comment\">// 1, 2, 3</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([key, value]);<br>&#125;<br><span class=\"hljs-comment\">//[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-values\"><a href=\"#Object-values\" class=\"headerlink\" title=\"Object.values()\"></a><code>Object.values()</code></h4><p>返回一个数组，成员是参数对象自身的（不含继承）所有可遍历（enumerable）属性的键值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(obj);<br><span class=\"hljs-comment\">// [&#x27;baz&#x27;, 42]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-entries\"><a href=\"#Object-entries\" class=\"headerlink\" title=\"Object.entries\"></a><code>Object.entries</code></h4><p>返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj);<br><span class=\"hljs-comment\">// [ [ &#x27;foo&#x27;, &#x27;bar&#x27; ], [ &#x27;baz&#x27;, 42 ] ]</span><br></code></pre></td></tr></table></figure>\n<p>基本用途为遍历对象的属性，也可以将对象转换为Map</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">one</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">two</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k, v] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(k)&#125;</span> : <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(v)&#125;</span>`</span>)<br>&#125;<br><span class=\"hljs-comment\">// &quot;one&quot;: 1</span><br><span class=\"hljs-comment\">// &quot;two&quot;: 2</span><br><br><span class=\"hljs-comment\">// 另一个用途是将对象转换为Map</span><br><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj));<br>map <span class=\"hljs-comment\">// Map &#123;foo: &quot;bar&quot;, baz: 42 &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"对象的扩展运算符\"><a href=\"#对象的扩展运算符\" class=\"headerlink\" title=\"对象的扩展运算符\"></a>对象的扩展运算符</h2><p>之前提到过扩展运算符（<code>...</code>），在对象中也有运用。</p>\n<h4 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到指定的对象上。所有的键和值，都会拷贝到新对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123; x, y, ...z &#125; = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">4</span> &#125;;<br>x <span class=\"hljs-comment\">// 1</span><br>y <span class=\"hljs-comment\">// 2</span><br>z <span class=\"hljs-comment\">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>解构必须是最后一个参数，否则会报错，这和Java是完全一样的。注意一点：解构赋值时浅拷贝，如果一个键的值是复合类型的值（数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span> &#125;&#125;;<br><span class=\"hljs-keyword\">let</span> &#123;...x&#125; = obj;<br>obj.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>x.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2 (浅拷贝无疑了)</span><br></code></pre></td></tr></table></figure>\n<p>另外解构赋值不会拷贝继承自原型对象的属性。下面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>\n<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">baseFunction</span> (&#123;a, b&#125;) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">wrapperFunction</span> (&#123;x, y, ...restConfig&#125;) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">baseFunction</span>(restConfig);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> z = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">4</span> &#125;;<br><span class=\"hljs-keyword\">let</span> n = &#123; ...z &#125;;<br>n <span class=\"hljs-comment\">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>还可以用于合并两个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> ab = &#123; ...a, ...b &#125;;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">let</span> ab = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, a, b);<br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors()\"></a><code>Object.getOwnPropertyDescriptors()</code></h2><p>前面提到了：这个方法是用来返回某个对象属性的描述对象的。ES7有个提案：返回指定对象所有自身属性（非继承性——的描述对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">123</span>,<br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">bar</span>() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span> &#125;<br>&#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescription</span>(obj)<br><br><span class=\"hljs-comment\">// 返回结果如下</span><br>&#123;<br>  <span class=\"hljs-attr\">foo</span>: &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">123</span>, <span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span> &#125;,<br>  <span class=\"hljs-attr\">bar</span>: &#123;<br>    <span class=\"hljs-attr\">get</span>: [<span class=\"hljs-title class_\">Function</span>: get bar],<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-literal\">undefined</span>,<br>    <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>该方法实现的目的：主要是为了解决<code>Object.assing()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。结合<code>Object.defineProperties</code>方法就可以实现正确拷贝。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> source = &#123;<br>    set foo (value) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> target2 = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperties</span>(target2, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(source));<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target2, <span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><br><span class=\"hljs-comment\">// 返回结果</span><br>&#123;                           <br>  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-literal\">undefined</span>,           <br>  <span class=\"hljs-attr\">set</span>: [<span class=\"hljs-title class_\">Function</span>: set foo], <br>  <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,         <br>  <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span>        <br>&#125;                           <br></code></pre></td></tr></table></figure>\n<p>将上面两部分代码合并起来，就是这样。是不是突然觉得眼熟悉？（就是React Thunk的使用方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shallowMerge</span> = (<span class=\"hljs-params\">target, source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperties</span>(<br>\ttarget,<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(source)<br>);<br><br><span class=\"hljs-comment\">// 浅拷贝对象</span><br><span class=\"hljs-keyword\">const</span> clone = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),<br>                           <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shallowClone</span> = (<span class=\"hljs-params\">obj</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<br>\t<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj)<br>);<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 编码风格","date":"2022-02-17T14:21:12.000Z","updated":"2022-02-17T14:21:12.000Z","_content":"\n# 编程风格\n\n## 块级作用域\n\n### （1）使用`let`来替代`var`\n\n原因之前讲过，`let`是ES6新增的关键字，和`var`一样可以用来声明变量，主要推荐用`let`的原因是：\n\n- `let`和`var`完全等价，主要是`let`必须先声明再使用；\n- `let`不存在变量提升；因此不会给程序带来副作用；\n\n\n\n### （2）全局常量和线程安全\n\n`let`和`const`主要先使用`const`，理由如下：\n\n- `const`可以提醒阅读代码的人，这个变量不应该被改变；\n- `const`符合函数式编程思想，运算不改变值，只是新建值；\n- JavaScript编译器会对`const`进行优化，这样有利于提供程序的运行效率；\n\n\n\n### （3）字符串\n\n静态字符串一律使用单引号或引号，不使用双引号。动态字符串使用反引号；\n\n```javascript\n// bad\nconst a = \"foobar\";\nconst b = 'foo' + a + 'bar';\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = 'foobar';\nconst b = `foo${a}bar`;\n```\n\n\n\n### （4）解构赋值\n\n遵循下列几个原则：\n\n- 使用数组成员对变量赋值时，优先使用解构赋值；\n- 函数的参数如果是对象成员，优先使用解构赋值；\n- 函数返回多个值，优先使用对象的结构赋值，而不是数组的解构赋值；这样便于以后添加返回值，以及更改返回值的顺序；\n\n例子如下：\n\n```javascript\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr; // 这样它会拿出arr的第一个和第二个值\n```\n\n```javascript\n// bad\nfunction getFullName(user) {\n    const firstName = user.firstName;\n    const secondName = user.secondName;\n}\n\n// good\nfunction getFullName(obj) {\n    const {firstName, lastName} = obj;\n}\n\n// best\nfunction getFullName({firstName, lastName}) {\n    \n}\n```\n\n```javascript\n// bad\nfunction processInput(input) {\n    return [left, right, top, buttom];\n}\n\n// good\nfunction processInput(input) {\n    return {left, right, top, buttom};\n}\nconst {left, right} = processInput(input);\n```\n\n\n\n### （5）对象\n\n单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象；最后一个成员以逗号结尾；\n\n```javascript\n// bad\nconst a = { k1: v1, k2: v2, };\nconst b = {\n    k1: v1,\n    k2: v2\n};\n\n// good\nconst a = { k1: v1, k2: v2 };\nconst b = {\n    k1: v1,\n    k2: v2,\n};\n```\n\n对象尽量静态化，一旦定义就不得随意添加新的属性。如果添加属性不可避免，要使用`Object.assign()`方法；\n\n```javascript\n// bad\nconst a = {};\na.x = 3;\n\n// if reshape unavoidable\nconst a = {};\nObject.assign(a, {x: 3});\n\n// good\ncont a = { x: null };\na.x = 3;\n```\n\n如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义；\n\nPS: [需要计算的内容]：这个语法就叫做计算属性，方括号中的内容需要通过动态计算得到；\n\n```javascript\n// bad\nconst obj = {\n    id: 5,\n    name: 'San Francisco'\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n    id: 5,\n    name: 'San Francisco',\n    [getKey('enabled')]: true\n};\n```\n\n\n\n### （6）数组\n\n使用扩展运算符(...)拷贝数组：\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n    itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n使用`Array.from`方法将类似数组的对象转换为数组；\n\n```javascript\nconst foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n```\n\n\n\n### （7）函数\n\n立即执行函数可以写成箭头函数的形式\n\n```javascript\n(() => {\n    console.log('Welcome to the Internet.')\n})();\n```\n\n需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this\n\n```javascript\n// bad\n[1, 2, 3].map(function(x){\n    return x * x;\n});\n\n// good\n[1, 2, 3].map((x) => {\n    return x * x;\n});\n\n// best\n[1, 2, 3].map(x => x * x);\n```\n\n箭头函数取代`Function.prototype.bind`，不再用self/_this/that绑定this。\n\n```javascript\n// bad\nconst self = this;\nconst boundMethod = function(...params) {\n    return method.apply(self, params);\n}\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) => method.apply(this, params);\n```\n\n简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体比较复杂，行数较多，还是应该采用传统的函数写法。\n\n```javascript\n/* 用rest运算符代替arguments */\n// bad\nfunction concatenateAll() {\n    const args = Array.prototype.slice.call(arguments);\n    return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n    return args.join('');\n}\n\n/* 使用默认值语法设置函数参数的默认值 */\n// bad\nfunction handleThings(opts) {\n    opts = opts || {};\n}\n\n// good\nfunction handleThingd(opts = {}) {\n    // ...\n}\n```\n\n\n\n\n\n### （8）Map结构\n\n只有模拟现实世界的实体对象，才使用Object。如果只是想要`key: value`的数据结构，使用Map结构。因为Map有内建的遍历机制。\n\n```javascript\nlet map = new Map(arr);\n\nfor (let key of map.keys()) {\n    console.log(key);\n}\n\nfor (let value of map.values()) {\n    console.log(value);\n}\n\nfor (let item of map.entries()) {\n    console.log(item[0], item[1]);\n}\n```\n\n\n\n### （9）Class\n\n总是使用Class来替代`prototype`的操作，因为Class写法更简洁，更易于理解；这个就不需要过多解释了。\n\n```javascript\nclass Queue {\n    constructor(contents = []) {\n        this._queue = [...contents];\n    }\n    pop () {\n        const value = this._queue[0];\n        this._queue.splice(0, 1);\n        return value;\n    }\n}\n```\n\n使用`extends`实现继承，因为这样更简单，不会破坏`instanceof`运算的危险，而且如果你是后端程序员，会更加理解这段逻辑想要表达的实际含义。\n\n```javascript\nclass PeekableQueue extends Queue {\n    peek() {\n        return this._queue[0];\n    }\n}\n```\n\n\n\n### （10）模块\n\n首先，Module语法是JavaScript模块的标准写法。坚持使用这种写法。使用`import`取代`require`。\n\n```javascript\n// bad\nconst moduleA = require('moduleA');\nconst func1 = moduleA.func1;\nconst func2 = moduleA.func2;\n\n// good\nimport { func1, func2 } from 'moduleA';\n```\n\n使用`export`取代`module.exports`；\n\n```javascript\n// ES6 Style\nimport React from 'react';\n\nconst Breadcrumbs = React.createClass({\n    render() {\n        return <nav />;\n    }\n});\n\nexport default Breadcrumbs;\n```\n\n\n\n### （11）ESLint使用\n\nESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。所有配置项都写在`.eslintrc`文件中，因此要启用eslint只需要在配置文件中开启相应的规则就可以。如果你是用脚手架工具新建的项目，一般都会集成eslint。\n","source":"_posts/javascript/es6-program-style.md","raw":"---\ntitle: ES6 编码风格\ndate: 2022-02-17 22:21:12\nupdated: 2022-02-17 22:21:12\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 编程风格\n\n## 块级作用域\n\n### （1）使用`let`来替代`var`\n\n原因之前讲过，`let`是ES6新增的关键字，和`var`一样可以用来声明变量，主要推荐用`let`的原因是：\n\n- `let`和`var`完全等价，主要是`let`必须先声明再使用；\n- `let`不存在变量提升；因此不会给程序带来副作用；\n\n\n\n### （2）全局常量和线程安全\n\n`let`和`const`主要先使用`const`，理由如下：\n\n- `const`可以提醒阅读代码的人，这个变量不应该被改变；\n- `const`符合函数式编程思想，运算不改变值，只是新建值；\n- JavaScript编译器会对`const`进行优化，这样有利于提供程序的运行效率；\n\n\n\n### （3）字符串\n\n静态字符串一律使用单引号或引号，不使用双引号。动态字符串使用反引号；\n\n```javascript\n// bad\nconst a = \"foobar\";\nconst b = 'foo' + a + 'bar';\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = 'foobar';\nconst b = `foo${a}bar`;\n```\n\n\n\n### （4）解构赋值\n\n遵循下列几个原则：\n\n- 使用数组成员对变量赋值时，优先使用解构赋值；\n- 函数的参数如果是对象成员，优先使用解构赋值；\n- 函数返回多个值，优先使用对象的结构赋值，而不是数组的解构赋值；这样便于以后添加返回值，以及更改返回值的顺序；\n\n例子如下：\n\n```javascript\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr; // 这样它会拿出arr的第一个和第二个值\n```\n\n```javascript\n// bad\nfunction getFullName(user) {\n    const firstName = user.firstName;\n    const secondName = user.secondName;\n}\n\n// good\nfunction getFullName(obj) {\n    const {firstName, lastName} = obj;\n}\n\n// best\nfunction getFullName({firstName, lastName}) {\n    \n}\n```\n\n```javascript\n// bad\nfunction processInput(input) {\n    return [left, right, top, buttom];\n}\n\n// good\nfunction processInput(input) {\n    return {left, right, top, buttom};\n}\nconst {left, right} = processInput(input);\n```\n\n\n\n### （5）对象\n\n单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象；最后一个成员以逗号结尾；\n\n```javascript\n// bad\nconst a = { k1: v1, k2: v2, };\nconst b = {\n    k1: v1,\n    k2: v2\n};\n\n// good\nconst a = { k1: v1, k2: v2 };\nconst b = {\n    k1: v1,\n    k2: v2,\n};\n```\n\n对象尽量静态化，一旦定义就不得随意添加新的属性。如果添加属性不可避免，要使用`Object.assign()`方法；\n\n```javascript\n// bad\nconst a = {};\na.x = 3;\n\n// if reshape unavoidable\nconst a = {};\nObject.assign(a, {x: 3});\n\n// good\ncont a = { x: null };\na.x = 3;\n```\n\n如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义；\n\nPS: [需要计算的内容]：这个语法就叫做计算属性，方括号中的内容需要通过动态计算得到；\n\n```javascript\n// bad\nconst obj = {\n    id: 5,\n    name: 'San Francisco'\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n    id: 5,\n    name: 'San Francisco',\n    [getKey('enabled')]: true\n};\n```\n\n\n\n### （6）数组\n\n使用扩展运算符(...)拷贝数组：\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n    itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n使用`Array.from`方法将类似数组的对象转换为数组；\n\n```javascript\nconst foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n```\n\n\n\n### （7）函数\n\n立即执行函数可以写成箭头函数的形式\n\n```javascript\n(() => {\n    console.log('Welcome to the Internet.')\n})();\n```\n\n需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this\n\n```javascript\n// bad\n[1, 2, 3].map(function(x){\n    return x * x;\n});\n\n// good\n[1, 2, 3].map((x) => {\n    return x * x;\n});\n\n// best\n[1, 2, 3].map(x => x * x);\n```\n\n箭头函数取代`Function.prototype.bind`，不再用self/_this/that绑定this。\n\n```javascript\n// bad\nconst self = this;\nconst boundMethod = function(...params) {\n    return method.apply(self, params);\n}\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) => method.apply(this, params);\n```\n\n简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体比较复杂，行数较多，还是应该采用传统的函数写法。\n\n```javascript\n/* 用rest运算符代替arguments */\n// bad\nfunction concatenateAll() {\n    const args = Array.prototype.slice.call(arguments);\n    return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n    return args.join('');\n}\n\n/* 使用默认值语法设置函数参数的默认值 */\n// bad\nfunction handleThings(opts) {\n    opts = opts || {};\n}\n\n// good\nfunction handleThingd(opts = {}) {\n    // ...\n}\n```\n\n\n\n\n\n### （8）Map结构\n\n只有模拟现实世界的实体对象，才使用Object。如果只是想要`key: value`的数据结构，使用Map结构。因为Map有内建的遍历机制。\n\n```javascript\nlet map = new Map(arr);\n\nfor (let key of map.keys()) {\n    console.log(key);\n}\n\nfor (let value of map.values()) {\n    console.log(value);\n}\n\nfor (let item of map.entries()) {\n    console.log(item[0], item[1]);\n}\n```\n\n\n\n### （9）Class\n\n总是使用Class来替代`prototype`的操作，因为Class写法更简洁，更易于理解；这个就不需要过多解释了。\n\n```javascript\nclass Queue {\n    constructor(contents = []) {\n        this._queue = [...contents];\n    }\n    pop () {\n        const value = this._queue[0];\n        this._queue.splice(0, 1);\n        return value;\n    }\n}\n```\n\n使用`extends`实现继承，因为这样更简单，不会破坏`instanceof`运算的危险，而且如果你是后端程序员，会更加理解这段逻辑想要表达的实际含义。\n\n```javascript\nclass PeekableQueue extends Queue {\n    peek() {\n        return this._queue[0];\n    }\n}\n```\n\n\n\n### （10）模块\n\n首先，Module语法是JavaScript模块的标准写法。坚持使用这种写法。使用`import`取代`require`。\n\n```javascript\n// bad\nconst moduleA = require('moduleA');\nconst func1 = moduleA.func1;\nconst func2 = moduleA.func2;\n\n// good\nimport { func1, func2 } from 'moduleA';\n```\n\n使用`export`取代`module.exports`；\n\n```javascript\n// ES6 Style\nimport React from 'react';\n\nconst Breadcrumbs = React.createClass({\n    render() {\n        return <nav />;\n    }\n});\n\nexport default Breadcrumbs;\n```\n\n\n\n### （11）ESLint使用\n\nESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。所有配置项都写在`.eslintrc`文件中，因此要启用eslint只需要在配置文件中开启相应的规则就可以。如果你是用脚手架工具新建的项目，一般都会集成eslint。\n","slug":"javascript/es6-program-style","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vi001u4f611e41hsee","content":"<h1 id=\"编程风格\"><a href=\"#编程风格\" class=\"headerlink\" title=\"编程风格\"></a>编程风格</h1><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><h3 id=\"（1）使用let来替代var\"><a href=\"#（1）使用let来替代var\" class=\"headerlink\" title=\"（1）使用let来替代var\"></a>（1）使用<code>let</code>来替代<code>var</code></h3><p>原因之前讲过，<code>let</code>是ES6新增的关键字，和<code>var</code>一样可以用来声明变量，主要推荐用<code>let</code>的原因是：</p>\n<ul>\n<li><code>let</code>和<code>var</code>完全等价，主要是<code>let</code>必须先声明再使用；</li>\n<li><code>let</code>不存在变量提升；因此不会给程序带来副作用；</li>\n</ul>\n<h3 id=\"（2）全局常量和线程安全\"><a href=\"#（2）全局常量和线程安全\" class=\"headerlink\" title=\"（2）全局常量和线程安全\"></a>（2）全局常量和线程安全</h3><p><code>let</code>和<code>const</code>主要先使用<code>const</code>，理由如下：</p>\n<ul>\n<li><code>const</code>可以提醒阅读代码的人，这个变量不应该被改变；</li>\n<li><code>const</code>符合函数式编程思想，运算不改变值，只是新建值；</li>\n<li>JavaScript编译器会对<code>const</code>进行优化，这样有利于提供程序的运行效率；</li>\n</ul>\n<h3 id=\"（3）字符串\"><a href=\"#（3）字符串\" class=\"headerlink\" title=\"（3）字符串\"></a>（3）字符串</h3><p>静态字符串一律使用单引号或引号，不使用双引号。动态字符串使用反引号；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&quot;foobar&quot;</span>;<br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&#x27;foo&#x27;</span> + a + <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><br><span class=\"hljs-comment\">// acceptable</span><br><span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-string\">`foobar`</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&#x27;foobar&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">`foo<span class=\"hljs-subst\">$&#123;a&#125;</span>bar`</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）解构赋值\"><a href=\"#（4）解构赋值\" class=\"headerlink\" title=\"（4）解构赋值\"></a>（4）解构赋值</h3><p>遵循下列几个原则：</p>\n<ul>\n<li>使用数组成员对变量赋值时，优先使用解构赋值；</li>\n<li>函数的参数如果是对象成员，优先使用解构赋值；</li>\n<li>函数返回多个值，优先使用对象的结构赋值，而不是数组的解构赋值；这样便于以后添加返回值，以及更改返回值的顺序；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> first = arr[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">const</span> second = arr[<span class=\"hljs-number\">1</span>];<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> [first, second] = arr; <span class=\"hljs-comment\">// 这样它会拿出arr的第一个和第二个值</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">user</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> firstName = user.<span class=\"hljs-property\">firstName</span>;<br>    <span class=\"hljs-keyword\">const</span> secondName = user.<span class=\"hljs-property\">secondName</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123;firstName, lastName&#125; = obj;<br>&#125;<br><br><span class=\"hljs-comment\">// best</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">&#123;firstName, lastName&#125;</span>) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processInput</span>(<span class=\"hljs-params\">input</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [left, right, top, buttom];<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processInput</span>(<span class=\"hljs-params\">input</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;left, right, top, buttom&#125;;<br>&#125;<br><span class=\"hljs-keyword\">const</span> &#123;left, right&#125; = <span class=\"hljs-title function_\">processInput</span>(input);<br></code></pre></td></tr></table></figure>\n<h3 id=\"（5）对象\"><a href=\"#（5）对象\" class=\"headerlink\" title=\"（5）对象\"></a>（5）对象</h3><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象；最后一个成员以逗号结尾；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = &#123; <span class=\"hljs-attr\">k1</span>: v1, <span class=\"hljs-attr\">k2</span>: v2, &#125;;<br><span class=\"hljs-keyword\">const</span> b = &#123;<br>    <span class=\"hljs-attr\">k1</span>: v1,<br>    <span class=\"hljs-attr\">k2</span>: v2<br>&#125;;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> a = &#123; <span class=\"hljs-attr\">k1</span>: v1, <span class=\"hljs-attr\">k2</span>: v2 &#125;;<br><span class=\"hljs-keyword\">const</span> b = &#123;<br>    <span class=\"hljs-attr\">k1</span>: v1,<br>    <span class=\"hljs-attr\">k2</span>: v2,<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>对象尽量静态化，一旦定义就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign()</code>方法；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br>a.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-comment\">// if reshape unavoidable</span><br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;);<br><br><span class=\"hljs-comment\">// good</span><br>cont a = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-literal\">null</span> &#125;;<br>a.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义；</p>\n<p>PS: [需要计算的内容]：这个语法就叫做计算属性，方括号中的内容需要通过动态计算得到；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">5</span>,<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;San Francisco&#x27;</span><br>&#125;;<br>obj[<span class=\"hljs-title function_\">getKey</span>(<span class=\"hljs-string\">&#x27;enabled&#x27;</span>)] = <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">5</span>,<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;San Francisco&#x27;</span>,<br>    [<span class=\"hljs-title function_\">getKey</span>(<span class=\"hljs-string\">&#x27;enabled&#x27;</span>)]: <span class=\"hljs-literal\">true</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（6）数组\"><a href=\"#（6）数组\" class=\"headerlink\" title=\"（6）数组\"></a>（6）数组</h3><p>使用扩展运算符(…)拷贝数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> len = items.<span class=\"hljs-property\">length</span>;<br><span class=\"hljs-keyword\">const</span> itemsCopy = [];<br><span class=\"hljs-keyword\">let</span> i;<br><br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++) &#123;<br>    itemsCopy[i] = items[i];<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> itemsCopy = [...items];<br></code></pre></td></tr></table></figure>\n<p>使用<code>Array.from</code>方法将类似数组的对象转换为数组；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;.foo&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> nodes = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(foo);<br></code></pre></td></tr></table></figure>\n<h3 id=\"（7）函数\"><a href=\"#（7）函数\" class=\"headerlink\" title=\"（7）函数\"></a>（7）函数</h3><p>立即执行函数可以写成箭头函数的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Welcome to the Internet.&#x27;</span>)<br>&#125;)();<br></code></pre></td></tr></table></figure>\n<p>需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;);<br><br><span class=\"hljs-comment\">// good</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;);<br><br><span class=\"hljs-comment\">// best</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * x);<br></code></pre></td></tr></table></figure>\n<p>箭头函数取代<code>Function.prototype.bind</code>，不再用self/_this/that绑定this。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-variable language_\">this</span>;<br><span class=\"hljs-keyword\">const</span> boundMethod = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...params</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> method.<span class=\"hljs-title function_\">apply</span>(self, params);<br>&#125;<br><br><span class=\"hljs-comment\">// acceptable</span><br><span class=\"hljs-keyword\">const</span> boundMethod = method.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-comment\">// best</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">boundMethod</span> = (<span class=\"hljs-params\">...params</span>) =&gt; method.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, params);<br></code></pre></td></tr></table></figure>\n<p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体比较复杂，行数较多，还是应该采用传统的函数写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* 用rest运算符代替arguments */</span><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concatenateAll</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>    <span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concatenateAll</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">/* 使用默认值语法设置函数参数的默认值 */</span><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleThings</span>(<span class=\"hljs-params\">opts</span>) &#123;<br>    opts = opts || &#123;&#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleThingd</span>(<span class=\"hljs-params\">opts = &#123;&#125;</span>) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（8）Map结构\"><a href=\"#（8）Map结构\" class=\"headerlink\" title=\"（8）Map结构\"></a>（8）Map结构</h3><p>只有模拟现实世界的实体对象，才使用Object。如果只是想要<code>key: value</code>的数据结构，使用Map结构。因为Map有内建的遍历机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item[<span class=\"hljs-number\">0</span>], item[<span class=\"hljs-number\">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（9）Class\"><a href=\"#（9）Class\" class=\"headerlink\" title=\"（9）Class\"></a>（9）Class</h3><p>总是使用Class来替代<code>prototype</code>的操作，因为Class写法更简洁，更易于理解；这个就不需要过多解释了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">contents = []</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span> = [...contents];<br>    &#125;<br>    pop () &#123;<br>        <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用<code>extends</code>实现继承，因为这样更简单，不会破坏<code>instanceof</code>运算的危险，而且如果你是后端程序员，会更加理解这段逻辑想要表达的实际含义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PeekableQueue</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Queue</span> &#123;<br>    <span class=\"hljs-title function_\">peek</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>[<span class=\"hljs-number\">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（10）模块\"><a href=\"#（10）模块\" class=\"headerlink\" title=\"（10）模块\"></a>（10）模块</h3><p>首先，Module语法是JavaScript模块的标准写法。坚持使用这种写法。使用<code>import</code>取代<code>require</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> moduleA = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;moduleA&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> func1 = moduleA.<span class=\"hljs-property\">func1</span>;<br><span class=\"hljs-keyword\">const</span> func2 = moduleA.<span class=\"hljs-property\">func2</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">import</span> &#123; func1, func2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;moduleA&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>使用<code>export</code>取代<code>module.exports</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6 Style</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Breadcrumbs</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createClass</span>(&#123;<br>    <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> /&gt;</span></span>;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Breadcrumbs</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（11）ESLint使用\"><a href=\"#（11）ESLint使用\" class=\"headerlink\" title=\"（11）ESLint使用\"></a>（11）ESLint使用</h3><p>ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。所有配置项都写在<code>.eslintrc</code>文件中，因此要启用eslint只需要在配置文件中开启相应的规则就可以。如果你是用脚手架工具新建的项目，一般都会集成eslint。</p>\n","site":{"data":{}},"wordcount":4445,"excerpt":"","more":"<h1 id=\"编程风格\"><a href=\"#编程风格\" class=\"headerlink\" title=\"编程风格\"></a>编程风格</h1><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><h3 id=\"（1）使用let来替代var\"><a href=\"#（1）使用let来替代var\" class=\"headerlink\" title=\"（1）使用let来替代var\"></a>（1）使用<code>let</code>来替代<code>var</code></h3><p>原因之前讲过，<code>let</code>是ES6新增的关键字，和<code>var</code>一样可以用来声明变量，主要推荐用<code>let</code>的原因是：</p>\n<ul>\n<li><code>let</code>和<code>var</code>完全等价，主要是<code>let</code>必须先声明再使用；</li>\n<li><code>let</code>不存在变量提升；因此不会给程序带来副作用；</li>\n</ul>\n<h3 id=\"（2）全局常量和线程安全\"><a href=\"#（2）全局常量和线程安全\" class=\"headerlink\" title=\"（2）全局常量和线程安全\"></a>（2）全局常量和线程安全</h3><p><code>let</code>和<code>const</code>主要先使用<code>const</code>，理由如下：</p>\n<ul>\n<li><code>const</code>可以提醒阅读代码的人，这个变量不应该被改变；</li>\n<li><code>const</code>符合函数式编程思想，运算不改变值，只是新建值；</li>\n<li>JavaScript编译器会对<code>const</code>进行优化，这样有利于提供程序的运行效率；</li>\n</ul>\n<h3 id=\"（3）字符串\"><a href=\"#（3）字符串\" class=\"headerlink\" title=\"（3）字符串\"></a>（3）字符串</h3><p>静态字符串一律使用单引号或引号，不使用双引号。动态字符串使用反引号；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&quot;foobar&quot;</span>;<br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&#x27;foo&#x27;</span> + a + <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><br><span class=\"hljs-comment\">// acceptable</span><br><span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-string\">`foobar`</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&#x27;foobar&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">`foo<span class=\"hljs-subst\">$&#123;a&#125;</span>bar`</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）解构赋值\"><a href=\"#（4）解构赋值\" class=\"headerlink\" title=\"（4）解构赋值\"></a>（4）解构赋值</h3><p>遵循下列几个原则：</p>\n<ul>\n<li>使用数组成员对变量赋值时，优先使用解构赋值；</li>\n<li>函数的参数如果是对象成员，优先使用解构赋值；</li>\n<li>函数返回多个值，优先使用对象的结构赋值，而不是数组的解构赋值；这样便于以后添加返回值，以及更改返回值的顺序；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> first = arr[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">const</span> second = arr[<span class=\"hljs-number\">1</span>];<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> [first, second] = arr; <span class=\"hljs-comment\">// 这样它会拿出arr的第一个和第二个值</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">user</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> firstName = user.<span class=\"hljs-property\">firstName</span>;<br>    <span class=\"hljs-keyword\">const</span> secondName = user.<span class=\"hljs-property\">secondName</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123;firstName, lastName&#125; = obj;<br>&#125;<br><br><span class=\"hljs-comment\">// best</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">&#123;firstName, lastName&#125;</span>) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processInput</span>(<span class=\"hljs-params\">input</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [left, right, top, buttom];<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processInput</span>(<span class=\"hljs-params\">input</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;left, right, top, buttom&#125;;<br>&#125;<br><span class=\"hljs-keyword\">const</span> &#123;left, right&#125; = <span class=\"hljs-title function_\">processInput</span>(input);<br></code></pre></td></tr></table></figure>\n<h3 id=\"（5）对象\"><a href=\"#（5）对象\" class=\"headerlink\" title=\"（5）对象\"></a>（5）对象</h3><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象；最后一个成员以逗号结尾；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = &#123; <span class=\"hljs-attr\">k1</span>: v1, <span class=\"hljs-attr\">k2</span>: v2, &#125;;<br><span class=\"hljs-keyword\">const</span> b = &#123;<br>    <span class=\"hljs-attr\">k1</span>: v1,<br>    <span class=\"hljs-attr\">k2</span>: v2<br>&#125;;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> a = &#123; <span class=\"hljs-attr\">k1</span>: v1, <span class=\"hljs-attr\">k2</span>: v2 &#125;;<br><span class=\"hljs-keyword\">const</span> b = &#123;<br>    <span class=\"hljs-attr\">k1</span>: v1,<br>    <span class=\"hljs-attr\">k2</span>: v2,<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>对象尽量静态化，一旦定义就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign()</code>方法；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br>a.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-comment\">// if reshape unavoidable</span><br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;);<br><br><span class=\"hljs-comment\">// good</span><br>cont a = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-literal\">null</span> &#125;;<br>a.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义；</p>\n<p>PS: [需要计算的内容]：这个语法就叫做计算属性，方括号中的内容需要通过动态计算得到；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">5</span>,<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;San Francisco&#x27;</span><br>&#125;;<br>obj[<span class=\"hljs-title function_\">getKey</span>(<span class=\"hljs-string\">&#x27;enabled&#x27;</span>)] = <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">5</span>,<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;San Francisco&#x27;</span>,<br>    [<span class=\"hljs-title function_\">getKey</span>(<span class=\"hljs-string\">&#x27;enabled&#x27;</span>)]: <span class=\"hljs-literal\">true</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（6）数组\"><a href=\"#（6）数组\" class=\"headerlink\" title=\"（6）数组\"></a>（6）数组</h3><p>使用扩展运算符(…)拷贝数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> len = items.<span class=\"hljs-property\">length</span>;<br><span class=\"hljs-keyword\">const</span> itemsCopy = [];<br><span class=\"hljs-keyword\">let</span> i;<br><br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++) &#123;<br>    itemsCopy[i] = items[i];<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> itemsCopy = [...items];<br></code></pre></td></tr></table></figure>\n<p>使用<code>Array.from</code>方法将类似数组的对象转换为数组；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;.foo&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> nodes = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(foo);<br></code></pre></td></tr></table></figure>\n<h3 id=\"（7）函数\"><a href=\"#（7）函数\" class=\"headerlink\" title=\"（7）函数\"></a>（7）函数</h3><p>立即执行函数可以写成箭头函数的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Welcome to the Internet.&#x27;</span>)<br>&#125;)();<br></code></pre></td></tr></table></figure>\n<p>需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;);<br><br><span class=\"hljs-comment\">// good</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;);<br><br><span class=\"hljs-comment\">// best</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * x);<br></code></pre></td></tr></table></figure>\n<p>箭头函数取代<code>Function.prototype.bind</code>，不再用self/_this/that绑定this。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-variable language_\">this</span>;<br><span class=\"hljs-keyword\">const</span> boundMethod = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...params</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> method.<span class=\"hljs-title function_\">apply</span>(self, params);<br>&#125;<br><br><span class=\"hljs-comment\">// acceptable</span><br><span class=\"hljs-keyword\">const</span> boundMethod = method.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-comment\">// best</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">boundMethod</span> = (<span class=\"hljs-params\">...params</span>) =&gt; method.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, params);<br></code></pre></td></tr></table></figure>\n<p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体比较复杂，行数较多，还是应该采用传统的函数写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* 用rest运算符代替arguments */</span><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concatenateAll</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>    <span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concatenateAll</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">/* 使用默认值语法设置函数参数的默认值 */</span><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleThings</span>(<span class=\"hljs-params\">opts</span>) &#123;<br>    opts = opts || &#123;&#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleThingd</span>(<span class=\"hljs-params\">opts = &#123;&#125;</span>) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（8）Map结构\"><a href=\"#（8）Map结构\" class=\"headerlink\" title=\"（8）Map结构\"></a>（8）Map结构</h3><p>只有模拟现实世界的实体对象，才使用Object。如果只是想要<code>key: value</code>的数据结构，使用Map结构。因为Map有内建的遍历机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item[<span class=\"hljs-number\">0</span>], item[<span class=\"hljs-number\">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（9）Class\"><a href=\"#（9）Class\" class=\"headerlink\" title=\"（9）Class\"></a>（9）Class</h3><p>总是使用Class来替代<code>prototype</code>的操作，因为Class写法更简洁，更易于理解；这个就不需要过多解释了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">contents = []</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span> = [...contents];<br>    &#125;<br>    pop () &#123;<br>        <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用<code>extends</code>实现继承，因为这样更简单，不会破坏<code>instanceof</code>运算的危险，而且如果你是后端程序员，会更加理解这段逻辑想要表达的实际含义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PeekableQueue</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Queue</span> &#123;<br>    <span class=\"hljs-title function_\">peek</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>[<span class=\"hljs-number\">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（10）模块\"><a href=\"#（10）模块\" class=\"headerlink\" title=\"（10）模块\"></a>（10）模块</h3><p>首先，Module语法是JavaScript模块的标准写法。坚持使用这种写法。使用<code>import</code>取代<code>require</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> moduleA = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;moduleA&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> func1 = moduleA.<span class=\"hljs-property\">func1</span>;<br><span class=\"hljs-keyword\">const</span> func2 = moduleA.<span class=\"hljs-property\">func2</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">import</span> &#123; func1, func2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;moduleA&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>使用<code>export</code>取代<code>module.exports</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6 Style</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Breadcrumbs</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createClass</span>(&#123;<br>    <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> /&gt;</span></span>;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Breadcrumbs</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（11）ESLint使用\"><a href=\"#（11）ESLint使用\" class=\"headerlink\" title=\"（11）ESLint使用\"></a>（11）ESLint使用</h3><p>ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。所有配置项都写在<code>.eslintrc</code>文件中，因此要启用eslint只需要在配置文件中开启相应的规则就可以。如果你是用脚手架工具新建的项目，一般都会集成eslint。</p>\n"},{"title":"ES6 Promise对象","date":"2022-02-17T14:20:53.000Z","updated":"2022-02-17T14:20:53.000Z","_content":"\n# Promise对象\n\n## 含义\n\nPromise是异步编程的一种解决方案，最早由社区提出和实现，ES6在次基础上统一了用法并且提供了Promise对象。\n\n所谓的Promise简单来说就是一个容器：里面保存着某个未来才会结束的事件的结果。从语法上说：Promise是一个对象，从它可以获取异步操作的消息。\n\nPromise对象由两个特点：\n\n- 对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这种状态；\n- 一旦状态发生了改变，就不会再变，任何时候都可以得到这个结果。\n\n因此：有了Promise，就可以将异步操作以同步的流程表达出来，避免了蹭蹭嵌套的回调函数。此外，Promise还提供了统一的接口，使得控制异步操作更加容易。\n\n但是Promise也存在缺点：例如一旦创建就会立即执行，无法中途取消，其次，如果不设置回调函数，Promise内部会抛出异常，不会反应到外部。最后，当处于Pending状态的时候，无法得知目前进展到哪一个阶段。\n\n## 基本用法\n\nES6规定，Promise对象是一个构造函数，用来生成Promise实例。\n\n```javascript\nvar promise = new Promise(function(resolve, reject){\n    if (a) {\n        resolve(value); // Pending -> Resolved\n    } else {\n        reject(error); // Pending -> Rejected\n    }\n});\n\npromise.then(function(value){\n    // success\n}, function(error){\n   // failure \n});\n```\n\nPromise新建后会立即执行\n\n```javascript\nlet promise = new Promise(function(resolve, reject){\n    console.log('Promise');\n    resolve();\n});\n\npromise.then(function() {\n    console.log('Resolved.')\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\n## Promise.prototype.then()\n\n`then`方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。该方法返回的是一个新的Promise实例。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\n\n```javascript\ngetJSON(\"/posts.json\").then(function(json){\n    return json.post;\n}).then(function(post){\n    // ...\n});\n```\n\n如果使用箭头函数，可以将上面代码进一步简化。\n\n```javascript\ngetJSON(\"/post/1.json\").then(\n\tpost => getJSON(post.commentURL)\n).then(\n\tcomments => console.log(\"Resolved: \" + comments),\n    err => console.log(\"Rejected: \", err)\n);\n```\n\n## Promise.prototype.catch()\n\n用于指定发生错误时的回调函数。\n\n```javascript\ngetJSON(\"/post.json\").then(function(posts){\n    // ...\n}).catch(function(error){\n    console.log('Error ', error);\n});\n```\n\n如果Promise状态已经变成了Resolved，再抛出错误就是无效的。\n\n```javascript\nvar promise = new Promise(function (resolve, reject){\n    resolve('ok');\n    throw new Error('test');\n});\n\npromise\n\t.then(function(value) {console.log(value)})\n\t.catch(function(value) {console.log(error)});\n// ok\n```\n\nPromise对象错误具有”冒泡“性质，会一直向后传递，直到被捕获为止。也就是说：错误总会被下一个`catch`语句捕获。\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post){\n    return getJSON(post.commentURL);\n}).then(function(comments){\n    // some code\n}).catch(function(error){\n    // error handler\n});\n```\n\n与传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码。但是Chrome不遵守这个规则，还是会抛出异常。好在Node.js提供了一个`unhandledRejection`事件，专门监听未捕获的`reject`错误。\n\n```javascript\nprocess.on('unhandledRejection', function(err, p){\n    console.error(err.stack);\n});\n\nvar someAsyncThing = function() {\n    return new Promise(function(resolve, reject){\n        resolve(x + 2);\n    });\n};\n\nsomeAsyncThing().then(function() {\n    console.log('everything is great');\n});\n```\n\n`catch`方法中还可以继续抛出异常。例如下面的代码：第二个`catch`方法用来捕获，前一个`catch`方法抛出错误。\n\n```javascript\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [ReferenceError: x is not defined]\n// carry on [ReferenceError: y is not defined]\n```\n\n## Promise.all()\n\n`Promise.all`方法用于将多个Promise实例，包装成一个新的Promise实例。语法如下：\n\n```javascript\nvar p = Promise.all([p1, p2, p3]);\n```\n\n例子如下：只有这6个实例的状态都变成了`fulfilled`，或者其中有一个状态变成了`rejected`，才会调用`Promise.all`方法后面的回调函数。\n\n```javascript\nvar promises = [2, 3, 5, 7, 11, 13].map(function (id){\n    return getJSON(\"/post/\" + id + \".json\");\n});\n\nPromise.all(promises).then(function (post){\n    // ...\n}).catch(function(reason){\n    // ...\n});\n```\n\n再例如下面这个例子：只有`booksPromise`和`userPromise`的结果都返回了，才会触发`pickTopRecommentations`这个回调函数。\n\n```javascript\nconst databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise.then(findAllBooks);\n\nconst userPromise = databasrPromise.then(getCurrentUser);\n\nPromise.all([\n    booksPromise,\n    userPromise\n]).then([books, user] => pickTopRecommentations(books, user));\n```\n\n## Promise.race()\n\n跟上面的作用一样，将多个Promise实例合成一个新的Promise实例。\n\n```\nvar p = Promise.race([p1, p2, p3]);\n```\n\n上面的例子中：只要三个状态有其中一个率先改变，新对象的状态就跟着一起改变。率先改变的Promise实例的返回值就是新Promise实例的回调函数的输入。\n\n下面提供一个实例：如果指定时间内没有获得结果，就将Promise的状态变为`reject`，否则就为`resolve`\n\n```javascript\nvar p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n])\np.then(response => console.log(response))\np.catch(error => console.log(error))\n```\n\n## Promise.resolve()\n\n有时需要将现有对象转为Promise对象，Promise.resolve()方法就起这个作用。\n\n```javascript\nPromise.resolve('foo')\n// equal to\nnew Promisr(resolve => resolve('foo'));\n```\n\n`Promise.resolve`方法的参数可以分为4种情况。\n\n- 参数是一个Promise实例：不做任何修改，原封不动返回实例\n- 参数是一个thenable对象：将该对象转换为Promise对象，然后立即执行`thenable`对象的`then`方法；\n- 参数不是具有then方法的对象，或根本就不是对象：返回一个新的`Promise`对象，状态为`Resolved`；\n- 不带有任何参数：直接返回一个状态为`Resolved`的Promise对象；\n\n## Promise.reject()\n\n也会返回一个新的Promise实例，该实例的状态为`rejected`。其参数用法和`Promise.resolve()`方法完全一致；\n\n## 两个有用的附加方法\n\n### done()\n\n提供一个`done`方法，总是处于回调链的尾端，保证抛出任何可能出现的错误\n\n### finally()\n\n用于指定不管Promise对象最后状态如何，都会执行的操作。与`Done`方法最大的区别，接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\n\n## 应用\n\n### 加载图片\n\n我们可以将图片加载写成一个Promise，一旦加载完成，`Promise`的状态就发生变化；\n\n### Generator函数结合Promise\n\n使用Generator函数管理函数流程，遇到异步操作的时候，通常返回一个`Promise`对象；\n\n### Promise.try()\n\n实际开发中还遇到一种情况：不知道或者不想区分函数f是同步还是异步，但还是想用Promise来处理。\n\n实际开发中提供了两种写法来实现这种效果：\n\n```javascript\n// async 写法\nconst f = () => console.log('now');\n(async () => f())();\nconsole.log('next');\n\n// Promise写法\nconst f = () => console.log('now');\n{\n    () => new Promise(\n    \tresolve => resolve(f())\n    )\n}();\nconsole.log('next');\n```\n\n需要注意的是`async () => f()`会吃掉`f()`抛出的异常，因此需要使用`promise.catch`方法来捕获异常；\n","source":"_posts/javascript/es6-promise.md","raw":"---\ntitle: ES6 Promise对象\ndate: 2022-02-17 22:20:53\nupdated: 2022-02-17 22:20:53\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Promise对象\n\n## 含义\n\nPromise是异步编程的一种解决方案，最早由社区提出和实现，ES6在次基础上统一了用法并且提供了Promise对象。\n\n所谓的Promise简单来说就是一个容器：里面保存着某个未来才会结束的事件的结果。从语法上说：Promise是一个对象，从它可以获取异步操作的消息。\n\nPromise对象由两个特点：\n\n- 对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这种状态；\n- 一旦状态发生了改变，就不会再变，任何时候都可以得到这个结果。\n\n因此：有了Promise，就可以将异步操作以同步的流程表达出来，避免了蹭蹭嵌套的回调函数。此外，Promise还提供了统一的接口，使得控制异步操作更加容易。\n\n但是Promise也存在缺点：例如一旦创建就会立即执行，无法中途取消，其次，如果不设置回调函数，Promise内部会抛出异常，不会反应到外部。最后，当处于Pending状态的时候，无法得知目前进展到哪一个阶段。\n\n## 基本用法\n\nES6规定，Promise对象是一个构造函数，用来生成Promise实例。\n\n```javascript\nvar promise = new Promise(function(resolve, reject){\n    if (a) {\n        resolve(value); // Pending -> Resolved\n    } else {\n        reject(error); // Pending -> Rejected\n    }\n});\n\npromise.then(function(value){\n    // success\n}, function(error){\n   // failure \n});\n```\n\nPromise新建后会立即执行\n\n```javascript\nlet promise = new Promise(function(resolve, reject){\n    console.log('Promise');\n    resolve();\n});\n\npromise.then(function() {\n    console.log('Resolved.')\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\n## Promise.prototype.then()\n\n`then`方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。该方法返回的是一个新的Promise实例。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\n\n```javascript\ngetJSON(\"/posts.json\").then(function(json){\n    return json.post;\n}).then(function(post){\n    // ...\n});\n```\n\n如果使用箭头函数，可以将上面代码进一步简化。\n\n```javascript\ngetJSON(\"/post/1.json\").then(\n\tpost => getJSON(post.commentURL)\n).then(\n\tcomments => console.log(\"Resolved: \" + comments),\n    err => console.log(\"Rejected: \", err)\n);\n```\n\n## Promise.prototype.catch()\n\n用于指定发生错误时的回调函数。\n\n```javascript\ngetJSON(\"/post.json\").then(function(posts){\n    // ...\n}).catch(function(error){\n    console.log('Error ', error);\n});\n```\n\n如果Promise状态已经变成了Resolved，再抛出错误就是无效的。\n\n```javascript\nvar promise = new Promise(function (resolve, reject){\n    resolve('ok');\n    throw new Error('test');\n});\n\npromise\n\t.then(function(value) {console.log(value)})\n\t.catch(function(value) {console.log(error)});\n// ok\n```\n\nPromise对象错误具有”冒泡“性质，会一直向后传递，直到被捕获为止。也就是说：错误总会被下一个`catch`语句捕获。\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post){\n    return getJSON(post.commentURL);\n}).then(function(comments){\n    // some code\n}).catch(function(error){\n    // error handler\n});\n```\n\n与传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码。但是Chrome不遵守这个规则，还是会抛出异常。好在Node.js提供了一个`unhandledRejection`事件，专门监听未捕获的`reject`错误。\n\n```javascript\nprocess.on('unhandledRejection', function(err, p){\n    console.error(err.stack);\n});\n\nvar someAsyncThing = function() {\n    return new Promise(function(resolve, reject){\n        resolve(x + 2);\n    });\n};\n\nsomeAsyncThing().then(function() {\n    console.log('everything is great');\n});\n```\n\n`catch`方法中还可以继续抛出异常。例如下面的代码：第二个`catch`方法用来捕获，前一个`catch`方法抛出错误。\n\n```javascript\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [ReferenceError: x is not defined]\n// carry on [ReferenceError: y is not defined]\n```\n\n## Promise.all()\n\n`Promise.all`方法用于将多个Promise实例，包装成一个新的Promise实例。语法如下：\n\n```javascript\nvar p = Promise.all([p1, p2, p3]);\n```\n\n例子如下：只有这6个实例的状态都变成了`fulfilled`，或者其中有一个状态变成了`rejected`，才会调用`Promise.all`方法后面的回调函数。\n\n```javascript\nvar promises = [2, 3, 5, 7, 11, 13].map(function (id){\n    return getJSON(\"/post/\" + id + \".json\");\n});\n\nPromise.all(promises).then(function (post){\n    // ...\n}).catch(function(reason){\n    // ...\n});\n```\n\n再例如下面这个例子：只有`booksPromise`和`userPromise`的结果都返回了，才会触发`pickTopRecommentations`这个回调函数。\n\n```javascript\nconst databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise.then(findAllBooks);\n\nconst userPromise = databasrPromise.then(getCurrentUser);\n\nPromise.all([\n    booksPromise,\n    userPromise\n]).then([books, user] => pickTopRecommentations(books, user));\n```\n\n## Promise.race()\n\n跟上面的作用一样，将多个Promise实例合成一个新的Promise实例。\n\n```\nvar p = Promise.race([p1, p2, p3]);\n```\n\n上面的例子中：只要三个状态有其中一个率先改变，新对象的状态就跟着一起改变。率先改变的Promise实例的返回值就是新Promise实例的回调函数的输入。\n\n下面提供一个实例：如果指定时间内没有获得结果，就将Promise的状态变为`reject`，否则就为`resolve`\n\n```javascript\nvar p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n])\np.then(response => console.log(response))\np.catch(error => console.log(error))\n```\n\n## Promise.resolve()\n\n有时需要将现有对象转为Promise对象，Promise.resolve()方法就起这个作用。\n\n```javascript\nPromise.resolve('foo')\n// equal to\nnew Promisr(resolve => resolve('foo'));\n```\n\n`Promise.resolve`方法的参数可以分为4种情况。\n\n- 参数是一个Promise实例：不做任何修改，原封不动返回实例\n- 参数是一个thenable对象：将该对象转换为Promise对象，然后立即执行`thenable`对象的`then`方法；\n- 参数不是具有then方法的对象，或根本就不是对象：返回一个新的`Promise`对象，状态为`Resolved`；\n- 不带有任何参数：直接返回一个状态为`Resolved`的Promise对象；\n\n## Promise.reject()\n\n也会返回一个新的Promise实例，该实例的状态为`rejected`。其参数用法和`Promise.resolve()`方法完全一致；\n\n## 两个有用的附加方法\n\n### done()\n\n提供一个`done`方法，总是处于回调链的尾端，保证抛出任何可能出现的错误\n\n### finally()\n\n用于指定不管Promise对象最后状态如何，都会执行的操作。与`Done`方法最大的区别，接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\n\n## 应用\n\n### 加载图片\n\n我们可以将图片加载写成一个Promise，一旦加载完成，`Promise`的状态就发生变化；\n\n### Generator函数结合Promise\n\n使用Generator函数管理函数流程，遇到异步操作的时候，通常返回一个`Promise`对象；\n\n### Promise.try()\n\n实际开发中还遇到一种情况：不知道或者不想区分函数f是同步还是异步，但还是想用Promise来处理。\n\n实际开发中提供了两种写法来实现这种效果：\n\n```javascript\n// async 写法\nconst f = () => console.log('now');\n(async () => f())();\nconsole.log('next');\n\n// Promise写法\nconst f = () => console.log('now');\n{\n    () => new Promise(\n    \tresolve => resolve(f())\n    )\n}();\nconsole.log('next');\n```\n\n需要注意的是`async () => f()`会吃掉`f()`抛出的异常，因此需要使用`promise.catch`方法来捕获异常；\n","slug":"javascript/es6-promise","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vi001v4f61g22zak62","content":"<h1 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h1><h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>Promise是异步编程的一种解决方案，最早由社区提出和实现，ES6在次基础上统一了用法并且提供了Promise对象。</p>\n<p>所谓的Promise简单来说就是一个容器：里面保存着某个未来才会结束的事件的结果。从语法上说：Promise是一个对象，从它可以获取异步操作的消息。</p>\n<p>Promise对象由两个特点：</p>\n<ul>\n<li>对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这种状态；</li>\n<li>一旦状态发生了改变，就不会再变，任何时候都可以得到这个结果。</li>\n</ul>\n<p>因此：有了Promise，就可以将异步操作以同步的流程表达出来，避免了蹭蹭嵌套的回调函数。此外，Promise还提供了统一的接口，使得控制异步操作更加容易。</p>\n<p>但是Promise也存在缺点：例如一旦创建就会立即执行，无法中途取消，其次，如果不设置回调函数，Promise内部会抛出异常，不会反应到外部。最后，当处于Pending状态的时候，无法得知目前进展到哪一个阶段。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span> (a) &#123;<br>        <span class=\"hljs-title function_\">resolve</span>(value); <span class=\"hljs-comment\">// Pending -&gt; Resolved</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-title function_\">reject</span>(error); <span class=\"hljs-comment\">// Pending -&gt; Rejected</span><br>    &#125;<br>&#125;);<br><br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>)&#123;<br>    <span class=\"hljs-comment\">// success</span><br>&#125;, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>   <span class=\"hljs-comment\">// failure </span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>Promise新建后会立即执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Promise&#x27;</span>);<br>    <span class=\"hljs-title function_\">resolve</span>();<br>&#125;);<br><br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Resolved.&#x27;</span>)<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hi!&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise</span><br><span class=\"hljs-comment\">// Hi!</span><br><span class=\"hljs-comment\">// Resolved</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h2><p><code>then</code>方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。该方法返回的是一个新的Promise实例。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/posts.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">json</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> json.<span class=\"hljs-property\">post</span>;<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果使用箭头函数，可以将上面代码进一步简化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">post</span> =&gt;</span> <span class=\"hljs-title function_\">getJSON</span>(post.<span class=\"hljs-property\">commentURL</span>)<br>).<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">comments</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Resolved: &quot;</span> + comments),<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Rejected: &quot;</span>, err)<br>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h2><p>用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">posts</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Error &#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果Promise状态已经变成了Resolved，再抛出错误就是无效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;ok&#x27;</span>);<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>);<br>&#125;);<br><br>promise<br>\t.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)&#125;)<br>\t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error)&#125;);<br><span class=\"hljs-comment\">// ok</span><br></code></pre></td></tr></table></figure>\n<p>Promise对象错误具有”冒泡“性质，会一直向后传递，直到被捕获为止。也就是说：错误总会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">getJSON</span>(post.<span class=\"hljs-property\">commentURL</span>);<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">comments</span>)&#123;<br>    <span class=\"hljs-comment\">// some code</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>    <span class=\"hljs-comment\">// error handler</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>与传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码。但是Chrome不遵守这个规则，还是会抛出异常。好在Node.js提供了一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, p</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err.<span class=\"hljs-property\">stack</span>);<br>&#125;);<br><br><span class=\"hljs-keyword\">var</span> someAsyncThing = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>        <span class=\"hljs-title function_\">resolve</span>(x + <span class=\"hljs-number\">2</span>);<br>    &#125;);<br>&#125;;<br><br><span class=\"hljs-title function_\">someAsyncThing</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;everything is great&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p><code>catch</code>方法中还可以继续抛出异常。例如下面的代码：第二个<code>catch</code>方法用来捕获，前一个<code>catch</code>方法抛出错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">someAsyncThing</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">someOtherAsyncThing</span>();<br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;oh no&#x27;</span>, error);<br>  <span class=\"hljs-comment\">// 下面一行会报错，因为y没有声明</span><br>  y + <span class=\"hljs-number\">2</span>;<br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;carry on&#x27;</span>, error);<br>&#125;);<br><span class=\"hljs-comment\">// oh no [ReferenceError: x is not defined]</span><br><span class=\"hljs-comment\">// carry on [ReferenceError: y is not defined]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h2><p><code>Promise.all</code>方法用于将多个Promise实例，包装成一个新的Promise实例。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([p1, p2, p3]);<br></code></pre></td></tr></table></figure>\n<p>例子如下：只有这6个实例的状态都变成了<code>fulfilled</code>，或者其中有一个状态变成了<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promises = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">id</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/&quot;</span> + id + <span class=\"hljs-string\">&quot;.json&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>再例如下面这个例子：只有<code>booksPromise</code>和<code>userPromise</code>的结果都返回了，才会触发<code>pickTopRecommentations</code>这个回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> databasePromise = <span class=\"hljs-title function_\">connectDatabase</span>();<br><br><span class=\"hljs-keyword\">const</span> booksPromise = databasePromise.<span class=\"hljs-title function_\">then</span>(findAllBooks);<br><br><span class=\"hljs-keyword\">const</span> userPromise = databasrPromise.<span class=\"hljs-title function_\">then</span>(getCurrentUser);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<br>    booksPromise,<br>    userPromise<br>]).<span class=\"hljs-title function_\">then</span>([books, user] =&gt; <span class=\"hljs-title function_\">pickTopRecommentations</span>(books, user));<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h2><p>跟上面的作用一样，将多个Promise实例合成一个新的Promise实例。</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">var</span> p = Promise.race([<span class=\"hljs-built_in\">p1</span>, <span class=\"hljs-built_in\">p2</span>, <span class=\"hljs-built_in\">p3</span>])<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n<p>上面的例子中：只要三个状态有其中一个率先改变，新对象的状态就跟着一起改变。率先改变的Promise实例的返回值就是新Promise实例的回调函数的输入。</p>\n<p>下面提供一个实例：如果指定时间内没有获得结果，就将Promise的状态变为<code>reject</code>，否则就为<code>resolve</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([<br>  <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/resource-that-may-take-a-while&#x27;</span>),<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;request timeout&#x27;</span>)), <span class=\"hljs-number\">5000</span>)<br>  &#125;)<br>])<br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(response))<br>p.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error))<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve()方法就起这个作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-comment\">// equal to</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promisr</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>));<br></code></pre></td></tr></table></figure>\n<p><code>Promise.resolve</code>方法的参数可以分为4种情况。</p>\n<ul>\n<li>参数是一个Promise实例：不做任何修改，原封不动返回实例</li>\n<li>参数是一个thenable对象：将该对象转换为Promise对象，然后立即执行<code>thenable</code>对象的<code>then</code>方法；</li>\n<li>参数不是具有then方法的对象，或根本就不是对象：返回一个新的<code>Promise</code>对象，状态为<code>Resolved</code>；</li>\n<li>不带有任何参数：直接返回一个状态为<code>Resolved</code>的Promise对象；</li>\n</ul>\n<h2 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h2><p>也会返回一个新的Promise实例，该实例的状态为<code>rejected</code>。其参数用法和<code>Promise.resolve()</code>方法完全一致；</p>\n<h2 id=\"两个有用的附加方法\"><a href=\"#两个有用的附加方法\" class=\"headerlink\" title=\"两个有用的附加方法\"></a>两个有用的附加方法</h2><h3 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h3><p>提供一个<code>done</code>方法，总是处于回调链的尾端，保证抛出任何可能出现的错误</p>\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h3><p>用于指定不管Promise对象最后状态如何，都会执行的操作。与<code>Done</code>方法最大的区别，接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"加载图片\"><a href=\"#加载图片\" class=\"headerlink\" title=\"加载图片\"></a>加载图片</h3><p>我们可以将图片加载写成一个Promise，一旦加载完成，<code>Promise</code>的状态就发生变化；</p>\n<h3 id=\"Generator函数结合Promise\"><a href=\"#Generator函数结合Promise\" class=\"headerlink\" title=\"Generator函数结合Promise\"></a>Generator函数结合Promise</h3><p>使用Generator函数管理函数流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象；</p>\n<h3 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h3><p>实际开发中还遇到一种情况：不知道或者不想区分函数f是同步还是异步，但还是想用Promise来处理。</p>\n<p>实际开发中提供了两种写法来实现这种效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// async 写法</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>(<span class=\"hljs-keyword\">async</span> () =&gt; <span class=\"hljs-title function_\">f</span>())();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise写法</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>&#123;<br>    <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<br>    \t<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-title function_\">f</span>())<br>    )<br>&#125;();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>需要注意的是<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的异常，因此需要使用<code>promise.catch</code>方法来捕获异常；</p>\n","site":{"data":{}},"wordcount":5446,"excerpt":"","more":"<h1 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h1><h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>Promise是异步编程的一种解决方案，最早由社区提出和实现，ES6在次基础上统一了用法并且提供了Promise对象。</p>\n<p>所谓的Promise简单来说就是一个容器：里面保存着某个未来才会结束的事件的结果。从语法上说：Promise是一个对象，从它可以获取异步操作的消息。</p>\n<p>Promise对象由两个特点：</p>\n<ul>\n<li>对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这种状态；</li>\n<li>一旦状态发生了改变，就不会再变，任何时候都可以得到这个结果。</li>\n</ul>\n<p>因此：有了Promise，就可以将异步操作以同步的流程表达出来，避免了蹭蹭嵌套的回调函数。此外，Promise还提供了统一的接口，使得控制异步操作更加容易。</p>\n<p>但是Promise也存在缺点：例如一旦创建就会立即执行，无法中途取消，其次，如果不设置回调函数，Promise内部会抛出异常，不会反应到外部。最后，当处于Pending状态的时候，无法得知目前进展到哪一个阶段。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span> (a) &#123;<br>        <span class=\"hljs-title function_\">resolve</span>(value); <span class=\"hljs-comment\">// Pending -&gt; Resolved</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-title function_\">reject</span>(error); <span class=\"hljs-comment\">// Pending -&gt; Rejected</span><br>    &#125;<br>&#125;);<br><br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>)&#123;<br>    <span class=\"hljs-comment\">// success</span><br>&#125;, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>   <span class=\"hljs-comment\">// failure </span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>Promise新建后会立即执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Promise&#x27;</span>);<br>    <span class=\"hljs-title function_\">resolve</span>();<br>&#125;);<br><br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Resolved.&#x27;</span>)<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hi!&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise</span><br><span class=\"hljs-comment\">// Hi!</span><br><span class=\"hljs-comment\">// Resolved</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h2><p><code>then</code>方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。该方法返回的是一个新的Promise实例。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/posts.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">json</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> json.<span class=\"hljs-property\">post</span>;<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果使用箭头函数，可以将上面代码进一步简化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">post</span> =&gt;</span> <span class=\"hljs-title function_\">getJSON</span>(post.<span class=\"hljs-property\">commentURL</span>)<br>).<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">comments</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Resolved: &quot;</span> + comments),<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Rejected: &quot;</span>, err)<br>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h2><p>用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">posts</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Error &#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果Promise状态已经变成了Resolved，再抛出错误就是无效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;ok&#x27;</span>);<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>);<br>&#125;);<br><br>promise<br>\t.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)&#125;)<br>\t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error)&#125;);<br><span class=\"hljs-comment\">// ok</span><br></code></pre></td></tr></table></figure>\n<p>Promise对象错误具有”冒泡“性质，会一直向后传递，直到被捕获为止。也就是说：错误总会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">getJSON</span>(post.<span class=\"hljs-property\">commentURL</span>);<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">comments</span>)&#123;<br>    <span class=\"hljs-comment\">// some code</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>    <span class=\"hljs-comment\">// error handler</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>与传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码。但是Chrome不遵守这个规则，还是会抛出异常。好在Node.js提供了一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, p</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err.<span class=\"hljs-property\">stack</span>);<br>&#125;);<br><br><span class=\"hljs-keyword\">var</span> someAsyncThing = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>        <span class=\"hljs-title function_\">resolve</span>(x + <span class=\"hljs-number\">2</span>);<br>    &#125;);<br>&#125;;<br><br><span class=\"hljs-title function_\">someAsyncThing</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;everything is great&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p><code>catch</code>方法中还可以继续抛出异常。例如下面的代码：第二个<code>catch</code>方法用来捕获，前一个<code>catch</code>方法抛出错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">someAsyncThing</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">someOtherAsyncThing</span>();<br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;oh no&#x27;</span>, error);<br>  <span class=\"hljs-comment\">// 下面一行会报错，因为y没有声明</span><br>  y + <span class=\"hljs-number\">2</span>;<br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;carry on&#x27;</span>, error);<br>&#125;);<br><span class=\"hljs-comment\">// oh no [ReferenceError: x is not defined]</span><br><span class=\"hljs-comment\">// carry on [ReferenceError: y is not defined]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h2><p><code>Promise.all</code>方法用于将多个Promise实例，包装成一个新的Promise实例。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([p1, p2, p3]);<br></code></pre></td></tr></table></figure>\n<p>例子如下：只有这6个实例的状态都变成了<code>fulfilled</code>，或者其中有一个状态变成了<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promises = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">id</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/&quot;</span> + id + <span class=\"hljs-string\">&quot;.json&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>再例如下面这个例子：只有<code>booksPromise</code>和<code>userPromise</code>的结果都返回了，才会触发<code>pickTopRecommentations</code>这个回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> databasePromise = <span class=\"hljs-title function_\">connectDatabase</span>();<br><br><span class=\"hljs-keyword\">const</span> booksPromise = databasePromise.<span class=\"hljs-title function_\">then</span>(findAllBooks);<br><br><span class=\"hljs-keyword\">const</span> userPromise = databasrPromise.<span class=\"hljs-title function_\">then</span>(getCurrentUser);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<br>    booksPromise,<br>    userPromise<br>]).<span class=\"hljs-title function_\">then</span>([books, user] =&gt; <span class=\"hljs-title function_\">pickTopRecommentations</span>(books, user));<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h2><p>跟上面的作用一样，将多个Promise实例合成一个新的Promise实例。</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">var</span> p = Promise.race([<span class=\"hljs-built_in\">p1</span>, <span class=\"hljs-built_in\">p2</span>, <span class=\"hljs-built_in\">p3</span>])<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n<p>上面的例子中：只要三个状态有其中一个率先改变，新对象的状态就跟着一起改变。率先改变的Promise实例的返回值就是新Promise实例的回调函数的输入。</p>\n<p>下面提供一个实例：如果指定时间内没有获得结果，就将Promise的状态变为<code>reject</code>，否则就为<code>resolve</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([<br>  <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/resource-that-may-take-a-while&#x27;</span>),<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;request timeout&#x27;</span>)), <span class=\"hljs-number\">5000</span>)<br>  &#125;)<br>])<br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(response))<br>p.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error))<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve()方法就起这个作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-comment\">// equal to</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promisr</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>));<br></code></pre></td></tr></table></figure>\n<p><code>Promise.resolve</code>方法的参数可以分为4种情况。</p>\n<ul>\n<li>参数是一个Promise实例：不做任何修改，原封不动返回实例</li>\n<li>参数是一个thenable对象：将该对象转换为Promise对象，然后立即执行<code>thenable</code>对象的<code>then</code>方法；</li>\n<li>参数不是具有then方法的对象，或根本就不是对象：返回一个新的<code>Promise</code>对象，状态为<code>Resolved</code>；</li>\n<li>不带有任何参数：直接返回一个状态为<code>Resolved</code>的Promise对象；</li>\n</ul>\n<h2 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h2><p>也会返回一个新的Promise实例，该实例的状态为<code>rejected</code>。其参数用法和<code>Promise.resolve()</code>方法完全一致；</p>\n<h2 id=\"两个有用的附加方法\"><a href=\"#两个有用的附加方法\" class=\"headerlink\" title=\"两个有用的附加方法\"></a>两个有用的附加方法</h2><h3 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h3><p>提供一个<code>done</code>方法，总是处于回调链的尾端，保证抛出任何可能出现的错误</p>\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h3><p>用于指定不管Promise对象最后状态如何，都会执行的操作。与<code>Done</code>方法最大的区别，接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"加载图片\"><a href=\"#加载图片\" class=\"headerlink\" title=\"加载图片\"></a>加载图片</h3><p>我们可以将图片加载写成一个Promise，一旦加载完成，<code>Promise</code>的状态就发生变化；</p>\n<h3 id=\"Generator函数结合Promise\"><a href=\"#Generator函数结合Promise\" class=\"headerlink\" title=\"Generator函数结合Promise\"></a>Generator函数结合Promise</h3><p>使用Generator函数管理函数流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象；</p>\n<h3 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h3><p>实际开发中还遇到一种情况：不知道或者不想区分函数f是同步还是异步，但还是想用Promise来处理。</p>\n<p>实际开发中提供了两种写法来实现这种效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// async 写法</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>(<span class=\"hljs-keyword\">async</span> () =&gt; <span class=\"hljs-title function_\">f</span>())();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise写法</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>&#123;<br>    <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<br>    \t<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-title function_\">f</span>())<br>    )<br>&#125;();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>需要注意的是<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的异常，因此需要使用<code>promise.catch</code>方法来捕获异常；</p>\n"},{"title":"ES6 Proxy和Reflect","date":"2022-02-17T07:18:01.000Z","updated":"2022-02-17T07:18:01.000Z","_content":"\n# Proxy和Reflect\n\n## Proxy\n\n### 概述\n\nProxy用于修改某些操作的默认行为，等同于在语言层面做修改，所以属于一种“元编程”。Proxy可以理解为在目标对象之前架设一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制：可以对外界的访问进行过滤和改写。例子如下：\n\n```javascript\nvar obj = new Proxy({}, {\n    get: function (target, key, receiver) {\n        console.log(`getting ${key}!`);\n        return Reflect.get(target, key, receiver);\n    },\n    set: function (target, key, value, receiver) {\n        console.log(`setting ${key}`);\n        return Reflect.set(target, key, value, receiver);\n    }\n});\n```\n\nES6原生提供了Proxy构造函数，用来生成Proxy实例。\n\n```javascript\nvar proxy = new Proxy(target, handler);\n```\n\n其中target表示所要拦截的对象，handler用来定制拦截行为。例子如下：\n\n```javascript\nvar proxy = new Proxy({}, {\n    get: function(target, property) {\n        return 35;\n    }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.titile // 35\n```\n\n需要说明的是：如果handler没有设置任何拦截对象，那么将继续保持原对象的行为不变。并且同一个拦截函数可以设置多个拦截操作：\n\n```javascript\nvar handler = {\n    get: function(target, name) {\n        if (name === 'prototype') {\n            return Object.prototype;\n        }\n        return 'Hello, ' + name;\n    },\n\n    apply: function(target, thisBinding, args) {\n        return args[0];\n    },\n    construct: function(target, args) {\n        return {value: args[1]};\n    }\n};\n\nvar fproxy = new Proxy(function (x, y){\n    return x + y;\n}, handler);\n\nconsole.log(fproxy(1, 2)); // 1\nconsole.log(new fproxy(1, 2)); // {value: 2}\nconsole.log(fproxy.prototype === Object.prototype); // true\nconsole.log(fproxy.foo) // \"Hello, foo\"\n```\n\n下面是Proxy支持的拦截操作一览：\n\n- get(target, propKey, receiver)：拦截对象属性的读取\n- set(target, propKey, value, receiver)：拦截对象属性的设置\n- has(target, propKey)：拦截`propKey in proxy`的操作，以及对象的`hasOwnProperty`方法，返回一个布尔值\n- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值；\n- ownKeys(target)：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`返回一个数组。该方法返回对象所有自身的属性\n- getOwnPropertyDescriptor(target, propKey)：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`返回属性的描述对象。\n- defineProperty(target, propKey, propDesc)：拦截`Object.defineProperty(proxy, propKey, propDesc)`返回一个布尔值；\n- preventExtensions(target)：拦截`Object.preventExtensions(proxy)`，返回一个布尔值；\n- getPrototypeOf(target)：拦截`Object.getPropertyOf(proxy)`返回一个对象\n- isExtensible(target)：拦截`Object.isExtensible(target)`，返回一个布尔值\n- setPrototypeOf(target, proto)：拦截`Object.setPrototypeOf(proxy, proto)`返回一个布尔值；\n- apply(target, object, args)：拦截Proxy实例作为函数的调用操作\n- construct(target, args)：拦截Proxy实例作为构造函数调用的操作\n\n### 实例方法\n\n#### get()\n\n```javascript\nvar person = {\n    name: \"zhangsan\"\n};\n\nvar proxy = new Proxy(person, {\n    get: function(target, property) {\n        if (property in target) {\n            return target[property];\n        } else {\n            throw new ReferenceError(\"Property \\\"\" + property + \"\\\" doesn't exist.\");\n        }\n    }\n});\n```\n\n#### set()\n\n```javascript\nlet validator = {\n    set: function(target, prop, value) {\n        if (prop === 'age') {\n            if (!Number.isInteger(value)) {\n                throw new TypeError('The age is not an integer');\n            }\n            if (value > 200) {\n                throw new RangeError('The age seems invalid');\n            }\n        }\n\n        target[prop] = value;\n    }\n};\n\nlet person = new Proxy({}, validator);\nperson.age = 100;\n\nconsole.log(person.age);\nperson.age = 'young';\nconsole.log(person.age);\n```\n\n#### apply()\n\n```javascript\nvar target = function () { return \"I am the target;\"; };\nvar handler = {\n    apply: function() {\n        return \"I am the proxy\";\n    }\n};\n\nvar p = new Proxy(target, handler);\n\nconsole.log(p()); // I am the proxy\n```\n\n#### has()\n\n```javascript\nlet stu1 = { name: 'zhangsan', score: 59 };\nlet stu2 = { name: 'lisi', score: 99 };\n\nlet handler = {\n    has(target, prop) {\n        if (prop === 'score' && target[prop] < 60) {\n            console.log(`${target.name} 不及格`);\n            return false;\n        }\n        return prop in target;\n    }\n}\n\nlet oproxy1 = new Proxy(stu1, handler);\nlet oproxy2 = new Proxy(stu2, handler);\n\nconsole.log('score' in oproxy1)\nconsole.log('score' in oproxy2)\n\nfor (let a in oproxy1) {\n    console.log(oproxy1[a]);\n}\n\nfor (let b in oproxy2) {\n    console.log(oproxy2[b]);\n}\n```\n\n#### construct()\n\n```javascript\nvar p = new Proxy(function() {}, {\n    construct: function(target, args) {\n        console.log('called: ' + args.join(', '));\n        return { value: args[0] * 10 };\n    }\n});\n\nconsole.log(new p(1).value);\n```\n\n#### deleteProperty()\n\n```javascript\nvar handler = {\n    deleteProperty(target, key) {\n        invariant(key, 'delete');\n        return true;\n    }\n};\n\nfunction invariant(key, action) {\n    if (key[0] === '_') {\n        throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n    }\n}\n\nvar target = { _prop: 'foo' };\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n```\n\n#### defineProperty()\n\n```javascript\nvar handler = {\n    defineProperty(target, key, descriptor) {\n        return false;\n    }\n};\n\nvar target = {};\nvar proxy = new Proxy(target, handler);\nproxy.foo = 'bar';\n```\n\n#### getOwnPropertyDescriptor()\n\n```javascript\nvar handler = {\n  getOwnPropertyDescriptor (target, key) {\n    if (key[0] === '_') {\n      return;\n    }\n    return Object.getOwnPropertyDescriptor(target, key);\n  }\n};\nvar target = { _foo: 'bar', baz: 'tar' };\nvar proxy = new Proxy(target, handler);\nObject.getOwnPropertyDescriptor(proxy, 'wat')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, '_foo')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n```\n\n#### getPrototypeOf()\n\n```javascript\nvar proto = {};\nvar p = new Proxy({}, {\n    getPrototypeOf(target) {\n        return proto;\n    }\n});\n\nObject.getPrototypeOf(p) === proto // true\n```\n\n#### isExtensible()\n\n```javascript\nvar p = new Proxy({}, {\n    isExtensible: function(target) {\n        console.log('called');\n        return false;\n    }\n});\n\nObject.isExtensible(p)\n```\n\n#### ownKeys()\n\n```javascript\nlet target = {\n    _bar: 'foo',\n    _prop: 'bar',\n    prop: 'baz'\n};\n\nlet handler = {\n    ownKeys(target) {\n        return Reflect.ownKeys(target).filter(key => key[0] !== '_');\n    }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n    console.log(target[key]); // baz\n}\n```\n\n### 取消代理\n\nProxy.revocable()方法返回一个可取消的Proxy实例。\n\n```javascript\nlet target = {};\nlet handler = {};\n\nlet {proxy, revoke} = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n```\n\n### this问题\n\n虽然Proxy可以代理针对目标对象的访问，但不是目标对象的透明代理：即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因是在Proxy代理的情况下，目标对象内部的`this`关键字会指向Proxy代理。\n\n```javascript\nconst _name = new WeakMap();\n\nclass Person {\n    constructor(name) {\n        _name.set(this, name);\n    }\n\n    get name() {\n        return _name.get(this);\n    }\n}\n\nconst jane = new Person('Jane');\njane.name; // \"Jane\"\n\nconst proxy = new Proxy(jane, {});\nproxy.name // undefined\n```\n\n## Reflect\n\n### 概述\n\nReflect也是ES6为了操作对象而提供的新API，其设计目的主要有几个：\n\n1. 将Object对象的一些明显属于语言内部的方法放到Reflect对象上。\n2. 修改某些Object方法返回的结果，让其变得合理。\n3. 让Object的操作都变成函数行为。某些Object操作是命令式的；\n4. Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。\n\n```javascript\nvar loggedObj = new Proxy(obj, {\n    get(target, name) {\n        console.log('get', target, name);\n        return Reflect.get(target, name);\n    },\n    deleteProperty(target, name) {\n        console.log('delete' + name);\n        return Reflect.deleteProperty(target, name);\n    },\n    has(target, name) {\n        console.log('has' + name);\n        return Reflect.has(target, name);\n    }\n});\n```\n\n### Reflect对象的方法\n\n大体上和Object对象的同名方法的作用是相同的，而且与Proxy对象的方法是一一对应的。\n","source":"_posts/javascript/es6-proxy-and-reflect.md","raw":"---\ntitle: ES6 Proxy和Reflect\ndate: 2022-02-17 15:18:01\nupdated: 2022-02-17 15:18:01\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Proxy和Reflect\n\n## Proxy\n\n### 概述\n\nProxy用于修改某些操作的默认行为，等同于在语言层面做修改，所以属于一种“元编程”。Proxy可以理解为在目标对象之前架设一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制：可以对外界的访问进行过滤和改写。例子如下：\n\n```javascript\nvar obj = new Proxy({}, {\n    get: function (target, key, receiver) {\n        console.log(`getting ${key}!`);\n        return Reflect.get(target, key, receiver);\n    },\n    set: function (target, key, value, receiver) {\n        console.log(`setting ${key}`);\n        return Reflect.set(target, key, value, receiver);\n    }\n});\n```\n\nES6原生提供了Proxy构造函数，用来生成Proxy实例。\n\n```javascript\nvar proxy = new Proxy(target, handler);\n```\n\n其中target表示所要拦截的对象，handler用来定制拦截行为。例子如下：\n\n```javascript\nvar proxy = new Proxy({}, {\n    get: function(target, property) {\n        return 35;\n    }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.titile // 35\n```\n\n需要说明的是：如果handler没有设置任何拦截对象，那么将继续保持原对象的行为不变。并且同一个拦截函数可以设置多个拦截操作：\n\n```javascript\nvar handler = {\n    get: function(target, name) {\n        if (name === 'prototype') {\n            return Object.prototype;\n        }\n        return 'Hello, ' + name;\n    },\n\n    apply: function(target, thisBinding, args) {\n        return args[0];\n    },\n    construct: function(target, args) {\n        return {value: args[1]};\n    }\n};\n\nvar fproxy = new Proxy(function (x, y){\n    return x + y;\n}, handler);\n\nconsole.log(fproxy(1, 2)); // 1\nconsole.log(new fproxy(1, 2)); // {value: 2}\nconsole.log(fproxy.prototype === Object.prototype); // true\nconsole.log(fproxy.foo) // \"Hello, foo\"\n```\n\n下面是Proxy支持的拦截操作一览：\n\n- get(target, propKey, receiver)：拦截对象属性的读取\n- set(target, propKey, value, receiver)：拦截对象属性的设置\n- has(target, propKey)：拦截`propKey in proxy`的操作，以及对象的`hasOwnProperty`方法，返回一个布尔值\n- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值；\n- ownKeys(target)：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`返回一个数组。该方法返回对象所有自身的属性\n- getOwnPropertyDescriptor(target, propKey)：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`返回属性的描述对象。\n- defineProperty(target, propKey, propDesc)：拦截`Object.defineProperty(proxy, propKey, propDesc)`返回一个布尔值；\n- preventExtensions(target)：拦截`Object.preventExtensions(proxy)`，返回一个布尔值；\n- getPrototypeOf(target)：拦截`Object.getPropertyOf(proxy)`返回一个对象\n- isExtensible(target)：拦截`Object.isExtensible(target)`，返回一个布尔值\n- setPrototypeOf(target, proto)：拦截`Object.setPrototypeOf(proxy, proto)`返回一个布尔值；\n- apply(target, object, args)：拦截Proxy实例作为函数的调用操作\n- construct(target, args)：拦截Proxy实例作为构造函数调用的操作\n\n### 实例方法\n\n#### get()\n\n```javascript\nvar person = {\n    name: \"zhangsan\"\n};\n\nvar proxy = new Proxy(person, {\n    get: function(target, property) {\n        if (property in target) {\n            return target[property];\n        } else {\n            throw new ReferenceError(\"Property \\\"\" + property + \"\\\" doesn't exist.\");\n        }\n    }\n});\n```\n\n#### set()\n\n```javascript\nlet validator = {\n    set: function(target, prop, value) {\n        if (prop === 'age') {\n            if (!Number.isInteger(value)) {\n                throw new TypeError('The age is not an integer');\n            }\n            if (value > 200) {\n                throw new RangeError('The age seems invalid');\n            }\n        }\n\n        target[prop] = value;\n    }\n};\n\nlet person = new Proxy({}, validator);\nperson.age = 100;\n\nconsole.log(person.age);\nperson.age = 'young';\nconsole.log(person.age);\n```\n\n#### apply()\n\n```javascript\nvar target = function () { return \"I am the target;\"; };\nvar handler = {\n    apply: function() {\n        return \"I am the proxy\";\n    }\n};\n\nvar p = new Proxy(target, handler);\n\nconsole.log(p()); // I am the proxy\n```\n\n#### has()\n\n```javascript\nlet stu1 = { name: 'zhangsan', score: 59 };\nlet stu2 = { name: 'lisi', score: 99 };\n\nlet handler = {\n    has(target, prop) {\n        if (prop === 'score' && target[prop] < 60) {\n            console.log(`${target.name} 不及格`);\n            return false;\n        }\n        return prop in target;\n    }\n}\n\nlet oproxy1 = new Proxy(stu1, handler);\nlet oproxy2 = new Proxy(stu2, handler);\n\nconsole.log('score' in oproxy1)\nconsole.log('score' in oproxy2)\n\nfor (let a in oproxy1) {\n    console.log(oproxy1[a]);\n}\n\nfor (let b in oproxy2) {\n    console.log(oproxy2[b]);\n}\n```\n\n#### construct()\n\n```javascript\nvar p = new Proxy(function() {}, {\n    construct: function(target, args) {\n        console.log('called: ' + args.join(', '));\n        return { value: args[0] * 10 };\n    }\n});\n\nconsole.log(new p(1).value);\n```\n\n#### deleteProperty()\n\n```javascript\nvar handler = {\n    deleteProperty(target, key) {\n        invariant(key, 'delete');\n        return true;\n    }\n};\n\nfunction invariant(key, action) {\n    if (key[0] === '_') {\n        throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n    }\n}\n\nvar target = { _prop: 'foo' };\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n```\n\n#### defineProperty()\n\n```javascript\nvar handler = {\n    defineProperty(target, key, descriptor) {\n        return false;\n    }\n};\n\nvar target = {};\nvar proxy = new Proxy(target, handler);\nproxy.foo = 'bar';\n```\n\n#### getOwnPropertyDescriptor()\n\n```javascript\nvar handler = {\n  getOwnPropertyDescriptor (target, key) {\n    if (key[0] === '_') {\n      return;\n    }\n    return Object.getOwnPropertyDescriptor(target, key);\n  }\n};\nvar target = { _foo: 'bar', baz: 'tar' };\nvar proxy = new Proxy(target, handler);\nObject.getOwnPropertyDescriptor(proxy, 'wat')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, '_foo')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n```\n\n#### getPrototypeOf()\n\n```javascript\nvar proto = {};\nvar p = new Proxy({}, {\n    getPrototypeOf(target) {\n        return proto;\n    }\n});\n\nObject.getPrototypeOf(p) === proto // true\n```\n\n#### isExtensible()\n\n```javascript\nvar p = new Proxy({}, {\n    isExtensible: function(target) {\n        console.log('called');\n        return false;\n    }\n});\n\nObject.isExtensible(p)\n```\n\n#### ownKeys()\n\n```javascript\nlet target = {\n    _bar: 'foo',\n    _prop: 'bar',\n    prop: 'baz'\n};\n\nlet handler = {\n    ownKeys(target) {\n        return Reflect.ownKeys(target).filter(key => key[0] !== '_');\n    }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n    console.log(target[key]); // baz\n}\n```\n\n### 取消代理\n\nProxy.revocable()方法返回一个可取消的Proxy实例。\n\n```javascript\nlet target = {};\nlet handler = {};\n\nlet {proxy, revoke} = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n```\n\n### this问题\n\n虽然Proxy可以代理针对目标对象的访问，但不是目标对象的透明代理：即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因是在Proxy代理的情况下，目标对象内部的`this`关键字会指向Proxy代理。\n\n```javascript\nconst _name = new WeakMap();\n\nclass Person {\n    constructor(name) {\n        _name.set(this, name);\n    }\n\n    get name() {\n        return _name.get(this);\n    }\n}\n\nconst jane = new Person('Jane');\njane.name; // \"Jane\"\n\nconst proxy = new Proxy(jane, {});\nproxy.name // undefined\n```\n\n## Reflect\n\n### 概述\n\nReflect也是ES6为了操作对象而提供的新API，其设计目的主要有几个：\n\n1. 将Object对象的一些明显属于语言内部的方法放到Reflect对象上。\n2. 修改某些Object方法返回的结果，让其变得合理。\n3. 让Object的操作都变成函数行为。某些Object操作是命令式的；\n4. Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。\n\n```javascript\nvar loggedObj = new Proxy(obj, {\n    get(target, name) {\n        console.log('get', target, name);\n        return Reflect.get(target, name);\n    },\n    deleteProperty(target, name) {\n        console.log('delete' + name);\n        return Reflect.deleteProperty(target, name);\n    },\n    has(target, name) {\n        console.log('has' + name);\n        return Reflect.has(target, name);\n    }\n});\n```\n\n### Reflect对象的方法\n\n大体上和Object对象的同名方法的作用是相同的，而且与Proxy对象的方法是一一对应的。\n","slug":"javascript/es6-proxy-and-reflect","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vj001z4f6112llf3zz","content":"<h1 id=\"Proxy和Reflect\"><a href=\"#Proxy和Reflect\" class=\"headerlink\" title=\"Proxy和Reflect\"></a>Proxy和Reflect</h1><h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做修改，所以属于一种“元编程”。Proxy可以理解为在目标对象之前架设一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制：可以对外界的访问进行过滤和改写。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, key, receiver</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`getting <span class=\"hljs-subst\">$&#123;key&#125;</span>!`</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key, receiver);<br>    &#125;,<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, key, value, receiver</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`setting <span class=\"hljs-subst\">$&#123;key&#125;</span>`</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>ES6原生提供了Proxy构造函数，用来生成Proxy实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure>\n<p>其中target表示所要拦截的对象，handler用来定制拦截行为。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">35</span>;<br>    &#125;<br>&#125;);<br><br>proxy.<span class=\"hljs-property\">time</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">titile</span> <span class=\"hljs-comment\">// 35</span><br></code></pre></td></tr></table></figure>\n<p>需要说明的是：如果handler没有设置任何拦截对象，那么将继续保持原对象的行为不变。并且同一个拦截函数可以设置多个拦截操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">&#x27;prototype&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + name;<br>    &#125;,<br><br>    <span class=\"hljs-attr\">apply</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, thisBinding, args</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> args[<span class=\"hljs-number\">0</span>];<br>    &#125;,<br>    <span class=\"hljs-attr\">construct</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, args</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">value</span>: args[<span class=\"hljs-number\">1</span>]&#125;;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> fproxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fproxy</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">fproxy</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// &#123;value: 2&#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fproxy.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> === <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fproxy.<span class=\"hljs-property\">foo</span>) <span class=\"hljs-comment\">// &quot;Hello, foo&quot;</span><br></code></pre></td></tr></table></figure>\n<p>下面是Proxy支持的拦截操作一览：</p>\n<ul>\n<li>get(target, propKey, receiver)：拦截对象属性的读取</li>\n<li>set(target, propKey, value, receiver)：拦截对象属性的设置</li>\n<li>has(target, propKey)：拦截<code>propKey in proxy</code>的操作，以及对象的<code>hasOwnProperty</code>方法，返回一个布尔值</li>\n<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值；</li>\n<li>ownKeys(target)：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>返回一个数组。该方法返回对象所有自身的属性</li>\n<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>返回属性的描述对象。</li>\n<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc)</code>返回一个布尔值；</li>\n<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值；</li>\n<li>getPrototypeOf(target)：拦截<code>Object.getPropertyOf(proxy)</code>返回一个对象</li>\n<li>isExtensible(target)：拦截<code>Object.isExtensible(target)</code>，返回一个布尔值</li>\n<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>返回一个布尔值；</li>\n<li>apply(target, object, args)：拦截Proxy实例作为函数的调用操作</li>\n<li>construct(target, args)：拦截Proxy实例作为构造函数调用的操作</li>\n</ul>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;zhangsan&quot;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(person, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (property <span class=\"hljs-keyword\">in</span> target) &#123;<br>            <span class=\"hljs-keyword\">return</span> target[property];<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReferenceError</span>(<span class=\"hljs-string\">&quot;Property \\&quot;&quot;</span> + property + <span class=\"hljs-string\">&quot;\\&quot; doesn&#x27;t exist.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> validator = &#123;<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, prop, value</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (prop === <span class=\"hljs-string\">&#x27;age&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isInteger</span>(value)) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;The age is not an integer&#x27;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (value &gt; <span class=\"hljs-number\">200</span>) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeError</span>(<span class=\"hljs-string\">&#x27;The age seems invalid&#x27;</span>);<br>            &#125;<br>        &#125;<br><br>        target[prop] = value;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, validator);<br>person.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">100</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>);<br>person.<span class=\"hljs-property\">age</span> = <span class=\"hljs-string\">&#x27;young&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> target = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;I am the target;&quot;</span>; &#125;;<br><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-attr\">apply</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;I am the proxy&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">p</span>()); <span class=\"hljs-comment\">// I am the proxy</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has()\"></a>has()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> stu1 = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span>, <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">59</span> &#125;;<br><span class=\"hljs-keyword\">let</span> stu2 = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;lisi&#x27;</span>, <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">99</span> &#125;;<br><br><span class=\"hljs-keyword\">let</span> handler = &#123;<br>    <span class=\"hljs-title function_\">has</span>(<span class=\"hljs-params\">target, prop</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (prop === <span class=\"hljs-string\">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class=\"hljs-number\">60</span>) &#123;<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;target.name&#125;</span> 不及格`</span>);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> prop <span class=\"hljs-keyword\">in</span> target;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> oproxy1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(stu1, handler);<br><span class=\"hljs-keyword\">let</span> oproxy2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(stu2, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;score&#x27;</span> <span class=\"hljs-keyword\">in</span> oproxy1)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;score&#x27;</span> <span class=\"hljs-keyword\">in</span> oproxy2)<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> a <span class=\"hljs-keyword\">in</span> oproxy1) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(oproxy1[a]);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> b <span class=\"hljs-keyword\">in</span> oproxy2) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(oproxy2[b]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"construct\"><a href=\"#construct\" class=\"headerlink\" title=\"construct()\"></a>construct()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">construct</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, args</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;called: &#x27;</span> + args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;, &#x27;</span>));<br>        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">value</span>: args[<span class=\"hljs-number\">0</span>] * <span class=\"hljs-number\">10</span> &#125;;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">p</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-property\">value</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"deleteProperty\"><a href=\"#deleteProperty\" class=\"headerlink\" title=\"deleteProperty()\"></a>deleteProperty()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-params\">target, key</span>) &#123;<br>        <span class=\"hljs-title function_\">invariant</span>(key, <span class=\"hljs-string\">&#x27;delete&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">invariant</span>(<span class=\"hljs-params\">key, action</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;_&#x27;</span>) &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Invalid attempt to <span class=\"hljs-subst\">$&#123;action&#125;</span> private &quot;<span class=\"hljs-subst\">$&#123;key&#125;</span>&quot; property`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">_prop</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-keyword\">delete</span> proxy.<span class=\"hljs-property\">_prop</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"defineProperty\"><a href=\"#defineProperty\" class=\"headerlink\" title=\"defineProperty()\"></a>defineProperty()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-title function_\">defineProperty</span>(<span class=\"hljs-params\">target, key, descriptor</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> target = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br>proxy.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<h4 id=\"getOwnPropertyDescriptor\"><a href=\"#getOwnPropertyDescriptor\" class=\"headerlink\" title=\"getOwnPropertyDescriptor()\"></a>getOwnPropertyDescriptor()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>  getOwnPropertyDescriptor (target, key) &#123;<br>    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;_&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target, key);<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">_foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-string\">&#x27;tar&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;wat&#x27;</span>)<br><span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;_foo&#x27;</span>)<br><span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><span class=\"hljs-comment\">// &#123; value: &#x27;tar&#x27;, writable: true, enumerable: true, configurable: true &#125;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"getPrototypeOf\"><a href=\"#getPrototypeOf\" class=\"headerlink\" title=\"getPrototypeOf()\"></a>getPrototypeOf()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proto = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-title function_\">getPrototypeOf</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> proto;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(p) === proto <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"isExtensible\"><a href=\"#isExtensible\" class=\"headerlink\" title=\"isExtensible()\"></a>isExtensible()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">isExtensible</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;called&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">isExtensible</span>(p)<br></code></pre></td></tr></table></figure>\n<h4 id=\"ownKeys\"><a href=\"#ownKeys\" class=\"headerlink\" title=\"ownKeys()\"></a>ownKeys()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> target = &#123;<br>    <span class=\"hljs-attr\">_bar</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span>,<br>    <span class=\"hljs-attr\">_prop</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>,<br>    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">&#x27;baz&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> handler = &#123;<br>    <span class=\"hljs-title function_\">ownKeys</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(target).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> key[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">&#x27;_&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(proxy)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(target[key]); <span class=\"hljs-comment\">// baz</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"取消代理\"><a href=\"#取消代理\" class=\"headerlink\" title=\"取消代理\"></a>取消代理</h3><p>Proxy.revocable()方法返回一个可取消的Proxy实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> target = &#123;&#125;;<br><span class=\"hljs-keyword\">let</span> handler = &#123;&#125;;<br><br><span class=\"hljs-keyword\">let</span> &#123;proxy, revoke&#125; = <span class=\"hljs-title class_\">Proxy</span>.<span class=\"hljs-title function_\">revocable</span>(target, handler);<br><br>proxy.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-number\">123</span>;<br>proxy.<span class=\"hljs-property\">foo</span> <span class=\"hljs-comment\">// 123</span><br><br><span class=\"hljs-title function_\">revoke</span>();<br>proxy.<span class=\"hljs-property\">foo</span> <span class=\"hljs-comment\">// TypeError: Revoked</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"this问题\"><a href=\"#this问题\" class=\"headerlink\" title=\"this问题\"></a>this问题</h3><p>虽然Proxy可以代理针对目标对象的访问，但不是目标对象的透明代理：即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因是在Proxy代理的情况下，目标对象内部的<code>this</code>关键字会指向Proxy代理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> _name = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>        _name.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, name);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">name</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> _name.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> jane = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;Jane&#x27;</span>);<br>jane.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">// &quot;Jane&quot;</span><br><br><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(jane, &#123;&#125;);<br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Reflect也是ES6为了操作对象而提供的新API，其设计目的主要有几个：</p>\n<ol>\n<li>将Object对象的一些明显属于语言内部的方法放到Reflect对象上。</li>\n<li>修改某些Object方法返回的结果，让其变得合理。</li>\n<li>让Object的操作都变成函数行为。某些Object操作是命令式的；</li>\n<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> loggedObj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, &#123;<br>    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;get&#x27;</span>, target, name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, name);<br>    &#125;,<br>    <span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;delete&#x27;</span> + name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(target, name);<br>    &#125;,<br>    <span class=\"hljs-title function_\">has</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;has&#x27;</span> + name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">has</span>(target, name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"Reflect对象的方法\"><a href=\"#Reflect对象的方法\" class=\"headerlink\" title=\"Reflect对象的方法\"></a>Reflect对象的方法</h3><p>大体上和Object对象的同名方法的作用是相同的，而且与Proxy对象的方法是一一对应的。</p>\n","site":{"data":{}},"wordcount":7233,"excerpt":"","more":"<h1 id=\"Proxy和Reflect\"><a href=\"#Proxy和Reflect\" class=\"headerlink\" title=\"Proxy和Reflect\"></a>Proxy和Reflect</h1><h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做修改，所以属于一种“元编程”。Proxy可以理解为在目标对象之前架设一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制：可以对外界的访问进行过滤和改写。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, key, receiver</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`getting <span class=\"hljs-subst\">$&#123;key&#125;</span>!`</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key, receiver);<br>    &#125;,<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, key, value, receiver</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`setting <span class=\"hljs-subst\">$&#123;key&#125;</span>`</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>ES6原生提供了Proxy构造函数，用来生成Proxy实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure>\n<p>其中target表示所要拦截的对象，handler用来定制拦截行为。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">35</span>;<br>    &#125;<br>&#125;);<br><br>proxy.<span class=\"hljs-property\">time</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">titile</span> <span class=\"hljs-comment\">// 35</span><br></code></pre></td></tr></table></figure>\n<p>需要说明的是：如果handler没有设置任何拦截对象，那么将继续保持原对象的行为不变。并且同一个拦截函数可以设置多个拦截操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">&#x27;prototype&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + name;<br>    &#125;,<br><br>    <span class=\"hljs-attr\">apply</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, thisBinding, args</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> args[<span class=\"hljs-number\">0</span>];<br>    &#125;,<br>    <span class=\"hljs-attr\">construct</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, args</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">value</span>: args[<span class=\"hljs-number\">1</span>]&#125;;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> fproxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fproxy</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">fproxy</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// &#123;value: 2&#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fproxy.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> === <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fproxy.<span class=\"hljs-property\">foo</span>) <span class=\"hljs-comment\">// &quot;Hello, foo&quot;</span><br></code></pre></td></tr></table></figure>\n<p>下面是Proxy支持的拦截操作一览：</p>\n<ul>\n<li>get(target, propKey, receiver)：拦截对象属性的读取</li>\n<li>set(target, propKey, value, receiver)：拦截对象属性的设置</li>\n<li>has(target, propKey)：拦截<code>propKey in proxy</code>的操作，以及对象的<code>hasOwnProperty</code>方法，返回一个布尔值</li>\n<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值；</li>\n<li>ownKeys(target)：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>返回一个数组。该方法返回对象所有自身的属性</li>\n<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>返回属性的描述对象。</li>\n<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc)</code>返回一个布尔值；</li>\n<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值；</li>\n<li>getPrototypeOf(target)：拦截<code>Object.getPropertyOf(proxy)</code>返回一个对象</li>\n<li>isExtensible(target)：拦截<code>Object.isExtensible(target)</code>，返回一个布尔值</li>\n<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>返回一个布尔值；</li>\n<li>apply(target, object, args)：拦截Proxy实例作为函数的调用操作</li>\n<li>construct(target, args)：拦截Proxy实例作为构造函数调用的操作</li>\n</ul>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;zhangsan&quot;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(person, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (property <span class=\"hljs-keyword\">in</span> target) &#123;<br>            <span class=\"hljs-keyword\">return</span> target[property];<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReferenceError</span>(<span class=\"hljs-string\">&quot;Property \\&quot;&quot;</span> + property + <span class=\"hljs-string\">&quot;\\&quot; doesn&#x27;t exist.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> validator = &#123;<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, prop, value</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (prop === <span class=\"hljs-string\">&#x27;age&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isInteger</span>(value)) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;The age is not an integer&#x27;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (value &gt; <span class=\"hljs-number\">200</span>) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeError</span>(<span class=\"hljs-string\">&#x27;The age seems invalid&#x27;</span>);<br>            &#125;<br>        &#125;<br><br>        target[prop] = value;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, validator);<br>person.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">100</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>);<br>person.<span class=\"hljs-property\">age</span> = <span class=\"hljs-string\">&#x27;young&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> target = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;I am the target;&quot;</span>; &#125;;<br><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-attr\">apply</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;I am the proxy&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">p</span>()); <span class=\"hljs-comment\">// I am the proxy</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has()\"></a>has()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> stu1 = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span>, <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">59</span> &#125;;<br><span class=\"hljs-keyword\">let</span> stu2 = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;lisi&#x27;</span>, <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">99</span> &#125;;<br><br><span class=\"hljs-keyword\">let</span> handler = &#123;<br>    <span class=\"hljs-title function_\">has</span>(<span class=\"hljs-params\">target, prop</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (prop === <span class=\"hljs-string\">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class=\"hljs-number\">60</span>) &#123;<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;target.name&#125;</span> 不及格`</span>);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> prop <span class=\"hljs-keyword\">in</span> target;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> oproxy1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(stu1, handler);<br><span class=\"hljs-keyword\">let</span> oproxy2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(stu2, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;score&#x27;</span> <span class=\"hljs-keyword\">in</span> oproxy1)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;score&#x27;</span> <span class=\"hljs-keyword\">in</span> oproxy2)<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> a <span class=\"hljs-keyword\">in</span> oproxy1) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(oproxy1[a]);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> b <span class=\"hljs-keyword\">in</span> oproxy2) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(oproxy2[b]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"construct\"><a href=\"#construct\" class=\"headerlink\" title=\"construct()\"></a>construct()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">construct</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, args</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;called: &#x27;</span> + args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;, &#x27;</span>));<br>        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">value</span>: args[<span class=\"hljs-number\">0</span>] * <span class=\"hljs-number\">10</span> &#125;;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">p</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-property\">value</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"deleteProperty\"><a href=\"#deleteProperty\" class=\"headerlink\" title=\"deleteProperty()\"></a>deleteProperty()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-params\">target, key</span>) &#123;<br>        <span class=\"hljs-title function_\">invariant</span>(key, <span class=\"hljs-string\">&#x27;delete&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">invariant</span>(<span class=\"hljs-params\">key, action</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;_&#x27;</span>) &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Invalid attempt to <span class=\"hljs-subst\">$&#123;action&#125;</span> private &quot;<span class=\"hljs-subst\">$&#123;key&#125;</span>&quot; property`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">_prop</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-keyword\">delete</span> proxy.<span class=\"hljs-property\">_prop</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"defineProperty\"><a href=\"#defineProperty\" class=\"headerlink\" title=\"defineProperty()\"></a>defineProperty()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-title function_\">defineProperty</span>(<span class=\"hljs-params\">target, key, descriptor</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> target = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br>proxy.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<h4 id=\"getOwnPropertyDescriptor\"><a href=\"#getOwnPropertyDescriptor\" class=\"headerlink\" title=\"getOwnPropertyDescriptor()\"></a>getOwnPropertyDescriptor()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>  getOwnPropertyDescriptor (target, key) &#123;<br>    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;_&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target, key);<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">_foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-string\">&#x27;tar&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;wat&#x27;</span>)<br><span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;_foo&#x27;</span>)<br><span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><span class=\"hljs-comment\">// &#123; value: &#x27;tar&#x27;, writable: true, enumerable: true, configurable: true &#125;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"getPrototypeOf\"><a href=\"#getPrototypeOf\" class=\"headerlink\" title=\"getPrototypeOf()\"></a>getPrototypeOf()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proto = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-title function_\">getPrototypeOf</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> proto;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(p) === proto <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"isExtensible\"><a href=\"#isExtensible\" class=\"headerlink\" title=\"isExtensible()\"></a>isExtensible()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">isExtensible</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;called&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">isExtensible</span>(p)<br></code></pre></td></tr></table></figure>\n<h4 id=\"ownKeys\"><a href=\"#ownKeys\" class=\"headerlink\" title=\"ownKeys()\"></a>ownKeys()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> target = &#123;<br>    <span class=\"hljs-attr\">_bar</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span>,<br>    <span class=\"hljs-attr\">_prop</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>,<br>    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">&#x27;baz&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> handler = &#123;<br>    <span class=\"hljs-title function_\">ownKeys</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(target).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> key[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">&#x27;_&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(proxy)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(target[key]); <span class=\"hljs-comment\">// baz</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"取消代理\"><a href=\"#取消代理\" class=\"headerlink\" title=\"取消代理\"></a>取消代理</h3><p>Proxy.revocable()方法返回一个可取消的Proxy实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> target = &#123;&#125;;<br><span class=\"hljs-keyword\">let</span> handler = &#123;&#125;;<br><br><span class=\"hljs-keyword\">let</span> &#123;proxy, revoke&#125; = <span class=\"hljs-title class_\">Proxy</span>.<span class=\"hljs-title function_\">revocable</span>(target, handler);<br><br>proxy.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-number\">123</span>;<br>proxy.<span class=\"hljs-property\">foo</span> <span class=\"hljs-comment\">// 123</span><br><br><span class=\"hljs-title function_\">revoke</span>();<br>proxy.<span class=\"hljs-property\">foo</span> <span class=\"hljs-comment\">// TypeError: Revoked</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"this问题\"><a href=\"#this问题\" class=\"headerlink\" title=\"this问题\"></a>this问题</h3><p>虽然Proxy可以代理针对目标对象的访问，但不是目标对象的透明代理：即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因是在Proxy代理的情况下，目标对象内部的<code>this</code>关键字会指向Proxy代理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> _name = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>        _name.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, name);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">name</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> _name.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> jane = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;Jane&#x27;</span>);<br>jane.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">// &quot;Jane&quot;</span><br><br><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(jane, &#123;&#125;);<br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Reflect也是ES6为了操作对象而提供的新API，其设计目的主要有几个：</p>\n<ol>\n<li>将Object对象的一些明显属于语言内部的方法放到Reflect对象上。</li>\n<li>修改某些Object方法返回的结果，让其变得合理。</li>\n<li>让Object的操作都变成函数行为。某些Object操作是命令式的；</li>\n<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> loggedObj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, &#123;<br>    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;get&#x27;</span>, target, name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, name);<br>    &#125;,<br>    <span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;delete&#x27;</span> + name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(target, name);<br>    &#125;,<br>    <span class=\"hljs-title function_\">has</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;has&#x27;</span> + name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">has</span>(target, name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"Reflect对象的方法\"><a href=\"#Reflect对象的方法\" class=\"headerlink\" title=\"Reflect对象的方法\"></a>Reflect对象的方法</h3><p>大体上和Object对象的同名方法的作用是相同的，而且与Proxy对象的方法是一一对应的。</p>\n"},{"title":"ES6 正则表达式","date":"2022-02-17T06:59:44.000Z","updated":"2022-02-17T06:59:44.000Z","_content":"\n# 正则表达式\n\n## 基本概念\n\n用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。模式匹配常用在`RegExp` `exec` `test`方法，以及`String`的`match`、`matchAll`、`replace`、`search`和`split`方法。\n\n## 创建语法\n\n使用下面两种方法都可以创建：\n\n```javascript\n// method 1\nvar re = /abc/ig; // 其中ig为正则对象修饰符\n\n// method 2\nvar re = new RegExp(/abc/ig); // 返回一个原有正则表达式的拷贝\n```\n\n除此之外ES6还提供了带两个参数的`RegExp`函数，但是在ES5这种写法是非法的。ES6中则放款了此项限制：\n\n```javascript\nvar regex = new RegExp(/xyz/, 'i'); // ES5中报错、但是在ES6中是允许的\n// regex \"i\" 第二个参数为指定修饰符，返回的正则表达式对象会忽略原有的修饰符，只使用新指定的修饰符\n```\n\n## ES6新增功能：`u`修饰符\n\n`u字符`为Unicode字符的意思，可以识别码点超过`0xFFFF`的字符。前一章节也讲过ES6加入了Unicode字符表示。因此正则也是可以支持Unicode的模式识别的。例子如下：\n\n```javascript\n/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n```\n\n### 预定义模式\n\n另外`u`字符也会影响预定义模式，能否正确识别大于`0xFFFF`的Unicode字符：\n\n```javascript\nfunction codePointLength(text) {\n    var result = text.match(/[\\s\\S]/gu);\n    return result ? result.length : 0;\n}\n\nvar s = '\\u{20BB7}\\u{20BB7}';\n\ns.length // 4\ncodePointLength(s) // 2\n```\n\n## ES6新增功能：`y`修饰符\n\n`y`字符也称为粘连字符，其作用于`g`修饰符类似。后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于`g`修饰符只要剩余位置中存在匹配即可，而`y`修饰符确保匹配必须从剩余的第一个位置开始；例子如下：\n\n```javascript\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr1.exec(s);\n[ 'aa', index: 4, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\nnull\n\nr1.exec(s);\n[ 'a', index: 7, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr1.exec(s);\nnull\n\nr2.exec(s);\nnull\n```\n\n### 例子：`g`修饰符和`y`修饰符的区别\n\n使用`g`修饰符和`lastIndex`来验证运行方式\n\n```javascript\nconst REGEX = /a/g;\n\nREGEX.lastIndex = 2; // 默认从2开始匹配（数组下标2）\nconst match = REGEX.exec('xaya');\n\nmatch.index // 3 也就是指定位置向后搜索字符'a'\n\nREGEX.lastIndex // 4 从下一次匹配的位置开始\nREGEX.exec('xaya') // null\n```\n\n使用`y`修饰符和`lastIndex`来验证运行方式\n\n```javascript\nconst REGEX = /a/y;\n\nREGEX.lastIndex = 2;\nREGEX.exec('xaya') // null 不是粘连，因为位置2指向的是字符'y'\n\nREGEX.lastIndex = 3;\n\nconst match = REGEX.exec('xaxa');\nmatch.index // 3\nREGEX.lastIndex // 4\n```\n\n### sticky属性\n\nES6正则对象多了`sticky`属性，表示是否设置了`y`修饰符。\n\n```javascript\nvar r = /hello\\d/y;\nr.sticky // true\n```\n\n### flags属性\n\nES6为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。\n\n```javascript\n/abc/ig.source // \"abc\"\n\n/abc/ig.flags // \"gi\"\n```\n\n## ES6新增功能：`s`修饰符\n\n### dotAll模式：即点代表一切字符\n\n正则表达式中`.`是个特殊字符，可以用于表示任意的单个字符。但是它排除了行终止符。而有时候我们希望匹配的是任意单个字符，因此，提案中引入了`/s`修饰符，使得`.`可以匹配任意单个字符。\n\n```javascript\n/foo.bar/s.test('foo\\nbar') // true\n```\n\n### 先行断言\n\nES5中，JavaScript的正则表达式只支持“先行断言”和“先行否定断言”。先行断言的意思是：`x`只有在`y`前面才匹配，对应的正则模式需写成`/x(?=y)/`。同理：先行否定断言是指：`x`只有不在`y`前面才匹配，对应的正则匹配模式为：`/x(?!y)/`\n\n### 后行断言\n\nES7中新增了一个提案，允许正则表达式进行“后行断言”。后行断言的意思是：`x`只有在`y`的后面才匹配，必须写成`/(?<=y)x/`。同理：后行否定断言是指：x只有不在y后面才匹配，对应的正则匹配模式为：`/(?<!y)x/`\n\n## Unicode属性类\n\n目前有一个新提案，允许正则表达式匹配符合Unicode某种属性的所有字符，使用前一定要加上`u`字符：\n\n```javascript\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π'); // true\n```\n\nUnicode属性类要指定属性名和属性值：\n\n```javascript\n// 需要指定Unicode属性名和属性值\n\\p{UnicodePropertyName=UnicodePropertyValue}\n\n// 对于某些属性，可以只写属性名\n\\p{UnicodePropertyName}\n```\n","source":"_posts/javascript/es6-regexp.md","raw":"---\ntitle: ES6 正则表达式\ndate: 2022-02-17 14:59:44\nupdated: 2022-02-17 14:59:44\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 正则表达式\n\n## 基本概念\n\n用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。模式匹配常用在`RegExp` `exec` `test`方法，以及`String`的`match`、`matchAll`、`replace`、`search`和`split`方法。\n\n## 创建语法\n\n使用下面两种方法都可以创建：\n\n```javascript\n// method 1\nvar re = /abc/ig; // 其中ig为正则对象修饰符\n\n// method 2\nvar re = new RegExp(/abc/ig); // 返回一个原有正则表达式的拷贝\n```\n\n除此之外ES6还提供了带两个参数的`RegExp`函数，但是在ES5这种写法是非法的。ES6中则放款了此项限制：\n\n```javascript\nvar regex = new RegExp(/xyz/, 'i'); // ES5中报错、但是在ES6中是允许的\n// regex \"i\" 第二个参数为指定修饰符，返回的正则表达式对象会忽略原有的修饰符，只使用新指定的修饰符\n```\n\n## ES6新增功能：`u`修饰符\n\n`u字符`为Unicode字符的意思，可以识别码点超过`0xFFFF`的字符。前一章节也讲过ES6加入了Unicode字符表示。因此正则也是可以支持Unicode的模式识别的。例子如下：\n\n```javascript\n/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n```\n\n### 预定义模式\n\n另外`u`字符也会影响预定义模式，能否正确识别大于`0xFFFF`的Unicode字符：\n\n```javascript\nfunction codePointLength(text) {\n    var result = text.match(/[\\s\\S]/gu);\n    return result ? result.length : 0;\n}\n\nvar s = '\\u{20BB7}\\u{20BB7}';\n\ns.length // 4\ncodePointLength(s) // 2\n```\n\n## ES6新增功能：`y`修饰符\n\n`y`字符也称为粘连字符，其作用于`g`修饰符类似。后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于`g`修饰符只要剩余位置中存在匹配即可，而`y`修饰符确保匹配必须从剩余的第一个位置开始；例子如下：\n\n```javascript\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr1.exec(s);\n[ 'aa', index: 4, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\nnull\n\nr1.exec(s);\n[ 'a', index: 7, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr1.exec(s);\nnull\n\nr2.exec(s);\nnull\n```\n\n### 例子：`g`修饰符和`y`修饰符的区别\n\n使用`g`修饰符和`lastIndex`来验证运行方式\n\n```javascript\nconst REGEX = /a/g;\n\nREGEX.lastIndex = 2; // 默认从2开始匹配（数组下标2）\nconst match = REGEX.exec('xaya');\n\nmatch.index // 3 也就是指定位置向后搜索字符'a'\n\nREGEX.lastIndex // 4 从下一次匹配的位置开始\nREGEX.exec('xaya') // null\n```\n\n使用`y`修饰符和`lastIndex`来验证运行方式\n\n```javascript\nconst REGEX = /a/y;\n\nREGEX.lastIndex = 2;\nREGEX.exec('xaya') // null 不是粘连，因为位置2指向的是字符'y'\n\nREGEX.lastIndex = 3;\n\nconst match = REGEX.exec('xaxa');\nmatch.index // 3\nREGEX.lastIndex // 4\n```\n\n### sticky属性\n\nES6正则对象多了`sticky`属性，表示是否设置了`y`修饰符。\n\n```javascript\nvar r = /hello\\d/y;\nr.sticky // true\n```\n\n### flags属性\n\nES6为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。\n\n```javascript\n/abc/ig.source // \"abc\"\n\n/abc/ig.flags // \"gi\"\n```\n\n## ES6新增功能：`s`修饰符\n\n### dotAll模式：即点代表一切字符\n\n正则表达式中`.`是个特殊字符，可以用于表示任意的单个字符。但是它排除了行终止符。而有时候我们希望匹配的是任意单个字符，因此，提案中引入了`/s`修饰符，使得`.`可以匹配任意单个字符。\n\n```javascript\n/foo.bar/s.test('foo\\nbar') // true\n```\n\n### 先行断言\n\nES5中，JavaScript的正则表达式只支持“先行断言”和“先行否定断言”。先行断言的意思是：`x`只有在`y`前面才匹配，对应的正则模式需写成`/x(?=y)/`。同理：先行否定断言是指：`x`只有不在`y`前面才匹配，对应的正则匹配模式为：`/x(?!y)/`\n\n### 后行断言\n\nES7中新增了一个提案，允许正则表达式进行“后行断言”。后行断言的意思是：`x`只有在`y`的后面才匹配，必须写成`/(?<=y)x/`。同理：后行否定断言是指：x只有不在y后面才匹配，对应的正则匹配模式为：`/(?<!y)x/`\n\n## Unicode属性类\n\n目前有一个新提案，允许正则表达式匹配符合Unicode某种属性的所有字符，使用前一定要加上`u`字符：\n\n```javascript\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π'); // true\n```\n\nUnicode属性类要指定属性名和属性值：\n\n```javascript\n// 需要指定Unicode属性名和属性值\n\\p{UnicodePropertyName=UnicodePropertyValue}\n\n// 对于某些属性，可以只写属性名\n\\p{UnicodePropertyName}\n```\n","slug":"javascript/es6-regexp","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vk00214f614q2f3d6f","content":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。模式匹配常用在<code>RegExp</code> <code>exec</code> <code>test</code>方法，以及<code>String</code>的<code>match</code>、<code>matchAll</code>、<code>replace</code>、<code>search</code>和<code>split</code>方法。</p>\n<h2 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h2><p>使用下面两种方法都可以创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// method 1</span><br><span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-regexp\">/abc/ig</span>; <span class=\"hljs-comment\">// 其中ig为正则对象修饰符</span><br><br><span class=\"hljs-comment\">// method 2</span><br><span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/abc/ig</span>); <span class=\"hljs-comment\">// 返回一个原有正则表达式的拷贝</span><br></code></pre></td></tr></table></figure>\n<p>除此之外ES6还提供了带两个参数的<code>RegExp</code>函数，但是在ES5这种写法是非法的。ES6中则放款了此项限制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> regex = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/xyz/</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>); <span class=\"hljs-comment\">// ES5中报错、但是在ES6中是允许的</span><br><span class=\"hljs-comment\">// regex &quot;i&quot; 第二个参数为指定修饰符，返回的正则表达式对象会忽略原有的修饰符，只使用新指定的修饰符</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：u修饰符\"><a href=\"#ES6新增功能：u修饰符\" class=\"headerlink\" title=\"ES6新增功能：u修饰符\"></a>ES6新增功能：<code>u</code>修饰符</h2><p><code>u字符</code>为Unicode字符的意思，可以识别码点超过<code>0xFFFF</code>的字符。前一章节也讲过ES6加入了Unicode字符表示。因此正则也是可以支持Unicode的模式识别的。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/\\u&#123;<span class=\"hljs-number\">61</span>&#125;/.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-comment\">// false</span><br>/\\u&#123;<span class=\"hljs-number\">61</span>&#125;/u.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>/\\u&#123;20BB7&#125;/u.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;𠮷&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"预定义模式\"><a href=\"#预定义模式\" class=\"headerlink\" title=\"预定义模式\"></a>预定义模式</h3><p>另外<code>u</code>字符也会影响预定义模式，能否正确识别大于<code>0xFFFF</code>的Unicode字符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">codePointLength</span>(<span class=\"hljs-params\">text</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = text.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/[\\s\\S]/gu</span>);<br>    <span class=\"hljs-keyword\">return</span> result ? result.<span class=\"hljs-property\">length</span> : <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&#x27;\\u&#123;20BB7&#125;\\u&#123;20BB7&#125;&#x27;</span>;<br><br>s.<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title function_\">codePointLength</span>(s) <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：y修饰符\"><a href=\"#ES6新增功能：y修饰符\" class=\"headerlink\" title=\"ES6新增功能：y修饰符\"></a>ES6新增功能：<code>y</code>修饰符</h2><p><code>y</code>字符也称为粘连字符，其作用于<code>g</code>修饰符类似。后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于<code>g</code>修饰符只要剩余位置中存在匹配即可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始；例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> r1 = <span class=\"hljs-regexp\">/a+/g</span>;<br><span class=\"hljs-keyword\">var</span> r2 = <span class=\"hljs-regexp\">/a+/y</span>;<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">7</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"例子：g修饰符和y修饰符的区别\"><a href=\"#例子：g修饰符和y修饰符的区别\" class=\"headerlink\" title=\"例子：g修饰符和y修饰符的区别\"></a>例子：<code>g</code>修饰符和<code>y</code>修饰符的区别</h3><p>使用<code>g</code>修饰符和<code>lastIndex</code>来验证运行方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">REGEX</span> = <span class=\"hljs-regexp\">/a/g</span>;<br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 默认从2开始匹配（数组下标2）</span><br><span class=\"hljs-keyword\">const</span> match = <span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>);<br><br>match.<span class=\"hljs-property\">index</span> <span class=\"hljs-comment\">// 3 也就是指定位置向后搜索字符&#x27;a&#x27;</span><br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> <span class=\"hljs-comment\">// 4 从下一次匹配的位置开始</span><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>) <span class=\"hljs-comment\">// null</span><br></code></pre></td></tr></table></figure>\n<p>使用<code>y</code>修饰符和<code>lastIndex</code>来验证运行方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">REGEX</span> = <span class=\"hljs-regexp\">/a/y</span>;<br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>) <span class=\"hljs-comment\">// null 不是粘连，因为位置2指向的是字符&#x27;y&#x27;</span><br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-keyword\">const</span> match = <span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaxa&#x27;</span>);<br>match.<span class=\"hljs-property\">index</span> <span class=\"hljs-comment\">// 3</span><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> <span class=\"hljs-comment\">// 4</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"sticky属性\"><a href=\"#sticky属性\" class=\"headerlink\" title=\"sticky属性\"></a>sticky属性</h3><p>ES6正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> r = <span class=\"hljs-regexp\">/hello\\d/y</span>;<br>r.<span class=\"hljs-property\">sticky</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"flags属性\"><a href=\"#flags属性\" class=\"headerlink\" title=\"flags属性\"></a>flags属性</h3><p>ES6为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/abc/ig.<span class=\"hljs-property\">source</span> <span class=\"hljs-comment\">// &quot;abc&quot;</span><br><br>/abc/ig.<span class=\"hljs-property\">flags</span> <span class=\"hljs-comment\">// &quot;gi&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：s修饰符\"><a href=\"#ES6新增功能：s修饰符\" class=\"headerlink\" title=\"ES6新增功能：s修饰符\"></a>ES6新增功能：<code>s</code>修饰符</h2><h3 id=\"dotAll模式：即点代表一切字符\"><a href=\"#dotAll模式：即点代表一切字符\" class=\"headerlink\" title=\"dotAll模式：即点代表一切字符\"></a>dotAll模式：即点代表一切字符</h3><p>正则表达式中<code>.</code>是个特殊字符，可以用于表示任意的单个字符。但是它排除了行终止符。而有时候我们希望匹配的是任意单个字符，因此，提案中引入了<code>/s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/foo.<span class=\"hljs-property\">bar</span>/s.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;foo\\nbar&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>ES5中，JavaScript的正则表达式只支持“先行断言”和“先行否定断言”。先行断言的意思是：<code>x</code>只有在<code>y</code>前面才匹配，对应的正则模式需写成<code>/x(?=y)/</code>。同理：先行否定断言是指：<code>x</code>只有不在<code>y</code>前面才匹配，对应的正则匹配模式为：<code>/x(?!y)/</code></p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>ES7中新增了一个提案，允许正则表达式进行“后行断言”。后行断言的意思是：<code>x</code>只有在<code>y</code>的后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。同理：后行否定断言是指：x只有不在y后面才匹配，对应的正则匹配模式为：<code>/(?&lt;!y)x/</code></p>\n<h2 id=\"Unicode属性类\"><a href=\"#Unicode属性类\" class=\"headerlink\" title=\"Unicode属性类\"></a>Unicode属性类</h2><p>目前有一个新提案，允许正则表达式匹配符合Unicode某种属性的所有字符，使用前一定要加上<code>u</code>字符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> regexGreekSymbol = <span class=\"hljs-regexp\">/\\p&#123;Script=Greek&#125;/u</span>;<br>regexGreekSymbol.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;π&#x27;</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>Unicode属性类要指定属性名和属性值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 需要指定Unicode属性名和属性值</span><br>\\p&#123;<span class=\"hljs-title class_\">UnicodePropertyName</span>=<span class=\"hljs-title class_\">UnicodePropertyValue</span>&#125;<br><br><span class=\"hljs-comment\">// 对于某些属性，可以只写属性名</span><br>\\p&#123;<span class=\"hljs-title class_\">UnicodePropertyName</span>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2883,"excerpt":"","more":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。模式匹配常用在<code>RegExp</code> <code>exec</code> <code>test</code>方法，以及<code>String</code>的<code>match</code>、<code>matchAll</code>、<code>replace</code>、<code>search</code>和<code>split</code>方法。</p>\n<h2 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h2><p>使用下面两种方法都可以创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// method 1</span><br><span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-regexp\">/abc/ig</span>; <span class=\"hljs-comment\">// 其中ig为正则对象修饰符</span><br><br><span class=\"hljs-comment\">// method 2</span><br><span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/abc/ig</span>); <span class=\"hljs-comment\">// 返回一个原有正则表达式的拷贝</span><br></code></pre></td></tr></table></figure>\n<p>除此之外ES6还提供了带两个参数的<code>RegExp</code>函数，但是在ES5这种写法是非法的。ES6中则放款了此项限制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> regex = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/xyz/</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>); <span class=\"hljs-comment\">// ES5中报错、但是在ES6中是允许的</span><br><span class=\"hljs-comment\">// regex &quot;i&quot; 第二个参数为指定修饰符，返回的正则表达式对象会忽略原有的修饰符，只使用新指定的修饰符</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：u修饰符\"><a href=\"#ES6新增功能：u修饰符\" class=\"headerlink\" title=\"ES6新增功能：u修饰符\"></a>ES6新增功能：<code>u</code>修饰符</h2><p><code>u字符</code>为Unicode字符的意思，可以识别码点超过<code>0xFFFF</code>的字符。前一章节也讲过ES6加入了Unicode字符表示。因此正则也是可以支持Unicode的模式识别的。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/\\u&#123;<span class=\"hljs-number\">61</span>&#125;/.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-comment\">// false</span><br>/\\u&#123;<span class=\"hljs-number\">61</span>&#125;/u.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>/\\u&#123;20BB7&#125;/u.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;𠮷&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"预定义模式\"><a href=\"#预定义模式\" class=\"headerlink\" title=\"预定义模式\"></a>预定义模式</h3><p>另外<code>u</code>字符也会影响预定义模式，能否正确识别大于<code>0xFFFF</code>的Unicode字符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">codePointLength</span>(<span class=\"hljs-params\">text</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = text.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/[\\s\\S]/gu</span>);<br>    <span class=\"hljs-keyword\">return</span> result ? result.<span class=\"hljs-property\">length</span> : <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&#x27;\\u&#123;20BB7&#125;\\u&#123;20BB7&#125;&#x27;</span>;<br><br>s.<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title function_\">codePointLength</span>(s) <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：y修饰符\"><a href=\"#ES6新增功能：y修饰符\" class=\"headerlink\" title=\"ES6新增功能：y修饰符\"></a>ES6新增功能：<code>y</code>修饰符</h2><p><code>y</code>字符也称为粘连字符，其作用于<code>g</code>修饰符类似。后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于<code>g</code>修饰符只要剩余位置中存在匹配即可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始；例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> r1 = <span class=\"hljs-regexp\">/a+/g</span>;<br><span class=\"hljs-keyword\">var</span> r2 = <span class=\"hljs-regexp\">/a+/y</span>;<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">7</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"例子：g修饰符和y修饰符的区别\"><a href=\"#例子：g修饰符和y修饰符的区别\" class=\"headerlink\" title=\"例子：g修饰符和y修饰符的区别\"></a>例子：<code>g</code>修饰符和<code>y</code>修饰符的区别</h3><p>使用<code>g</code>修饰符和<code>lastIndex</code>来验证运行方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">REGEX</span> = <span class=\"hljs-regexp\">/a/g</span>;<br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 默认从2开始匹配（数组下标2）</span><br><span class=\"hljs-keyword\">const</span> match = <span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>);<br><br>match.<span class=\"hljs-property\">index</span> <span class=\"hljs-comment\">// 3 也就是指定位置向后搜索字符&#x27;a&#x27;</span><br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> <span class=\"hljs-comment\">// 4 从下一次匹配的位置开始</span><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>) <span class=\"hljs-comment\">// null</span><br></code></pre></td></tr></table></figure>\n<p>使用<code>y</code>修饰符和<code>lastIndex</code>来验证运行方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">REGEX</span> = <span class=\"hljs-regexp\">/a/y</span>;<br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>) <span class=\"hljs-comment\">// null 不是粘连，因为位置2指向的是字符&#x27;y&#x27;</span><br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-keyword\">const</span> match = <span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaxa&#x27;</span>);<br>match.<span class=\"hljs-property\">index</span> <span class=\"hljs-comment\">// 3</span><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> <span class=\"hljs-comment\">// 4</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"sticky属性\"><a href=\"#sticky属性\" class=\"headerlink\" title=\"sticky属性\"></a>sticky属性</h3><p>ES6正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> r = <span class=\"hljs-regexp\">/hello\\d/y</span>;<br>r.<span class=\"hljs-property\">sticky</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"flags属性\"><a href=\"#flags属性\" class=\"headerlink\" title=\"flags属性\"></a>flags属性</h3><p>ES6为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/abc/ig.<span class=\"hljs-property\">source</span> <span class=\"hljs-comment\">// &quot;abc&quot;</span><br><br>/abc/ig.<span class=\"hljs-property\">flags</span> <span class=\"hljs-comment\">// &quot;gi&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：s修饰符\"><a href=\"#ES6新增功能：s修饰符\" class=\"headerlink\" title=\"ES6新增功能：s修饰符\"></a>ES6新增功能：<code>s</code>修饰符</h2><h3 id=\"dotAll模式：即点代表一切字符\"><a href=\"#dotAll模式：即点代表一切字符\" class=\"headerlink\" title=\"dotAll模式：即点代表一切字符\"></a>dotAll模式：即点代表一切字符</h3><p>正则表达式中<code>.</code>是个特殊字符，可以用于表示任意的单个字符。但是它排除了行终止符。而有时候我们希望匹配的是任意单个字符，因此，提案中引入了<code>/s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/foo.<span class=\"hljs-property\">bar</span>/s.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;foo\\nbar&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>ES5中，JavaScript的正则表达式只支持“先行断言”和“先行否定断言”。先行断言的意思是：<code>x</code>只有在<code>y</code>前面才匹配，对应的正则模式需写成<code>/x(?=y)/</code>。同理：先行否定断言是指：<code>x</code>只有不在<code>y</code>前面才匹配，对应的正则匹配模式为：<code>/x(?!y)/</code></p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>ES7中新增了一个提案，允许正则表达式进行“后行断言”。后行断言的意思是：<code>x</code>只有在<code>y</code>的后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。同理：后行否定断言是指：x只有不在y后面才匹配，对应的正则匹配模式为：<code>/(?&lt;!y)x/</code></p>\n<h2 id=\"Unicode属性类\"><a href=\"#Unicode属性类\" class=\"headerlink\" title=\"Unicode属性类\"></a>Unicode属性类</h2><p>目前有一个新提案，允许正则表达式匹配符合Unicode某种属性的所有字符，使用前一定要加上<code>u</code>字符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> regexGreekSymbol = <span class=\"hljs-regexp\">/\\p&#123;Script=Greek&#125;/u</span>;<br>regexGreekSymbol.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;π&#x27;</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>Unicode属性类要指定属性名和属性值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 需要指定Unicode属性名和属性值</span><br>\\p&#123;<span class=\"hljs-title class_\">UnicodePropertyName</span>=<span class=\"hljs-title class_\">UnicodePropertyValue</span>&#125;<br><br><span class=\"hljs-comment\">// 对于某些属性，可以只写属性名</span><br>\\p&#123;<span class=\"hljs-title class_\">UnicodePropertyName</span>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 Set和Map","date":"2022-02-17T07:16:56.000Z","updated":"2022-02-17T07:16:56.000Z","_content":"\n# Set和Map\n\n## Set\n\n### 基本用法\n\n类似与数组结构，但是数组中的成员值时唯一不重复的。跟Java中的Set是同样的意思。\n\n```javascript\nvar s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n也可以结合扩展运算符写成下面这样：\n\n```javascript\nvar set = new Set([1,2,3,4,5,2,3]);\n[...set] // 1 2 3 4 5\nset.size() // 5\n```\n\n### 实例的属性和方法\n\n除了构造函数以及返回size的大小，还有下面4个操作的方法：使用基本和Java相同\n\n- add(value)：添加某个值，返回Set结构本身\n- delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；\n- has(value)：返回一个布尔值，表示该值是否为Set成员\n- clear()：清除所有成员，没返回值。\n\n```javascript\nvar s = new Set();\ns.add(1).add(2).add(2);\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n### 遍历操作\n\n遍历器包含下面4个方法，可以用于遍历成员，结合Lambda表示可以有十分简洁的写法，跟Java 8的lambda表达式差不多，这里不再赘述。\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回键值对的遍历器\n- forEach()：使用回调函数遍历每个成员\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries) {\n  console.log(item)\n}\n// ['red', 'red']\n// ['green', 'green']\n// ['blue', 'blue']\n```\n\n### WeakSet\n\n从名字上看，WeakSet也是Set的一种，但是跟Set有下列几个区别：\n\n- 成员只能是对象，不能是其他类型的值；\n- 集合内的对象全都是弱引用，GC不会考虑对WeakSet中的对象的引用，因此WeakSet是不可遍历的。\n\n你可能会问，WeakSet的这种特性有什么用呢？由于不能遍历且内存中的对象随时会丢失，因此十分适合存储DOM节点，而不用担心这些节点从文档移除时引发内存泄露。\n\n```javascript\nconst foos = new WeakSet();\n\nclass foo {\n  constructor() {\n    foos.add(this);\n  }\n  \n  method() {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method智能在Foo实例上调用!')\n    }\n  }\n}\n```\n\n\n\n## Map\n\n### 基本用法\n\nJavaScript的对象本质上也是键值对的集合，但是传统上只能用字符串当键。因为ES6提供了Map这个对象。概念跟Java中的差不多。与JavaScript中对象唯一不同的是：它的键不仅限于字符串，还可以是其他类型。\n\n```javascript\nvar m = new Map();\nvar o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o)\n\nm.has(o)\nm.delete(o)\nm.has(o)\n```\n\n与此同时，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n```javascript\nvar map = new Map([\n    ['name', 'zhangsan'],\n    ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // zhangsan\nmap.has('title') // true\nmap.get('title') // Author\n```\n\n### 实例的属性和方法\n\n跟上面提到的Set一样，Map也有属于自己的实例属性和方法。\n\n- size：返回Map结构的成员总数\n- set(key, value)：设置key对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新；\n- get(key)：读取key对应的键值，如果找不到则返回undefined；\n- has(key)：返回一个布尔值，表示某个键是否在Map数据结构中；\n- delete(key)：删除某个键，返回true，如果删除失败则返回false；\n- clear()：清除所有成员，没有返回值；\n\n### 遍历方法\n\nMap提供了三个原生的遍历器生成函数和一个遍历方法，这个和之前的Set很相似；\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回所有成员的遍历器\n- forEach()：返回Map的所有成员\n\n下面提供一个实例的使用方法：\n\n```javascript\nlet map = new Map([\n    ['F', 'no'],\n    ['T', 'yes']\n]);\n\nfor (let key of map.keys()) {\n    console.log(key);\n}\n\nfor (let value of map.values()) {\n    console.log(value);\n}\n\nfor (let item of map.entries()) {\n    console.log(item)\n}\n\nfor (let [key, value] of map.entries()) {\n    console.log(key, value)\n}\n\nfor (let [key, value] of map) {\n    console.log(key, value)\n}\n```\n\n同样的，使用扩展运算符可以将Map快速转换为数组。\n\n```javascript\nlet map = new Map([\n    [1, 'one'],\n    [2, 'two'],\n    [3, 'three']\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1, 'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1, 'one'], [2, 'two'], [3, 'three']]\n```\n\n结合map和Filter等方法可以实现更加方便简洁的操作。\n\n```javascript\nlet map0 = new Map()\n\t.set(1, 'a')\n\t.set(2, 'b')\n\t.set(3, 'c');\n\nlet map1 = new Map(\n\t[...map0].filter([k, v] => k < 3)\n);\n\nlet map2 = new Map(\n\t[...map0].map([k, v] => [k * 2, '_' + v])\n);\n```\n\n此外，还有forEach方法，可以实现遍历。效果和Set上的forEach完全一样\n\n```javascript\nmap.forEach(function (key, value, map) {\n    console.log(\"key: %s, value: %s\", key, value);\n});\n\n// 还可以绑定this\nmap.forEach(function (key, value, map){\n    this.report(key, value);\n}, reporter);\n```\n\n### 与其他数据结构的互相转换\n\n### Map转数组\n\n前面已经提到，使用扩展运算符可以很好地将Map转换成数组，这里不再赘述；\n\n### 数组转Map\n\n将数组作为参数传入Map的构造函数，就可以将数组转换为Map\n\n### Map转对象\n\n如果Map中的所有键都是字符串，那么就可以将其转换为对象\n\n```javascript\nfunction strMapToObj(strMap) {\n    let obj = Object.create(null);\n    for (let [k, v] of strMap) {\n        obj[k] = v;\n    }\n    return obj;\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToObj(myMap)\n```\n\n### 对象转Map\n\n```javascript\nfunction objToStrMap(obj) {\n    let strMap = new Map();\n    for (let k of Object.keys(obj)) {\n        strMap.set(k, obj[k]);\n    }\n    return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n```\n\n### Map转JSON\n\nMap转JSON要分为两种情况：如果键名都是字符串，那么可以直接转成JSON；如果键名中有非字符串，这时可以选择转为数组JSON。\n\n```javascript\n// Map --> JSON (1)\nfunction strMapToJson(strMap) {\n    return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n\nfunction mapToArrayJson(map) {\n    return JSON.stringify([...map]);\n}\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n```\n\n### JSON转Map\n\n跟上面的情况一样：所有键名都是字符串，随便转；另外一个：整个JSON就是数组，每个数组成员本身又只有一个两个成员的数组。这个时候可以一一对应转换为Map。\n\n```javascript\nfunction jsonToMap(jsonStr) {\n    return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true, 7], [{\"foo\":3}, [\"abc\"]]]')\n```\n\n### WeakMap\n\nWeakMap和Map基本类似，唯一区别就是：它只接受对象作为键名，不接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。跟WeakSet一样，设计它的目的有助于防止内存泄露：\n\n```javascript\nlet myElement = document.getElementById('logo');\nlet myWeakMap = new WeakMap();\n\nmyWeakMap.set(myElement, {timesClicked: 0});\n\nmyElement.addEventListener('click', function(){\n    let logoData = myWeakMap.get(myElement);\n    logoData.timesClicked ++;\n}, false);\n```\n\n上述代码设计了一个机制：每当DOM中节点发生click事件，就更新一下状态。一旦这个DOM节点删除，该状态就会自动消失，不会存在内存泄露的风险。\n\nWeakMap的另一个作用就是部署私有属性\n\n```javascript\nlet _counter = new WeakMap();\nlet _action = new WeakMap();\n\nclass Countdown {\n    constructor(counter, action) {\n        _counter.set(this, counter);\n        _action.set(this, action);\n    }\n    dec() {\n        let counter = _counter.get(this);\n        if (counter < 1) return;\n        counter--;\n        _counter.set(this, counter);\n        if (counter === 0) {\n            _action.get(this)();\n        }\n    }\n}\n\nlet c = new Countdown(2, () => console.log('DONE'));\n\nc.dec()\nc.dec()\n// DONE\n```\n\n上面代码中，Countdown类的两个内部属性`_counter`和`_action`是实例的弱引用，所以如果删除实例，它们也就随之消失。不会造成内存泄露。\n","source":"_posts/javascript/es6-set-and-map.md","raw":"---\ntitle: ES6 Set和Map\ndate: 2022-02-17 15:16:56\nupdated: 2022-02-17 15:16:56\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Set和Map\n\n## Set\n\n### 基本用法\n\n类似与数组结构，但是数组中的成员值时唯一不重复的。跟Java中的Set是同样的意思。\n\n```javascript\nvar s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n也可以结合扩展运算符写成下面这样：\n\n```javascript\nvar set = new Set([1,2,3,4,5,2,3]);\n[...set] // 1 2 3 4 5\nset.size() // 5\n```\n\n### 实例的属性和方法\n\n除了构造函数以及返回size的大小，还有下面4个操作的方法：使用基本和Java相同\n\n- add(value)：添加某个值，返回Set结构本身\n- delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；\n- has(value)：返回一个布尔值，表示该值是否为Set成员\n- clear()：清除所有成员，没返回值。\n\n```javascript\nvar s = new Set();\ns.add(1).add(2).add(2);\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n### 遍历操作\n\n遍历器包含下面4个方法，可以用于遍历成员，结合Lambda表示可以有十分简洁的写法，跟Java 8的lambda表达式差不多，这里不再赘述。\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回键值对的遍历器\n- forEach()：使用回调函数遍历每个成员\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries) {\n  console.log(item)\n}\n// ['red', 'red']\n// ['green', 'green']\n// ['blue', 'blue']\n```\n\n### WeakSet\n\n从名字上看，WeakSet也是Set的一种，但是跟Set有下列几个区别：\n\n- 成员只能是对象，不能是其他类型的值；\n- 集合内的对象全都是弱引用，GC不会考虑对WeakSet中的对象的引用，因此WeakSet是不可遍历的。\n\n你可能会问，WeakSet的这种特性有什么用呢？由于不能遍历且内存中的对象随时会丢失，因此十分适合存储DOM节点，而不用担心这些节点从文档移除时引发内存泄露。\n\n```javascript\nconst foos = new WeakSet();\n\nclass foo {\n  constructor() {\n    foos.add(this);\n  }\n  \n  method() {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method智能在Foo实例上调用!')\n    }\n  }\n}\n```\n\n\n\n## Map\n\n### 基本用法\n\nJavaScript的对象本质上也是键值对的集合，但是传统上只能用字符串当键。因为ES6提供了Map这个对象。概念跟Java中的差不多。与JavaScript中对象唯一不同的是：它的键不仅限于字符串，还可以是其他类型。\n\n```javascript\nvar m = new Map();\nvar o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o)\n\nm.has(o)\nm.delete(o)\nm.has(o)\n```\n\n与此同时，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n```javascript\nvar map = new Map([\n    ['name', 'zhangsan'],\n    ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // zhangsan\nmap.has('title') // true\nmap.get('title') // Author\n```\n\n### 实例的属性和方法\n\n跟上面提到的Set一样，Map也有属于自己的实例属性和方法。\n\n- size：返回Map结构的成员总数\n- set(key, value)：设置key对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新；\n- get(key)：读取key对应的键值，如果找不到则返回undefined；\n- has(key)：返回一个布尔值，表示某个键是否在Map数据结构中；\n- delete(key)：删除某个键，返回true，如果删除失败则返回false；\n- clear()：清除所有成员，没有返回值；\n\n### 遍历方法\n\nMap提供了三个原生的遍历器生成函数和一个遍历方法，这个和之前的Set很相似；\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回所有成员的遍历器\n- forEach()：返回Map的所有成员\n\n下面提供一个实例的使用方法：\n\n```javascript\nlet map = new Map([\n    ['F', 'no'],\n    ['T', 'yes']\n]);\n\nfor (let key of map.keys()) {\n    console.log(key);\n}\n\nfor (let value of map.values()) {\n    console.log(value);\n}\n\nfor (let item of map.entries()) {\n    console.log(item)\n}\n\nfor (let [key, value] of map.entries()) {\n    console.log(key, value)\n}\n\nfor (let [key, value] of map) {\n    console.log(key, value)\n}\n```\n\n同样的，使用扩展运算符可以将Map快速转换为数组。\n\n```javascript\nlet map = new Map([\n    [1, 'one'],\n    [2, 'two'],\n    [3, 'three']\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1, 'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1, 'one'], [2, 'two'], [3, 'three']]\n```\n\n结合map和Filter等方法可以实现更加方便简洁的操作。\n\n```javascript\nlet map0 = new Map()\n\t.set(1, 'a')\n\t.set(2, 'b')\n\t.set(3, 'c');\n\nlet map1 = new Map(\n\t[...map0].filter([k, v] => k < 3)\n);\n\nlet map2 = new Map(\n\t[...map0].map([k, v] => [k * 2, '_' + v])\n);\n```\n\n此外，还有forEach方法，可以实现遍历。效果和Set上的forEach完全一样\n\n```javascript\nmap.forEach(function (key, value, map) {\n    console.log(\"key: %s, value: %s\", key, value);\n});\n\n// 还可以绑定this\nmap.forEach(function (key, value, map){\n    this.report(key, value);\n}, reporter);\n```\n\n### 与其他数据结构的互相转换\n\n### Map转数组\n\n前面已经提到，使用扩展运算符可以很好地将Map转换成数组，这里不再赘述；\n\n### 数组转Map\n\n将数组作为参数传入Map的构造函数，就可以将数组转换为Map\n\n### Map转对象\n\n如果Map中的所有键都是字符串，那么就可以将其转换为对象\n\n```javascript\nfunction strMapToObj(strMap) {\n    let obj = Object.create(null);\n    for (let [k, v] of strMap) {\n        obj[k] = v;\n    }\n    return obj;\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToObj(myMap)\n```\n\n### 对象转Map\n\n```javascript\nfunction objToStrMap(obj) {\n    let strMap = new Map();\n    for (let k of Object.keys(obj)) {\n        strMap.set(k, obj[k]);\n    }\n    return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n```\n\n### Map转JSON\n\nMap转JSON要分为两种情况：如果键名都是字符串，那么可以直接转成JSON；如果键名中有非字符串，这时可以选择转为数组JSON。\n\n```javascript\n// Map --> JSON (1)\nfunction strMapToJson(strMap) {\n    return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n\nfunction mapToArrayJson(map) {\n    return JSON.stringify([...map]);\n}\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n```\n\n### JSON转Map\n\n跟上面的情况一样：所有键名都是字符串，随便转；另外一个：整个JSON就是数组，每个数组成员本身又只有一个两个成员的数组。这个时候可以一一对应转换为Map。\n\n```javascript\nfunction jsonToMap(jsonStr) {\n    return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true, 7], [{\"foo\":3}, [\"abc\"]]]')\n```\n\n### WeakMap\n\nWeakMap和Map基本类似，唯一区别就是：它只接受对象作为键名，不接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。跟WeakSet一样，设计它的目的有助于防止内存泄露：\n\n```javascript\nlet myElement = document.getElementById('logo');\nlet myWeakMap = new WeakMap();\n\nmyWeakMap.set(myElement, {timesClicked: 0});\n\nmyElement.addEventListener('click', function(){\n    let logoData = myWeakMap.get(myElement);\n    logoData.timesClicked ++;\n}, false);\n```\n\n上述代码设计了一个机制：每当DOM中节点发生click事件，就更新一下状态。一旦这个DOM节点删除，该状态就会自动消失，不会存在内存泄露的风险。\n\nWeakMap的另一个作用就是部署私有属性\n\n```javascript\nlet _counter = new WeakMap();\nlet _action = new WeakMap();\n\nclass Countdown {\n    constructor(counter, action) {\n        _counter.set(this, counter);\n        _action.set(this, action);\n    }\n    dec() {\n        let counter = _counter.get(this);\n        if (counter < 1) return;\n        counter--;\n        _counter.set(this, counter);\n        if (counter === 0) {\n            _action.get(this)();\n        }\n    }\n}\n\nlet c = new Countdown(2, () => console.log('DONE'));\n\nc.dec()\nc.dec()\n// DONE\n```\n\n上面代码中，Countdown类的两个内部属性`_counter`和`_action`是实例的弱引用，所以如果删除实例，它们也就随之消失。不会造成内存泄露。\n","slug":"javascript/es6-set-and-map","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vl00264f612cck29jx","content":"<h1 id=\"Set和Map\"><a href=\"#Set和Map\" class=\"headerlink\" title=\"Set和Map\"></a>Set和Map</h1><h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>类似与数组结构，但是数组中的成员值时唯一不重复的。跟Java中的Set是同样的意思。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><br>[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> s.<span class=\"hljs-title function_\">add</span>(x));<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> s) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br><span class=\"hljs-comment\">// 2 3 5 4</span><br></code></pre></td></tr></table></figure>\n<p>也可以结合扩展运算符写成下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]);<br>[...set] <span class=\"hljs-comment\">// 1 2 3 4 5</span><br>set.<span class=\"hljs-title function_\">size</span>() <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法\"><a href=\"#实例的属性和方法\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><p>除了构造函数以及返回size的大小，还有下面4个操作的方法：使用基本和Java相同</p>\n<ul>\n<li>add(value)：添加某个值，返回Set结构本身</li>\n<li>delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；</li>\n<li>has(value)：返回一个布尔值，表示该值是否为Set成员</li>\n<li>clear()：清除所有成员，没返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>s.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>);<br><br>s.<span class=\"hljs-property\">size</span> <span class=\"hljs-comment\">// 2</span><br><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// false</span><br><br>s.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">2</span>);<br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历操作\"><a href=\"#遍历操作\" class=\"headerlink\" title=\"遍历操作\"></a>遍历操作</h3><p>遍历器包含下面4个方法，可以用于遍历成员，结合Lambda表示可以有十分简洁的写法，跟Java 8的lambda表达式差不多，这里不再赘述。</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回键值对的遍历器</li>\n<li>forEach()：使用回调函数遍历每个成员</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-title function_\">values</span>()) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-property\">entries</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item)<br>&#125;<br><span class=\"hljs-comment\">// [&#x27;red&#x27;, &#x27;red&#x27;]</span><br><span class=\"hljs-comment\">// [&#x27;green&#x27;, &#x27;green&#x27;]</span><br><span class=\"hljs-comment\">// [&#x27;blue&#x27;, &#x27;blue&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>从名字上看，WeakSet也是Set的一种，但是跟Set有下列几个区别：</p>\n<ul>\n<li>成员只能是对象，不能是其他类型的值；</li>\n<li>集合内的对象全都是弱引用，GC不会考虑对WeakSet中的对象的引用，因此WeakSet是不可遍历的。</li>\n</ul>\n<p>你可能会问，WeakSet的这种特性有什么用呢？由于不能遍历且内存中的对象随时会丢失，因此十分适合存储DOM节点，而不用担心这些节点从文档移除时引发内存泄露。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foos = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakSet</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">foo</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    foos.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!foos.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-variable language_\">this</span>)) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Foo.prototype.method智能在Foo实例上调用!&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>JavaScript的对象本质上也是键值对的集合，但是传统上只能用字符串当键。因为ES6提供了Map这个对象。概念跟Java中的差不多。与JavaScript中对象唯一不同的是：它的键不仅限于字符串，还可以是其他类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><span class=\"hljs-keyword\">var</span> o = &#123;<span class=\"hljs-attr\">p</span>: <span class=\"hljs-string\">&#x27;Hello World&#x27;</span>&#125;;<br><br>m.<span class=\"hljs-title function_\">set</span>(o, <span class=\"hljs-string\">&#x27;content&#x27;</span>)<br>m.<span class=\"hljs-title function_\">get</span>(o)<br><br>m.<span class=\"hljs-title function_\">has</span>(o)<br>m.<span class=\"hljs-title function_\">delete</span>(o)<br>m.<span class=\"hljs-title function_\">has</span>(o)<br></code></pre></td></tr></table></figure>\n<p>与此同时，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-string\">&#x27;name&#x27;</span>, <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span>],<br>    [<span class=\"hljs-string\">&#x27;title&#x27;</span>, <span class=\"hljs-string\">&#x27;Author&#x27;</span>]<br>]);<br><br>map.<span class=\"hljs-property\">size</span> <span class=\"hljs-comment\">// 2</span><br>map.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// zhangsan</span><br>map.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// Author</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法-1\"><a href=\"#实例的属性和方法-1\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><p>跟上面提到的Set一样，Map也有属于自己的实例属性和方法。</p>\n<ul>\n<li>size：返回Map结构的成员总数</li>\n<li>set(key, value)：设置key对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新；</li>\n<li>get(key)：读取key对应的键值，如果找不到则返回undefined；</li>\n<li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中；</li>\n<li>delete(key)：删除某个键，返回true，如果删除失败则返回false；</li>\n<li>clear()：清除所有成员，没有返回值；</li>\n</ul>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><p>Map提供了三个原生的遍历器生成函数和一个遍历方法，这个和之前的Set很相似；</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回所有成员的遍历器</li>\n<li>forEach()：返回Map的所有成员</li>\n</ul>\n<p>下面提供一个实例的使用方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-string\">&#x27;F&#x27;</span>, <span class=\"hljs-string\">&#x27;no&#x27;</span>],<br>    [<span class=\"hljs-string\">&#x27;T&#x27;</span>, <span class=\"hljs-string\">&#x27;yes&#x27;</span>]<br>]);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>同样的，使用扩展运算符可以将Map快速转换为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;one&#x27;</span>],<br>    [<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;two&#x27;</span>],<br>    [<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;three&#x27;</span>]<br>]);<br><br>[...map.<span class=\"hljs-title function_\">keys</span>()]<br><span class=\"hljs-comment\">// [1, 2, 3]</span><br><br>[...map.<span class=\"hljs-title function_\">values</span>()]<br><span class=\"hljs-comment\">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span><br><br>[...map.<span class=\"hljs-title function_\">entries</span>()]<br><span class=\"hljs-comment\">// [[1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span><br><br>[...map]<br><span class=\"hljs-comment\">// [[1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span><br></code></pre></td></tr></table></figure>\n<p>结合map和Filter等方法可以实现更加方便简洁的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map0 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>);<br><br><span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<br>\t[...map0].<span class=\"hljs-title function_\">filter</span>([k, v] =&gt; k &lt; <span class=\"hljs-number\">3</span>)<br>);<br><br><span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<br>\t[...map0].<span class=\"hljs-title function_\">map</span>([k, v] =&gt; [k * <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;_&#x27;</span> + v])<br>);<br></code></pre></td></tr></table></figure>\n<p>此外，还有forEach方法，可以实现遍历。效果和Set上的forEach完全一样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">map.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">key, value, map</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;key: %s, value: %s&quot;</span>, key, value);<br>&#125;);<br><br><span class=\"hljs-comment\">// 还可以绑定this</span><br>map.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">key, value, map</span>)&#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">report</span>(key, value);<br>&#125;, reporter);<br></code></pre></td></tr></table></figure>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><h3 id=\"Map转数组\"><a href=\"#Map转数组\" class=\"headerlink\" title=\"Map转数组\"></a>Map转数组</h3><p>前面已经提到，使用扩展运算符可以很好地将Map转换成数组，这里不再赘述；</p>\n<h3 id=\"数组转Map\"><a href=\"#数组转Map\" class=\"headerlink\" title=\"数组转Map\"></a>数组转Map</h3><p>将数组作为参数传入Map的构造函数，就可以将数组转换为Map</p>\n<h3 id=\"Map转对象\"><a href=\"#Map转对象\" class=\"headerlink\" title=\"Map转对象\"></a>Map转对象</h3><p>如果Map中的所有键都是字符串，那么就可以将其转换为对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">strMapToObj</span>(<span class=\"hljs-params\">strMap</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k, v] <span class=\"hljs-keyword\">of</span> strMap) &#123;<br>        obj[k] = v;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> obj;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;yes&#x27;</span>, <span class=\"hljs-literal\">true</span>).<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;no&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-title function_\">strMapToObj</span>(myMap)<br></code></pre></td></tr></table></figure>\n<h3 id=\"对象转Map\"><a href=\"#对象转Map\" class=\"headerlink\" title=\"对象转Map\"></a>对象转Map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">objToStrMap</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> strMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)) &#123;<br>        strMap.<span class=\"hljs-title function_\">set</span>(k, obj[k]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> strMap;<br>&#125;<br><br><span class=\"hljs-title function_\">objToStrMap</span>(&#123;<span class=\"hljs-attr\">yes</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">no</span>: <span class=\"hljs-literal\">false</span>&#125;)<br></code></pre></td></tr></table></figure>\n<h3 id=\"Map转JSON\"><a href=\"#Map转JSON\" class=\"headerlink\" title=\"Map转JSON\"></a>Map转JSON</h3><p>Map转JSON要分为两种情况：如果键名都是字符串，那么可以直接转成JSON；如果键名中有非字符串，这时可以选择转为数组JSON。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Map --&gt; JSON (1)</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">strMapToJson</span>(<span class=\"hljs-params\">strMap</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(<span class=\"hljs-title function_\">strMapToObj</span>(strMap));<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;yes&#x27;</span>, <span class=\"hljs-literal\">true</span>).<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;no&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-title function_\">strMapToJson</span>(myMap)<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mapToArrayJson</span>(<span class=\"hljs-params\">map</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>([...map]);<br>&#125;<br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">7</span>).<span class=\"hljs-title function_\">set</span>(&#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">3</span>&#125;, [<span class=\"hljs-string\">&#x27;abc&#x27;</span>]);<br><span class=\"hljs-title function_\">mapToArrayJson</span>(myMap)<br></code></pre></td></tr></table></figure>\n<h3 id=\"JSON转Map\"><a href=\"#JSON转Map\" class=\"headerlink\" title=\"JSON转Map\"></a>JSON转Map</h3><p>跟上面的情况一样：所有键名都是字符串，随便转；另外一个：整个JSON就是数组，每个数组成员本身又只有一个两个成员的数组。这个时候可以一一对应转换为Map。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">jsonToMap</span>(<span class=\"hljs-params\">jsonStr</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(jsonStr));<br>&#125;<br><br><span class=\"hljs-title function_\">jsonToMap</span>(<span class=\"hljs-string\">&#x27;[[true, 7], [&#123;&quot;foo&quot;:3&#125;, [&quot;abc&quot;]]]&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap和Map基本类似，唯一区别就是：它只接受对象作为键名，不接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。跟WeakSet一样，设计它的目的有助于防止内存泄露：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> myElement = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;logo&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> myWeakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br>myWeakMap.<span class=\"hljs-title function_\">set</span>(myElement, &#123;<span class=\"hljs-attr\">timesClicked</span>: <span class=\"hljs-number\">0</span>&#125;);<br><br>myElement.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">let</span> logoData = myWeakMap.<span class=\"hljs-title function_\">get</span>(myElement);<br>    logoData.<span class=\"hljs-property\">timesClicked</span> ++;<br>&#125;, <span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\n<p>上述代码设计了一个机制：每当DOM中节点发生click事件，就更新一下状态。一旦这个DOM节点删除，该状态就会自动消失，不会存在内存泄露的风险。</p>\n<p>WeakMap的另一个作用就是部署私有属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> _counter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><span class=\"hljs-keyword\">let</span> _action = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Countdown</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">counter, action</span>) &#123;<br>        _counter.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, counter);<br>        _action.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, action);<br>    &#125;<br>    <span class=\"hljs-title function_\">dec</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> counter = _counter.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>);<br>        <span class=\"hljs-keyword\">if</span> (counter &lt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;<br>        counter--;<br>        _counter.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, counter);<br>        <span class=\"hljs-keyword\">if</span> (counter === <span class=\"hljs-number\">0</span>) &#123;<br>            _action.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>)();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Countdown</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;DONE&#x27;</span>));<br><br>c.<span class=\"hljs-title function_\">dec</span>()<br>c.<span class=\"hljs-title function_\">dec</span>()<br><span class=\"hljs-comment\">// DONE</span><br></code></pre></td></tr></table></figure>\n<p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>是实例的弱引用，所以如果删除实例，它们也就随之消失。不会造成内存泄露。</p>\n","site":{"data":{}},"wordcount":5866,"excerpt":"","more":"<h1 id=\"Set和Map\"><a href=\"#Set和Map\" class=\"headerlink\" title=\"Set和Map\"></a>Set和Map</h1><h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>类似与数组结构，但是数组中的成员值时唯一不重复的。跟Java中的Set是同样的意思。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><br>[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> s.<span class=\"hljs-title function_\">add</span>(x));<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> s) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br><span class=\"hljs-comment\">// 2 3 5 4</span><br></code></pre></td></tr></table></figure>\n<p>也可以结合扩展运算符写成下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]);<br>[...set] <span class=\"hljs-comment\">// 1 2 3 4 5</span><br>set.<span class=\"hljs-title function_\">size</span>() <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法\"><a href=\"#实例的属性和方法\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><p>除了构造函数以及返回size的大小，还有下面4个操作的方法：使用基本和Java相同</p>\n<ul>\n<li>add(value)：添加某个值，返回Set结构本身</li>\n<li>delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；</li>\n<li>has(value)：返回一个布尔值，表示该值是否为Set成员</li>\n<li>clear()：清除所有成员，没返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>s.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>);<br><br>s.<span class=\"hljs-property\">size</span> <span class=\"hljs-comment\">// 2</span><br><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// false</span><br><br>s.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">2</span>);<br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历操作\"><a href=\"#遍历操作\" class=\"headerlink\" title=\"遍历操作\"></a>遍历操作</h3><p>遍历器包含下面4个方法，可以用于遍历成员，结合Lambda表示可以有十分简洁的写法，跟Java 8的lambda表达式差不多，这里不再赘述。</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回键值对的遍历器</li>\n<li>forEach()：使用回调函数遍历每个成员</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-title function_\">values</span>()) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-property\">entries</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item)<br>&#125;<br><span class=\"hljs-comment\">// [&#x27;red&#x27;, &#x27;red&#x27;]</span><br><span class=\"hljs-comment\">// [&#x27;green&#x27;, &#x27;green&#x27;]</span><br><span class=\"hljs-comment\">// [&#x27;blue&#x27;, &#x27;blue&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>从名字上看，WeakSet也是Set的一种，但是跟Set有下列几个区别：</p>\n<ul>\n<li>成员只能是对象，不能是其他类型的值；</li>\n<li>集合内的对象全都是弱引用，GC不会考虑对WeakSet中的对象的引用，因此WeakSet是不可遍历的。</li>\n</ul>\n<p>你可能会问，WeakSet的这种特性有什么用呢？由于不能遍历且内存中的对象随时会丢失，因此十分适合存储DOM节点，而不用担心这些节点从文档移除时引发内存泄露。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foos = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakSet</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">foo</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    foos.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!foos.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-variable language_\">this</span>)) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Foo.prototype.method智能在Foo实例上调用!&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>JavaScript的对象本质上也是键值对的集合，但是传统上只能用字符串当键。因为ES6提供了Map这个对象。概念跟Java中的差不多。与JavaScript中对象唯一不同的是：它的键不仅限于字符串，还可以是其他类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><span class=\"hljs-keyword\">var</span> o = &#123;<span class=\"hljs-attr\">p</span>: <span class=\"hljs-string\">&#x27;Hello World&#x27;</span>&#125;;<br><br>m.<span class=\"hljs-title function_\">set</span>(o, <span class=\"hljs-string\">&#x27;content&#x27;</span>)<br>m.<span class=\"hljs-title function_\">get</span>(o)<br><br>m.<span class=\"hljs-title function_\">has</span>(o)<br>m.<span class=\"hljs-title function_\">delete</span>(o)<br>m.<span class=\"hljs-title function_\">has</span>(o)<br></code></pre></td></tr></table></figure>\n<p>与此同时，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-string\">&#x27;name&#x27;</span>, <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span>],<br>    [<span class=\"hljs-string\">&#x27;title&#x27;</span>, <span class=\"hljs-string\">&#x27;Author&#x27;</span>]<br>]);<br><br>map.<span class=\"hljs-property\">size</span> <span class=\"hljs-comment\">// 2</span><br>map.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// zhangsan</span><br>map.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// Author</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法-1\"><a href=\"#实例的属性和方法-1\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><p>跟上面提到的Set一样，Map也有属于自己的实例属性和方法。</p>\n<ul>\n<li>size：返回Map结构的成员总数</li>\n<li>set(key, value)：设置key对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新；</li>\n<li>get(key)：读取key对应的键值，如果找不到则返回undefined；</li>\n<li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中；</li>\n<li>delete(key)：删除某个键，返回true，如果删除失败则返回false；</li>\n<li>clear()：清除所有成员，没有返回值；</li>\n</ul>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><p>Map提供了三个原生的遍历器生成函数和一个遍历方法，这个和之前的Set很相似；</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回所有成员的遍历器</li>\n<li>forEach()：返回Map的所有成员</li>\n</ul>\n<p>下面提供一个实例的使用方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-string\">&#x27;F&#x27;</span>, <span class=\"hljs-string\">&#x27;no&#x27;</span>],<br>    [<span class=\"hljs-string\">&#x27;T&#x27;</span>, <span class=\"hljs-string\">&#x27;yes&#x27;</span>]<br>]);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>同样的，使用扩展运算符可以将Map快速转换为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;one&#x27;</span>],<br>    [<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;two&#x27;</span>],<br>    [<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;three&#x27;</span>]<br>]);<br><br>[...map.<span class=\"hljs-title function_\">keys</span>()]<br><span class=\"hljs-comment\">// [1, 2, 3]</span><br><br>[...map.<span class=\"hljs-title function_\">values</span>()]<br><span class=\"hljs-comment\">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span><br><br>[...map.<span class=\"hljs-title function_\">entries</span>()]<br><span class=\"hljs-comment\">// [[1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span><br><br>[...map]<br><span class=\"hljs-comment\">// [[1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span><br></code></pre></td></tr></table></figure>\n<p>结合map和Filter等方法可以实现更加方便简洁的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map0 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>);<br><br><span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<br>\t[...map0].<span class=\"hljs-title function_\">filter</span>([k, v] =&gt; k &lt; <span class=\"hljs-number\">3</span>)<br>);<br><br><span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<br>\t[...map0].<span class=\"hljs-title function_\">map</span>([k, v] =&gt; [k * <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;_&#x27;</span> + v])<br>);<br></code></pre></td></tr></table></figure>\n<p>此外，还有forEach方法，可以实现遍历。效果和Set上的forEach完全一样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">map.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">key, value, map</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;key: %s, value: %s&quot;</span>, key, value);<br>&#125;);<br><br><span class=\"hljs-comment\">// 还可以绑定this</span><br>map.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">key, value, map</span>)&#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">report</span>(key, value);<br>&#125;, reporter);<br></code></pre></td></tr></table></figure>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><h3 id=\"Map转数组\"><a href=\"#Map转数组\" class=\"headerlink\" title=\"Map转数组\"></a>Map转数组</h3><p>前面已经提到，使用扩展运算符可以很好地将Map转换成数组，这里不再赘述；</p>\n<h3 id=\"数组转Map\"><a href=\"#数组转Map\" class=\"headerlink\" title=\"数组转Map\"></a>数组转Map</h3><p>将数组作为参数传入Map的构造函数，就可以将数组转换为Map</p>\n<h3 id=\"Map转对象\"><a href=\"#Map转对象\" class=\"headerlink\" title=\"Map转对象\"></a>Map转对象</h3><p>如果Map中的所有键都是字符串，那么就可以将其转换为对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">strMapToObj</span>(<span class=\"hljs-params\">strMap</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k, v] <span class=\"hljs-keyword\">of</span> strMap) &#123;<br>        obj[k] = v;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> obj;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;yes&#x27;</span>, <span class=\"hljs-literal\">true</span>).<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;no&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-title function_\">strMapToObj</span>(myMap)<br></code></pre></td></tr></table></figure>\n<h3 id=\"对象转Map\"><a href=\"#对象转Map\" class=\"headerlink\" title=\"对象转Map\"></a>对象转Map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">objToStrMap</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> strMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)) &#123;<br>        strMap.<span class=\"hljs-title function_\">set</span>(k, obj[k]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> strMap;<br>&#125;<br><br><span class=\"hljs-title function_\">objToStrMap</span>(&#123;<span class=\"hljs-attr\">yes</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">no</span>: <span class=\"hljs-literal\">false</span>&#125;)<br></code></pre></td></tr></table></figure>\n<h3 id=\"Map转JSON\"><a href=\"#Map转JSON\" class=\"headerlink\" title=\"Map转JSON\"></a>Map转JSON</h3><p>Map转JSON要分为两种情况：如果键名都是字符串，那么可以直接转成JSON；如果键名中有非字符串，这时可以选择转为数组JSON。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Map --&gt; JSON (1)</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">strMapToJson</span>(<span class=\"hljs-params\">strMap</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(<span class=\"hljs-title function_\">strMapToObj</span>(strMap));<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;yes&#x27;</span>, <span class=\"hljs-literal\">true</span>).<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;no&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-title function_\">strMapToJson</span>(myMap)<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mapToArrayJson</span>(<span class=\"hljs-params\">map</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>([...map]);<br>&#125;<br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">7</span>).<span class=\"hljs-title function_\">set</span>(&#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">3</span>&#125;, [<span class=\"hljs-string\">&#x27;abc&#x27;</span>]);<br><span class=\"hljs-title function_\">mapToArrayJson</span>(myMap)<br></code></pre></td></tr></table></figure>\n<h3 id=\"JSON转Map\"><a href=\"#JSON转Map\" class=\"headerlink\" title=\"JSON转Map\"></a>JSON转Map</h3><p>跟上面的情况一样：所有键名都是字符串，随便转；另外一个：整个JSON就是数组，每个数组成员本身又只有一个两个成员的数组。这个时候可以一一对应转换为Map。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">jsonToMap</span>(<span class=\"hljs-params\">jsonStr</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(jsonStr));<br>&#125;<br><br><span class=\"hljs-title function_\">jsonToMap</span>(<span class=\"hljs-string\">&#x27;[[true, 7], [&#123;&quot;foo&quot;:3&#125;, [&quot;abc&quot;]]]&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap和Map基本类似，唯一区别就是：它只接受对象作为键名，不接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。跟WeakSet一样，设计它的目的有助于防止内存泄露：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> myElement = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;logo&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> myWeakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br>myWeakMap.<span class=\"hljs-title function_\">set</span>(myElement, &#123;<span class=\"hljs-attr\">timesClicked</span>: <span class=\"hljs-number\">0</span>&#125;);<br><br>myElement.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">let</span> logoData = myWeakMap.<span class=\"hljs-title function_\">get</span>(myElement);<br>    logoData.<span class=\"hljs-property\">timesClicked</span> ++;<br>&#125;, <span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\n<p>上述代码设计了一个机制：每当DOM中节点发生click事件，就更新一下状态。一旦这个DOM节点删除，该状态就会自动消失，不会存在内存泄露的风险。</p>\n<p>WeakMap的另一个作用就是部署私有属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> _counter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><span class=\"hljs-keyword\">let</span> _action = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Countdown</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">counter, action</span>) &#123;<br>        _counter.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, counter);<br>        _action.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, action);<br>    &#125;<br>    <span class=\"hljs-title function_\">dec</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> counter = _counter.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>);<br>        <span class=\"hljs-keyword\">if</span> (counter &lt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;<br>        counter--;<br>        _counter.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, counter);<br>        <span class=\"hljs-keyword\">if</span> (counter === <span class=\"hljs-number\">0</span>) &#123;<br>            _action.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>)();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Countdown</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;DONE&#x27;</span>));<br><br>c.<span class=\"hljs-title function_\">dec</span>()<br>c.<span class=\"hljs-title function_\">dec</span>()<br><span class=\"hljs-comment\">// DONE</span><br></code></pre></td></tr></table></figure>\n<p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>是实例的弱引用，所以如果删除实例，它们也就随之消失。不会造成内存泄露。</p>\n"},{"title":"ES6 字符串","date":"2022-02-17T03:26:20.000Z","updated":"2022-02-17T03:26:20.000Z","_content":"\n# 字符串\n\n和其他类型的编程语言一样，ES6对原有JavaScript字符的基础上进行了扩展和增强；\n\n## Unicode字符表示法\n\n使用`\\uxxxx`的方式表示字符，但是仅仅能表示`\\u0000`到`\\uFFFF`之间的字符串，超出后必须使用两个字符来表示。\n\n## codePointAt函数\n\n对于使用4个字节存储的字符，JavaScript不能很好地处理。因此ES6提供了codePointAt()方法来处理4个字节的字符。`codePointAt()`会返回32位的UTF-16字符，常规码点和`charAt()`返回值相同。如下所示：\n\n```javascript\nvar s = \"𠮷\";\ns.length // 2\ns.charAt(0); // ''\ns.charAt(1); // ''\ns.codePointAt(0); // 55362\ns.codePointAt(1); // 57271\n```\n\n测试一个字符是2字节还是4字节的方法如下：\n\n```javascript\nfunction is32Bit(c) {\n  return c.codePointAt(0) > 0xFFFF;\n}\n```\n\n## String.fromCodePoint()\n\nES5开始提供了该方法，用于从码点返回对应字符，但是无法识别UTF-16的字符（也就是Unicode编号大于0xFFFF），但是在ES6开始，该函数可以识别`0xFFFF`的函数。示例如下：\n\n```javascript\nString.fromCodePoint(0x20BB7);\n\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD830D\\uDE80y'\n```\n\n## 字符串的遍历接口\n\nES6为字符提供了遍历接口（因为实现了Iterator接口），使得字符串可以被`for ... of`遍历循环；\n\n```javascript\nfor (let codePoint of 'foo') {\n  console.log(codePoint);\n}\n\n// \"f\"\n// \"o\"\n// \"o\"\n```\n\n除了遍历字符串还可以识别大于`0xFFFF`的码点，例如：\n\n```javascript\nvar text = String.fromCodePoint(0x20BB7);\n\nfor (let i of text) {\n  console.log(i);\n}\n```\n\n## at()\n\nES5中的charAt()方法不能用于识别码点大于`0xFFFF`的字符，但是ES6提案中的`at()`却可以识别码点大于`0xFFFF`的字符。如下所示：\n\n```javascript\n\t'abc'.at(0)\n'0x20BB7'.at(0) \n```\n\n## normalize()\n\nES6提供的normalize()函数可以将字符的不同表示犯法统一为同样的形式，这样称之为Unicode的正规化；使用正规化的原因时欧洲许多国家的字符存在重音符号。有些字符时通过两个符号合成得到的。但是目前还不支持三个字符的合成分解，所以对于多字符情况还是使用正则表达式吧。\n\n```javascript\n'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize() // true\n```\n\n此外normalize()方法可以接受一个参数来指定normalize的方式，参数可选值如下：\n\n- `NFC`：默认参数，标准等价合成，返回合成字符；即视觉上和语义上的等价；\n- `NFD`：标准等价分解，返回合成字符分解的多个简单字符；\n- `NFKC`：兼容等价合成，返回合成字符。即语义上等价、视觉上不等价；\n- `NFKD`：兼容等价分解，返回合成字符分解的多个简单字符；\n\n## includes(), startsWith(), endsWith()\n\n传统的JavaScript只有一个`indexOf()`方法用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：\n\n- `includes()`：表示是否找到了参数字符串\n- `startsWith()`：表示参数字符串是否在源字符串的头部；\n- `endsWith()`：表示参数字符串是否在源字符串的尾部；\n\n例子如下：\n\n```javascript\nvar s = \"Hello World!\";\n\ns.startsWith('Hello'); // true\ns.endsWith('!'); // true\ns.includes('o'); // true\n```\n\n## repeat()\n\n`repeat()`方法返回一个新字符串，表示将源字符串重复n次，如果n为小数则会向下取整；如果为负数或者`Infinity`会报`Range Error`错误；如果时-1~0之间的数据会先取整再运算，因此当0处理；\n\n```javascript\n'x'.repeat(3); //xxx\n'hello'.repeat(2); //hellohello\n'na'.repeat(0); // \"\"\n'na'.repeat(2.9); // \"nana\"\n'na'.repeat(Infinity); // Range Error\n'na'.repeat(-1); // Range Error\n'na'.repeat(-0.5); // \"\"\n```\n\n## padStart(), padEnd()\n\nES7推出字符串补全长度功能。如果某个字符串不够指定长度，这会在头部和尾部补全。此处不再赘述。\n\n```javascript\n'x'.padStart(5, 'ab'); // 'ababx';\n'x'.padStart(4, 'ab'); // 'abax';\n\n'x'.padEnd(5, 'ab'); // 'xabab';\n'x'.padEnd(4, 'ab'); // 'xaba';\n```\n\n如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。\n\n```javascript\n'xxx'.padStart(2, 'ab'); // xxx\n```\n\n如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串；如果省略第二个字符，则会使用空格来进行填充。\n\n```javascript\n'abc'.padStart(10, '0123456789'); // 0123456abc\n'X'.padStart(4); '   X'\n```\n\n因此也可以看出它主要是用来给数值补全指定位数或者字符串格式化。例子如下：\n\n```javascript\n// 数值补位\n'1'.padStart(10, '0'); // 0000000001\n'12'.padStart(10, '0'); // 0000000012\n'123456'.padStart(10, '0'); // 0000123456\n\n// 字符串格式\n'12'.padStart(10, 'YYYY-MM-DD'); // YYYY-MM-12\n'09-12'.padStart(10, 'YYYY-MM-DD'); // YYYY-09-12\n```\n\n## 模板字符串\n\nES6引用了模板字符串来撰写模板，这样可以在表示上更加简洁。类似的语法在Python和Golang中也有；如下所示：使用`${expression}`包裹的表达式可以作为占位符解析：\n\n```javascript\n$('#result').append(`\n\tThere are <b>${basket.count}</b> items\n\tin your basket, <em>${basket.onSale}</em>\n\tare on sale!\n`);\n```\n\n所有模板字符的空格和换行都是被原样保留的，如果不想要换行，可以加上`trim()`来消除：\n\n```javascript\n$('#list').html(`\n<ul>\n\t<li>first</li>\n\t<li>second</li>\n</ul>\n`.trim());\n```\n\n模板字符串除了可以嵌套JavaScript表达式，还可以调用函数；除此之外，模板表达式还可以嵌套。注意：由于模板字符串可以传入JavaScript，因此变量在使用前必须声明，否则会编译失败；\n\n```javascript\nconst tmpl = addrs => `\n\t<table>\n\t${addrs.map(addr => `\n\t\t<tr><td>${addr.first}</td></tr>\n\t\t<tr><td>${addr.last}</td></tr>\n\t`).join('')}\n\t</table>\n`;\n```\n","source":"_posts/javascript/es6-string.md","raw":"---\ntitle: ES6 字符串\ndate: 2022-02-17 11:26:20\nupdated: 2022-02-17 11:26:20\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 字符串\n\n和其他类型的编程语言一样，ES6对原有JavaScript字符的基础上进行了扩展和增强；\n\n## Unicode字符表示法\n\n使用`\\uxxxx`的方式表示字符，但是仅仅能表示`\\u0000`到`\\uFFFF`之间的字符串，超出后必须使用两个字符来表示。\n\n## codePointAt函数\n\n对于使用4个字节存储的字符，JavaScript不能很好地处理。因此ES6提供了codePointAt()方法来处理4个字节的字符。`codePointAt()`会返回32位的UTF-16字符，常规码点和`charAt()`返回值相同。如下所示：\n\n```javascript\nvar s = \"𠮷\";\ns.length // 2\ns.charAt(0); // ''\ns.charAt(1); // ''\ns.codePointAt(0); // 55362\ns.codePointAt(1); // 57271\n```\n\n测试一个字符是2字节还是4字节的方法如下：\n\n```javascript\nfunction is32Bit(c) {\n  return c.codePointAt(0) > 0xFFFF;\n}\n```\n\n## String.fromCodePoint()\n\nES5开始提供了该方法，用于从码点返回对应字符，但是无法识别UTF-16的字符（也就是Unicode编号大于0xFFFF），但是在ES6开始，该函数可以识别`0xFFFF`的函数。示例如下：\n\n```javascript\nString.fromCodePoint(0x20BB7);\n\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD830D\\uDE80y'\n```\n\n## 字符串的遍历接口\n\nES6为字符提供了遍历接口（因为实现了Iterator接口），使得字符串可以被`for ... of`遍历循环；\n\n```javascript\nfor (let codePoint of 'foo') {\n  console.log(codePoint);\n}\n\n// \"f\"\n// \"o\"\n// \"o\"\n```\n\n除了遍历字符串还可以识别大于`0xFFFF`的码点，例如：\n\n```javascript\nvar text = String.fromCodePoint(0x20BB7);\n\nfor (let i of text) {\n  console.log(i);\n}\n```\n\n## at()\n\nES5中的charAt()方法不能用于识别码点大于`0xFFFF`的字符，但是ES6提案中的`at()`却可以识别码点大于`0xFFFF`的字符。如下所示：\n\n```javascript\n\t'abc'.at(0)\n'0x20BB7'.at(0) \n```\n\n## normalize()\n\nES6提供的normalize()函数可以将字符的不同表示犯法统一为同样的形式，这样称之为Unicode的正规化；使用正规化的原因时欧洲许多国家的字符存在重音符号。有些字符时通过两个符号合成得到的。但是目前还不支持三个字符的合成分解，所以对于多字符情况还是使用正则表达式吧。\n\n```javascript\n'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize() // true\n```\n\n此外normalize()方法可以接受一个参数来指定normalize的方式，参数可选值如下：\n\n- `NFC`：默认参数，标准等价合成，返回合成字符；即视觉上和语义上的等价；\n- `NFD`：标准等价分解，返回合成字符分解的多个简单字符；\n- `NFKC`：兼容等价合成，返回合成字符。即语义上等价、视觉上不等价；\n- `NFKD`：兼容等价分解，返回合成字符分解的多个简单字符；\n\n## includes(), startsWith(), endsWith()\n\n传统的JavaScript只有一个`indexOf()`方法用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：\n\n- `includes()`：表示是否找到了参数字符串\n- `startsWith()`：表示参数字符串是否在源字符串的头部；\n- `endsWith()`：表示参数字符串是否在源字符串的尾部；\n\n例子如下：\n\n```javascript\nvar s = \"Hello World!\";\n\ns.startsWith('Hello'); // true\ns.endsWith('!'); // true\ns.includes('o'); // true\n```\n\n## repeat()\n\n`repeat()`方法返回一个新字符串，表示将源字符串重复n次，如果n为小数则会向下取整；如果为负数或者`Infinity`会报`Range Error`错误；如果时-1~0之间的数据会先取整再运算，因此当0处理；\n\n```javascript\n'x'.repeat(3); //xxx\n'hello'.repeat(2); //hellohello\n'na'.repeat(0); // \"\"\n'na'.repeat(2.9); // \"nana\"\n'na'.repeat(Infinity); // Range Error\n'na'.repeat(-1); // Range Error\n'na'.repeat(-0.5); // \"\"\n```\n\n## padStart(), padEnd()\n\nES7推出字符串补全长度功能。如果某个字符串不够指定长度，这会在头部和尾部补全。此处不再赘述。\n\n```javascript\n'x'.padStart(5, 'ab'); // 'ababx';\n'x'.padStart(4, 'ab'); // 'abax';\n\n'x'.padEnd(5, 'ab'); // 'xabab';\n'x'.padEnd(4, 'ab'); // 'xaba';\n```\n\n如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。\n\n```javascript\n'xxx'.padStart(2, 'ab'); // xxx\n```\n\n如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串；如果省略第二个字符，则会使用空格来进行填充。\n\n```javascript\n'abc'.padStart(10, '0123456789'); // 0123456abc\n'X'.padStart(4); '   X'\n```\n\n因此也可以看出它主要是用来给数值补全指定位数或者字符串格式化。例子如下：\n\n```javascript\n// 数值补位\n'1'.padStart(10, '0'); // 0000000001\n'12'.padStart(10, '0'); // 0000000012\n'123456'.padStart(10, '0'); // 0000123456\n\n// 字符串格式\n'12'.padStart(10, 'YYYY-MM-DD'); // YYYY-MM-12\n'09-12'.padStart(10, 'YYYY-MM-DD'); // YYYY-09-12\n```\n\n## 模板字符串\n\nES6引用了模板字符串来撰写模板，这样可以在表示上更加简洁。类似的语法在Python和Golang中也有；如下所示：使用`${expression}`包裹的表达式可以作为占位符解析：\n\n```javascript\n$('#result').append(`\n\tThere are <b>${basket.count}</b> items\n\tin your basket, <em>${basket.onSale}</em>\n\tare on sale!\n`);\n```\n\n所有模板字符的空格和换行都是被原样保留的，如果不想要换行，可以加上`trim()`来消除：\n\n```javascript\n$('#list').html(`\n<ul>\n\t<li>first</li>\n\t<li>second</li>\n</ul>\n`.trim());\n```\n\n模板字符串除了可以嵌套JavaScript表达式，还可以调用函数；除此之外，模板表达式还可以嵌套。注意：由于模板字符串可以传入JavaScript，因此变量在使用前必须声明，否则会编译失败；\n\n```javascript\nconst tmpl = addrs => `\n\t<table>\n\t${addrs.map(addr => `\n\t\t<tr><td>${addr.first}</td></tr>\n\t\t<tr><td>${addr.last}</td></tr>\n\t`).join('')}\n\t</table>\n`;\n```\n","slug":"javascript/es6-string","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vl00294f614elggkd4","content":"<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><p>和其他类型的编程语言一样，ES6对原有JavaScript字符的基础上进行了扩展和增强；</p>\n<h2 id=\"Unicode字符表示法\"><a href=\"#Unicode字符表示法\" class=\"headerlink\" title=\"Unicode字符表示法\"></a>Unicode字符表示法</h2><p>使用<code>\\uxxxx</code>的方式表示字符，但是仅仅能表示<code>\\u0000</code>到<code>\\uFFFF</code>之间的字符串，超出后必须使用两个字符来表示。</p>\n<h2 id=\"codePointAt函数\"><a href=\"#codePointAt函数\" class=\"headerlink\" title=\"codePointAt函数\"></a>codePointAt函数</h2><p>对于使用4个字节存储的字符，JavaScript不能很好地处理。因此ES6提供了codePointAt()方法来处理4个字节的字符。<code>codePointAt()</code>会返回32位的UTF-16字符，常规码点和<code>charAt()</code>返回值相同。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;𠮷&quot;</span>;<br>s.<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 2</span><br>s.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &#x27;&#x27;</span><br>s.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// &#x27;&#x27;</span><br>s.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 55362</span><br>s.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 57271</span><br></code></pre></td></tr></table></figure>\n<p>测试一个字符是2字节还是4字节的方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">is32Bit</span>(<span class=\"hljs-params\">c</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> c.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">0</span>) &gt; <span class=\"hljs-number\">0xFFFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"String-fromCodePoint\"><a href=\"#String-fromCodePoint\" class=\"headerlink\" title=\"String.fromCodePoint()\"></a>String.fromCodePoint()</h2><p>ES5开始提供了该方法，用于从码点返回对应字符，但是无法识别UTF-16的字符（也就是Unicode编号大于0xFFFF），但是在ES6开始，该函数可以识别<code>0xFFFF</code>的函数。示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x20BB7</span>);<br><br><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x78</span>, <span class=\"hljs-number\">0x1f680</span>, <span class=\"hljs-number\">0x79</span>) === <span class=\"hljs-string\">&#x27;x\\uD830D\\uDE80y&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"字符串的遍历接口\"><a href=\"#字符串的遍历接口\" class=\"headerlink\" title=\"字符串的遍历接口\"></a>字符串的遍历接口</h2><p>ES6为字符提供了遍历接口（因为实现了Iterator接口），使得字符串可以被<code>for ... of</code>遍历循环；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> codePoint <span class=\"hljs-keyword\">of</span> <span class=\"hljs-string\">&#x27;foo&#x27;</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(codePoint);<br>&#125;<br><br><span class=\"hljs-comment\">// &quot;f&quot;</span><br><span class=\"hljs-comment\">// &quot;o&quot;</span><br><span class=\"hljs-comment\">// &quot;o&quot;</span><br></code></pre></td></tr></table></figure>\n<p>除了遍历字符串还可以识别大于<code>0xFFFF</code>的码点，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> text = <span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x20BB7</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> text) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"at\"><a href=\"#at\" class=\"headerlink\" title=\"at()\"></a>at()</h2><p>ES5中的charAt()方法不能用于识别码点大于<code>0xFFFF</code>的字符，但是ES6提案中的<code>at()</code>却可以识别码点大于<code>0xFFFF</code>的字符。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">\t<span class=\"hljs-string\">&#x27;abc&#x27;</span>.<span class=\"hljs-title function_\">at</span>(<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-string\">&#x27;0x20BB7&#x27;</span>.<span class=\"hljs-title function_\">at</span>(<span class=\"hljs-number\">0</span>) <br></code></pre></td></tr></table></figure>\n<h2 id=\"normalize\"><a href=\"#normalize\" class=\"headerlink\" title=\"normalize()\"></a>normalize()</h2><p>ES6提供的normalize()函数可以将字符的不同表示犯法统一为同样的形式，这样称之为Unicode的正规化；使用正规化的原因时欧洲许多国家的字符存在重音符号。有些字符时通过两个符号合成得到的。但是目前还不支持三个字符的合成分解，所以对于多字符情况还是使用正则表达式吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;\\u01D1&#x27;</span>.<span class=\"hljs-title function_\">normalize</span>() === <span class=\"hljs-string\">&#x27;\\u004F\\u030C&#x27;</span>.<span class=\"hljs-title function_\">normalize</span>() <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>此外normalize()方法可以接受一个参数来指定normalize的方式，参数可选值如下：</p>\n<ul>\n<li><code>NFC</code>：默认参数，标准等价合成，返回合成字符；即视觉上和语义上的等价；</li>\n<li><code>NFD</code>：标准等价分解，返回合成字符分解的多个简单字符；</li>\n<li><code>NFKC</code>：兼容等价合成，返回合成字符。即语义上等价、视觉上不等价；</li>\n<li><code>NFKD</code>：兼容等价分解，返回合成字符分解的多个简单字符；</li>\n</ul>\n<h2 id=\"includes-startsWith-endsWith\"><a href=\"#includes-startsWith-endsWith\" class=\"headerlink\" title=\"includes(), startsWith(), endsWith()\"></a>includes(), startsWith(), endsWith()</h2><p>传统的JavaScript只有一个<code>indexOf()</code>方法用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：</p>\n<ul>\n<li><code>includes()</code>：表示是否找到了参数字符串</li>\n<li><code>startsWith()</code>：表示参数字符串是否在源字符串的头部；</li>\n<li><code>endsWith()</code>：表示参数字符串是否在源字符串的尾部；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;Hello World!&quot;</span>;<br><br>s.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>); <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">endsWith</span>(<span class=\"hljs-string\">&#x27;!&#x27;</span>); <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">&#x27;o&#x27;</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h2><p><code>repeat()</code>方法返回一个新字符串，表示将源字符串重复n次，如果n为小数则会向下取整；如果为负数或者<code>Infinity</code>会报<code>Range Error</code>错误；如果时-1~0之间的数据会先取整再运算，因此当0处理；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//xxx</span><br><span class=\"hljs-string\">&#x27;hello&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">//hellohello</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &quot;&quot;</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">2.9</span>); <span class=\"hljs-comment\">// &quot;nana&quot;</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// Range Error</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Range Error</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(-<span class=\"hljs-number\">0.5</span>); <span class=\"hljs-comment\">// &quot;&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"padStart-padEnd\"><a href=\"#padStart-padEnd\" class=\"headerlink\" title=\"padStart(), padEnd()\"></a>padStart(), padEnd()</h2><p>ES7推出字符串补全长度功能。如果某个字符串不够指定长度，这会在头部和尾部补全。此处不再赘述。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;ababx&#x27;;</span><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;abax&#x27;;</span><br><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;xabab&#x27;;</span><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;xaba&#x27;;</span><br></code></pre></td></tr></table></figure>\n<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// xxx</span><br></code></pre></td></tr></table></figure>\n<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串；如果省略第二个字符，则会使用空格来进行填充。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;abc&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0123456789&#x27;</span>); <span class=\"hljs-comment\">// 0123456abc</span><br><span class=\"hljs-string\">&#x27;X&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-string\">&#x27;   X&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>因此也可以看出它主要是用来给数值补全指定位数或者字符串格式化。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 数值补位</span><br><span class=\"hljs-string\">&#x27;1&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000000001</span><br><span class=\"hljs-string\">&#x27;12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000000012</span><br><span class=\"hljs-string\">&#x27;123456&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000123456</span><br><br><span class=\"hljs-comment\">// 字符串格式</span><br><span class=\"hljs-string\">&#x27;12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;YYYY-MM-DD&#x27;</span>); <span class=\"hljs-comment\">// YYYY-MM-12</span><br><span class=\"hljs-string\">&#x27;09-12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;YYYY-MM-DD&#x27;</span>); <span class=\"hljs-comment\">// YYYY-09-12</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>ES6引用了模板字符串来撰写模板，这样可以在表示上更加简洁。类似的语法在Python和Golang中也有；如下所示：使用<code>$&#123;expression&#125;</code>包裹的表达式可以作为占位符解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$(<span class=\"hljs-string\">&#x27;#result&#x27;</span>).<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\tThere are &lt;b&gt;<span class=\"hljs-subst\">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span><br><span class=\"hljs-string\">\tin your basket, &lt;em&gt;<span class=\"hljs-subst\">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span><br><span class=\"hljs-string\">\tare on sale!</span><br><span class=\"hljs-string\">`</span>);<br></code></pre></td></tr></table></figure>\n<p>所有模板字符的空格和换行都是被原样保留的，如果不想要换行，可以加上<code>trim()</code>来消除：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$(<span class=\"hljs-string\">&#x27;#list&#x27;</span>).<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">&lt;ul&gt;</span><br><span class=\"hljs-string\">\t&lt;li&gt;first&lt;/li&gt;</span><br><span class=\"hljs-string\">\t&lt;li&gt;second&lt;/li&gt;</span><br><span class=\"hljs-string\">&lt;/ul&gt;</span><br><span class=\"hljs-string\">`</span>.<span class=\"hljs-title function_\">trim</span>());<br></code></pre></td></tr></table></figure>\n<p>模板字符串除了可以嵌套JavaScript表达式，还可以调用函数；除此之外，模板表达式还可以嵌套。注意：由于模板字符串可以传入JavaScript，因此变量在使用前必须声明，否则会编译失败；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">tmpl</span> = addrs =&gt; <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\t&lt;table&gt;</span><br><span class=\"hljs-string\">\t<span class=\"hljs-subst\">$&#123;addrs.map(addr =&gt; <span class=\"hljs-string\">`</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t\t&lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t\t&lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t`</span>).join(<span class=\"hljs-string\">&#x27;&#x27;</span>)&#125;</span></span><br><span class=\"hljs-string\">\t&lt;/table&gt;</span><br><span class=\"hljs-string\">`</span>;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":3897,"excerpt":"","more":"<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><p>和其他类型的编程语言一样，ES6对原有JavaScript字符的基础上进行了扩展和增强；</p>\n<h2 id=\"Unicode字符表示法\"><a href=\"#Unicode字符表示法\" class=\"headerlink\" title=\"Unicode字符表示法\"></a>Unicode字符表示法</h2><p>使用<code>\\uxxxx</code>的方式表示字符，但是仅仅能表示<code>\\u0000</code>到<code>\\uFFFF</code>之间的字符串，超出后必须使用两个字符来表示。</p>\n<h2 id=\"codePointAt函数\"><a href=\"#codePointAt函数\" class=\"headerlink\" title=\"codePointAt函数\"></a>codePointAt函数</h2><p>对于使用4个字节存储的字符，JavaScript不能很好地处理。因此ES6提供了codePointAt()方法来处理4个字节的字符。<code>codePointAt()</code>会返回32位的UTF-16字符，常规码点和<code>charAt()</code>返回值相同。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;𠮷&quot;</span>;<br>s.<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 2</span><br>s.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &#x27;&#x27;</span><br>s.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// &#x27;&#x27;</span><br>s.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 55362</span><br>s.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 57271</span><br></code></pre></td></tr></table></figure>\n<p>测试一个字符是2字节还是4字节的方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">is32Bit</span>(<span class=\"hljs-params\">c</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> c.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">0</span>) &gt; <span class=\"hljs-number\">0xFFFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"String-fromCodePoint\"><a href=\"#String-fromCodePoint\" class=\"headerlink\" title=\"String.fromCodePoint()\"></a>String.fromCodePoint()</h2><p>ES5开始提供了该方法，用于从码点返回对应字符，但是无法识别UTF-16的字符（也就是Unicode编号大于0xFFFF），但是在ES6开始，该函数可以识别<code>0xFFFF</code>的函数。示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x20BB7</span>);<br><br><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x78</span>, <span class=\"hljs-number\">0x1f680</span>, <span class=\"hljs-number\">0x79</span>) === <span class=\"hljs-string\">&#x27;x\\uD830D\\uDE80y&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"字符串的遍历接口\"><a href=\"#字符串的遍历接口\" class=\"headerlink\" title=\"字符串的遍历接口\"></a>字符串的遍历接口</h2><p>ES6为字符提供了遍历接口（因为实现了Iterator接口），使得字符串可以被<code>for ... of</code>遍历循环；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> codePoint <span class=\"hljs-keyword\">of</span> <span class=\"hljs-string\">&#x27;foo&#x27;</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(codePoint);<br>&#125;<br><br><span class=\"hljs-comment\">// &quot;f&quot;</span><br><span class=\"hljs-comment\">// &quot;o&quot;</span><br><span class=\"hljs-comment\">// &quot;o&quot;</span><br></code></pre></td></tr></table></figure>\n<p>除了遍历字符串还可以识别大于<code>0xFFFF</code>的码点，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> text = <span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x20BB7</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> text) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"at\"><a href=\"#at\" class=\"headerlink\" title=\"at()\"></a>at()</h2><p>ES5中的charAt()方法不能用于识别码点大于<code>0xFFFF</code>的字符，但是ES6提案中的<code>at()</code>却可以识别码点大于<code>0xFFFF</code>的字符。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">\t<span class=\"hljs-string\">&#x27;abc&#x27;</span>.<span class=\"hljs-title function_\">at</span>(<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-string\">&#x27;0x20BB7&#x27;</span>.<span class=\"hljs-title function_\">at</span>(<span class=\"hljs-number\">0</span>) <br></code></pre></td></tr></table></figure>\n<h2 id=\"normalize\"><a href=\"#normalize\" class=\"headerlink\" title=\"normalize()\"></a>normalize()</h2><p>ES6提供的normalize()函数可以将字符的不同表示犯法统一为同样的形式，这样称之为Unicode的正规化；使用正规化的原因时欧洲许多国家的字符存在重音符号。有些字符时通过两个符号合成得到的。但是目前还不支持三个字符的合成分解，所以对于多字符情况还是使用正则表达式吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;\\u01D1&#x27;</span>.<span class=\"hljs-title function_\">normalize</span>() === <span class=\"hljs-string\">&#x27;\\u004F\\u030C&#x27;</span>.<span class=\"hljs-title function_\">normalize</span>() <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>此外normalize()方法可以接受一个参数来指定normalize的方式，参数可选值如下：</p>\n<ul>\n<li><code>NFC</code>：默认参数，标准等价合成，返回合成字符；即视觉上和语义上的等价；</li>\n<li><code>NFD</code>：标准等价分解，返回合成字符分解的多个简单字符；</li>\n<li><code>NFKC</code>：兼容等价合成，返回合成字符。即语义上等价、视觉上不等价；</li>\n<li><code>NFKD</code>：兼容等价分解，返回合成字符分解的多个简单字符；</li>\n</ul>\n<h2 id=\"includes-startsWith-endsWith\"><a href=\"#includes-startsWith-endsWith\" class=\"headerlink\" title=\"includes(), startsWith(), endsWith()\"></a>includes(), startsWith(), endsWith()</h2><p>传统的JavaScript只有一个<code>indexOf()</code>方法用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：</p>\n<ul>\n<li><code>includes()</code>：表示是否找到了参数字符串</li>\n<li><code>startsWith()</code>：表示参数字符串是否在源字符串的头部；</li>\n<li><code>endsWith()</code>：表示参数字符串是否在源字符串的尾部；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;Hello World!&quot;</span>;<br><br>s.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>); <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">endsWith</span>(<span class=\"hljs-string\">&#x27;!&#x27;</span>); <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">&#x27;o&#x27;</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h2><p><code>repeat()</code>方法返回一个新字符串，表示将源字符串重复n次，如果n为小数则会向下取整；如果为负数或者<code>Infinity</code>会报<code>Range Error</code>错误；如果时-1~0之间的数据会先取整再运算，因此当0处理；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//xxx</span><br><span class=\"hljs-string\">&#x27;hello&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">//hellohello</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &quot;&quot;</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">2.9</span>); <span class=\"hljs-comment\">// &quot;nana&quot;</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// Range Error</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Range Error</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(-<span class=\"hljs-number\">0.5</span>); <span class=\"hljs-comment\">// &quot;&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"padStart-padEnd\"><a href=\"#padStart-padEnd\" class=\"headerlink\" title=\"padStart(), padEnd()\"></a>padStart(), padEnd()</h2><p>ES7推出字符串补全长度功能。如果某个字符串不够指定长度，这会在头部和尾部补全。此处不再赘述。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;ababx&#x27;;</span><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;abax&#x27;;</span><br><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;xabab&#x27;;</span><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;xaba&#x27;;</span><br></code></pre></td></tr></table></figure>\n<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// xxx</span><br></code></pre></td></tr></table></figure>\n<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串；如果省略第二个字符，则会使用空格来进行填充。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;abc&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0123456789&#x27;</span>); <span class=\"hljs-comment\">// 0123456abc</span><br><span class=\"hljs-string\">&#x27;X&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-string\">&#x27;   X&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>因此也可以看出它主要是用来给数值补全指定位数或者字符串格式化。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 数值补位</span><br><span class=\"hljs-string\">&#x27;1&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000000001</span><br><span class=\"hljs-string\">&#x27;12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000000012</span><br><span class=\"hljs-string\">&#x27;123456&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000123456</span><br><br><span class=\"hljs-comment\">// 字符串格式</span><br><span class=\"hljs-string\">&#x27;12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;YYYY-MM-DD&#x27;</span>); <span class=\"hljs-comment\">// YYYY-MM-12</span><br><span class=\"hljs-string\">&#x27;09-12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;YYYY-MM-DD&#x27;</span>); <span class=\"hljs-comment\">// YYYY-09-12</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>ES6引用了模板字符串来撰写模板，这样可以在表示上更加简洁。类似的语法在Python和Golang中也有；如下所示：使用<code>$&#123;expression&#125;</code>包裹的表达式可以作为占位符解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$(<span class=\"hljs-string\">&#x27;#result&#x27;</span>).<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\tThere are &lt;b&gt;<span class=\"hljs-subst\">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span><br><span class=\"hljs-string\">\tin your basket, &lt;em&gt;<span class=\"hljs-subst\">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span><br><span class=\"hljs-string\">\tare on sale!</span><br><span class=\"hljs-string\">`</span>);<br></code></pre></td></tr></table></figure>\n<p>所有模板字符的空格和换行都是被原样保留的，如果不想要换行，可以加上<code>trim()</code>来消除：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$(<span class=\"hljs-string\">&#x27;#list&#x27;</span>).<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">&lt;ul&gt;</span><br><span class=\"hljs-string\">\t&lt;li&gt;first&lt;/li&gt;</span><br><span class=\"hljs-string\">\t&lt;li&gt;second&lt;/li&gt;</span><br><span class=\"hljs-string\">&lt;/ul&gt;</span><br><span class=\"hljs-string\">`</span>.<span class=\"hljs-title function_\">trim</span>());<br></code></pre></td></tr></table></figure>\n<p>模板字符串除了可以嵌套JavaScript表达式，还可以调用函数；除此之外，模板表达式还可以嵌套。注意：由于模板字符串可以传入JavaScript，因此变量在使用前必须声明，否则会编译失败；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">tmpl</span> = addrs =&gt; <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\t&lt;table&gt;</span><br><span class=\"hljs-string\">\t<span class=\"hljs-subst\">$&#123;addrs.map(addr =&gt; <span class=\"hljs-string\">`</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t\t&lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t\t&lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t`</span>).join(<span class=\"hljs-string\">&#x27;&#x27;</span>)&#125;</span></span><br><span class=\"hljs-string\">\t&lt;/table&gt;</span><br><span class=\"hljs-string\">`</span>;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 Symbol","date":"2022-02-17T07:15:26.000Z","updated":"2022-02-17T07:15:26.000Z","_content":"\n# Symbol\n\nES5的对象属性名都是字符串，这容易造成属性名的冲突。如果存在一种机制，能够保证每个属性的名字都是独一无二的就可以解决这个问题。因此ES6中引入了Symbol。\n\nES6引入了一种新的原始数据类型Symbol，表示独一无二的值。可以称之为JavaScript的第七种数据类型。\n\nSymbol是通过symbol函数生成的。也就是说，对象的属性名可以有两种类型，一种是原来就有的字符串，另一种是新增的Symbol类型。凡是属性名属于Symbol的，就是独一无二的，可以保证不会与其他属性名发生冲突。\n\n```javascript\nlet s = Symbol();\ntypeof s // symbol\n```\n\n`Symbol`函数可以接收一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示或者是转为字符串的过程中方便区分。\n\n```javascript\nvar s1 = Symbol('foo');\nvar s2 = Symbol('bar');\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // \"Symbol(foo)\"\ns2.toString() // \"Symbol(bar)\"\n```\n\n如果Symbol的参数是一个对象，那么就会调用该对象的`toString()`方法，将其转换为字符串，然后才生成一个Symbol值。\n\n```javascript\nconst obj = {\n    toString() {\n        return 'abc';\n    }\n};\n\nconst sym = Symbol(obj);\nsym // Symbol(abc)\n```\n\nSymbol值不能与其他类型的值进行运算，会报错；但是却可以显式转换为字符串\n\n```javascript\nvar sym = Symbol('My Symbol');\n\n\"your symbol is \" + sym // Error\n\nString(sym); // Symbol('My symbol')\nsym.toString(); // Symbol(My symbol)\n```\n\n## 作为属性名的Symbol\n\n由于每一个Symbol值都是不相等的，这意味着Symbol可以作为标识符，用在对象的属性名，就能保证不会出现同名的属性。可以防止某一个键被不小心改写或覆盖。\n\n```javascript\nvar mySymbol = Symbol();\n\nvar a = {};\na[mySymbol] = 'Hello!';\n\nvar a = {\n    [mySymbol]: 'Hello'\n};\n\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello' });\n\na[mySymbol] // \"Hello\"\n```\n\nSymbol值作为对象属性名时，不能用作点运算符。\n\n```javascript\nvar mySymbol = Symbol();\nvar a = {};\n\na.mySymbol = 'Hello';\na[mySymbol] // undefined\na['mySymbol'] // Hello\n```\n\nSymbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\n\n```javascript\nlog.levels = {\n    DEBUG: Symbol('debug'),\n    INFO: Symbol('info'),\n    WARN: Symbol('warn')\n};\n\nlog(log.levels.DEBUG, 'debug message');\nlog(log.levels.INFO, 'info message');\n```\n\n还有一个例子：\n\n```javascript\nvar shapeType = {\n    triangle: Symbol()\n};\n\nfunction getArea(shape, options) {\n    var area = 0;\n\n    switch(shape) {\n        case shapeType.triangle:\n            area = .5 * options.width * options.height;\n            break;\n    }\n\n    return area;\n}\n\ngetArea(shapeType.triangle, {width: 100, height: 100}); // 5000\n```\n\n## 属性名的遍历\n\nSymbol作为属性名，不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有Symbol属性名。\n\n```javascript\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n\nobj[a] = 'Hello';\nobj[b] = 'World';\n\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\n\nobjSymbols // [Symbol(a), Symbol(b)]\n```\n\n由于以Symbol值作为名称的属性，不会被常规方法遍历得到。因此可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\n\n```javascript\nvar size = Symbol('size');\n\nclass Collection {\n    constructor() {\n        this[size] = 0;\n    }\n    \n    add(item) {\n        this[this[size]] = item;\n        this[size]++;\n    }\n    \n    static sizeOf(instance) {\n        return instance[size];\n    }\n}\n\nvar x = new Collection();\nCollection.sizeOf(x) // 0\n\nx.add('foo');\nCollection.sizeOf(x) // 1\n\nObject.keys(x) // ['0']\nObject.getOwnPropertyNames(x) // ['0']\nObject.getOwnPropertySymbols(x) // [Symbol(size)]\n```\n\n## Symbol.for(), Symbol.keyFor()\n\n有时候希望重新使用同一个Symbol值，`Symbol.for`可以做到这一点。其接受一个字符串为参数，然后搜索有没有已该参数作为名称的Symbol值，有就返回，没有就以这个名称创建一个Symbol值。\n\n```javascript\nvar s1 = Symbol.for('foo')\nvar s2 = Symbol.for('foo')\ns1 === s2 // true\n```\n\n`Symbol.keyFor`方法返回一个已经登记的Symbol类型值的`key`\n\n```javascript\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // foo\n\nvar s2 = Symbol(\"Foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n### 模块的单例模式\n\n```javascript\nconst FOO_KEY = Symbol.for('foo');\n\nfunction A() {\n  this.foo = 'hello';\n}\n\nif (!global[FOO_KEY]) {\n  global[FOO_KEY] = new A();\n}\n\nmodule.exports = global[FOO_KEY];\n```\n\n上面的代码中，可以保证`global[FOO_KEY]`不会被无意间覆盖，但还是可以被改写。\n\n## 内置的Symbol值\n\n除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。\n\n### Symbol.hasInstance\n\n指向一个内部方法。当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用此方法。例如：\n\n```javascript\nclass MyClass {\n  [Symbol.hasIntance](foo) {\n    return foo instanceof Array;\n  }\n}\n\n[1, 2, 3] instanceof new MyClass() // true\n```\n\n### Symbol.isConcatSpreadable\n\n等于一个布尔值，表示该对象使用`Array.prototype.concat()`时，是否可以展开。默认情况下是可以展开的。\n\n```javascript\nlet arr1 = ['c', 'd'];\n['a', 'b'].concat(arr1, 'e'] // ['a', 'b', 'c', 'd', 'e']\narr1[Symbol.isConcatSpreadable] // undefined\n\nlet arr2 = ['c', 'd'];\narr2[Symbol.isConcatSpreadable] = false;\n['a', 'b'].concat(arr2, 'e'] // ['a', 'b', ['c', 'd'], 'e']\n```\n\n### Symbol.species\n\n指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，如果`this.constructor[Symbol.species]`存在，会使用这个属性作为构造函数，来创造新的实例对象。\n\n```javascript\n// 默认读取器如下\nstatic get [Symbol.species] {\n  return this;\n}\n```\n\n### Symbol.match\n\n指向一个函数，当执行`str.match(myObject)`时，如果该属性存在，会调用它，返回该方法的返回值。\n\n```javascript\nString.prototype.match(regexp);\n// 等同于\nregexp[Symbol.match](this);\n\nclass MyMatcher {\n  [Symbol.match](string) {\n    return 'hello world'.indexOf(string);\n  }\n}\n\n'e'.match(new MyMatcher()]; // 1\n```\n\n### Symbol.replace\n\n指向一个方法，当该对象被`Symbol.prototype.replace`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.replace(searchValue, replaceValue);\n// 等同于\nsearchValue[Symbol.replace](this, replaceValue);\n```\n\n下面有一个例子说明这个问题：\n\n```javascript\nconst x = {};\nx[Symbol.replace] = {...s} => console.log(s);\n\n'Hello'.replace(x, 'World') // [\"Hello\", \"World\"]\n```\n\n第一个参数是replace方法正在坐拥的对象，第二个参数替换后的值。\n\n### Symbol.search\n\n指向一个方法，当该对象被`String.prototype.search`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.search(regexp);\n// 等同于\nregexp[Symbol.search](this);\n\nclass MySearch {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.search](string) {\n    return string.indexOf(this.value);\n  }\n}\n'foobar'.search(new MySearch('foo')) // 0\n```\n\n### Symbol.split\n\n指向一个方法，当该对象被`String.prototype.split`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.split(separator, limit);\n// 等同于\nseparator[Symbol.split](this, limit);\n```\n\n### Symbol.iterator\n\n指向该对象的默认遍历方法\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]\n```\n\n### Symbol.toPrimitive\n\n指向一个方法。该对象被转化为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\n\n该方法被调用时，会接受一个字符串参数，表示当前运算的模式，共有三种模式：\n\n- Number：该场合需要转换成数值\n- String：该场合需要转换成字符串\n- Defaul：该场合既可以转换成数值，也可以转换成字符串\n\n```javascript\nlet obj = {\n  [Symbol.toPrimitive](hint) {\n    switch(hint) {\n      case 'number':\n        return 123;\n      case 'string':\n        return 'str';\n      case 'default':\n        return 'default';\n      default:\n        throw new Error();\n    }\n  }\n};\n\n2 * obj // 246\n3 + obj // 3default\nobj == 'default' // true\nString(obj) // str\n```\n\n### Symbol.toStringTag\n\n指向一个方法，在该对象上面调用`Object.prototye.toString`方法时，如果这个属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型。这个属性可以用于定制`[object Object]`或者`[object Array]`中`object`后面的那个字符串。\n\n```javascript\n({[Symbol.toStringTag]: 'Foo'}.toString())\n// [object Object]\n\nclass Collection {\n  get [Symbol.toStringTag]() {\n    return 'xxx';\n  }\n}\n\nvar x = new Collection();\nObject.prototype.toString.call(x); // [object xxx]\n```\n\n### Symbol.unscopables\n\n指向一个对象。该对象指定了使用`with`关键字时，哪些属性会被`with`环境排除。\n\n```javascript\nArray.prototype[Symbol.unscopables]\n\nObject.keys(Array.prototype[Symbol.unscopables])\n```\n\n上面的代码说明，数组有6个属性，会被`with`命令排除。\n\n```javascript\nclass MyClass {\n  foo() {return 1;}\n}\n\nvar foo = function () {return 2;}\n\nwith [MyClass.prototype] {\n  foo();\n}\n\nclass MyClass {\n  foo() {return 1;}\n  get [Symbol.unscopables]() {\n    return {foo: true};\n  }\n}\n\nvar foo = function() {return 2;}\nwith (MyClass.prototype) {\n  foo();\n}\n```\n","source":"_posts/javascript/es6-symbol.md","raw":"---\ntitle: ES6 Symbol\ndate: 2022-02-17 15:15:26\nupdated: 2022-02-17 15:15:26\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Symbol\n\nES5的对象属性名都是字符串，这容易造成属性名的冲突。如果存在一种机制，能够保证每个属性的名字都是独一无二的就可以解决这个问题。因此ES6中引入了Symbol。\n\nES6引入了一种新的原始数据类型Symbol，表示独一无二的值。可以称之为JavaScript的第七种数据类型。\n\nSymbol是通过symbol函数生成的。也就是说，对象的属性名可以有两种类型，一种是原来就有的字符串，另一种是新增的Symbol类型。凡是属性名属于Symbol的，就是独一无二的，可以保证不会与其他属性名发生冲突。\n\n```javascript\nlet s = Symbol();\ntypeof s // symbol\n```\n\n`Symbol`函数可以接收一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示或者是转为字符串的过程中方便区分。\n\n```javascript\nvar s1 = Symbol('foo');\nvar s2 = Symbol('bar');\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // \"Symbol(foo)\"\ns2.toString() // \"Symbol(bar)\"\n```\n\n如果Symbol的参数是一个对象，那么就会调用该对象的`toString()`方法，将其转换为字符串，然后才生成一个Symbol值。\n\n```javascript\nconst obj = {\n    toString() {\n        return 'abc';\n    }\n};\n\nconst sym = Symbol(obj);\nsym // Symbol(abc)\n```\n\nSymbol值不能与其他类型的值进行运算，会报错；但是却可以显式转换为字符串\n\n```javascript\nvar sym = Symbol('My Symbol');\n\n\"your symbol is \" + sym // Error\n\nString(sym); // Symbol('My symbol')\nsym.toString(); // Symbol(My symbol)\n```\n\n## 作为属性名的Symbol\n\n由于每一个Symbol值都是不相等的，这意味着Symbol可以作为标识符，用在对象的属性名，就能保证不会出现同名的属性。可以防止某一个键被不小心改写或覆盖。\n\n```javascript\nvar mySymbol = Symbol();\n\nvar a = {};\na[mySymbol] = 'Hello!';\n\nvar a = {\n    [mySymbol]: 'Hello'\n};\n\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello' });\n\na[mySymbol] // \"Hello\"\n```\n\nSymbol值作为对象属性名时，不能用作点运算符。\n\n```javascript\nvar mySymbol = Symbol();\nvar a = {};\n\na.mySymbol = 'Hello';\na[mySymbol] // undefined\na['mySymbol'] // Hello\n```\n\nSymbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\n\n```javascript\nlog.levels = {\n    DEBUG: Symbol('debug'),\n    INFO: Symbol('info'),\n    WARN: Symbol('warn')\n};\n\nlog(log.levels.DEBUG, 'debug message');\nlog(log.levels.INFO, 'info message');\n```\n\n还有一个例子：\n\n```javascript\nvar shapeType = {\n    triangle: Symbol()\n};\n\nfunction getArea(shape, options) {\n    var area = 0;\n\n    switch(shape) {\n        case shapeType.triangle:\n            area = .5 * options.width * options.height;\n            break;\n    }\n\n    return area;\n}\n\ngetArea(shapeType.triangle, {width: 100, height: 100}); // 5000\n```\n\n## 属性名的遍历\n\nSymbol作为属性名，不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有Symbol属性名。\n\n```javascript\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n\nobj[a] = 'Hello';\nobj[b] = 'World';\n\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\n\nobjSymbols // [Symbol(a), Symbol(b)]\n```\n\n由于以Symbol值作为名称的属性，不会被常规方法遍历得到。因此可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\n\n```javascript\nvar size = Symbol('size');\n\nclass Collection {\n    constructor() {\n        this[size] = 0;\n    }\n    \n    add(item) {\n        this[this[size]] = item;\n        this[size]++;\n    }\n    \n    static sizeOf(instance) {\n        return instance[size];\n    }\n}\n\nvar x = new Collection();\nCollection.sizeOf(x) // 0\n\nx.add('foo');\nCollection.sizeOf(x) // 1\n\nObject.keys(x) // ['0']\nObject.getOwnPropertyNames(x) // ['0']\nObject.getOwnPropertySymbols(x) // [Symbol(size)]\n```\n\n## Symbol.for(), Symbol.keyFor()\n\n有时候希望重新使用同一个Symbol值，`Symbol.for`可以做到这一点。其接受一个字符串为参数，然后搜索有没有已该参数作为名称的Symbol值，有就返回，没有就以这个名称创建一个Symbol值。\n\n```javascript\nvar s1 = Symbol.for('foo')\nvar s2 = Symbol.for('foo')\ns1 === s2 // true\n```\n\n`Symbol.keyFor`方法返回一个已经登记的Symbol类型值的`key`\n\n```javascript\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // foo\n\nvar s2 = Symbol(\"Foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n### 模块的单例模式\n\n```javascript\nconst FOO_KEY = Symbol.for('foo');\n\nfunction A() {\n  this.foo = 'hello';\n}\n\nif (!global[FOO_KEY]) {\n  global[FOO_KEY] = new A();\n}\n\nmodule.exports = global[FOO_KEY];\n```\n\n上面的代码中，可以保证`global[FOO_KEY]`不会被无意间覆盖，但还是可以被改写。\n\n## 内置的Symbol值\n\n除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。\n\n### Symbol.hasInstance\n\n指向一个内部方法。当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用此方法。例如：\n\n```javascript\nclass MyClass {\n  [Symbol.hasIntance](foo) {\n    return foo instanceof Array;\n  }\n}\n\n[1, 2, 3] instanceof new MyClass() // true\n```\n\n### Symbol.isConcatSpreadable\n\n等于一个布尔值，表示该对象使用`Array.prototype.concat()`时，是否可以展开。默认情况下是可以展开的。\n\n```javascript\nlet arr1 = ['c', 'd'];\n['a', 'b'].concat(arr1, 'e'] // ['a', 'b', 'c', 'd', 'e']\narr1[Symbol.isConcatSpreadable] // undefined\n\nlet arr2 = ['c', 'd'];\narr2[Symbol.isConcatSpreadable] = false;\n['a', 'b'].concat(arr2, 'e'] // ['a', 'b', ['c', 'd'], 'e']\n```\n\n### Symbol.species\n\n指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，如果`this.constructor[Symbol.species]`存在，会使用这个属性作为构造函数，来创造新的实例对象。\n\n```javascript\n// 默认读取器如下\nstatic get [Symbol.species] {\n  return this;\n}\n```\n\n### Symbol.match\n\n指向一个函数，当执行`str.match(myObject)`时，如果该属性存在，会调用它，返回该方法的返回值。\n\n```javascript\nString.prototype.match(regexp);\n// 等同于\nregexp[Symbol.match](this);\n\nclass MyMatcher {\n  [Symbol.match](string) {\n    return 'hello world'.indexOf(string);\n  }\n}\n\n'e'.match(new MyMatcher()]; // 1\n```\n\n### Symbol.replace\n\n指向一个方法，当该对象被`Symbol.prototype.replace`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.replace(searchValue, replaceValue);\n// 等同于\nsearchValue[Symbol.replace](this, replaceValue);\n```\n\n下面有一个例子说明这个问题：\n\n```javascript\nconst x = {};\nx[Symbol.replace] = {...s} => console.log(s);\n\n'Hello'.replace(x, 'World') // [\"Hello\", \"World\"]\n```\n\n第一个参数是replace方法正在坐拥的对象，第二个参数替换后的值。\n\n### Symbol.search\n\n指向一个方法，当该对象被`String.prototype.search`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.search(regexp);\n// 等同于\nregexp[Symbol.search](this);\n\nclass MySearch {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.search](string) {\n    return string.indexOf(this.value);\n  }\n}\n'foobar'.search(new MySearch('foo')) // 0\n```\n\n### Symbol.split\n\n指向一个方法，当该对象被`String.prototype.split`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.split(separator, limit);\n// 等同于\nseparator[Symbol.split](this, limit);\n```\n\n### Symbol.iterator\n\n指向该对象的默认遍历方法\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]\n```\n\n### Symbol.toPrimitive\n\n指向一个方法。该对象被转化为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\n\n该方法被调用时，会接受一个字符串参数，表示当前运算的模式，共有三种模式：\n\n- Number：该场合需要转换成数值\n- String：该场合需要转换成字符串\n- Defaul：该场合既可以转换成数值，也可以转换成字符串\n\n```javascript\nlet obj = {\n  [Symbol.toPrimitive](hint) {\n    switch(hint) {\n      case 'number':\n        return 123;\n      case 'string':\n        return 'str';\n      case 'default':\n        return 'default';\n      default:\n        throw new Error();\n    }\n  }\n};\n\n2 * obj // 246\n3 + obj // 3default\nobj == 'default' // true\nString(obj) // str\n```\n\n### Symbol.toStringTag\n\n指向一个方法，在该对象上面调用`Object.prototye.toString`方法时，如果这个属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型。这个属性可以用于定制`[object Object]`或者`[object Array]`中`object`后面的那个字符串。\n\n```javascript\n({[Symbol.toStringTag]: 'Foo'}.toString())\n// [object Object]\n\nclass Collection {\n  get [Symbol.toStringTag]() {\n    return 'xxx';\n  }\n}\n\nvar x = new Collection();\nObject.prototype.toString.call(x); // [object xxx]\n```\n\n### Symbol.unscopables\n\n指向一个对象。该对象指定了使用`with`关键字时，哪些属性会被`with`环境排除。\n\n```javascript\nArray.prototype[Symbol.unscopables]\n\nObject.keys(Array.prototype[Symbol.unscopables])\n```\n\n上面的代码说明，数组有6个属性，会被`with`命令排除。\n\n```javascript\nclass MyClass {\n  foo() {return 1;}\n}\n\nvar foo = function () {return 2;}\n\nwith [MyClass.prototype] {\n  foo();\n}\n\nclass MyClass {\n  foo() {return 1;}\n  get [Symbol.unscopables]() {\n    return {foo: true};\n  }\n}\n\nvar foo = function() {return 2;}\nwith (MyClass.prototype) {\n  foo();\n}\n```\n","slug":"javascript/es6-symbol","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vm002e4f61c7thfp7g","content":"<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。如果存在一种机制，能够保证每个属性的名字都是独一无二的就可以解决这个问题。因此ES6中引入了Symbol。</p>\n<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。可以称之为JavaScript的第七种数据类型。</p>\n<p>Symbol是通过symbol函数生成的。也就是说，对象的属性名可以有两种类型，一种是原来就有的字符串，另一种是新增的Symbol类型。凡是属性名属于Symbol的，就是独一无二的，可以保证不会与其他属性名发生冲突。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-title class_\">Symbol</span>();<br><span class=\"hljs-keyword\">typeof</span> s <span class=\"hljs-comment\">// symbol</span><br></code></pre></td></tr></table></figure>\n<p><code>Symbol</code>函数可以接收一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示或者是转为字符串的过程中方便区分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>);<br><br>s1 <span class=\"hljs-comment\">// Symbol(foo)</span><br>s2 <span class=\"hljs-comment\">// Symbol(bar)</span><br><br>s1.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// &quot;Symbol(foo)&quot;</span><br>s2.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// &quot;Symbol(bar)&quot;</span><br></code></pre></td></tr></table></figure>\n<p>如果Symbol的参数是一个对象，那么就会调用该对象的<code>toString()</code>方法，将其转换为字符串，然后才生成一个Symbol值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> sym = <span class=\"hljs-title class_\">Symbol</span>(obj);<br>sym <span class=\"hljs-comment\">// Symbol(abc)</span><br></code></pre></td></tr></table></figure>\n<p>Symbol值不能与其他类型的值进行运算，会报错；但是却可以显式转换为字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> sym = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;My Symbol&#x27;</span>);<br><br><span class=\"hljs-string\">&quot;your symbol is &quot;</span> + sym <span class=\"hljs-comment\">// Error</span><br><br><span class=\"hljs-title class_\">String</span>(sym); <span class=\"hljs-comment\">// Symbol(&#x27;My symbol&#x27;)</span><br>sym.<span class=\"hljs-title function_\">toString</span>(); <span class=\"hljs-comment\">// Symbol(My symbol)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"作为属性名的Symbol\"><a href=\"#作为属性名的Symbol\" class=\"headerlink\" title=\"作为属性名的Symbol\"></a>作为属性名的Symbol</h2><p>由于每一个Symbol值都是不相等的，这意味着Symbol可以作为标识符，用在对象的属性名，就能保证不会出现同名的属性。可以防止某一个键被不小心改写或覆盖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> mySymbol = <span class=\"hljs-title class_\">Symbol</span>();<br><br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br>a[mySymbol] = <span class=\"hljs-string\">&#x27;Hello!&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;<br>    [mySymbol]: <span class=\"hljs-string\">&#x27;Hello&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(a, mySymbol, &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span> &#125;);<br><br>a[mySymbol] <span class=\"hljs-comment\">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<p>Symbol值作为对象属性名时，不能用作点运算符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> mySymbol = <span class=\"hljs-title class_\">Symbol</span>();<br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br><br>a.<span class=\"hljs-property\">mySymbol</span> = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;<br>a[mySymbol] <span class=\"hljs-comment\">// undefined</span><br>a[<span class=\"hljs-string\">&#x27;mySymbol&#x27;</span>] <span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n<p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">log.<span class=\"hljs-property\">levels</span> = &#123;<br>    <span class=\"hljs-attr\">DEBUG</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;debug&#x27;</span>),<br>    <span class=\"hljs-attr\">INFO</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;info&#x27;</span>),<br>    <span class=\"hljs-attr\">WARN</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;warn&#x27;</span>)<br>&#125;;<br><br><span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-property\">levels</span>.<span class=\"hljs-property\">DEBUG</span>, <span class=\"hljs-string\">&#x27;debug message&#x27;</span>);<br><span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-property\">levels</span>.<span class=\"hljs-property\">INFO</span>, <span class=\"hljs-string\">&#x27;info message&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>还有一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> shapeType = &#123;<br>    <span class=\"hljs-attr\">triangle</span>: <span class=\"hljs-title class_\">Symbol</span>()<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getArea</span>(<span class=\"hljs-params\">shape, options</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> area = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">switch</span>(shape) &#123;<br>        <span class=\"hljs-keyword\">case</span> shapeType.<span class=\"hljs-property\">triangle</span>:<br>            area = <span class=\"hljs-number\">.5</span> * options.<span class=\"hljs-property\">width</span> * options.<span class=\"hljs-property\">height</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> area;<br>&#125;<br><br><span class=\"hljs-title function_\">getArea</span>(shapeType.<span class=\"hljs-property\">triangle</span>, &#123;<span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">100</span>&#125;); <span class=\"hljs-comment\">// 5000</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"属性名的遍历\"><a href=\"#属性名的遍历\" class=\"headerlink\" title=\"属性名的遍历\"></a>属性名的遍历</h2><p>Symbol作为属性名，不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有Symbol属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br><br>obj[a] = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;<br>obj[b] = <span class=\"hljs-string\">&#x27;World&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> objectSymbols = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(obj);<br><br>objSymbols <span class=\"hljs-comment\">// [Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure>\n<p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到。因此可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> size = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;size&#x27;</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Collection</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[size] = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">item</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[<span class=\"hljs-variable language_\">this</span>[size]] = item;<br>        <span class=\"hljs-variable language_\">this</span>[size]++;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">sizeOf</span>(<span class=\"hljs-params\">instance</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> instance[size];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Collection</span>();<br><span class=\"hljs-title class_\">Collection</span>.<span class=\"hljs-title function_\">sizeOf</span>(x) <span class=\"hljs-comment\">// 0</span><br><br>x.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-title class_\">Collection</span>.<span class=\"hljs-title function_\">sizeOf</span>(x) <span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(x) <span class=\"hljs-comment\">// [&#x27;0&#x27;]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyNames</span>(x) <span class=\"hljs-comment\">// [&#x27;0&#x27;]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(x) <span class=\"hljs-comment\">// [Symbol(size)]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Symbol-for-Symbol-keyFor\"><a href=\"#Symbol-for-Symbol-keyFor\" class=\"headerlink\" title=\"Symbol.for(), Symbol.keyFor()\"></a>Symbol.for(), Symbol.keyFor()</h2><p>有时候希望重新使用同一个Symbol值，<code>Symbol.for</code>可以做到这一点。其接受一个字符串为参数，然后搜索有没有已该参数作为名称的Symbol值，有就返回，没有就以这个名称创建一个Symbol值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>s1 === s2 <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p><code>Symbol.keyFor</code>方法返回一个已经登记的Symbol类型值的<code>key</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;foo&quot;</span>);<br><span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(s1) <span class=\"hljs-comment\">// foo</span><br><br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;Foo&quot;</span>);<br><span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(s2) <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"模块的单例模式\"><a href=\"#模块的单例模式\" class=\"headerlink\" title=\"模块的单例模式\"></a>模块的单例模式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">FOO_KEY</span> = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">A</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>]) &#123;<br>  <span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>();<br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>];<br></code></pre></td></tr></table></figure>\n<p>上面的代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>\n<h2 id=\"内置的Symbol值\"><a href=\"#内置的Symbol值\" class=\"headerlink\" title=\"内置的Symbol值\"></a>内置的Symbol值</h2><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>\n<h3 id=\"Symbol-hasInstance\"><a href=\"#Symbol-hasInstance\" class=\"headerlink\" title=\"Symbol.hasInstance\"></a>Symbol.hasInstance</h3><p>指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用此方法。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">hasIntance</span>](foo) &#123;<br>    <span class=\"hljs-keyword\">return</span> foo <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>;<br>  &#125;<br>&#125;<br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClass</span>() <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-isConcatSpreadable\"><a href=\"#Symbol-isConcatSpreadable\" class=\"headerlink\" title=\"Symbol.isConcatSpreadable\"></a>Symbol.isConcatSpreadable</h3><p>等于一个布尔值，表示该对象使用<code>Array.prototype.concat()</code>时，是否可以展开。默认情况下是可以展开的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>];<br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">concat</span>(arr1, <span class=\"hljs-string\">&#x27;e&#x27;</span>] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br>arr1[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">isConcatSpreadable</span>] <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">let</span> arr2 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>];<br>arr2[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">isConcatSpreadable</span>] = <span class=\"hljs-literal\">false</span>;<br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">concat</span>(arr2, <span class=\"hljs-string\">&#x27;e&#x27;</span>] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;, &#x27;d&#x27;], &#x27;e&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-species\"><a href=\"#Symbol-species\" class=\"headerlink\" title=\"Symbol.species\"></a>Symbol.species</h3><p>指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，如果<code>this.constructor[Symbol.species]</code>存在，会使用这个属性作为构造函数，来创造新的实例对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 默认读取器如下</span><br><span class=\"hljs-keyword\">static</span> get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">species</span>] &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-match\"><a href=\"#Symbol-match\" class=\"headerlink\" title=\"Symbol.match\"></a>Symbol.match</h3><p>指向一个函数，当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">match</span>(regexp);<br><span class=\"hljs-comment\">// 等同于</span><br>regexp[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">match</span>](<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyMatcher</span> &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">match</span>](string) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span>.<span class=\"hljs-title function_\">indexOf</span>(string);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-string\">&#x27;e&#x27;</span>.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyMatcher</span>()]; <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-replace\"><a href=\"#Symbol-replace\" class=\"headerlink\" title=\"Symbol.replace\"></a>Symbol.replace</h3><p>指向一个方法，当该对象被<code>Symbol.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">replace</span>(searchValue, replaceValue);<br><span class=\"hljs-comment\">// 等同于</span><br>searchValue[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">replace</span>](<span class=\"hljs-variable language_\">this</span>, replaceValue);<br></code></pre></td></tr></table></figure>\n<p>下面有一个例子说明这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> x = &#123;&#125;;<br>x[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">replace</span>] = &#123;...s&#125; =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s);<br><br><span class=\"hljs-string\">&#x27;Hello&#x27;</span>.<span class=\"hljs-title function_\">replace</span>(x, <span class=\"hljs-string\">&#x27;World&#x27;</span>) <span class=\"hljs-comment\">// [&quot;Hello&quot;, &quot;World&quot;]</span><br></code></pre></td></tr></table></figure>\n<p>第一个参数是replace方法正在坐拥的对象，第二个参数替换后的值。</p>\n<h3 id=\"Symbol-search\"><a href=\"#Symbol-search\" class=\"headerlink\" title=\"Symbol.search\"></a>Symbol.search</h3><p>指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">search</span>(regexp);<br><span class=\"hljs-comment\">// 等同于</span><br>regexp[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">search</span>](<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MySearch</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;<br>  &#125;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">search</span>](string) &#123;<br>    <span class=\"hljs-keyword\">return</span> string.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-string\">&#x27;foobar&#x27;</span>.<span class=\"hljs-title function_\">search</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MySearch</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)) <span class=\"hljs-comment\">// 0</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-split\"><a href=\"#Symbol-split\" class=\"headerlink\" title=\"Symbol.split\"></a>Symbol.split</h3><p>指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">split</span>(separator, limit);<br><span class=\"hljs-comment\">// 等同于</span><br>separator[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">split</span>](<span class=\"hljs-variable language_\">this</span>, limit);<br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-iterator\"><a href=\"#Symbol-iterator\" class=\"headerlink\" title=\"Symbol.iterator\"></a>Symbol.iterator</h3><p>指向该对象的默认遍历方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br><br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-toPrimitive\"><a href=\"#Symbol-toPrimitive\" class=\"headerlink\" title=\"Symbol.toPrimitive\"></a>Symbol.toPrimitive</h3><p>指向一个方法。该对象被转化为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>\n<p>该方法被调用时，会接受一个字符串参数，表示当前运算的模式，共有三种模式：</p>\n<ul>\n<li>Number：该场合需要转换成数值</li>\n<li>String：该场合需要转换成字符串</li>\n<li>Defaul：该场合既可以转换成数值，也可以转换成字符串</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toPrimitive</span>](hint) &#123;<br>    <span class=\"hljs-keyword\">switch</span>(hint) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;number&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">123</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;string&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;str&#x27;</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;default&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;default&#x27;</span>;<br>      <span class=\"hljs-attr\">default</span>:<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-number\">2</span> * obj <span class=\"hljs-comment\">// 246</span><br><span class=\"hljs-number\">3</span> + obj <span class=\"hljs-comment\">// 3default</span><br>obj == <span class=\"hljs-string\">&#x27;default&#x27;</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">String</span>(obj) <span class=\"hljs-comment\">// str</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-toStringTag\"><a href=\"#Symbol-toStringTag\" class=\"headerlink\" title=\"Symbol.toStringTag\"></a>Symbol.toStringTag</h3><p>指向一个方法，在该对象上面调用<code>Object.prototye.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。这个属性可以用于定制<code>[object Object]</code>或者<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(&#123;[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]: <span class=\"hljs-string\">&#x27;Foo&#x27;</span>&#125;.<span class=\"hljs-title function_\">toString</span>())<br><span class=\"hljs-comment\">// [object Object]</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Collection</span> &#123;<br>  get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;xxx&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Collection</span>();<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(x); <span class=\"hljs-comment\">// [object xxx]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-unscopables\"><a href=\"#Symbol-unscopables\" class=\"headerlink\" title=\"Symbol.unscopables\"></a>Symbol.unscopables</h3><p>指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>]<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>])<br></code></pre></td></tr></table></figure>\n<p>上面的代码说明，数组有6个属性，会被<code>with</code>命令排除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;&#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;&#125;<br><br><span class=\"hljs-keyword\">with</span> [<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>] &#123;<br>  <span class=\"hljs-title function_\">foo</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;&#125;<br>  get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>]() &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-literal\">true</span>&#125;;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;&#125;<br><span class=\"hljs-keyword\">with</span> (<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) &#123;<br>  <span class=\"hljs-title function_\">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":7133,"excerpt":"","more":"<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。如果存在一种机制，能够保证每个属性的名字都是独一无二的就可以解决这个问题。因此ES6中引入了Symbol。</p>\n<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。可以称之为JavaScript的第七种数据类型。</p>\n<p>Symbol是通过symbol函数生成的。也就是说，对象的属性名可以有两种类型，一种是原来就有的字符串，另一种是新增的Symbol类型。凡是属性名属于Symbol的，就是独一无二的，可以保证不会与其他属性名发生冲突。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-title class_\">Symbol</span>();<br><span class=\"hljs-keyword\">typeof</span> s <span class=\"hljs-comment\">// symbol</span><br></code></pre></td></tr></table></figure>\n<p><code>Symbol</code>函数可以接收一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示或者是转为字符串的过程中方便区分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>);<br><br>s1 <span class=\"hljs-comment\">// Symbol(foo)</span><br>s2 <span class=\"hljs-comment\">// Symbol(bar)</span><br><br>s1.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// &quot;Symbol(foo)&quot;</span><br>s2.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// &quot;Symbol(bar)&quot;</span><br></code></pre></td></tr></table></figure>\n<p>如果Symbol的参数是一个对象，那么就会调用该对象的<code>toString()</code>方法，将其转换为字符串，然后才生成一个Symbol值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> sym = <span class=\"hljs-title class_\">Symbol</span>(obj);<br>sym <span class=\"hljs-comment\">// Symbol(abc)</span><br></code></pre></td></tr></table></figure>\n<p>Symbol值不能与其他类型的值进行运算，会报错；但是却可以显式转换为字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> sym = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;My Symbol&#x27;</span>);<br><br><span class=\"hljs-string\">&quot;your symbol is &quot;</span> + sym <span class=\"hljs-comment\">// Error</span><br><br><span class=\"hljs-title class_\">String</span>(sym); <span class=\"hljs-comment\">// Symbol(&#x27;My symbol&#x27;)</span><br>sym.<span class=\"hljs-title function_\">toString</span>(); <span class=\"hljs-comment\">// Symbol(My symbol)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"作为属性名的Symbol\"><a href=\"#作为属性名的Symbol\" class=\"headerlink\" title=\"作为属性名的Symbol\"></a>作为属性名的Symbol</h2><p>由于每一个Symbol值都是不相等的，这意味着Symbol可以作为标识符，用在对象的属性名，就能保证不会出现同名的属性。可以防止某一个键被不小心改写或覆盖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> mySymbol = <span class=\"hljs-title class_\">Symbol</span>();<br><br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br>a[mySymbol] = <span class=\"hljs-string\">&#x27;Hello!&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;<br>    [mySymbol]: <span class=\"hljs-string\">&#x27;Hello&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(a, mySymbol, &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span> &#125;);<br><br>a[mySymbol] <span class=\"hljs-comment\">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<p>Symbol值作为对象属性名时，不能用作点运算符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> mySymbol = <span class=\"hljs-title class_\">Symbol</span>();<br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br><br>a.<span class=\"hljs-property\">mySymbol</span> = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;<br>a[mySymbol] <span class=\"hljs-comment\">// undefined</span><br>a[<span class=\"hljs-string\">&#x27;mySymbol&#x27;</span>] <span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n<p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">log.<span class=\"hljs-property\">levels</span> = &#123;<br>    <span class=\"hljs-attr\">DEBUG</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;debug&#x27;</span>),<br>    <span class=\"hljs-attr\">INFO</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;info&#x27;</span>),<br>    <span class=\"hljs-attr\">WARN</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;warn&#x27;</span>)<br>&#125;;<br><br><span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-property\">levels</span>.<span class=\"hljs-property\">DEBUG</span>, <span class=\"hljs-string\">&#x27;debug message&#x27;</span>);<br><span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-property\">levels</span>.<span class=\"hljs-property\">INFO</span>, <span class=\"hljs-string\">&#x27;info message&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>还有一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> shapeType = &#123;<br>    <span class=\"hljs-attr\">triangle</span>: <span class=\"hljs-title class_\">Symbol</span>()<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getArea</span>(<span class=\"hljs-params\">shape, options</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> area = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">switch</span>(shape) &#123;<br>        <span class=\"hljs-keyword\">case</span> shapeType.<span class=\"hljs-property\">triangle</span>:<br>            area = <span class=\"hljs-number\">.5</span> * options.<span class=\"hljs-property\">width</span> * options.<span class=\"hljs-property\">height</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> area;<br>&#125;<br><br><span class=\"hljs-title function_\">getArea</span>(shapeType.<span class=\"hljs-property\">triangle</span>, &#123;<span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">100</span>&#125;); <span class=\"hljs-comment\">// 5000</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"属性名的遍历\"><a href=\"#属性名的遍历\" class=\"headerlink\" title=\"属性名的遍历\"></a>属性名的遍历</h2><p>Symbol作为属性名，不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有Symbol属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br><br>obj[a] = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;<br>obj[b] = <span class=\"hljs-string\">&#x27;World&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> objectSymbols = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(obj);<br><br>objSymbols <span class=\"hljs-comment\">// [Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure>\n<p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到。因此可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> size = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;size&#x27;</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Collection</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[size] = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">item</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[<span class=\"hljs-variable language_\">this</span>[size]] = item;<br>        <span class=\"hljs-variable language_\">this</span>[size]++;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">sizeOf</span>(<span class=\"hljs-params\">instance</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> instance[size];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Collection</span>();<br><span class=\"hljs-title class_\">Collection</span>.<span class=\"hljs-title function_\">sizeOf</span>(x) <span class=\"hljs-comment\">// 0</span><br><br>x.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-title class_\">Collection</span>.<span class=\"hljs-title function_\">sizeOf</span>(x) <span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(x) <span class=\"hljs-comment\">// [&#x27;0&#x27;]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyNames</span>(x) <span class=\"hljs-comment\">// [&#x27;0&#x27;]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(x) <span class=\"hljs-comment\">// [Symbol(size)]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Symbol-for-Symbol-keyFor\"><a href=\"#Symbol-for-Symbol-keyFor\" class=\"headerlink\" title=\"Symbol.for(), Symbol.keyFor()\"></a>Symbol.for(), Symbol.keyFor()</h2><p>有时候希望重新使用同一个Symbol值，<code>Symbol.for</code>可以做到这一点。其接受一个字符串为参数，然后搜索有没有已该参数作为名称的Symbol值，有就返回，没有就以这个名称创建一个Symbol值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>s1 === s2 <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p><code>Symbol.keyFor</code>方法返回一个已经登记的Symbol类型值的<code>key</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;foo&quot;</span>);<br><span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(s1) <span class=\"hljs-comment\">// foo</span><br><br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;Foo&quot;</span>);<br><span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(s2) <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"模块的单例模式\"><a href=\"#模块的单例模式\" class=\"headerlink\" title=\"模块的单例模式\"></a>模块的单例模式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">FOO_KEY</span> = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">A</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>]) &#123;<br>  <span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>();<br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>];<br></code></pre></td></tr></table></figure>\n<p>上面的代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>\n<h2 id=\"内置的Symbol值\"><a href=\"#内置的Symbol值\" class=\"headerlink\" title=\"内置的Symbol值\"></a>内置的Symbol值</h2><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>\n<h3 id=\"Symbol-hasInstance\"><a href=\"#Symbol-hasInstance\" class=\"headerlink\" title=\"Symbol.hasInstance\"></a>Symbol.hasInstance</h3><p>指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用此方法。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">hasIntance</span>](foo) &#123;<br>    <span class=\"hljs-keyword\">return</span> foo <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>;<br>  &#125;<br>&#125;<br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClass</span>() <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-isConcatSpreadable\"><a href=\"#Symbol-isConcatSpreadable\" class=\"headerlink\" title=\"Symbol.isConcatSpreadable\"></a>Symbol.isConcatSpreadable</h3><p>等于一个布尔值，表示该对象使用<code>Array.prototype.concat()</code>时，是否可以展开。默认情况下是可以展开的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>];<br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">concat</span>(arr1, <span class=\"hljs-string\">&#x27;e&#x27;</span>] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br>arr1[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">isConcatSpreadable</span>] <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">let</span> arr2 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>];<br>arr2[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">isConcatSpreadable</span>] = <span class=\"hljs-literal\">false</span>;<br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">concat</span>(arr2, <span class=\"hljs-string\">&#x27;e&#x27;</span>] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;, &#x27;d&#x27;], &#x27;e&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-species\"><a href=\"#Symbol-species\" class=\"headerlink\" title=\"Symbol.species\"></a>Symbol.species</h3><p>指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，如果<code>this.constructor[Symbol.species]</code>存在，会使用这个属性作为构造函数，来创造新的实例对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 默认读取器如下</span><br><span class=\"hljs-keyword\">static</span> get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">species</span>] &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-match\"><a href=\"#Symbol-match\" class=\"headerlink\" title=\"Symbol.match\"></a>Symbol.match</h3><p>指向一个函数，当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">match</span>(regexp);<br><span class=\"hljs-comment\">// 等同于</span><br>regexp[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">match</span>](<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyMatcher</span> &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">match</span>](string) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span>.<span class=\"hljs-title function_\">indexOf</span>(string);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-string\">&#x27;e&#x27;</span>.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyMatcher</span>()]; <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-replace\"><a href=\"#Symbol-replace\" class=\"headerlink\" title=\"Symbol.replace\"></a>Symbol.replace</h3><p>指向一个方法，当该对象被<code>Symbol.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">replace</span>(searchValue, replaceValue);<br><span class=\"hljs-comment\">// 等同于</span><br>searchValue[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">replace</span>](<span class=\"hljs-variable language_\">this</span>, replaceValue);<br></code></pre></td></tr></table></figure>\n<p>下面有一个例子说明这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> x = &#123;&#125;;<br>x[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">replace</span>] = &#123;...s&#125; =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s);<br><br><span class=\"hljs-string\">&#x27;Hello&#x27;</span>.<span class=\"hljs-title function_\">replace</span>(x, <span class=\"hljs-string\">&#x27;World&#x27;</span>) <span class=\"hljs-comment\">// [&quot;Hello&quot;, &quot;World&quot;]</span><br></code></pre></td></tr></table></figure>\n<p>第一个参数是replace方法正在坐拥的对象，第二个参数替换后的值。</p>\n<h3 id=\"Symbol-search\"><a href=\"#Symbol-search\" class=\"headerlink\" title=\"Symbol.search\"></a>Symbol.search</h3><p>指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">search</span>(regexp);<br><span class=\"hljs-comment\">// 等同于</span><br>regexp[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">search</span>](<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MySearch</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;<br>  &#125;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">search</span>](string) &#123;<br>    <span class=\"hljs-keyword\">return</span> string.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-string\">&#x27;foobar&#x27;</span>.<span class=\"hljs-title function_\">search</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MySearch</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)) <span class=\"hljs-comment\">// 0</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-split\"><a href=\"#Symbol-split\" class=\"headerlink\" title=\"Symbol.split\"></a>Symbol.split</h3><p>指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">split</span>(separator, limit);<br><span class=\"hljs-comment\">// 等同于</span><br>separator[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">split</span>](<span class=\"hljs-variable language_\">this</span>, limit);<br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-iterator\"><a href=\"#Symbol-iterator\" class=\"headerlink\" title=\"Symbol.iterator\"></a>Symbol.iterator</h3><p>指向该对象的默认遍历方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br><br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-toPrimitive\"><a href=\"#Symbol-toPrimitive\" class=\"headerlink\" title=\"Symbol.toPrimitive\"></a>Symbol.toPrimitive</h3><p>指向一个方法。该对象被转化为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>\n<p>该方法被调用时，会接受一个字符串参数，表示当前运算的模式，共有三种模式：</p>\n<ul>\n<li>Number：该场合需要转换成数值</li>\n<li>String：该场合需要转换成字符串</li>\n<li>Defaul：该场合既可以转换成数值，也可以转换成字符串</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toPrimitive</span>](hint) &#123;<br>    <span class=\"hljs-keyword\">switch</span>(hint) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;number&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">123</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;string&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;str&#x27;</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;default&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;default&#x27;</span>;<br>      <span class=\"hljs-attr\">default</span>:<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-number\">2</span> * obj <span class=\"hljs-comment\">// 246</span><br><span class=\"hljs-number\">3</span> + obj <span class=\"hljs-comment\">// 3default</span><br>obj == <span class=\"hljs-string\">&#x27;default&#x27;</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">String</span>(obj) <span class=\"hljs-comment\">// str</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-toStringTag\"><a href=\"#Symbol-toStringTag\" class=\"headerlink\" title=\"Symbol.toStringTag\"></a>Symbol.toStringTag</h3><p>指向一个方法，在该对象上面调用<code>Object.prototye.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。这个属性可以用于定制<code>[object Object]</code>或者<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(&#123;[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]: <span class=\"hljs-string\">&#x27;Foo&#x27;</span>&#125;.<span class=\"hljs-title function_\">toString</span>())<br><span class=\"hljs-comment\">// [object Object]</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Collection</span> &#123;<br>  get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;xxx&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Collection</span>();<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(x); <span class=\"hljs-comment\">// [object xxx]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-unscopables\"><a href=\"#Symbol-unscopables\" class=\"headerlink\" title=\"Symbol.unscopables\"></a>Symbol.unscopables</h3><p>指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>]<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>])<br></code></pre></td></tr></table></figure>\n<p>上面的代码说明，数组有6个属性，会被<code>with</code>命令排除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;&#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;&#125;<br><br><span class=\"hljs-keyword\">with</span> [<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>] &#123;<br>  <span class=\"hljs-title function_\">foo</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;&#125;<br>  get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>]() &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-literal\">true</span>&#125;;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;&#125;<br><span class=\"hljs-keyword\">with</span> (<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) &#123;<br>  <span class=\"hljs-title function_\">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 变量解构","date":"2022-02-17T02:53:06.000Z","updated":"2022-02-17T02:53:06.000Z","_content":"\n# 变量解构与赋值\n\n## 基本用法\n\nES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。写法如下：\n\n```javascript\nlet [a, b, c] = [1, 2, 3];\na // 1\nb // 2\nc // 3\n\n// 与下列写法等价\nvar a = 1;\nvar b = 2;\nvar c = 3;\n```\n\n本质上只有等号两边的模式匹配的情况下，解构变量才会成功，如果解构不成功，那么值就等于undefined；但是即便两边的模式不完全匹配也是可以解构成功的。即：等号右边的模式仅等于等号左边声明的一部分。例如：\n\n```javascript\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n```\n\n## 适用范围\n\n除了`var`变量可以解构赋值，还有`let`和`const`也可以解构，除此之外，一种数据结构只要其有Iterator接口都可以使用数组解构赋值。例如：\n\n```javascript\nlet [a, b, c] = new Set({'aa', 'bb', 'cc'});\na // aa\nb // bb\nc // cc\n\nconst [d, e, f] = new Set({'dd', 'ee', 'ff'});\nd // dd\ne // ee\nf // ff\n```\n\n使用Generator函数解斐波那契数列，内部使用解构赋值，每次循环过程中变量`a`和`b`都会重新赋值；\n\n```javascript\nfunction* fibs() {\n  var a = 0;\n  var b = 1;\n  while(true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nvar [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n\n## 初始化\n\n变量解构可以在声明前初始化，注意：如果解构右侧值不等于`undefined`那么初始化的值就不会生效。例如：\n\n```javascript\nlet [x, y = 'y'] = [x, undefined];\ny // y - 解构初始化成功\n\nlet [x, y = 'y'] = [x, null];\ny // null - 解构初始化失败\n```\n\n如果解构默认值是一个表达式，那么只有在需要使用到表达式的时候才会赋值，否则默认值无效。\n\n```javascript\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\nx // 1\n// 由于x能在后面的数组中获取到数值1，因此默认值中的f()不生效；\n```\n\n## 对象的解构\n\n除了可以对数组做解构，对象同样可以做解构，但是与数组有区别的是：对象解构只有在对象属性名相同的情况下才能解构成功，如下：\n\n```javascript\nlet {foo, bar} = {foo: 'aaa', bar: 'bbb'}\nfoo // aaa\nbar // bbb\n\nlet {baz} = {foo: 'aaa', bar: 'bbb'}\nbaz // undefined\n```\n\n如果变量名和属性名不一样必须写成下面这样才行；\n\n```javascript\nvar {foo: baz} = {foo: 'aaa', bar: 'bbb'}\nbaz // aaa\n\nlet object = {first: 'hello', last: 'world'};\nlet {first: f, last: l} = object;\nf // hello\nl // world\n```\n\n解构也可以用于嵌套结构的对象\n\n```javascript\nvar obj = {\n  p: [\n    'Hello',\n    {y: 'world'}\n  ]\n};\n\nvar {p: [x, {y}]} = obj;\nx // hello\ny // world\n// p 为模式而不是变量，因此也不会被赋值\n```\n\n## 解构已声明的变量\n\n如果需要给已经声明的变量解构，一定要使用圆括号将其包裹起来，否则JavaScript引擎会将其解析为代码块。从而导致解构失败。ES6在解构变量时，除非会造成歧义必须使用圆括号围起来，否则不推荐使用圆括号；\n\n```javascript\n// Wrong syntax\nvar x;\n{x} = {x: 1}\n\n// Correct syntax\nvar x;\n({x} = {x: 1})\n\n// 还可以很方便地将现有对象的方法赋值到某个变量\nlet {log, sin, cos} = Math;\n```\n\n## 字符串的解构\n\n字符串也可以解构，解构出来的结果是当作数组处理。程序代码如下：\n\n```javascript\nconst [a, b, c, d, e] = 'hello';\na // 'h'\nb // 'e'\nc // 'l'\nd // 'l'\ne // 'o'\n\n// 类似数组对象都存在一个length属性，也可以通过解构获得\nlet {length: len} = 'hello';\nlen // 5\n```\n\n## 数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转换为对象；但是`undefined`和`null`无法转为对象，因此会解构失败；\n\n```javascript\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n```\n\n## 函数参数的解构赋值\n\n函数参数也可以解构赋值\n\n```javascript\nfunction add([x, y]) {\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [3, 7]\n```\n\n函数参数的解构也可以使用默认值（这不是废话嘛）\n\n```javascript\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n```\n\n下面这种写法不是解构，而是给函数参数设置默认值\n\n```javascript\nfunction move({x, y} = {x: 0, y: 0}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, undefined]\nmove({}); // [undefined, undefined]\nmove(); // [0, 0]\n```\n\n## 说了那么多，解构有什么用呢？\n\n### 交换变量的值\n\n```javascript\n[x, y] = [y, x]\n```\n\n### 从函数返回多个值\n\n```javascript\nfunction example() {\n  return [1, 2, 3];\n}\n\nvar [a, b, c] = example();\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: \n  };\n}\n  \nvar {foo, bar} = example();\n```\n\n### 函数参数的定义\n\n```javascript\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n```\n\n### 提取JSON数据\n\n```javascript\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet {id, status, data: number} = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n\n### 函数参数的默认值\n\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function() {},\n  cache = true,\n  complete = function() {},\n  crossDomain = false,\n  global = true,\n  // ... more config params\n}) {\n  // ... do stuff\n};\n```\n\n### 遍历Map解构\n\n```javascript\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('last', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n\n// first is hello\n// last is world\n\n// 如果只想获取键名称，可以这样\nfor (let [key] of map) {\n  // ... do something\n}\n\n// 只想获取键值\nfor (let [,value] of map) {\n  // ... do something\n}\n```\n\n### 输入模块的指定方法\n\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n\n// 除此之外使用import也可以使用解构倒入指定方法\nimport { SourceMapConsumer, SourceNode } from 'source-map';\n```\n","source":"_posts/javascript/es6-var-expand.md","raw":"---\ntitle: ES6 变量解构\ndate: 2022-02-17 10:53:06\nupdated: 2022-02-17 10:53:06\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 变量解构与赋值\n\n## 基本用法\n\nES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。写法如下：\n\n```javascript\nlet [a, b, c] = [1, 2, 3];\na // 1\nb // 2\nc // 3\n\n// 与下列写法等价\nvar a = 1;\nvar b = 2;\nvar c = 3;\n```\n\n本质上只有等号两边的模式匹配的情况下，解构变量才会成功，如果解构不成功，那么值就等于undefined；但是即便两边的模式不完全匹配也是可以解构成功的。即：等号右边的模式仅等于等号左边声明的一部分。例如：\n\n```javascript\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n```\n\n## 适用范围\n\n除了`var`变量可以解构赋值，还有`let`和`const`也可以解构，除此之外，一种数据结构只要其有Iterator接口都可以使用数组解构赋值。例如：\n\n```javascript\nlet [a, b, c] = new Set({'aa', 'bb', 'cc'});\na // aa\nb // bb\nc // cc\n\nconst [d, e, f] = new Set({'dd', 'ee', 'ff'});\nd // dd\ne // ee\nf // ff\n```\n\n使用Generator函数解斐波那契数列，内部使用解构赋值，每次循环过程中变量`a`和`b`都会重新赋值；\n\n```javascript\nfunction* fibs() {\n  var a = 0;\n  var b = 1;\n  while(true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nvar [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n\n## 初始化\n\n变量解构可以在声明前初始化，注意：如果解构右侧值不等于`undefined`那么初始化的值就不会生效。例如：\n\n```javascript\nlet [x, y = 'y'] = [x, undefined];\ny // y - 解构初始化成功\n\nlet [x, y = 'y'] = [x, null];\ny // null - 解构初始化失败\n```\n\n如果解构默认值是一个表达式，那么只有在需要使用到表达式的时候才会赋值，否则默认值无效。\n\n```javascript\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\nx // 1\n// 由于x能在后面的数组中获取到数值1，因此默认值中的f()不生效；\n```\n\n## 对象的解构\n\n除了可以对数组做解构，对象同样可以做解构，但是与数组有区别的是：对象解构只有在对象属性名相同的情况下才能解构成功，如下：\n\n```javascript\nlet {foo, bar} = {foo: 'aaa', bar: 'bbb'}\nfoo // aaa\nbar // bbb\n\nlet {baz} = {foo: 'aaa', bar: 'bbb'}\nbaz // undefined\n```\n\n如果变量名和属性名不一样必须写成下面这样才行；\n\n```javascript\nvar {foo: baz} = {foo: 'aaa', bar: 'bbb'}\nbaz // aaa\n\nlet object = {first: 'hello', last: 'world'};\nlet {first: f, last: l} = object;\nf // hello\nl // world\n```\n\n解构也可以用于嵌套结构的对象\n\n```javascript\nvar obj = {\n  p: [\n    'Hello',\n    {y: 'world'}\n  ]\n};\n\nvar {p: [x, {y}]} = obj;\nx // hello\ny // world\n// p 为模式而不是变量，因此也不会被赋值\n```\n\n## 解构已声明的变量\n\n如果需要给已经声明的变量解构，一定要使用圆括号将其包裹起来，否则JavaScript引擎会将其解析为代码块。从而导致解构失败。ES6在解构变量时，除非会造成歧义必须使用圆括号围起来，否则不推荐使用圆括号；\n\n```javascript\n// Wrong syntax\nvar x;\n{x} = {x: 1}\n\n// Correct syntax\nvar x;\n({x} = {x: 1})\n\n// 还可以很方便地将现有对象的方法赋值到某个变量\nlet {log, sin, cos} = Math;\n```\n\n## 字符串的解构\n\n字符串也可以解构，解构出来的结果是当作数组处理。程序代码如下：\n\n```javascript\nconst [a, b, c, d, e] = 'hello';\na // 'h'\nb // 'e'\nc // 'l'\nd // 'l'\ne // 'o'\n\n// 类似数组对象都存在一个length属性，也可以通过解构获得\nlet {length: len} = 'hello';\nlen // 5\n```\n\n## 数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转换为对象；但是`undefined`和`null`无法转为对象，因此会解构失败；\n\n```javascript\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n```\n\n## 函数参数的解构赋值\n\n函数参数也可以解构赋值\n\n```javascript\nfunction add([x, y]) {\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [3, 7]\n```\n\n函数参数的解构也可以使用默认值（这不是废话嘛）\n\n```javascript\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n```\n\n下面这种写法不是解构，而是给函数参数设置默认值\n\n```javascript\nfunction move({x, y} = {x: 0, y: 0}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, undefined]\nmove({}); // [undefined, undefined]\nmove(); // [0, 0]\n```\n\n## 说了那么多，解构有什么用呢？\n\n### 交换变量的值\n\n```javascript\n[x, y] = [y, x]\n```\n\n### 从函数返回多个值\n\n```javascript\nfunction example() {\n  return [1, 2, 3];\n}\n\nvar [a, b, c] = example();\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: \n  };\n}\n  \nvar {foo, bar} = example();\n```\n\n### 函数参数的定义\n\n```javascript\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n```\n\n### 提取JSON数据\n\n```javascript\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet {id, status, data: number} = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n\n### 函数参数的默认值\n\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function() {},\n  cache = true,\n  complete = function() {},\n  crossDomain = false,\n  global = true,\n  // ... more config params\n}) {\n  // ... do stuff\n};\n```\n\n### 遍历Map解构\n\n```javascript\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('last', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n\n// first is hello\n// last is world\n\n// 如果只想获取键名称，可以这样\nfor (let [key] of map) {\n  // ... do something\n}\n\n// 只想获取键值\nfor (let [,value] of map) {\n  // ... do something\n}\n```\n\n### 输入模块的指定方法\n\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n\n// 除此之外使用import也可以使用解构倒入指定方法\nimport { SourceMapConsumer, SourceNode } from 'source-map';\n```\n","slug":"javascript/es6-var-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vn002h4f61f0y5ggz3","content":"<h1 id=\"变量解构与赋值\"><a href=\"#变量解构与赋值\" class=\"headerlink\" title=\"变量解构与赋值\"></a>变量解构与赋值</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>a <span class=\"hljs-comment\">// 1</span><br>b <span class=\"hljs-comment\">// 2</span><br>c <span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// 与下列写法等价</span><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n<p>本质上只有等号两边的模式匹配的情况下，解构变量才会成功，如果解构不成功，那么值就等于undefined；但是即便两边的模式不完全匹配也是可以解构成功的。即：等号右边的模式仅等于等号左边声明的一部分。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [x, y] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>x <span class=\"hljs-comment\">// 1</span><br>y <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"适用范围\"><a href=\"#适用范围\" class=\"headerlink\" title=\"适用范围\"></a>适用范围</h2><p>除了<code>var</code>变量可以解构赋值，还有<code>let</code>和<code>const</code>也可以解构，除此之外，一种数据结构只要其有Iterator接口都可以使用数组解构赋值。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(&#123;<span class=\"hljs-string\">&#x27;aa&#x27;</span>, <span class=\"hljs-string\">&#x27;bb&#x27;</span>, <span class=\"hljs-string\">&#x27;cc&#x27;</span>&#125;);<br>a <span class=\"hljs-comment\">// aa</span><br>b <span class=\"hljs-comment\">// bb</span><br>c <span class=\"hljs-comment\">// cc</span><br><br><span class=\"hljs-keyword\">const</span> [d, e, f] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(&#123;<span class=\"hljs-string\">&#x27;dd&#x27;</span>, <span class=\"hljs-string\">&#x27;ee&#x27;</span>, <span class=\"hljs-string\">&#x27;ff&#x27;</span>&#125;);<br>d <span class=\"hljs-comment\">// dd</span><br>e <span class=\"hljs-comment\">// ee</span><br>f <span class=\"hljs-comment\">// ff</span><br></code></pre></td></tr></table></figure>\n<p>使用Generator函数解斐波那契数列，内部使用解构赋值，每次循环过程中变量<code>a</code>和<code>b</code>都会重新赋值；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibs</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> [first, second, third, fourth, fifth, sixth] = <span class=\"hljs-title function_\">fibs</span>();<br>sixth <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>变量解构可以在声明前初始化，注意：如果解构右侧值不等于<code>undefined</code>那么初始化的值就不会生效。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [x, y = <span class=\"hljs-string\">&#x27;y&#x27;</span>] = [x, <span class=\"hljs-literal\">undefined</span>];<br>y <span class=\"hljs-comment\">// y - 解构初始化成功</span><br><br><span class=\"hljs-keyword\">let</span> [x, y = <span class=\"hljs-string\">&#x27;y&#x27;</span>] = [x, <span class=\"hljs-literal\">null</span>];<br>y <span class=\"hljs-comment\">// null - 解构初始化失败</span><br></code></pre></td></tr></table></figure>\n<p>如果解构默认值是一个表达式，那么只有在需要使用到表达式的时候才会赋值，否则默认值无效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;aaa&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> [x = <span class=\"hljs-title function_\">f</span>()] = [<span class=\"hljs-number\">1</span>];<br>x <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-comment\">// 由于x能在后面的数组中获取到数值1，因此默认值中的f()不生效；</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"对象的解构\"><a href=\"#对象的解构\" class=\"headerlink\" title=\"对象的解构\"></a>对象的解构</h2><p>除了可以对数组做解构，对象同样可以做解构，但是与数组有区别的是：对象解构只有在对象属性名相同的情况下才能解构成功，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123;foo, bar&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>foo <span class=\"hljs-comment\">// aaa</span><br>bar <span class=\"hljs-comment\">// bbb</span><br><br><span class=\"hljs-keyword\">let</span> &#123;baz&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>baz <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>如果变量名和属性名不一样必须写成下面这样才行；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> &#123;<span class=\"hljs-attr\">foo</span>: baz&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>baz <span class=\"hljs-comment\">// aaa</span><br><br><span class=\"hljs-keyword\">let</span> object = &#123;<span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;;<br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">first</span>: f, <span class=\"hljs-attr\">last</span>: l&#125; = object;<br>f <span class=\"hljs-comment\">// hello</span><br>l <span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<p>解构也可以用于嵌套结构的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>  <span class=\"hljs-attr\">p</span>: [<br>    <span class=\"hljs-string\">&#x27;Hello&#x27;</span>,<br>    &#123;<span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;<br>  ]<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> &#123;<span class=\"hljs-attr\">p</span>: [x, &#123;y&#125;]&#125; = obj;<br>x <span class=\"hljs-comment\">// hello</span><br>y <span class=\"hljs-comment\">// world</span><br><span class=\"hljs-comment\">// p 为模式而不是变量，因此也不会被赋值</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"解构已声明的变量\"><a href=\"#解构已声明的变量\" class=\"headerlink\" title=\"解构已声明的变量\"></a>解构已声明的变量</h2><p>如果需要给已经声明的变量解构，一定要使用圆括号将其包裹起来，否则JavaScript引擎会将其解析为代码块。从而导致解构失败。ES6在解构变量时，除非会造成歧义必须使用圆括号围起来，否则不推荐使用圆括号；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Wrong syntax</span><br><span class=\"hljs-keyword\">var</span> x;<br>&#123;x&#125; = &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;<br><br><span class=\"hljs-comment\">// Correct syntax</span><br><span class=\"hljs-keyword\">var</span> x;<br>(&#123;x&#125; = &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;)<br><br><span class=\"hljs-comment\">// 还可以很方便地将现有对象的方法赋值到某个变量</span><br><span class=\"hljs-keyword\">let</span> &#123;log, sin, cos&#125; = <span class=\"hljs-title class_\">Math</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"字符串的解构\"><a href=\"#字符串的解构\" class=\"headerlink\" title=\"字符串的解构\"></a>字符串的解构</h2><p>字符串也可以解构，解构出来的结果是当作数组处理。程序代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [a, b, c, d, e] = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>a <span class=\"hljs-comment\">// &#x27;h&#x27;</span><br>b <span class=\"hljs-comment\">// &#x27;e&#x27;</span><br>c <span class=\"hljs-comment\">// &#x27;l&#x27;</span><br>d <span class=\"hljs-comment\">// &#x27;l&#x27;</span><br>e <span class=\"hljs-comment\">// &#x27;o&#x27;</span><br><br><span class=\"hljs-comment\">// 类似数组对象都存在一个length属性，也可以通过解构获得</span><br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">length</span>: len&#125; = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>len <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转换为对象；但是<code>undefined</code>和<code>null</code>无法转为对象，因此会解构失败；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">toString</span>: s&#125; = <span class=\"hljs-number\">123</span>;<br>s === <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">toString</span>: s&#125; = <span class=\"hljs-literal\">true</span>;<br>s === <span class=\"hljs-title class_\">Boolean</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数参数也可以解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">[x, y]</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// 3</span><br><br>[[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[a, b]</span>) =&gt;</span> a + b);<br><span class=\"hljs-comment\">// [3, 7]</span><br></code></pre></td></tr></table></figure>\n<p>函数参数的解构也可以使用默认值（这不是废话嘛）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">&#123;x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>&#125; = &#123;&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">8</span>&#125;); <span class=\"hljs-comment\">// [3, 8]</span><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;); <span class=\"hljs-comment\">// [3, 0]</span><br><span class=\"hljs-title function_\">move</span>(&#123;&#125;); <span class=\"hljs-comment\">// [0, 0]</span><br><span class=\"hljs-title function_\">move</span>(); <span class=\"hljs-comment\">// [0, 0]</span><br></code></pre></td></tr></table></figure>\n<p>下面这种写法不是解构，而是给函数参数设置默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">&#123;x, y&#125; = &#123;x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">0</span>&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">8</span>&#125;); <span class=\"hljs-comment\">// [3, 8]</span><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;); <span class=\"hljs-comment\">// [3, undefined]</span><br><span class=\"hljs-title function_\">move</span>(&#123;&#125;); <span class=\"hljs-comment\">// [undefined, undefined]</span><br><span class=\"hljs-title function_\">move</span>(); <span class=\"hljs-comment\">// [0, 0]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"说了那么多，解构有什么用呢？\"><a href=\"#说了那么多，解构有什么用呢？\" class=\"headerlink\" title=\"说了那么多，解构有什么用呢？\"></a>说了那么多，解构有什么用呢？</h2><h3 id=\"交换变量的值\"><a href=\"#交换变量的值\" class=\"headerlink\" title=\"交换变量的值\"></a>交换变量的值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[x, y] = [y, x]<br></code></pre></td></tr></table></figure>\n<h3 id=\"从函数返回多个值\"><a href=\"#从函数返回多个值\" class=\"headerlink\" title=\"从函数返回多个值\"></a>从函数返回多个值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">example</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> [a, b, c] = <span class=\"hljs-title function_\">example</span>();<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">example</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">bar</span>: <br>  &#125;;<br>&#125;<br>  <br><span class=\"hljs-keyword\">var</span> &#123;foo, bar&#125; = <span class=\"hljs-title function_\">example</span>();<br></code></pre></td></tr></table></figure>\n<h3 id=\"函数参数的定义\"><a href=\"#函数参数的定义\" class=\"headerlink\" title=\"函数参数的定义\"></a>函数参数的定义</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">[x, y, z]</span>) &#123; ... &#125;<br><span class=\"hljs-title function_\">f</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br></code></pre></td></tr></table></figure>\n<h3 id=\"提取JSON数据\"><a href=\"#提取JSON数据\" class=\"headerlink\" title=\"提取JSON数据\"></a>提取JSON数据</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> jsonData = &#123;<br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">42</span>,<br>  <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">&quot;OK&quot;</span>,<br>  <span class=\"hljs-attr\">data</span>: [<span class=\"hljs-number\">867</span>, <span class=\"hljs-number\">5309</span>]<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> &#123;id, status, <span class=\"hljs-attr\">data</span>: number&#125; = jsonData;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(id, status, number);<br><span class=\"hljs-comment\">// 42, &quot;OK&quot;, [867, 5309]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">jQuery.<span class=\"hljs-property\">ajax</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">url, &#123;</span><br><span class=\"hljs-params\">  <span class=\"hljs-keyword\">async</span> = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  beforeSend = <span class=\"hljs-keyword\">function</span>() &#123;&#125;,</span><br><span class=\"hljs-params\">  cache = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  complete = <span class=\"hljs-keyword\">function</span>() &#123;&#125;,</span><br><span class=\"hljs-params\">  crossDomain = <span class=\"hljs-literal\">false</span>,</span><br><span class=\"hljs-params\">  <span class=\"hljs-variable language_\">global</span> = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  // ... more config params</span><br><span class=\"hljs-params\">&#125;</span>) &#123;<br>  <span class=\"hljs-comment\">// ... do stuff</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历Map解构\"><a href=\"#遍历Map解构\" class=\"headerlink\" title=\"遍历Map解构\"></a>遍历Map解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;first&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;last&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key + <span class=\"hljs-string\">&quot; is &quot;</span> + value);<br>&#125;<br><br><span class=\"hljs-comment\">// first is hello</span><br><span class=\"hljs-comment\">// last is world</span><br><br><span class=\"hljs-comment\">// 如果只想获取键名称，可以这样</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-comment\">// ... do something</span><br>&#125;<br><br><span class=\"hljs-comment\">// 只想获取键值</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [,value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-comment\">// ... do something</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"输入模块的指定方法\"><a href=\"#输入模块的指定方法\" class=\"headerlink\" title=\"输入模块的指定方法\"></a>输入模块的指定方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">SourceMapConsumer</span>, <span class=\"hljs-title class_\">SourceNode</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;source-map&quot;</span>);<br><br><span class=\"hljs-comment\">// 除此之外使用import也可以使用解构倒入指定方法</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">SourceMapConsumer</span>, <span class=\"hljs-title class_\">SourceNode</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;source-map&#x27;</span>;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":4207,"excerpt":"","more":"<h1 id=\"变量解构与赋值\"><a href=\"#变量解构与赋值\" class=\"headerlink\" title=\"变量解构与赋值\"></a>变量解构与赋值</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>a <span class=\"hljs-comment\">// 1</span><br>b <span class=\"hljs-comment\">// 2</span><br>c <span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// 与下列写法等价</span><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n<p>本质上只有等号两边的模式匹配的情况下，解构变量才会成功，如果解构不成功，那么值就等于undefined；但是即便两边的模式不完全匹配也是可以解构成功的。即：等号右边的模式仅等于等号左边声明的一部分。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [x, y] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>x <span class=\"hljs-comment\">// 1</span><br>y <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"适用范围\"><a href=\"#适用范围\" class=\"headerlink\" title=\"适用范围\"></a>适用范围</h2><p>除了<code>var</code>变量可以解构赋值，还有<code>let</code>和<code>const</code>也可以解构，除此之外，一种数据结构只要其有Iterator接口都可以使用数组解构赋值。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(&#123;<span class=\"hljs-string\">&#x27;aa&#x27;</span>, <span class=\"hljs-string\">&#x27;bb&#x27;</span>, <span class=\"hljs-string\">&#x27;cc&#x27;</span>&#125;);<br>a <span class=\"hljs-comment\">// aa</span><br>b <span class=\"hljs-comment\">// bb</span><br>c <span class=\"hljs-comment\">// cc</span><br><br><span class=\"hljs-keyword\">const</span> [d, e, f] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(&#123;<span class=\"hljs-string\">&#x27;dd&#x27;</span>, <span class=\"hljs-string\">&#x27;ee&#x27;</span>, <span class=\"hljs-string\">&#x27;ff&#x27;</span>&#125;);<br>d <span class=\"hljs-comment\">// dd</span><br>e <span class=\"hljs-comment\">// ee</span><br>f <span class=\"hljs-comment\">// ff</span><br></code></pre></td></tr></table></figure>\n<p>使用Generator函数解斐波那契数列，内部使用解构赋值，每次循环过程中变量<code>a</code>和<code>b</code>都会重新赋值；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibs</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> [first, second, third, fourth, fifth, sixth] = <span class=\"hljs-title function_\">fibs</span>();<br>sixth <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>变量解构可以在声明前初始化，注意：如果解构右侧值不等于<code>undefined</code>那么初始化的值就不会生效。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [x, y = <span class=\"hljs-string\">&#x27;y&#x27;</span>] = [x, <span class=\"hljs-literal\">undefined</span>];<br>y <span class=\"hljs-comment\">// y - 解构初始化成功</span><br><br><span class=\"hljs-keyword\">let</span> [x, y = <span class=\"hljs-string\">&#x27;y&#x27;</span>] = [x, <span class=\"hljs-literal\">null</span>];<br>y <span class=\"hljs-comment\">// null - 解构初始化失败</span><br></code></pre></td></tr></table></figure>\n<p>如果解构默认值是一个表达式，那么只有在需要使用到表达式的时候才会赋值，否则默认值无效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;aaa&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> [x = <span class=\"hljs-title function_\">f</span>()] = [<span class=\"hljs-number\">1</span>];<br>x <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-comment\">// 由于x能在后面的数组中获取到数值1，因此默认值中的f()不生效；</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"对象的解构\"><a href=\"#对象的解构\" class=\"headerlink\" title=\"对象的解构\"></a>对象的解构</h2><p>除了可以对数组做解构，对象同样可以做解构，但是与数组有区别的是：对象解构只有在对象属性名相同的情况下才能解构成功，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123;foo, bar&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>foo <span class=\"hljs-comment\">// aaa</span><br>bar <span class=\"hljs-comment\">// bbb</span><br><br><span class=\"hljs-keyword\">let</span> &#123;baz&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>baz <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>如果变量名和属性名不一样必须写成下面这样才行；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> &#123;<span class=\"hljs-attr\">foo</span>: baz&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>baz <span class=\"hljs-comment\">// aaa</span><br><br><span class=\"hljs-keyword\">let</span> object = &#123;<span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;;<br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">first</span>: f, <span class=\"hljs-attr\">last</span>: l&#125; = object;<br>f <span class=\"hljs-comment\">// hello</span><br>l <span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<p>解构也可以用于嵌套结构的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>  <span class=\"hljs-attr\">p</span>: [<br>    <span class=\"hljs-string\">&#x27;Hello&#x27;</span>,<br>    &#123;<span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;<br>  ]<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> &#123;<span class=\"hljs-attr\">p</span>: [x, &#123;y&#125;]&#125; = obj;<br>x <span class=\"hljs-comment\">// hello</span><br>y <span class=\"hljs-comment\">// world</span><br><span class=\"hljs-comment\">// p 为模式而不是变量，因此也不会被赋值</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"解构已声明的变量\"><a href=\"#解构已声明的变量\" class=\"headerlink\" title=\"解构已声明的变量\"></a>解构已声明的变量</h2><p>如果需要给已经声明的变量解构，一定要使用圆括号将其包裹起来，否则JavaScript引擎会将其解析为代码块。从而导致解构失败。ES6在解构变量时，除非会造成歧义必须使用圆括号围起来，否则不推荐使用圆括号；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Wrong syntax</span><br><span class=\"hljs-keyword\">var</span> x;<br>&#123;x&#125; = &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;<br><br><span class=\"hljs-comment\">// Correct syntax</span><br><span class=\"hljs-keyword\">var</span> x;<br>(&#123;x&#125; = &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;)<br><br><span class=\"hljs-comment\">// 还可以很方便地将现有对象的方法赋值到某个变量</span><br><span class=\"hljs-keyword\">let</span> &#123;log, sin, cos&#125; = <span class=\"hljs-title class_\">Math</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"字符串的解构\"><a href=\"#字符串的解构\" class=\"headerlink\" title=\"字符串的解构\"></a>字符串的解构</h2><p>字符串也可以解构，解构出来的结果是当作数组处理。程序代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [a, b, c, d, e] = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>a <span class=\"hljs-comment\">// &#x27;h&#x27;</span><br>b <span class=\"hljs-comment\">// &#x27;e&#x27;</span><br>c <span class=\"hljs-comment\">// &#x27;l&#x27;</span><br>d <span class=\"hljs-comment\">// &#x27;l&#x27;</span><br>e <span class=\"hljs-comment\">// &#x27;o&#x27;</span><br><br><span class=\"hljs-comment\">// 类似数组对象都存在一个length属性，也可以通过解构获得</span><br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">length</span>: len&#125; = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>len <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转换为对象；但是<code>undefined</code>和<code>null</code>无法转为对象，因此会解构失败；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">toString</span>: s&#125; = <span class=\"hljs-number\">123</span>;<br>s === <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">toString</span>: s&#125; = <span class=\"hljs-literal\">true</span>;<br>s === <span class=\"hljs-title class_\">Boolean</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数参数也可以解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">[x, y]</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// 3</span><br><br>[[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[a, b]</span>) =&gt;</span> a + b);<br><span class=\"hljs-comment\">// [3, 7]</span><br></code></pre></td></tr></table></figure>\n<p>函数参数的解构也可以使用默认值（这不是废话嘛）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">&#123;x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>&#125; = &#123;&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">8</span>&#125;); <span class=\"hljs-comment\">// [3, 8]</span><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;); <span class=\"hljs-comment\">// [3, 0]</span><br><span class=\"hljs-title function_\">move</span>(&#123;&#125;); <span class=\"hljs-comment\">// [0, 0]</span><br><span class=\"hljs-title function_\">move</span>(); <span class=\"hljs-comment\">// [0, 0]</span><br></code></pre></td></tr></table></figure>\n<p>下面这种写法不是解构，而是给函数参数设置默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">&#123;x, y&#125; = &#123;x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">0</span>&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">8</span>&#125;); <span class=\"hljs-comment\">// [3, 8]</span><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;); <span class=\"hljs-comment\">// [3, undefined]</span><br><span class=\"hljs-title function_\">move</span>(&#123;&#125;); <span class=\"hljs-comment\">// [undefined, undefined]</span><br><span class=\"hljs-title function_\">move</span>(); <span class=\"hljs-comment\">// [0, 0]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"说了那么多，解构有什么用呢？\"><a href=\"#说了那么多，解构有什么用呢？\" class=\"headerlink\" title=\"说了那么多，解构有什么用呢？\"></a>说了那么多，解构有什么用呢？</h2><h3 id=\"交换变量的值\"><a href=\"#交换变量的值\" class=\"headerlink\" title=\"交换变量的值\"></a>交换变量的值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[x, y] = [y, x]<br></code></pre></td></tr></table></figure>\n<h3 id=\"从函数返回多个值\"><a href=\"#从函数返回多个值\" class=\"headerlink\" title=\"从函数返回多个值\"></a>从函数返回多个值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">example</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> [a, b, c] = <span class=\"hljs-title function_\">example</span>();<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">example</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">bar</span>: <br>  &#125;;<br>&#125;<br>  <br><span class=\"hljs-keyword\">var</span> &#123;foo, bar&#125; = <span class=\"hljs-title function_\">example</span>();<br></code></pre></td></tr></table></figure>\n<h3 id=\"函数参数的定义\"><a href=\"#函数参数的定义\" class=\"headerlink\" title=\"函数参数的定义\"></a>函数参数的定义</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">[x, y, z]</span>) &#123; ... &#125;<br><span class=\"hljs-title function_\">f</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br></code></pre></td></tr></table></figure>\n<h3 id=\"提取JSON数据\"><a href=\"#提取JSON数据\" class=\"headerlink\" title=\"提取JSON数据\"></a>提取JSON数据</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> jsonData = &#123;<br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">42</span>,<br>  <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">&quot;OK&quot;</span>,<br>  <span class=\"hljs-attr\">data</span>: [<span class=\"hljs-number\">867</span>, <span class=\"hljs-number\">5309</span>]<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> &#123;id, status, <span class=\"hljs-attr\">data</span>: number&#125; = jsonData;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(id, status, number);<br><span class=\"hljs-comment\">// 42, &quot;OK&quot;, [867, 5309]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">jQuery.<span class=\"hljs-property\">ajax</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">url, &#123;</span><br><span class=\"hljs-params\">  <span class=\"hljs-keyword\">async</span> = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  beforeSend = <span class=\"hljs-keyword\">function</span>() &#123;&#125;,</span><br><span class=\"hljs-params\">  cache = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  complete = <span class=\"hljs-keyword\">function</span>() &#123;&#125;,</span><br><span class=\"hljs-params\">  crossDomain = <span class=\"hljs-literal\">false</span>,</span><br><span class=\"hljs-params\">  <span class=\"hljs-variable language_\">global</span> = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  // ... more config params</span><br><span class=\"hljs-params\">&#125;</span>) &#123;<br>  <span class=\"hljs-comment\">// ... do stuff</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历Map解构\"><a href=\"#遍历Map解构\" class=\"headerlink\" title=\"遍历Map解构\"></a>遍历Map解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;first&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;last&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key + <span class=\"hljs-string\">&quot; is &quot;</span> + value);<br>&#125;<br><br><span class=\"hljs-comment\">// first is hello</span><br><span class=\"hljs-comment\">// last is world</span><br><br><span class=\"hljs-comment\">// 如果只想获取键名称，可以这样</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-comment\">// ... do something</span><br>&#125;<br><br><span class=\"hljs-comment\">// 只想获取键值</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [,value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-comment\">// ... do something</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"输入模块的指定方法\"><a href=\"#输入模块的指定方法\" class=\"headerlink\" title=\"输入模块的指定方法\"></a>输入模块的指定方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">SourceMapConsumer</span>, <span class=\"hljs-title class_\">SourceNode</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;source-map&quot;</span>);<br><br><span class=\"hljs-comment\">// 除此之外使用import也可以使用解构倒入指定方法</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">SourceMapConsumer</span>, <span class=\"hljs-title class_\">SourceNode</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;source-map&#x27;</span>;<br></code></pre></td></tr></table></figure>\n"},{"title":"谈谈MySQL索引","date":"2022-02-21T01:56:34.000Z","updated":"2022-02-21T01:56:34.000Z","_content":"\n# 什么是索引\n\n存储引擎中一种用于快速找到记录的数据结构。索引对于良好性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响愈发重要。\n\n# 索引类型\n\n## B-Tree索引\n\n毋庸置疑，B-Tree索引使用的是B-Tree数据结构来存储数据。索引类型在创建表的过程中是可以指定的。\n\nB-Tree意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。\n\n所以B-Tree索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引根节点开始进行搜索。\n\n## B+Tree\n\nMySQL中最常用的索引数据结构是B+树，存在以下特点：\n\n1. 所有数据记录节点按照键值大小存放在同层叶子节点上，非叶子结点只存储key的信息，这样可以大大减少每个节点存储key的数量，降低B+树的高度；\n2. 叶子节点的关键字从小到大排序，左边结尾数据会保存右边节点开始数据的指针；\n3. 层级更少意味着查询数据更快；\n4. 查询速度稳定，所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同；\n5. 天然具备排序功能，所有叶子节点就是一个有序链表，所以在查询大小取件的数据更方便，数据紧密性好，缓存的命中率也比B树高；\n6. 全节点遍历更快，有利于做数据库全表扫描；\n\n### 主键目录\n\n![image-20220221123200692](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221123200692.png)\n\n+ MySQL是以数据页为最小单位，数据页中的数据是连续存储的；\n+ 数据页的数据是按照主键排序的（若无主键由MySQL中的ROW_ID来排序）；\n+ 数据页之间使用双向链表关联；\n+ 数据之间使用单链表进行关联；\n\n### 索引页\n\n为了避免单个主键目录过大（例如1000万条记录，5000万条记录）。使用前面说的二分法查找效率就十分低下了。所以为了解决这个问题MySQL又提出了一种新的数据结构，索引页。\n\n![image-20220221124810004](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221124810004.png)\n\n索引页的记录是每页数据页的页号和该数据页中最小的主键记录，也就是说最小主键和数据页号不是单纯的维护在主键目录中，而是演变成了索引页，索引页和数据页类似。一张不够就分裂到下一张；\n\n因此：此时MySQL应该需要维护索引页的，MySQL也是这样设计的。也就是说MySQL同时也设计出用于维护索引页的数据结构。也称为索引页。类似下面的结构：\n\n![image-20220221125453613](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221125453613.png)\n\n也就是说维护索引的索引页是真正存储记录和数据页的索引页的上一层，如果想要查找就从最上层的索引页开始查找。通过二分法，很快就能定位到该条记录在索引页的具体位置上。\n\n### 索引页分层\n\n同样的，索引页一大也会出现类似的问题，那怎么办呢？好说。继续分裂\n\n![image-20220221132129655](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221132129655.png)\n\n综上所述，MySQL的查找流程如下，假设我们要找的记录是37：\n\n+ 先从最顶层的索引页开始查找，根据id = 37定位到索引页16；\n+ 在索引页16中继续搜索，此时定位到id = 37在索引页3中；\n+ 最终定位到数据在数据页8中，遍历数据页8中的数据链表，发现元素37；\n+ 查找完毕\n\n最后需要注意的是：索引页 + 数据页组成的B+树称之为聚簇索引。\n\n> 聚簇索引是MySQL基于主键索引结构创建的\n\n# 非主键索引\n\n非主键索引和主键索引的引用原理一样，都是去维护一颗B+树，建立多少个索引，就会帮忙维护多少个B+树。因为索引会占用磁盘空间，不能盲目建索引；\n\n## 它是怎么工作的呢？\n\n如果对`name + age`建立索引，此时MySQL会根据name + age维护一个单独的B+树结构。数据依然存放在数据页中。类似于下图：\n\n![image-20220221133527771](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221133527771.png)\n\n插入数据时，MySQL会根据name进行排序，如果name一样。就根据联合索引中的age字段排序，如果还一样就根据主键字段排序。\n\n# 什么是回表？\n\n根据非主键索引查询的结果并没有查找的字段，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完整的。\n\n针对上面的结构，假设存在如下查询：\n\n```sql\nSELECT name FROM student WHERE name = 'xx';\n```\n\n由于name字段是索引，所以查询是非常完美的；\n\n假设是这样子：\n\n```sql\nSELECT * FROM student WHERE name = 'xy';\n```\n\n虽然通过name很快定位到了索引，但由于name + age并不是聚簇索引，所以B+树的数据页存放的仅仅是和自己关联的索引和主键字段，并不存在其他字段。这个时候**MySQL会根据定位记录的id再次进行聚簇索引查找**，这个过程就叫做回表。\n\n# 索引的优缺点\n\n说了这么多，索引总结下来有三个优点：\n\n+ 大大减少服务器需要扫描的数据量；\n+ 帮助服务器避免排序和临时表；\n+ 将随机I/O变为顺序I/O（因为数据页本身就是有序的）；\n\n当然再好的工具也并不一定是解决问题的通用方案，索引也有缺点：\n\n+ 对于非常小的数据表，全表扫描更加高效，不需要使用索引，对于中大型的表来说索引比较高效；\n+ 对于特大型的表，应当直接区分查询需要的数据组，例如分区技术；\n+ 如果表的数量特别大，可以建立一个元数据信息表，用来查询需要用到的特性；\n\n# 高性能索引策略\n\n## 独立列\n\n索引列不能是表达式的一部分，也不能是函数参数，比如下面这两种写法会令索引失效；\n\n因此我们必须养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧；\n\n```sql\nSELECT actor_id FROM actor WHERE actor_id + 1 = 5;\nSELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;\n```\n\n\n\n## 前缀索引\n\n索引很长的字符列会使得索引变得大且慢，这时候可以索引开始的部分字符，这样可以大大节约索引空间，提高索引效率。\n\n诀窍在于：选择足够长的前缀以保证较高的选择性（也就是可以过滤掉绝大多数不相关的数据），同时又不能太长（节约空间）。因此前缀应该足够长，以使得前缀索引的选择性接近与索引整个列；\n\n## 计算完整列选择性\n\n用查询条件的索引字段除以总记录数，通常如果前缀选择性能够接近0.031基本上就可以用了。例如：\n\n```sql\nSELECT COUNT(DISTINCT LEFT(city, 3)) / COUNT(*) AS sel3,\n\t   COUNT(DISTINCT LEFT(city, 4)) / COUNT(*) AS sel4,\n\t   COUNT(DISTINCT LEFT(city, 5)) / COUNT(*) AS sel5,\n\t   COUNT(DISTINCT LEFT(city, 6)) / COUNT(*) AS sel6,\n\t   COUNT(DISTINCT LEFT(city, 7)) / COUNT(*) AS sel7\nFROM city_demo;\n```\n\n\n\n## 多列索引（这个看不懂，先放着）\n\n在多个列上建立独立索引大部分情况下并不能提高MySQL的查询性能，好在MySQL提供了一种“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。\n\n## 合适的索引列顺序\n\n依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这样索引确实可以够快过滤出需要的行。\n\n还有一个方法，在你不确定怎样排列查询的效果最好时，可以跑一下查询确定在这个表中值的分布情况，并确定哪个列的选择性更高。\n\n```sql\nSELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;\n```\n\n如法炮制，我们可以计算一下索引列选择性：\n\n```sql\nSELECT COUNT(DISTINCT staff_id) / COUNT(*) AS staff_id_selectivity,\n\t   COUNT(DISTINCT customer_Id) / COUNT(*) AS customer_id_selectivity,\n\t   COUNT(*)\n\t   FROM payment\\G;\n```\n\n最后数字大的那一个就是索引列的第一项；尽管关于选择性和基数的经验法则值得去研究和分析，但一定要注意WHERE字句中的排序、分组和范围条件等其他因素，这些因素可能对查询的性能会造成非常大的影响。\n\n\n\n## 聚簇索引\n\n> 聚簇索引：找到了索引就找到了需要的数据，因此主键就是一种聚簇索引；\n>\n> 非聚簇索引：结合上面的意思，找到了索引但没找到数据，需要根据索引的主键再次进行回表查询；\n\n聚簇索引一般是主键，前面已经介绍过了相关概念，就不再啰嗦。它也有优缺点：\n\n### 优点\n\n+ 相关数据聚合在一起，只需要从磁盘读取少数数据就可以拿到全部信息，减少磁盘I/O；\n+ 数据访问快，在聚簇索引中获取数据通常比非聚簇索引查找要快；\n+ 索引覆盖扫描的查询可以直接使用页节点中的主键值；\n\n### 缺点\n\n+ 数据全在内存中，聚簇索引的访问顺序性就没那么重要了；\n+ 插入速度严重依赖插入顺序，按照主键顺序插入是速度最快的，否则会特别慢；\n+ 更新聚簇索引代价很高，会强制InnoDB将每个被更新的行移动到新的位置；\n+ 当主键被更新导致需要移动行时会触发“页分裂”操作，这样会使得表占用更多的磁盘空间；\n+ 导致全表扫描变慢，尤其在数据比较稀疏或者由于页分裂导致数据存储不连续的时候；\n+ 二级索引可能比想象的要大，因为二级索引的叶子节点包含了引用行的主键列；\n+ 二级索引访问需要两次索引查找；\n\n### 注意的点\n\n使用InnoDB表中按主键顺序插入行，最简单的办法是使用AUTO_INCREMENT自增列。这样既可以保证数据行是按照顺序写入，对于根据主键做关联操作的性能也会更好。\n\n最好避免随机的聚簇索引（比如使用UUID来做聚簇索引会很糟糕），它会使得索引插入变得完全随机，这是最坏的情况。\n\n\n\n## 覆盖索引\n\n即从非主键索引中就能查询到的记录，而不需要查询主键索引（回表操作）中的记录。避免回表的产生减少了对树的搜索次数，从而提升性能。\n\n由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。二级索引（非聚簇索引）的叶子节点如果保存了行的主键值，所以如果二级主键能够覆盖查询就可以避免回表操作的产生。\n\n### 如何查看使用了覆盖查询？\n\n使用explain关键字解释查询，如果在Extra行显示\"Using index\"则说明使用了覆盖索引。\n\n### 例子\n\n假设inventory中存在多列索引(store_id, film_id)，并且MySQL只需要这两列数据，那么此时就是使用了覆盖索引；\n\n```sql\nEXPLAIN SELECT store_id, film_id FROM inventory\\G;\n```\n\n假设是下面这种情况，索引就无法实现查询覆盖：\n\n```sql\nEXPLAIN SELECT * FROM products WHERE actor = 'SEAM CARREY'\n\t    AND title like '%APOLLO%'\\G\n```\n\n原因有二：\n\n+ 没有任何索引能够覆盖查询，因为查询从表中选择了所有列，且没有任何索引覆盖了所有列；\n+ MySQL不能在索引中执行LIKE操作；\n\n### 如何优化呢？\n\n将索引列扩展覆盖至三个数据列（artist, title, prod_id），然后重写查询：\n\n```sql\nEXPLAIN SELECT *\n\t    FROM products\n\t    \tJOIN(\n            \tSELECT prod_id\n                FROM products\n                WHERE actor = 'SEAM CARREY'\n                AND title LIKE '%APOLLO%'\n            ) AS t1 ON (t1.prod_id = products.prod_id)\\G\n```\n\n这种方式成为延迟关联，由于延迟了对列的访问，因此在第一阶段可以使用覆盖索引，然后再根据prod_id的值在外层查询匹配获得需要的所有列值。\n\n## 索引扫描排序(这个不是很理解)\n\nMySQL可以通过两种方式做排序：\n\n+ 排序操作\n+ 索引顺序扫描（EXPLAIN后的结果为“index”则是索引扫描）\n\n索引本身是有序的，所以索引扫描应该很快，但如果索引无法覆盖查询所需的全部列，就不得不每扫描一跳记录都回表查询一次对应的行。\n\n> 只有当索引列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样，MySQL才能够使用索引来对结果做排序\n\n\n\n## 冗余和重复索引\n\n在 MySQL 中允许在相同的列上创建多个索引。\n\n+ 重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。\n\n+ 冗余索引和重复索引有些不同，例如创建了索引（A,B），在创建索引（A）就是冗余索引。\n\n下面的例子是重复索引：\n\n```sql\ncreate table test(\n    id int not null primary key,\n    A int not null,\n    B int not null,\n    UNIQUE(id),\n    INDEX(id)\n ) ENGINE=InnoDB;\n```\n\n> TIP：\n>\n> 1. MySQL需要单独维护重复索引和冗余索引\n> 2. 优化器在优化查询时，也需要对每个索引进行过滤，也会影响性能；\n> 3. 表中索引多，会影响对数据进行CRUD的速度；\n\n## 未使用的索引\n\n未使用的索引应当删除，最简单的办法是打开`userstates`服务器变量（默认关闭），然后让服务器正常运行一段时间，再通过`INFORMATION_SCHEMA.INDEX_STATISTICS`就可以查到每个索引的使用频率；\n\n## 索引和锁\n\n索引可以让查询锁定更少的行，如果查询从不访问那些不需要的行，就会锁定更少的行。虽然InnoDB的行锁效率很高，内存使用也少，但是锁定行的时候也会带来额外的开销，其次锁定超过需要的行会增加锁争用并减少并发性。\n\n# MySQL索引失效\n\n## 为什么会出现索引失效\n\n索引可以加快查找速度是因为，在每层兄弟节点之间索引是有序的，因此可以通过二分查找快速定位到相应的位置。假如有一些操作破坏了索引排列顺序的有序性或者不能利用索引的有序性，那么这个索引自然而然就失效了；\n\n## 哪些情况会出现索引失效\n\n+ 不符合最左匹配前缀原则导致索引失效;\n+ 对索引字段做函数操作；优化器会放弃树的搜索功能；\n+ 存在NULL值条件；\n+ 使用模糊搜索时，尽量采用后置通配符，因为走索引的过程中，其会从前去匹配索引列；\n\n## 总结\n\n索引失效是优化器不能很好的利用索引的有序性，因此在使用索引的过程中要尽量满足最左前缀匹配原则，范围查询放在最后，不使用%like、%like%等模糊查询；\n\n","source":"_posts/mysql/mysql-index.md","raw":"---\ntitle: 谈谈MySQL索引\ndate: 2022-02-21 09:56:34\nupdated: 2022-02-21 09:56:34\ntags: MySQL\ncategories: 数据库\n---\n\n# 什么是索引\n\n存储引擎中一种用于快速找到记录的数据结构。索引对于良好性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响愈发重要。\n\n# 索引类型\n\n## B-Tree索引\n\n毋庸置疑，B-Tree索引使用的是B-Tree数据结构来存储数据。索引类型在创建表的过程中是可以指定的。\n\nB-Tree意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。\n\n所以B-Tree索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引根节点开始进行搜索。\n\n## B+Tree\n\nMySQL中最常用的索引数据结构是B+树，存在以下特点：\n\n1. 所有数据记录节点按照键值大小存放在同层叶子节点上，非叶子结点只存储key的信息，这样可以大大减少每个节点存储key的数量，降低B+树的高度；\n2. 叶子节点的关键字从小到大排序，左边结尾数据会保存右边节点开始数据的指针；\n3. 层级更少意味着查询数据更快；\n4. 查询速度稳定，所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同；\n5. 天然具备排序功能，所有叶子节点就是一个有序链表，所以在查询大小取件的数据更方便，数据紧密性好，缓存的命中率也比B树高；\n6. 全节点遍历更快，有利于做数据库全表扫描；\n\n### 主键目录\n\n![image-20220221123200692](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221123200692.png)\n\n+ MySQL是以数据页为最小单位，数据页中的数据是连续存储的；\n+ 数据页的数据是按照主键排序的（若无主键由MySQL中的ROW_ID来排序）；\n+ 数据页之间使用双向链表关联；\n+ 数据之间使用单链表进行关联；\n\n### 索引页\n\n为了避免单个主键目录过大（例如1000万条记录，5000万条记录）。使用前面说的二分法查找效率就十分低下了。所以为了解决这个问题MySQL又提出了一种新的数据结构，索引页。\n\n![image-20220221124810004](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221124810004.png)\n\n索引页的记录是每页数据页的页号和该数据页中最小的主键记录，也就是说最小主键和数据页号不是单纯的维护在主键目录中，而是演变成了索引页，索引页和数据页类似。一张不够就分裂到下一张；\n\n因此：此时MySQL应该需要维护索引页的，MySQL也是这样设计的。也就是说MySQL同时也设计出用于维护索引页的数据结构。也称为索引页。类似下面的结构：\n\n![image-20220221125453613](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221125453613.png)\n\n也就是说维护索引的索引页是真正存储记录和数据页的索引页的上一层，如果想要查找就从最上层的索引页开始查找。通过二分法，很快就能定位到该条记录在索引页的具体位置上。\n\n### 索引页分层\n\n同样的，索引页一大也会出现类似的问题，那怎么办呢？好说。继续分裂\n\n![image-20220221132129655](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221132129655.png)\n\n综上所述，MySQL的查找流程如下，假设我们要找的记录是37：\n\n+ 先从最顶层的索引页开始查找，根据id = 37定位到索引页16；\n+ 在索引页16中继续搜索，此时定位到id = 37在索引页3中；\n+ 最终定位到数据在数据页8中，遍历数据页8中的数据链表，发现元素37；\n+ 查找完毕\n\n最后需要注意的是：索引页 + 数据页组成的B+树称之为聚簇索引。\n\n> 聚簇索引是MySQL基于主键索引结构创建的\n\n# 非主键索引\n\n非主键索引和主键索引的引用原理一样，都是去维护一颗B+树，建立多少个索引，就会帮忙维护多少个B+树。因为索引会占用磁盘空间，不能盲目建索引；\n\n## 它是怎么工作的呢？\n\n如果对`name + age`建立索引，此时MySQL会根据name + age维护一个单独的B+树结构。数据依然存放在数据页中。类似于下图：\n\n![image-20220221133527771](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221133527771.png)\n\n插入数据时，MySQL会根据name进行排序，如果name一样。就根据联合索引中的age字段排序，如果还一样就根据主键字段排序。\n\n# 什么是回表？\n\n根据非主键索引查询的结果并没有查找的字段，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完整的。\n\n针对上面的结构，假设存在如下查询：\n\n```sql\nSELECT name FROM student WHERE name = 'xx';\n```\n\n由于name字段是索引，所以查询是非常完美的；\n\n假设是这样子：\n\n```sql\nSELECT * FROM student WHERE name = 'xy';\n```\n\n虽然通过name很快定位到了索引，但由于name + age并不是聚簇索引，所以B+树的数据页存放的仅仅是和自己关联的索引和主键字段，并不存在其他字段。这个时候**MySQL会根据定位记录的id再次进行聚簇索引查找**，这个过程就叫做回表。\n\n# 索引的优缺点\n\n说了这么多，索引总结下来有三个优点：\n\n+ 大大减少服务器需要扫描的数据量；\n+ 帮助服务器避免排序和临时表；\n+ 将随机I/O变为顺序I/O（因为数据页本身就是有序的）；\n\n当然再好的工具也并不一定是解决问题的通用方案，索引也有缺点：\n\n+ 对于非常小的数据表，全表扫描更加高效，不需要使用索引，对于中大型的表来说索引比较高效；\n+ 对于特大型的表，应当直接区分查询需要的数据组，例如分区技术；\n+ 如果表的数量特别大，可以建立一个元数据信息表，用来查询需要用到的特性；\n\n# 高性能索引策略\n\n## 独立列\n\n索引列不能是表达式的一部分，也不能是函数参数，比如下面这两种写法会令索引失效；\n\n因此我们必须养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧；\n\n```sql\nSELECT actor_id FROM actor WHERE actor_id + 1 = 5;\nSELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;\n```\n\n\n\n## 前缀索引\n\n索引很长的字符列会使得索引变得大且慢，这时候可以索引开始的部分字符，这样可以大大节约索引空间，提高索引效率。\n\n诀窍在于：选择足够长的前缀以保证较高的选择性（也就是可以过滤掉绝大多数不相关的数据），同时又不能太长（节约空间）。因此前缀应该足够长，以使得前缀索引的选择性接近与索引整个列；\n\n## 计算完整列选择性\n\n用查询条件的索引字段除以总记录数，通常如果前缀选择性能够接近0.031基本上就可以用了。例如：\n\n```sql\nSELECT COUNT(DISTINCT LEFT(city, 3)) / COUNT(*) AS sel3,\n\t   COUNT(DISTINCT LEFT(city, 4)) / COUNT(*) AS sel4,\n\t   COUNT(DISTINCT LEFT(city, 5)) / COUNT(*) AS sel5,\n\t   COUNT(DISTINCT LEFT(city, 6)) / COUNT(*) AS sel6,\n\t   COUNT(DISTINCT LEFT(city, 7)) / COUNT(*) AS sel7\nFROM city_demo;\n```\n\n\n\n## 多列索引（这个看不懂，先放着）\n\n在多个列上建立独立索引大部分情况下并不能提高MySQL的查询性能，好在MySQL提供了一种“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。\n\n## 合适的索引列顺序\n\n依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这样索引确实可以够快过滤出需要的行。\n\n还有一个方法，在你不确定怎样排列查询的效果最好时，可以跑一下查询确定在这个表中值的分布情况，并确定哪个列的选择性更高。\n\n```sql\nSELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;\n```\n\n如法炮制，我们可以计算一下索引列选择性：\n\n```sql\nSELECT COUNT(DISTINCT staff_id) / COUNT(*) AS staff_id_selectivity,\n\t   COUNT(DISTINCT customer_Id) / COUNT(*) AS customer_id_selectivity,\n\t   COUNT(*)\n\t   FROM payment\\G;\n```\n\n最后数字大的那一个就是索引列的第一项；尽管关于选择性和基数的经验法则值得去研究和分析，但一定要注意WHERE字句中的排序、分组和范围条件等其他因素，这些因素可能对查询的性能会造成非常大的影响。\n\n\n\n## 聚簇索引\n\n> 聚簇索引：找到了索引就找到了需要的数据，因此主键就是一种聚簇索引；\n>\n> 非聚簇索引：结合上面的意思，找到了索引但没找到数据，需要根据索引的主键再次进行回表查询；\n\n聚簇索引一般是主键，前面已经介绍过了相关概念，就不再啰嗦。它也有优缺点：\n\n### 优点\n\n+ 相关数据聚合在一起，只需要从磁盘读取少数数据就可以拿到全部信息，减少磁盘I/O；\n+ 数据访问快，在聚簇索引中获取数据通常比非聚簇索引查找要快；\n+ 索引覆盖扫描的查询可以直接使用页节点中的主键值；\n\n### 缺点\n\n+ 数据全在内存中，聚簇索引的访问顺序性就没那么重要了；\n+ 插入速度严重依赖插入顺序，按照主键顺序插入是速度最快的，否则会特别慢；\n+ 更新聚簇索引代价很高，会强制InnoDB将每个被更新的行移动到新的位置；\n+ 当主键被更新导致需要移动行时会触发“页分裂”操作，这样会使得表占用更多的磁盘空间；\n+ 导致全表扫描变慢，尤其在数据比较稀疏或者由于页分裂导致数据存储不连续的时候；\n+ 二级索引可能比想象的要大，因为二级索引的叶子节点包含了引用行的主键列；\n+ 二级索引访问需要两次索引查找；\n\n### 注意的点\n\n使用InnoDB表中按主键顺序插入行，最简单的办法是使用AUTO_INCREMENT自增列。这样既可以保证数据行是按照顺序写入，对于根据主键做关联操作的性能也会更好。\n\n最好避免随机的聚簇索引（比如使用UUID来做聚簇索引会很糟糕），它会使得索引插入变得完全随机，这是最坏的情况。\n\n\n\n## 覆盖索引\n\n即从非主键索引中就能查询到的记录，而不需要查询主键索引（回表操作）中的记录。避免回表的产生减少了对树的搜索次数，从而提升性能。\n\n由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。二级索引（非聚簇索引）的叶子节点如果保存了行的主键值，所以如果二级主键能够覆盖查询就可以避免回表操作的产生。\n\n### 如何查看使用了覆盖查询？\n\n使用explain关键字解释查询，如果在Extra行显示\"Using index\"则说明使用了覆盖索引。\n\n### 例子\n\n假设inventory中存在多列索引(store_id, film_id)，并且MySQL只需要这两列数据，那么此时就是使用了覆盖索引；\n\n```sql\nEXPLAIN SELECT store_id, film_id FROM inventory\\G;\n```\n\n假设是下面这种情况，索引就无法实现查询覆盖：\n\n```sql\nEXPLAIN SELECT * FROM products WHERE actor = 'SEAM CARREY'\n\t    AND title like '%APOLLO%'\\G\n```\n\n原因有二：\n\n+ 没有任何索引能够覆盖查询，因为查询从表中选择了所有列，且没有任何索引覆盖了所有列；\n+ MySQL不能在索引中执行LIKE操作；\n\n### 如何优化呢？\n\n将索引列扩展覆盖至三个数据列（artist, title, prod_id），然后重写查询：\n\n```sql\nEXPLAIN SELECT *\n\t    FROM products\n\t    \tJOIN(\n            \tSELECT prod_id\n                FROM products\n                WHERE actor = 'SEAM CARREY'\n                AND title LIKE '%APOLLO%'\n            ) AS t1 ON (t1.prod_id = products.prod_id)\\G\n```\n\n这种方式成为延迟关联，由于延迟了对列的访问，因此在第一阶段可以使用覆盖索引，然后再根据prod_id的值在外层查询匹配获得需要的所有列值。\n\n## 索引扫描排序(这个不是很理解)\n\nMySQL可以通过两种方式做排序：\n\n+ 排序操作\n+ 索引顺序扫描（EXPLAIN后的结果为“index”则是索引扫描）\n\n索引本身是有序的，所以索引扫描应该很快，但如果索引无法覆盖查询所需的全部列，就不得不每扫描一跳记录都回表查询一次对应的行。\n\n> 只有当索引列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样，MySQL才能够使用索引来对结果做排序\n\n\n\n## 冗余和重复索引\n\n在 MySQL 中允许在相同的列上创建多个索引。\n\n+ 重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。\n\n+ 冗余索引和重复索引有些不同，例如创建了索引（A,B），在创建索引（A）就是冗余索引。\n\n下面的例子是重复索引：\n\n```sql\ncreate table test(\n    id int not null primary key,\n    A int not null,\n    B int not null,\n    UNIQUE(id),\n    INDEX(id)\n ) ENGINE=InnoDB;\n```\n\n> TIP：\n>\n> 1. MySQL需要单独维护重复索引和冗余索引\n> 2. 优化器在优化查询时，也需要对每个索引进行过滤，也会影响性能；\n> 3. 表中索引多，会影响对数据进行CRUD的速度；\n\n## 未使用的索引\n\n未使用的索引应当删除，最简单的办法是打开`userstates`服务器变量（默认关闭），然后让服务器正常运行一段时间，再通过`INFORMATION_SCHEMA.INDEX_STATISTICS`就可以查到每个索引的使用频率；\n\n## 索引和锁\n\n索引可以让查询锁定更少的行，如果查询从不访问那些不需要的行，就会锁定更少的行。虽然InnoDB的行锁效率很高，内存使用也少，但是锁定行的时候也会带来额外的开销，其次锁定超过需要的行会增加锁争用并减少并发性。\n\n# MySQL索引失效\n\n## 为什么会出现索引失效\n\n索引可以加快查找速度是因为，在每层兄弟节点之间索引是有序的，因此可以通过二分查找快速定位到相应的位置。假如有一些操作破坏了索引排列顺序的有序性或者不能利用索引的有序性，那么这个索引自然而然就失效了；\n\n## 哪些情况会出现索引失效\n\n+ 不符合最左匹配前缀原则导致索引失效;\n+ 对索引字段做函数操作；优化器会放弃树的搜索功能；\n+ 存在NULL值条件；\n+ 使用模糊搜索时，尽量采用后置通配符，因为走索引的过程中，其会从前去匹配索引列；\n\n## 总结\n\n索引失效是优化器不能很好的利用索引的有序性，因此在使用索引的过程中要尽量满足最左前缀匹配原则，范围查询放在最后，不使用%like、%like%等模糊查询；\n\n","slug":"mysql/mysql-index","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vn002m4f61gw3ohi08","content":"<h1 id=\"什么是索引\"><a href=\"#什么是索引\" class=\"headerlink\" title=\"什么是索引\"></a>什么是索引</h1><p>存储引擎中一种用于快速找到记录的数据结构。索引对于良好性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响愈发重要。</p>\n<h1 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h1><h2 id=\"B-Tree索引\"><a href=\"#B-Tree索引\" class=\"headerlink\" title=\"B-Tree索引\"></a>B-Tree索引</h2><p>毋庸置疑，B-Tree索引使用的是B-Tree数据结构来存储数据。索引类型在创建表的过程中是可以指定的。</p>\n<p>B-Tree意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。</p>\n<p>所以B-Tree索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引根节点开始进行搜索。</p>\n<h2 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B+Tree\"></a>B+Tree</h2><p>MySQL中最常用的索引数据结构是B+树，存在以下特点：</p>\n<ol>\n<li>所有数据记录节点按照键值大小存放在同层叶子节点上，非叶子结点只存储key的信息，这样可以大大减少每个节点存储key的数量，降低B+树的高度；</li>\n<li>叶子节点的关键字从小到大排序，左边结尾数据会保存右边节点开始数据的指针；</li>\n<li>层级更少意味着查询数据更快；</li>\n<li>查询速度稳定，所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同；</li>\n<li>天然具备排序功能，所有叶子节点就是一个有序链表，所以在查询大小取件的数据更方便，数据紧密性好，缓存的命中率也比B树高；</li>\n<li>全节点遍历更快，有利于做数据库全表扫描；</li>\n</ol>\n<h3 id=\"主键目录\"><a href=\"#主键目录\" class=\"headerlink\" title=\"主键目录\"></a>主键目录</h3><p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221123200692.png\" alt=\"image-20220221123200692\"></p>\n<ul>\n<li>MySQL是以数据页为最小单位，数据页中的数据是连续存储的；</li>\n<li>数据页的数据是按照主键排序的（若无主键由MySQL中的ROW_ID来排序）；</li>\n<li>数据页之间使用双向链表关联；</li>\n<li>数据之间使用单链表进行关联；</li>\n</ul>\n<h3 id=\"索引页\"><a href=\"#索引页\" class=\"headerlink\" title=\"索引页\"></a>索引页</h3><p>为了避免单个主键目录过大（例如1000万条记录，5000万条记录）。使用前面说的二分法查找效率就十分低下了。所以为了解决这个问题MySQL又提出了一种新的数据结构，索引页。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221124810004.png\" alt=\"image-20220221124810004\"></p>\n<p>索引页的记录是每页数据页的页号和该数据页中最小的主键记录，也就是说最小主键和数据页号不是单纯的维护在主键目录中，而是演变成了索引页，索引页和数据页类似。一张不够就分裂到下一张；</p>\n<p>因此：此时MySQL应该需要维护索引页的，MySQL也是这样设计的。也就是说MySQL同时也设计出用于维护索引页的数据结构。也称为索引页。类似下面的结构：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221125453613.png\" alt=\"image-20220221125453613\"></p>\n<p>也就是说维护索引的索引页是真正存储记录和数据页的索引页的上一层，如果想要查找就从最上层的索引页开始查找。通过二分法，很快就能定位到该条记录在索引页的具体位置上。</p>\n<h3 id=\"索引页分层\"><a href=\"#索引页分层\" class=\"headerlink\" title=\"索引页分层\"></a>索引页分层</h3><p>同样的，索引页一大也会出现类似的问题，那怎么办呢？好说。继续分裂</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221132129655.png\" alt=\"image-20220221132129655\"></p>\n<p>综上所述，MySQL的查找流程如下，假设我们要找的记录是37：</p>\n<ul>\n<li>先从最顶层的索引页开始查找，根据id = 37定位到索引页16；</li>\n<li>在索引页16中继续搜索，此时定位到id = 37在索引页3中；</li>\n<li>最终定位到数据在数据页8中，遍历数据页8中的数据链表，发现元素37；</li>\n<li>查找完毕</li>\n</ul>\n<p>最后需要注意的是：索引页 + 数据页组成的B+树称之为聚簇索引。</p>\n<blockquote>\n<p>聚簇索引是MySQL基于主键索引结构创建的</p>\n</blockquote>\n<h1 id=\"非主键索引\"><a href=\"#非主键索引\" class=\"headerlink\" title=\"非主键索引\"></a>非主键索引</h1><p>非主键索引和主键索引的引用原理一样，都是去维护一颗B+树，建立多少个索引，就会帮忙维护多少个B+树。因为索引会占用磁盘空间，不能盲目建索引；</p>\n<h2 id=\"它是怎么工作的呢？\"><a href=\"#它是怎么工作的呢？\" class=\"headerlink\" title=\"它是怎么工作的呢？\"></a>它是怎么工作的呢？</h2><p>如果对<code>name + age</code>建立索引，此时MySQL会根据name + age维护一个单独的B+树结构。数据依然存放在数据页中。类似于下图：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221133527771.png\" alt=\"image-20220221133527771\"></p>\n<p>插入数据时，MySQL会根据name进行排序，如果name一样。就根据联合索引中的age字段排序，如果还一样就根据主键字段排序。</p>\n<h1 id=\"什么是回表？\"><a href=\"#什么是回表？\" class=\"headerlink\" title=\"什么是回表？\"></a>什么是回表？</h1><p>根据非主键索引查询的结果并没有查找的字段，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完整的。</p>\n<p>针对上面的结构，假设存在如下查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> name <span class=\"hljs-keyword\">FROM</span> student <span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;xx&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>由于name字段是索引，所以查询是非常完美的；</p>\n<p>假设是这样子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> student <span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;xy&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>虽然通过name很快定位到了索引，但由于name + age并不是聚簇索引，所以B+树的数据页存放的仅仅是和自己关联的索引和主键字段，并不存在其他字段。这个时候<strong>MySQL会根据定位记录的id再次进行聚簇索引查找</strong>，这个过程就叫做回表。</p>\n<h1 id=\"索引的优缺点\"><a href=\"#索引的优缺点\" class=\"headerlink\" title=\"索引的优缺点\"></a>索引的优缺点</h1><p>说了这么多，索引总结下来有三个优点：</p>\n<ul>\n<li>大大减少服务器需要扫描的数据量；</li>\n<li>帮助服务器避免排序和临时表；</li>\n<li>将随机I/O变为顺序I/O（因为数据页本身就是有序的）；</li>\n</ul>\n<p>当然再好的工具也并不一定是解决问题的通用方案，索引也有缺点：</p>\n<ul>\n<li>对于非常小的数据表，全表扫描更加高效，不需要使用索引，对于中大型的表来说索引比较高效；</li>\n<li>对于特大型的表，应当直接区分查询需要的数据组，例如分区技术；</li>\n<li>如果表的数量特别大，可以建立一个元数据信息表，用来查询需要用到的特性；</li>\n</ul>\n<h1 id=\"高性能索引策略\"><a href=\"#高性能索引策略\" class=\"headerlink\" title=\"高性能索引策略\"></a>高性能索引策略</h1><h2 id=\"独立列\"><a href=\"#独立列\" class=\"headerlink\" title=\"独立列\"></a>独立列</h2><p>索引列不能是表达式的一部分，也不能是函数参数，比如下面这两种写法会令索引失效；</p>\n<p>因此我们必须养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧；</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> actor_id <span class=\"hljs-keyword\">FROM</span> actor <span class=\"hljs-keyword\">WHERE</span> actor_id <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">SELECT</span> ... <span class=\"hljs-keyword\">WHERE</span> TO_DAYS(<span class=\"hljs-built_in\">CURRENT_DATE</span>) <span class=\"hljs-operator\">-</span> TO_DAYS(date_col) <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">10</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"前缀索引\"><a href=\"#前缀索引\" class=\"headerlink\" title=\"前缀索引\"></a>前缀索引</h2><p>索引很长的字符列会使得索引变得大且慢，这时候可以索引开始的部分字符，这样可以大大节约索引空间，提高索引效率。</p>\n<p>诀窍在于：选择足够长的前缀以保证较高的选择性（也就是可以过滤掉绝大多数不相关的数据），同时又不能太长（节约空间）。因此前缀应该足够长，以使得前缀索引的选择性接近与索引整个列；</p>\n<h2 id=\"计算完整列选择性\"><a href=\"#计算完整列选择性\" class=\"headerlink\" title=\"计算完整列选择性\"></a>计算完整列选择性</h2><p>用查询条件的索引字段除以总记录数，通常如果前缀选择性能够接近0.031基本上就可以用了。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">3</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel3,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">4</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel4,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">5</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel5,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">6</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel6,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">7</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel7<br><span class=\"hljs-keyword\">FROM</span> city_demo;<br></code></pre></td></tr></table></figure>\n<h2 id=\"多列索引（这个看不懂，先放着）\"><a href=\"#多列索引（这个看不懂，先放着）\" class=\"headerlink\" title=\"多列索引（这个看不懂，先放着）\"></a>多列索引（这个看不懂，先放着）</h2><p>在多个列上建立独立索引大部分情况下并不能提高MySQL的查询性能，好在MySQL提供了一种“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</p>\n<h2 id=\"合适的索引列顺序\"><a href=\"#合适的索引列顺序\" class=\"headerlink\" title=\"合适的索引列顺序\"></a>合适的索引列顺序</h2><p>依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这样索引确实可以够快过滤出需要的行。</p>\n<p>还有一个方法，在你不确定怎样排列查询的效果最好时，可以跑一下查询确定在这个表中值的分布情况，并确定哪个列的选择性更高。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> payment <span class=\"hljs-keyword\">WHERE</span> staff_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">AND</span> customer_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">584</span>;<br></code></pre></td></tr></table></figure>\n<p>如法炮制，我们可以计算一下索引列选择性：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> staff_id) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> staff_id_selectivity,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> customer_Id) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> customer_id_selectivity,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>)<br>\t   <span class=\"hljs-keyword\">FROM</span> payment\\G;<br></code></pre></td></tr></table></figure>\n<p>最后数字大的那一个就是索引列的第一项；尽管关于选择性和基数的经验法则值得去研究和分析，但一定要注意WHERE字句中的排序、分组和范围条件等其他因素，这些因素可能对查询的性能会造成非常大的影响。</p>\n<h2 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h2><blockquote>\n<p>聚簇索引：找到了索引就找到了需要的数据，因此主键就是一种聚簇索引；</p>\n<p>非聚簇索引：结合上面的意思，找到了索引但没找到数据，需要根据索引的主键再次进行回表查询；</p>\n</blockquote>\n<p>聚簇索引一般是主键，前面已经介绍过了相关概念，就不再啰嗦。它也有优缺点：</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>相关数据聚合在一起，只需要从磁盘读取少数数据就可以拿到全部信息，减少磁盘I/O；</li>\n<li>数据访问快，在聚簇索引中获取数据通常比非聚簇索引查找要快；</li>\n<li>索引覆盖扫描的查询可以直接使用页节点中的主键值；</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>数据全在内存中，聚簇索引的访问顺序性就没那么重要了；</li>\n<li>插入速度严重依赖插入顺序，按照主键顺序插入是速度最快的，否则会特别慢；</li>\n<li>更新聚簇索引代价很高，会强制InnoDB将每个被更新的行移动到新的位置；</li>\n<li>当主键被更新导致需要移动行时会触发“页分裂”操作，这样会使得表占用更多的磁盘空间；</li>\n<li>导致全表扫描变慢，尤其在数据比较稀疏或者由于页分裂导致数据存储不连续的时候；</li>\n<li>二级索引可能比想象的要大，因为二级索引的叶子节点包含了引用行的主键列；</li>\n<li>二级索引访问需要两次索引查找；</li>\n</ul>\n<h3 id=\"注意的点\"><a href=\"#注意的点\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h3><p>使用InnoDB表中按主键顺序插入行，最简单的办法是使用AUTO_INCREMENT自增列。这样既可以保证数据行是按照顺序写入，对于根据主键做关联操作的性能也会更好。</p>\n<p>最好避免随机的聚簇索引（比如使用UUID来做聚簇索引会很糟糕），它会使得索引插入变得完全随机，这是最坏的情况。</p>\n<h2 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h2><p>即从非主键索引中就能查询到的记录，而不需要查询主键索引（回表操作）中的记录。避免回表的产生减少了对树的搜索次数，从而提升性能。</p>\n<p>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。二级索引（非聚簇索引）的叶子节点如果保存了行的主键值，所以如果二级主键能够覆盖查询就可以避免回表操作的产生。</p>\n<h3 id=\"如何查看使用了覆盖查询？\"><a href=\"#如何查看使用了覆盖查询？\" class=\"headerlink\" title=\"如何查看使用了覆盖查询？\"></a>如何查看使用了覆盖查询？</h3><p>使用explain关键字解释查询，如果在Extra行显示”Using index”则说明使用了覆盖索引。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>假设inventory中存在多列索引(store_id, film_id)，并且MySQL只需要这两列数据，那么此时就是使用了覆盖索引；</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">EXPLAIN <span class=\"hljs-keyword\">SELECT</span> store_id, film_id <span class=\"hljs-keyword\">FROM</span> inventory\\G;<br></code></pre></td></tr></table></figure>\n<p>假设是下面这种情况，索引就无法实现查询覆盖：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">EXPLAIN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> products <span class=\"hljs-keyword\">WHERE</span> actor <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;SEAM CARREY&#x27;</span><br>\t    <span class=\"hljs-keyword\">AND</span> title <span class=\"hljs-keyword\">like</span> <span class=\"hljs-string\">&#x27;%APOLLO%&#x27;</span>\\G<br></code></pre></td></tr></table></figure>\n<p>原因有二：</p>\n<ul>\n<li>没有任何索引能够覆盖查询，因为查询从表中选择了所有列，且没有任何索引覆盖了所有列；</li>\n<li>MySQL不能在索引中执行LIKE操作；</li>\n</ul>\n<h3 id=\"如何优化呢？\"><a href=\"#如何优化呢？\" class=\"headerlink\" title=\"如何优化呢？\"></a>如何优化呢？</h3><p>将索引列扩展覆盖至三个数据列（artist, title, prod_id），然后重写查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">EXPLAIN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span><br>\t    <span class=\"hljs-keyword\">FROM</span> products<br>\t    \t<span class=\"hljs-keyword\">JOIN</span>(<br>            \t<span class=\"hljs-keyword\">SELECT</span> prod_id<br>                <span class=\"hljs-keyword\">FROM</span> products<br>                <span class=\"hljs-keyword\">WHERE</span> actor <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;SEAM CARREY&#x27;</span><br>                <span class=\"hljs-keyword\">AND</span> title <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;%APOLLO%&#x27;</span><br>            ) <span class=\"hljs-keyword\">AS</span> t1 <span class=\"hljs-keyword\">ON</span> (t1.prod_id <span class=\"hljs-operator\">=</span> products.prod_id)\\G<br></code></pre></td></tr></table></figure>\n<p>这种方式成为延迟关联，由于延迟了对列的访问，因此在第一阶段可以使用覆盖索引，然后再根据prod_id的值在外层查询匹配获得需要的所有列值。</p>\n<h2 id=\"索引扫描排序-这个不是很理解\"><a href=\"#索引扫描排序-这个不是很理解\" class=\"headerlink\" title=\"索引扫描排序(这个不是很理解)\"></a>索引扫描排序(这个不是很理解)</h2><p>MySQL可以通过两种方式做排序：</p>\n<ul>\n<li>排序操作</li>\n<li>索引顺序扫描（EXPLAIN后的结果为“index”则是索引扫描）</li>\n</ul>\n<p>索引本身是有序的，所以索引扫描应该很快，但如果索引无法覆盖查询所需的全部列，就不得不每扫描一跳记录都回表查询一次对应的行。</p>\n<blockquote>\n<p>只有当索引列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样，MySQL才能够使用索引来对结果做排序</p>\n</blockquote>\n<h2 id=\"冗余和重复索引\"><a href=\"#冗余和重复索引\" class=\"headerlink\" title=\"冗余和重复索引\"></a>冗余和重复索引</h2><p>在 MySQL 中允许在相同的列上创建多个索引。</p>\n<ul>\n<li><p>重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。</p>\n</li>\n<li><p>冗余索引和重复索引有些不同，例如创建了索引（A,B），在创建索引（A）就是冗余索引。</p>\n</li>\n</ul>\n<p>下面的例子是重复索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test(<br>    id <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">primary</span> key,<br>    A <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>,<br>    B <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>,<br>    <span class=\"hljs-keyword\">UNIQUE</span>(id),<br>    INDEX(id)<br> ) ENGINE<span class=\"hljs-operator\">=</span>InnoDB;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>TIP：</p>\n<ol>\n<li>MySQL需要单独维护重复索引和冗余索引</li>\n<li>优化器在优化查询时，也需要对每个索引进行过滤，也会影响性能；</li>\n<li>表中索引多，会影响对数据进行CRUD的速度；</li>\n</ol>\n</blockquote>\n<h2 id=\"未使用的索引\"><a href=\"#未使用的索引\" class=\"headerlink\" title=\"未使用的索引\"></a>未使用的索引</h2><p>未使用的索引应当删除，最简单的办法是打开<code>userstates</code>服务器变量（默认关闭），然后让服务器正常运行一段时间，再通过<code>INFORMATION_SCHEMA.INDEX_STATISTICS</code>就可以查到每个索引的使用频率；</p>\n<h2 id=\"索引和锁\"><a href=\"#索引和锁\" class=\"headerlink\" title=\"索引和锁\"></a>索引和锁</h2><p>索引可以让查询锁定更少的行，如果查询从不访问那些不需要的行，就会锁定更少的行。虽然InnoDB的行锁效率很高，内存使用也少，但是锁定行的时候也会带来额外的开销，其次锁定超过需要的行会增加锁争用并减少并发性。</p>\n<h1 id=\"MySQL索引失效\"><a href=\"#MySQL索引失效\" class=\"headerlink\" title=\"MySQL索引失效\"></a>MySQL索引失效</h1><h2 id=\"为什么会出现索引失效\"><a href=\"#为什么会出现索引失效\" class=\"headerlink\" title=\"为什么会出现索引失效\"></a>为什么会出现索引失效</h2><p>索引可以加快查找速度是因为，在每层兄弟节点之间索引是有序的，因此可以通过二分查找快速定位到相应的位置。假如有一些操作破坏了索引排列顺序的有序性或者不能利用索引的有序性，那么这个索引自然而然就失效了；</p>\n<h2 id=\"哪些情况会出现索引失效\"><a href=\"#哪些情况会出现索引失效\" class=\"headerlink\" title=\"哪些情况会出现索引失效\"></a>哪些情况会出现索引失效</h2><ul>\n<li>不符合最左匹配前缀原则导致索引失效;</li>\n<li>对索引字段做函数操作；优化器会放弃树的搜索功能；</li>\n<li>存在NULL值条件；</li>\n<li>使用模糊搜索时，尽量采用后置通配符，因为走索引的过程中，其会从前去匹配索引列；</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>索引失效是优化器不能很好的利用索引的有序性，因此在使用索引的过程中要尽量满足最左前缀匹配原则，范围查询放在最后，不使用%like、%like%等模糊查询；</p>\n","site":{"data":{}},"wordcount":5494,"excerpt":"","more":"<h1 id=\"什么是索引\"><a href=\"#什么是索引\" class=\"headerlink\" title=\"什么是索引\"></a>什么是索引</h1><p>存储引擎中一种用于快速找到记录的数据结构。索引对于良好性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响愈发重要。</p>\n<h1 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h1><h2 id=\"B-Tree索引\"><a href=\"#B-Tree索引\" class=\"headerlink\" title=\"B-Tree索引\"></a>B-Tree索引</h2><p>毋庸置疑，B-Tree索引使用的是B-Tree数据结构来存储数据。索引类型在创建表的过程中是可以指定的。</p>\n<p>B-Tree意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同。</p>\n<p>所以B-Tree索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引根节点开始进行搜索。</p>\n<h2 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B+Tree\"></a>B+Tree</h2><p>MySQL中最常用的索引数据结构是B+树，存在以下特点：</p>\n<ol>\n<li>所有数据记录节点按照键值大小存放在同层叶子节点上，非叶子结点只存储key的信息，这样可以大大减少每个节点存储key的数量，降低B+树的高度；</li>\n<li>叶子节点的关键字从小到大排序，左边结尾数据会保存右边节点开始数据的指针；</li>\n<li>层级更少意味着查询数据更快；</li>\n<li>查询速度稳定，所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同；</li>\n<li>天然具备排序功能，所有叶子节点就是一个有序链表，所以在查询大小取件的数据更方便，数据紧密性好，缓存的命中率也比B树高；</li>\n<li>全节点遍历更快，有利于做数据库全表扫描；</li>\n</ol>\n<h3 id=\"主键目录\"><a href=\"#主键目录\" class=\"headerlink\" title=\"主键目录\"></a>主键目录</h3><p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221123200692.png\" alt=\"image-20220221123200692\"></p>\n<ul>\n<li>MySQL是以数据页为最小单位，数据页中的数据是连续存储的；</li>\n<li>数据页的数据是按照主键排序的（若无主键由MySQL中的ROW_ID来排序）；</li>\n<li>数据页之间使用双向链表关联；</li>\n<li>数据之间使用单链表进行关联；</li>\n</ul>\n<h3 id=\"索引页\"><a href=\"#索引页\" class=\"headerlink\" title=\"索引页\"></a>索引页</h3><p>为了避免单个主键目录过大（例如1000万条记录，5000万条记录）。使用前面说的二分法查找效率就十分低下了。所以为了解决这个问题MySQL又提出了一种新的数据结构，索引页。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221124810004.png\" alt=\"image-20220221124810004\"></p>\n<p>索引页的记录是每页数据页的页号和该数据页中最小的主键记录，也就是说最小主键和数据页号不是单纯的维护在主键目录中，而是演变成了索引页，索引页和数据页类似。一张不够就分裂到下一张；</p>\n<p>因此：此时MySQL应该需要维护索引页的，MySQL也是这样设计的。也就是说MySQL同时也设计出用于维护索引页的数据结构。也称为索引页。类似下面的结构：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221125453613.png\" alt=\"image-20220221125453613\"></p>\n<p>也就是说维护索引的索引页是真正存储记录和数据页的索引页的上一层，如果想要查找就从最上层的索引页开始查找。通过二分法，很快就能定位到该条记录在索引页的具体位置上。</p>\n<h3 id=\"索引页分层\"><a href=\"#索引页分层\" class=\"headerlink\" title=\"索引页分层\"></a>索引页分层</h3><p>同样的，索引页一大也会出现类似的问题，那怎么办呢？好说。继续分裂</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221132129655.png\" alt=\"image-20220221132129655\"></p>\n<p>综上所述，MySQL的查找流程如下，假设我们要找的记录是37：</p>\n<ul>\n<li>先从最顶层的索引页开始查找，根据id = 37定位到索引页16；</li>\n<li>在索引页16中继续搜索，此时定位到id = 37在索引页3中；</li>\n<li>最终定位到数据在数据页8中，遍历数据页8中的数据链表，发现元素37；</li>\n<li>查找完毕</li>\n</ul>\n<p>最后需要注意的是：索引页 + 数据页组成的B+树称之为聚簇索引。</p>\n<blockquote>\n<p>聚簇索引是MySQL基于主键索引结构创建的</p>\n</blockquote>\n<h1 id=\"非主键索引\"><a href=\"#非主键索引\" class=\"headerlink\" title=\"非主键索引\"></a>非主键索引</h1><p>非主键索引和主键索引的引用原理一样，都是去维护一颗B+树，建立多少个索引，就会帮忙维护多少个B+树。因为索引会占用磁盘空间，不能盲目建索引；</p>\n<h2 id=\"它是怎么工作的呢？\"><a href=\"#它是怎么工作的呢？\" class=\"headerlink\" title=\"它是怎么工作的呢？\"></a>它是怎么工作的呢？</h2><p>如果对<code>name + age</code>建立索引，此时MySQL会根据name + age维护一个单独的B+树结构。数据依然存放在数据页中。类似于下图：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220221133527771.png\" alt=\"image-20220221133527771\"></p>\n<p>插入数据时，MySQL会根据name进行排序，如果name一样。就根据联合索引中的age字段排序，如果还一样就根据主键字段排序。</p>\n<h1 id=\"什么是回表？\"><a href=\"#什么是回表？\" class=\"headerlink\" title=\"什么是回表？\"></a>什么是回表？</h1><p>根据非主键索引查询的结果并没有查找的字段，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完整的。</p>\n<p>针对上面的结构，假设存在如下查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> name <span class=\"hljs-keyword\">FROM</span> student <span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;xx&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>由于name字段是索引，所以查询是非常完美的；</p>\n<p>假设是这样子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> student <span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;xy&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>虽然通过name很快定位到了索引，但由于name + age并不是聚簇索引，所以B+树的数据页存放的仅仅是和自己关联的索引和主键字段，并不存在其他字段。这个时候<strong>MySQL会根据定位记录的id再次进行聚簇索引查找</strong>，这个过程就叫做回表。</p>\n<h1 id=\"索引的优缺点\"><a href=\"#索引的优缺点\" class=\"headerlink\" title=\"索引的优缺点\"></a>索引的优缺点</h1><p>说了这么多，索引总结下来有三个优点：</p>\n<ul>\n<li>大大减少服务器需要扫描的数据量；</li>\n<li>帮助服务器避免排序和临时表；</li>\n<li>将随机I/O变为顺序I/O（因为数据页本身就是有序的）；</li>\n</ul>\n<p>当然再好的工具也并不一定是解决问题的通用方案，索引也有缺点：</p>\n<ul>\n<li>对于非常小的数据表，全表扫描更加高效，不需要使用索引，对于中大型的表来说索引比较高效；</li>\n<li>对于特大型的表，应当直接区分查询需要的数据组，例如分区技术；</li>\n<li>如果表的数量特别大，可以建立一个元数据信息表，用来查询需要用到的特性；</li>\n</ul>\n<h1 id=\"高性能索引策略\"><a href=\"#高性能索引策略\" class=\"headerlink\" title=\"高性能索引策略\"></a>高性能索引策略</h1><h2 id=\"独立列\"><a href=\"#独立列\" class=\"headerlink\" title=\"独立列\"></a>独立列</h2><p>索引列不能是表达式的一部分，也不能是函数参数，比如下面这两种写法会令索引失效；</p>\n<p>因此我们必须养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧；</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> actor_id <span class=\"hljs-keyword\">FROM</span> actor <span class=\"hljs-keyword\">WHERE</span> actor_id <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">SELECT</span> ... <span class=\"hljs-keyword\">WHERE</span> TO_DAYS(<span class=\"hljs-built_in\">CURRENT_DATE</span>) <span class=\"hljs-operator\">-</span> TO_DAYS(date_col) <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">10</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"前缀索引\"><a href=\"#前缀索引\" class=\"headerlink\" title=\"前缀索引\"></a>前缀索引</h2><p>索引很长的字符列会使得索引变得大且慢，这时候可以索引开始的部分字符，这样可以大大节约索引空间，提高索引效率。</p>\n<p>诀窍在于：选择足够长的前缀以保证较高的选择性（也就是可以过滤掉绝大多数不相关的数据），同时又不能太长（节约空间）。因此前缀应该足够长，以使得前缀索引的选择性接近与索引整个列；</p>\n<h2 id=\"计算完整列选择性\"><a href=\"#计算完整列选择性\" class=\"headerlink\" title=\"计算完整列选择性\"></a>计算完整列选择性</h2><p>用查询条件的索引字段除以总记录数，通常如果前缀选择性能够接近0.031基本上就可以用了。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">3</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel3,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">4</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel4,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">5</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel5,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">6</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel6,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> <span class=\"hljs-keyword\">LEFT</span>(city, <span class=\"hljs-number\">7</span>)) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> sel7<br><span class=\"hljs-keyword\">FROM</span> city_demo;<br></code></pre></td></tr></table></figure>\n<h2 id=\"多列索引（这个看不懂，先放着）\"><a href=\"#多列索引（这个看不懂，先放着）\" class=\"headerlink\" title=\"多列索引（这个看不懂，先放着）\"></a>多列索引（这个看不懂，先放着）</h2><p>在多个列上建立独立索引大部分情况下并不能提高MySQL的查询性能，好在MySQL提供了一种“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</p>\n<h2 id=\"合适的索引列顺序\"><a href=\"#合适的索引列顺序\" class=\"headerlink\" title=\"合适的索引列顺序\"></a>合适的索引列顺序</h2><p>依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这样索引确实可以够快过滤出需要的行。</p>\n<p>还有一个方法，在你不确定怎样排列查询的效果最好时，可以跑一下查询确定在这个表中值的分布情况，并确定哪个列的选择性更高。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> payment <span class=\"hljs-keyword\">WHERE</span> staff_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">AND</span> customer_id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">584</span>;<br></code></pre></td></tr></table></figure>\n<p>如法炮制，我们可以计算一下索引列选择性：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> staff_id) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> staff_id_selectivity,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> customer_Id) <span class=\"hljs-operator\">/</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">AS</span> customer_id_selectivity,<br>\t   <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>)<br>\t   <span class=\"hljs-keyword\">FROM</span> payment\\G;<br></code></pre></td></tr></table></figure>\n<p>最后数字大的那一个就是索引列的第一项；尽管关于选择性和基数的经验法则值得去研究和分析，但一定要注意WHERE字句中的排序、分组和范围条件等其他因素，这些因素可能对查询的性能会造成非常大的影响。</p>\n<h2 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h2><blockquote>\n<p>聚簇索引：找到了索引就找到了需要的数据，因此主键就是一种聚簇索引；</p>\n<p>非聚簇索引：结合上面的意思，找到了索引但没找到数据，需要根据索引的主键再次进行回表查询；</p>\n</blockquote>\n<p>聚簇索引一般是主键，前面已经介绍过了相关概念，就不再啰嗦。它也有优缺点：</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>相关数据聚合在一起，只需要从磁盘读取少数数据就可以拿到全部信息，减少磁盘I/O；</li>\n<li>数据访问快，在聚簇索引中获取数据通常比非聚簇索引查找要快；</li>\n<li>索引覆盖扫描的查询可以直接使用页节点中的主键值；</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>数据全在内存中，聚簇索引的访问顺序性就没那么重要了；</li>\n<li>插入速度严重依赖插入顺序，按照主键顺序插入是速度最快的，否则会特别慢；</li>\n<li>更新聚簇索引代价很高，会强制InnoDB将每个被更新的行移动到新的位置；</li>\n<li>当主键被更新导致需要移动行时会触发“页分裂”操作，这样会使得表占用更多的磁盘空间；</li>\n<li>导致全表扫描变慢，尤其在数据比较稀疏或者由于页分裂导致数据存储不连续的时候；</li>\n<li>二级索引可能比想象的要大，因为二级索引的叶子节点包含了引用行的主键列；</li>\n<li>二级索引访问需要两次索引查找；</li>\n</ul>\n<h3 id=\"注意的点\"><a href=\"#注意的点\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h3><p>使用InnoDB表中按主键顺序插入行，最简单的办法是使用AUTO_INCREMENT自增列。这样既可以保证数据行是按照顺序写入，对于根据主键做关联操作的性能也会更好。</p>\n<p>最好避免随机的聚簇索引（比如使用UUID来做聚簇索引会很糟糕），它会使得索引插入变得完全随机，这是最坏的情况。</p>\n<h2 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h2><p>即从非主键索引中就能查询到的记录，而不需要查询主键索引（回表操作）中的记录。避免回表的产生减少了对树的搜索次数，从而提升性能。</p>\n<p>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。二级索引（非聚簇索引）的叶子节点如果保存了行的主键值，所以如果二级主键能够覆盖查询就可以避免回表操作的产生。</p>\n<h3 id=\"如何查看使用了覆盖查询？\"><a href=\"#如何查看使用了覆盖查询？\" class=\"headerlink\" title=\"如何查看使用了覆盖查询？\"></a>如何查看使用了覆盖查询？</h3><p>使用explain关键字解释查询，如果在Extra行显示”Using index”则说明使用了覆盖索引。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>假设inventory中存在多列索引(store_id, film_id)，并且MySQL只需要这两列数据，那么此时就是使用了覆盖索引；</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">EXPLAIN <span class=\"hljs-keyword\">SELECT</span> store_id, film_id <span class=\"hljs-keyword\">FROM</span> inventory\\G;<br></code></pre></td></tr></table></figure>\n<p>假设是下面这种情况，索引就无法实现查询覆盖：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">EXPLAIN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> products <span class=\"hljs-keyword\">WHERE</span> actor <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;SEAM CARREY&#x27;</span><br>\t    <span class=\"hljs-keyword\">AND</span> title <span class=\"hljs-keyword\">like</span> <span class=\"hljs-string\">&#x27;%APOLLO%&#x27;</span>\\G<br></code></pre></td></tr></table></figure>\n<p>原因有二：</p>\n<ul>\n<li>没有任何索引能够覆盖查询，因为查询从表中选择了所有列，且没有任何索引覆盖了所有列；</li>\n<li>MySQL不能在索引中执行LIKE操作；</li>\n</ul>\n<h3 id=\"如何优化呢？\"><a href=\"#如何优化呢？\" class=\"headerlink\" title=\"如何优化呢？\"></a>如何优化呢？</h3><p>将索引列扩展覆盖至三个数据列（artist, title, prod_id），然后重写查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">EXPLAIN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span><br>\t    <span class=\"hljs-keyword\">FROM</span> products<br>\t    \t<span class=\"hljs-keyword\">JOIN</span>(<br>            \t<span class=\"hljs-keyword\">SELECT</span> prod_id<br>                <span class=\"hljs-keyword\">FROM</span> products<br>                <span class=\"hljs-keyword\">WHERE</span> actor <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;SEAM CARREY&#x27;</span><br>                <span class=\"hljs-keyword\">AND</span> title <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;%APOLLO%&#x27;</span><br>            ) <span class=\"hljs-keyword\">AS</span> t1 <span class=\"hljs-keyword\">ON</span> (t1.prod_id <span class=\"hljs-operator\">=</span> products.prod_id)\\G<br></code></pre></td></tr></table></figure>\n<p>这种方式成为延迟关联，由于延迟了对列的访问，因此在第一阶段可以使用覆盖索引，然后再根据prod_id的值在外层查询匹配获得需要的所有列值。</p>\n<h2 id=\"索引扫描排序-这个不是很理解\"><a href=\"#索引扫描排序-这个不是很理解\" class=\"headerlink\" title=\"索引扫描排序(这个不是很理解)\"></a>索引扫描排序(这个不是很理解)</h2><p>MySQL可以通过两种方式做排序：</p>\n<ul>\n<li>排序操作</li>\n<li>索引顺序扫描（EXPLAIN后的结果为“index”则是索引扫描）</li>\n</ul>\n<p>索引本身是有序的，所以索引扫描应该很快，但如果索引无法覆盖查询所需的全部列，就不得不每扫描一跳记录都回表查询一次对应的行。</p>\n<blockquote>\n<p>只有当索引列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样，MySQL才能够使用索引来对结果做排序</p>\n</blockquote>\n<h2 id=\"冗余和重复索引\"><a href=\"#冗余和重复索引\" class=\"headerlink\" title=\"冗余和重复索引\"></a>冗余和重复索引</h2><p>在 MySQL 中允许在相同的列上创建多个索引。</p>\n<ul>\n<li><p>重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。</p>\n</li>\n<li><p>冗余索引和重复索引有些不同，例如创建了索引（A,B），在创建索引（A）就是冗余索引。</p>\n</li>\n</ul>\n<p>下面的例子是重复索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> test(<br>    id <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">primary</span> key,<br>    A <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>,<br>    B <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span>,<br>    <span class=\"hljs-keyword\">UNIQUE</span>(id),<br>    INDEX(id)<br> ) ENGINE<span class=\"hljs-operator\">=</span>InnoDB;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>TIP：</p>\n<ol>\n<li>MySQL需要单独维护重复索引和冗余索引</li>\n<li>优化器在优化查询时，也需要对每个索引进行过滤，也会影响性能；</li>\n<li>表中索引多，会影响对数据进行CRUD的速度；</li>\n</ol>\n</blockquote>\n<h2 id=\"未使用的索引\"><a href=\"#未使用的索引\" class=\"headerlink\" title=\"未使用的索引\"></a>未使用的索引</h2><p>未使用的索引应当删除，最简单的办法是打开<code>userstates</code>服务器变量（默认关闭），然后让服务器正常运行一段时间，再通过<code>INFORMATION_SCHEMA.INDEX_STATISTICS</code>就可以查到每个索引的使用频率；</p>\n<h2 id=\"索引和锁\"><a href=\"#索引和锁\" class=\"headerlink\" title=\"索引和锁\"></a>索引和锁</h2><p>索引可以让查询锁定更少的行，如果查询从不访问那些不需要的行，就会锁定更少的行。虽然InnoDB的行锁效率很高，内存使用也少，但是锁定行的时候也会带来额外的开销，其次锁定超过需要的行会增加锁争用并减少并发性。</p>\n<h1 id=\"MySQL索引失效\"><a href=\"#MySQL索引失效\" class=\"headerlink\" title=\"MySQL索引失效\"></a>MySQL索引失效</h1><h2 id=\"为什么会出现索引失效\"><a href=\"#为什么会出现索引失效\" class=\"headerlink\" title=\"为什么会出现索引失效\"></a>为什么会出现索引失效</h2><p>索引可以加快查找速度是因为，在每层兄弟节点之间索引是有序的，因此可以通过二分查找快速定位到相应的位置。假如有一些操作破坏了索引排列顺序的有序性或者不能利用索引的有序性，那么这个索引自然而然就失效了；</p>\n<h2 id=\"哪些情况会出现索引失效\"><a href=\"#哪些情况会出现索引失效\" class=\"headerlink\" title=\"哪些情况会出现索引失效\"></a>哪些情况会出现索引失效</h2><ul>\n<li>不符合最左匹配前缀原则导致索引失效;</li>\n<li>对索引字段做函数操作；优化器会放弃树的搜索功能；</li>\n<li>存在NULL值条件；</li>\n<li>使用模糊搜索时，尽量采用后置通配符，因为走索引的过程中，其会从前去匹配索引列；</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>索引失效是优化器不能很好的利用索引的有序性，因此在使用索引的过程中要尽量满足最左前缀匹配原则，范围查询放在最后，不使用%like、%like%等模糊查询；</p>\n"},{"title":"谈谈Spring AOP","date":"2022-03-04T12:55:35.000Z","updated":"2022-03-04T12:55:35.000Z","_content":"\n# 什么是Spring AOP\n\n## 你可能遇到过这样的需求\n\n假设要你统计一个方法执行的耗时情况，你会怎么做？\n\n```java\npublic void runTask() {\n    doSomething();\n}\n```\n\n相信这个肯定难不倒你，那还不简单，在这个方法的执行前后两个时间戳，方法执行结束计算一下不是就能知道耗时了吗？\n\n```java\npublic void runTask() {\n    long start = Syste.currentTimeMills();\n    doSomething();\n    System.out.println(\"方法执行耗时：\" + System.currentTimeMills() - start / 1000 + \" s\");\n}\n```\n\n但是弊端也非常明显，直接将非业务功能和业务功能耦合在一起，成本非常大；稍有不慎就会出错；那么解决这个问题的方法是什么呢？就是AOP（面向切面编程）；\n\n> 不用AOP，用你想到的设计模式怎么解决呢？\n>\n> + 将原对象通过组合包装到一个代理对象中；\n> + 生成一个代理对象去包裹我们需要包含非业务的代码；\n> + 在新创建的方法中再调用具体目标对象的方法；\n\n\n\n## AOP的基本概念\n\n### 定义\n\n面向切面编程，是一种编程思想。用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装多个模块并命名为切面；面向切面编程使用的是动态代理实现的；\n\n> 我们常用的有：打印日志、权限认证等场景；并且AOP需要解决下面几个问题：\n>\n> + 在什么地方进行切面操作\n> + 需要知道切面操作的具体内容\n> + 如果存在多个切面，怎样定义执行先后顺序\n\n\n\n### 基本术语\n\nAOP下包含几个重要的概念，需要理解：\n\n+ **JointPoint（连接点）：**具体的切面点，可以是字段、方法、Spring具体表现为PointCut（切入点），仅作用在方法上；\n+ **Advice（通知）：**在连接点进行的具体操作，如何进行处理增强，分为前置，后置，异常，最终和环绕；\n+ **目标对象：**被AOP框架进行增强处理的对象，也被称为被增强对象；\n+ **AOP代理：**AOP框架创建的代理对象，代理就是对被目标对象的加强，Spring中的代理既可以是JDK动态代理，也可以是cglib动态代理；\n+ **Weaving：**将增强处理添加到目标对象中，创建一个被增强的对象过程；\n\n> 一句话总结：在目标对象（target object）上的某些方法（jointpoint）添加不同种类的操作（通知、增强处理），最后通过某些方法（weaving、织入）实现一个新的代理目标对象；\n\n\n\n# 怎样实现Spring AOP\n\nSpring AOP的使用非常简单，我们以Spring框架为例：\n\n## 引入依赖\n\n比较关键的两个依赖是：\n\n+ spring-aop\n+ spring-aspects\n\n```groovy\nplugins {\n    id 'java'\n}\n\ngroup 'org.example'\nversion '1.0-SNAPSHOT'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework:spring-core:5.3.16'\n    implementation 'org.springframework:spring-beans:5.3.16'\n    implementation 'org.springframework:spring-tx:5.3.16'\n    implementation 'org.springframework:spring-context:5.3.16'\n    implementation 'org.springframework:spring-aop:5.3.16'\n    implementation 'org.springframework:spring-aspects:5.3.16'\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'\n}\n\ntest {\n    useJUnitPlatform()\n}\n```\n\n## 创建目标Bean（被增强对象）\n\n```java\n@Component\npublic class TestBean {\n\n    private String str = \"Testing\";\n\n    public String getStr() {\n        return str;\n    }\n\n    public void setStr(String str) {\n        this.str = str;\n    }\n}\n```\n\n## 创建切面（Aspect）\n\n这里需要注意几部分：\n\n+ 切面要交给Spring容器管理，然后使用`@Aspect`注解来修饰；\n+ 我们定义一个方法来存放切点，并且用`@Pointcut`注解修饰；\n+ 创建Advice方法，也就是我们在被增强的对象执行前，后会做什么事情；这个就不再描述了；\n\n```java\n@Aspect\n@Component\npublic class LogAspect {\n\n    // 这里的意思是当前包下的所有对象中的方法都会被增强\n    @Pointcut(\"execution(* com.hhp.spring..*(..))\")\n    private void allMethod() {}\n\n    // 我们在这里获取被增强的类名和方法名，执行打印输出\n    @Before(\"allMethod()\")\n    public void before(JoinPoint joinPoint) {\n        String className = joinPoint.getTarget().getClass().getName();\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(className + \".\" + methodName + \"()开始执行...\");\n    }\n\n    // 此处同上，不再赘述\n    @After(\"allMethod()\")\n    public void after(JoinPoint joinPoint) {\n        String className = joinPoint.getTarget().getClass().getName();\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(className + \".\" + methodName + \"()执行结束...\");\n    }\n}\n```\n\n## 运行效果\n\n我们编写一个启动类看看效果\n\n```java\npublic class Application {\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        TestBean testBean = (TestBean) ctx.getBean(\"testBean\");\n        System.out.println(testBean.getStr());\n    }\n}\n```\n\n控制台输出结果如下：\n\n```shell\ncom.hhp.spring.beans.TestBean.getStr()开始执行...\ncom.hhp.spring.beans.TestBean.getStr()执行结束...\nTesting\n```\n\n\n\n# 透过底层代码看Spring AOP\n\n## 它是怎么工作的？\n\n我们透过源代码来看看在配置类上添加`@EnableAspectJAutoProxy`注解就可以实现AOP功能，Spring在背后帮我们做了什么工作。\n\n```java\n// Registers an AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry as appropriate based on a given @EnableAspectJAutoProxy annotation.\nclass AspectJAutoProxyRegister implements ImportBeanDefinitionRegistrar {\n    \t@Override\n\tpublic void registerBeanDefinitions(\n\t\t\tAnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n\t\tAopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);\n\n\t\tAnnotationAttributes enableAspectJAutoProxy =\n\t\t\t\tAnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);\n\t}\n}\n```\n\n**英文注释的意思是：**通过指定注释`@EnableAspectJAutoProxy`并根据当前的`BeanDefinitionRegistry`来注册一个`AnnotationAwareAspectJAutoProxyCreator`；所以我们在加了注解后就可以启用ProxyCreator去为我们创建AOP代理对象；\n\n我们再去看`AnnotationAwareAspectJAutoProxyCreator`这个类它做了哪些工作：\n\n```java\npublic class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator {\n    @Override\n    protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n        // 调用父类的方法初始化Bean工厂\n        super.initBeanFactory(beanFactory);\n    }\n}\n```\n\n追踪代码到`AbstractAutowireCapableBeanFactory`如下：\n\n```java\npublic abstract class AbstractAutowireCapableBeanFactory {\n    \n    protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 执行beanPostProcessorsBeforeInitialization\n            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n            try {\n                // 初始化Bean\n                invokeInitMethod(beanName, wrappedBean, mbd);\n            }\n            \n            if (mbd == null || !mbd.isSynthetic()) {\n                // 执行beanPostProcessorsAfterInitialization\n                wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n            }\n            return wrappedBean;\n        }\n    }\n}\n```\n\n我们看下通知是如何创建的，继续追踪源代码\n\n```java\npublic abstract class AbstractAutoProxyCreator {\n    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n        // 省略其他不相关的代码...\n        // Create proxy if we have advice\n        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n        if (specificInterceptors != DO_NOT_PROXY) {\n            this.advisedBeans.put(cacheKey, Boolean.TRUE);\n            Object proxy = createProxy(\n\t\t\t\t\tbean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n\t\t\tthis.proxyTypes.put(cacheKey, proxy.getClass());\n\t\t\treturn proxy;\n        }\n        \n        this.advisedBeans.put(cackeKey, Boolean.FALSE);\n        return bean;\n    }\n}\n```\n\n创建代理的源码如下：\n\n```java\npublic abstract class AbstractAdvisorAutoProxyCreator {\n    @Override\n\t@Nullable\n\tprotected Object[] getAdvicesAndAdvisorsForBean(\n\t\t\tClass<?> beanClass, String beanName, @Nullable TargetSource targetSource) {\n\n\t\tList<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n\t\tif (advisors.isEmpty()) {\n\t\t\treturn DO_NOT_PROXY;\n\t\t}\n\t\treturn advisors.toArray();\n\t}\n}\n```\n\n# 总结\n\n我们用一张图再来回顾一下Bean的生命周期\n\n![image-20220306123615086](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220306123615086.png)\n\n用自己的话概括一下就是：\n\n1. 生成并且注册BeanDefinition对象；\n2. 初始化IoC容器并且加载BeanDefinition对象；\n3. 寻找对应的BeanFactory去实例化Bean;（实例化阶段）\n   1. 使用简单工厂 + 反射去推断构造函数进行实例化\n4. 执行Bean的属性赋值动作\n   1. 调用XXXAware接口回调方法；\n   2. 调用初始化生命周期的三种回调方法；\n   3. 假如Bean实现了AOP，会去创建动态代理对象；\n5. 销毁Bean\n   1. 销毁Bean的对象实例，仅在Spring容器关闭的过程中执行销毁；\n","source":"_posts/spring/spring-aop.md","raw":"---\ntitle: 谈谈Spring AOP\ndate: 2022-03-04 20:55:35\nupdated: 2022-03-04 20:55:35\ntags: Spring框架\ncategories: Spring\n---\n\n# 什么是Spring AOP\n\n## 你可能遇到过这样的需求\n\n假设要你统计一个方法执行的耗时情况，你会怎么做？\n\n```java\npublic void runTask() {\n    doSomething();\n}\n```\n\n相信这个肯定难不倒你，那还不简单，在这个方法的执行前后两个时间戳，方法执行结束计算一下不是就能知道耗时了吗？\n\n```java\npublic void runTask() {\n    long start = Syste.currentTimeMills();\n    doSomething();\n    System.out.println(\"方法执行耗时：\" + System.currentTimeMills() - start / 1000 + \" s\");\n}\n```\n\n但是弊端也非常明显，直接将非业务功能和业务功能耦合在一起，成本非常大；稍有不慎就会出错；那么解决这个问题的方法是什么呢？就是AOP（面向切面编程）；\n\n> 不用AOP，用你想到的设计模式怎么解决呢？\n>\n> + 将原对象通过组合包装到一个代理对象中；\n> + 生成一个代理对象去包裹我们需要包含非业务的代码；\n> + 在新创建的方法中再调用具体目标对象的方法；\n\n\n\n## AOP的基本概念\n\n### 定义\n\n面向切面编程，是一种编程思想。用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装多个模块并命名为切面；面向切面编程使用的是动态代理实现的；\n\n> 我们常用的有：打印日志、权限认证等场景；并且AOP需要解决下面几个问题：\n>\n> + 在什么地方进行切面操作\n> + 需要知道切面操作的具体内容\n> + 如果存在多个切面，怎样定义执行先后顺序\n\n\n\n### 基本术语\n\nAOP下包含几个重要的概念，需要理解：\n\n+ **JointPoint（连接点）：**具体的切面点，可以是字段、方法、Spring具体表现为PointCut（切入点），仅作用在方法上；\n+ **Advice（通知）：**在连接点进行的具体操作，如何进行处理增强，分为前置，后置，异常，最终和环绕；\n+ **目标对象：**被AOP框架进行增强处理的对象，也被称为被增强对象；\n+ **AOP代理：**AOP框架创建的代理对象，代理就是对被目标对象的加强，Spring中的代理既可以是JDK动态代理，也可以是cglib动态代理；\n+ **Weaving：**将增强处理添加到目标对象中，创建一个被增强的对象过程；\n\n> 一句话总结：在目标对象（target object）上的某些方法（jointpoint）添加不同种类的操作（通知、增强处理），最后通过某些方法（weaving、织入）实现一个新的代理目标对象；\n\n\n\n# 怎样实现Spring AOP\n\nSpring AOP的使用非常简单，我们以Spring框架为例：\n\n## 引入依赖\n\n比较关键的两个依赖是：\n\n+ spring-aop\n+ spring-aspects\n\n```groovy\nplugins {\n    id 'java'\n}\n\ngroup 'org.example'\nversion '1.0-SNAPSHOT'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework:spring-core:5.3.16'\n    implementation 'org.springframework:spring-beans:5.3.16'\n    implementation 'org.springframework:spring-tx:5.3.16'\n    implementation 'org.springframework:spring-context:5.3.16'\n    implementation 'org.springframework:spring-aop:5.3.16'\n    implementation 'org.springframework:spring-aspects:5.3.16'\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'\n}\n\ntest {\n    useJUnitPlatform()\n}\n```\n\n## 创建目标Bean（被增强对象）\n\n```java\n@Component\npublic class TestBean {\n\n    private String str = \"Testing\";\n\n    public String getStr() {\n        return str;\n    }\n\n    public void setStr(String str) {\n        this.str = str;\n    }\n}\n```\n\n## 创建切面（Aspect）\n\n这里需要注意几部分：\n\n+ 切面要交给Spring容器管理，然后使用`@Aspect`注解来修饰；\n+ 我们定义一个方法来存放切点，并且用`@Pointcut`注解修饰；\n+ 创建Advice方法，也就是我们在被增强的对象执行前，后会做什么事情；这个就不再描述了；\n\n```java\n@Aspect\n@Component\npublic class LogAspect {\n\n    // 这里的意思是当前包下的所有对象中的方法都会被增强\n    @Pointcut(\"execution(* com.hhp.spring..*(..))\")\n    private void allMethod() {}\n\n    // 我们在这里获取被增强的类名和方法名，执行打印输出\n    @Before(\"allMethod()\")\n    public void before(JoinPoint joinPoint) {\n        String className = joinPoint.getTarget().getClass().getName();\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(className + \".\" + methodName + \"()开始执行...\");\n    }\n\n    // 此处同上，不再赘述\n    @After(\"allMethod()\")\n    public void after(JoinPoint joinPoint) {\n        String className = joinPoint.getTarget().getClass().getName();\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(className + \".\" + methodName + \"()执行结束...\");\n    }\n}\n```\n\n## 运行效果\n\n我们编写一个启动类看看效果\n\n```java\npublic class Application {\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        TestBean testBean = (TestBean) ctx.getBean(\"testBean\");\n        System.out.println(testBean.getStr());\n    }\n}\n```\n\n控制台输出结果如下：\n\n```shell\ncom.hhp.spring.beans.TestBean.getStr()开始执行...\ncom.hhp.spring.beans.TestBean.getStr()执行结束...\nTesting\n```\n\n\n\n# 透过底层代码看Spring AOP\n\n## 它是怎么工作的？\n\n我们透过源代码来看看在配置类上添加`@EnableAspectJAutoProxy`注解就可以实现AOP功能，Spring在背后帮我们做了什么工作。\n\n```java\n// Registers an AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry as appropriate based on a given @EnableAspectJAutoProxy annotation.\nclass AspectJAutoProxyRegister implements ImportBeanDefinitionRegistrar {\n    \t@Override\n\tpublic void registerBeanDefinitions(\n\t\t\tAnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n\t\tAopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);\n\n\t\tAnnotationAttributes enableAspectJAutoProxy =\n\t\t\t\tAnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);\n\t}\n}\n```\n\n**英文注释的意思是：**通过指定注释`@EnableAspectJAutoProxy`并根据当前的`BeanDefinitionRegistry`来注册一个`AnnotationAwareAspectJAutoProxyCreator`；所以我们在加了注解后就可以启用ProxyCreator去为我们创建AOP代理对象；\n\n我们再去看`AnnotationAwareAspectJAutoProxyCreator`这个类它做了哪些工作：\n\n```java\npublic class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator {\n    @Override\n    protected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n        // 调用父类的方法初始化Bean工厂\n        super.initBeanFactory(beanFactory);\n    }\n}\n```\n\n追踪代码到`AbstractAutowireCapableBeanFactory`如下：\n\n```java\npublic abstract class AbstractAutowireCapableBeanFactory {\n    \n    protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n        Object wrappedBean = bean;\n        if (mbd == null || !mbd.isSynthetic()) {\n            // 执行beanPostProcessorsBeforeInitialization\n            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n            try {\n                // 初始化Bean\n                invokeInitMethod(beanName, wrappedBean, mbd);\n            }\n            \n            if (mbd == null || !mbd.isSynthetic()) {\n                // 执行beanPostProcessorsAfterInitialization\n                wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n            }\n            return wrappedBean;\n        }\n    }\n}\n```\n\n我们看下通知是如何创建的，继续追踪源代码\n\n```java\npublic abstract class AbstractAutoProxyCreator {\n    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n        // 省略其他不相关的代码...\n        // Create proxy if we have advice\n        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n        if (specificInterceptors != DO_NOT_PROXY) {\n            this.advisedBeans.put(cacheKey, Boolean.TRUE);\n            Object proxy = createProxy(\n\t\t\t\t\tbean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n\t\t\tthis.proxyTypes.put(cacheKey, proxy.getClass());\n\t\t\treturn proxy;\n        }\n        \n        this.advisedBeans.put(cackeKey, Boolean.FALSE);\n        return bean;\n    }\n}\n```\n\n创建代理的源码如下：\n\n```java\npublic abstract class AbstractAdvisorAutoProxyCreator {\n    @Override\n\t@Nullable\n\tprotected Object[] getAdvicesAndAdvisorsForBean(\n\t\t\tClass<?> beanClass, String beanName, @Nullable TargetSource targetSource) {\n\n\t\tList<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n\t\tif (advisors.isEmpty()) {\n\t\t\treturn DO_NOT_PROXY;\n\t\t}\n\t\treturn advisors.toArray();\n\t}\n}\n```\n\n# 总结\n\n我们用一张图再来回顾一下Bean的生命周期\n\n![image-20220306123615086](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220306123615086.png)\n\n用自己的话概括一下就是：\n\n1. 生成并且注册BeanDefinition对象；\n2. 初始化IoC容器并且加载BeanDefinition对象；\n3. 寻找对应的BeanFactory去实例化Bean;（实例化阶段）\n   1. 使用简单工厂 + 反射去推断构造函数进行实例化\n4. 执行Bean的属性赋值动作\n   1. 调用XXXAware接口回调方法；\n   2. 调用初始化生命周期的三种回调方法；\n   3. 假如Bean实现了AOP，会去创建动态代理对象；\n5. 销毁Bean\n   1. 销毁Bean的对象实例，仅在Spring容器关闭的过程中执行销毁；\n","slug":"spring/spring-aop","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vo002p4f61c8772xrn","content":"<h1 id=\"什么是Spring-AOP\"><a href=\"#什么是Spring-AOP\" class=\"headerlink\" title=\"什么是Spring AOP\"></a>什么是Spring AOP</h1><h2 id=\"你可能遇到过这样的需求\"><a href=\"#你可能遇到过这样的需求\" class=\"headerlink\" title=\"你可能遇到过这样的需求\"></a>你可能遇到过这样的需求</h2><p>假设要你统计一个方法执行的耗时情况，你会怎么做？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">runTask</span><span class=\"hljs-params\">()</span> &#123;<br>    doSomething();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>相信这个肯定难不倒你，那还不简单，在这个方法的执行前后两个时间戳，方法执行结束计算一下不是就能知道耗时了吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">runTask</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> Syste.currentTimeMills();<br>    doSomething();<br>    System.out.println(<span class=\"hljs-string\">&quot;方法执行耗时：&quot;</span> + System.currentTimeMills() - start / <span class=\"hljs-number\">1000</span> + <span class=\"hljs-string\">&quot; s&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>但是弊端也非常明显，直接将非业务功能和业务功能耦合在一起，成本非常大；稍有不慎就会出错；那么解决这个问题的方法是什么呢？就是AOP（面向切面编程）；</p>\n<blockquote>\n<p>不用AOP，用你想到的设计模式怎么解决呢？</p>\n<ul>\n<li>将原对象通过组合包装到一个代理对象中；</li>\n<li>生成一个代理对象去包裹我们需要包含非业务的代码；</li>\n<li>在新创建的方法中再调用具体目标对象的方法；</li>\n</ul>\n</blockquote>\n<h2 id=\"AOP的基本概念\"><a href=\"#AOP的基本概念\" class=\"headerlink\" title=\"AOP的基本概念\"></a>AOP的基本概念</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>面向切面编程，是一种编程思想。用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装多个模块并命名为切面；面向切面编程使用的是动态代理实现的；</p>\n<blockquote>\n<p>我们常用的有：打印日志、权限认证等场景；并且AOP需要解决下面几个问题：</p>\n<ul>\n<li>在什么地方进行切面操作</li>\n<li>需要知道切面操作的具体内容</li>\n<li>如果存在多个切面，怎样定义执行先后顺序</li>\n</ul>\n</blockquote>\n<h3 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h3><p>AOP下包含几个重要的概念，需要理解：</p>\n<ul>\n<li><strong>JointPoint（连接点）：</strong>具体的切面点，可以是字段、方法、Spring具体表现为PointCut（切入点），仅作用在方法上；</li>\n<li><strong>Advice（通知）：</strong>在连接点进行的具体操作，如何进行处理增强，分为前置，后置，异常，最终和环绕；</li>\n<li><strong>目标对象：</strong>被AOP框架进行增强处理的对象，也被称为被增强对象；</li>\n<li><strong>AOP代理：</strong>AOP框架创建的代理对象，代理就是对被目标对象的加强，Spring中的代理既可以是JDK动态代理，也可以是cglib动态代理；</li>\n<li><strong>Weaving：</strong>将增强处理添加到目标对象中，创建一个被增强的对象过程；</li>\n</ul>\n<blockquote>\n<p>一句话总结：在目标对象（target object）上的某些方法（jointpoint）添加不同种类的操作（通知、增强处理），最后通过某些方法（weaving、织入）实现一个新的代理目标对象；</p>\n</blockquote>\n<h1 id=\"怎样实现Spring-AOP\"><a href=\"#怎样实现Spring-AOP\" class=\"headerlink\" title=\"怎样实现Spring AOP\"></a>怎样实现Spring AOP</h1><p>Spring AOP的使用非常简单，我们以Spring框架为例：</p>\n<h2 id=\"引入依赖\"><a href=\"#引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a>引入依赖</h2><p>比较关键的两个依赖是：</p>\n<ul>\n<li>spring-aop</li>\n<li>spring-aspects</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group <span class=\"hljs-string\">&#x27;org.example&#x27;</span><br>version <span class=\"hljs-string\">&#x27;1.0-SNAPSHOT&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-core:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-beans:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-tx:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-context:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-aop:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-aspects:5.3.16&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.junit.jupiter:junit-jupiter-api:5.6.0&#x27;</span><br>    testRuntimeOnly <span class=\"hljs-string\">&#x27;org.junit.jupiter:junit-jupiter-engine&#x27;</span><br>&#125;<br><br>test &#123;<br>    useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建目标Bean（被增强对象）\"><a href=\"#创建目标Bean（被增强对象）\" class=\"headerlink\" title=\"创建目标Bean（被增强对象）\"></a>创建目标Bean（被增强对象）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TestBean</span> &#123;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Testing&quot;</span>;<br><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getStr</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> str;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setStr</span><span class=\"hljs-params\">(String str)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.str = str;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建切面（Aspect）\"><a href=\"#创建切面（Aspect）\" class=\"headerlink\" title=\"创建切面（Aspect）\"></a>创建切面（Aspect）</h2><p>这里需要注意几部分：</p>\n<ul>\n<li>切面要交给Spring容器管理，然后使用<code>@Aspect</code>注解来修饰；</li>\n<li>我们定义一个方法来存放切点，并且用<code>@Pointcut</code>注解修饰；</li>\n<li>创建Advice方法，也就是我们在被增强的对象执行前，后会做什么事情；这个就不再描述了；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Aspect</span><br><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LogAspect</span> &#123;<br><br>    <span class=\"hljs-comment\">// 这里的意思是当前包下的所有对象中的方法都会被增强</span><br>    <span class=\"hljs-meta\">@Pointcut(&quot;execution(* com.hhp.spring..*(..))&quot;)</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">allMethod</span><span class=\"hljs-params\">()</span> &#123;&#125;<br><br>    <span class=\"hljs-comment\">// 我们在这里获取被增强的类名和方法名，执行打印输出</span><br>    <span class=\"hljs-meta\">@Before(&quot;allMethod()&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">before</span><span class=\"hljs-params\">(JoinPoint joinPoint)</span> &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> joinPoint.getTarget().getClass().getName();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">methodName</span> <span class=\"hljs-operator\">=</span> joinPoint.getSignature().getName();<br>        System.out.println(className + <span class=\"hljs-string\">&quot;.&quot;</span> + methodName + <span class=\"hljs-string\">&quot;()开始执行...&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 此处同上，不再赘述</span><br>    <span class=\"hljs-meta\">@After(&quot;allMethod()&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">after</span><span class=\"hljs-params\">(JoinPoint joinPoint)</span> &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> joinPoint.getTarget().getClass().getName();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">methodName</span> <span class=\"hljs-operator\">=</span> joinPoint.getSignature().getName();<br>        System.out.println(className + <span class=\"hljs-string\">&quot;.&quot;</span> + methodName + <span class=\"hljs-string\">&quot;()执行结束...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"运行效果\"><a href=\"#运行效果\" class=\"headerlink\" title=\"运行效果\"></a>运行效果</h2><p>我们编写一个启动类看看效果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Application</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ApplicationContext</span> <span class=\"hljs-variable\">ctx</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>        <span class=\"hljs-type\">TestBean</span> <span class=\"hljs-variable\">testBean</span> <span class=\"hljs-operator\">=</span> (TestBean) ctx.getBean(<span class=\"hljs-string\">&quot;testBean&quot;</span>);<br>        System.out.println(testBean.getStr());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>控制台输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">com.hhp.spring.beans.TestBean.getStr()开始执行...<br>com.hhp.spring.beans.TestBean.getStr()执行结束...<br>Testing<br></code></pre></td></tr></table></figure>\n<h1 id=\"透过底层代码看Spring-AOP\"><a href=\"#透过底层代码看Spring-AOP\" class=\"headerlink\" title=\"透过底层代码看Spring AOP\"></a>透过底层代码看Spring AOP</h1><h2 id=\"它是怎么工作的？\"><a href=\"#它是怎么工作的？\" class=\"headerlink\" title=\"它是怎么工作的？\"></a>它是怎么工作的？</h2><p>我们透过源代码来看看在配置类上添加<code>@EnableAspectJAutoProxy</code>注解就可以实现AOP功能，Spring在背后帮我们做了什么工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// Registers an AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry as appropriate based on a given @EnableAspectJAutoProxy annotation.</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AspectJAutoProxyRegister</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">ImportBeanDefinitionRegistrar</span> &#123;<br>    \t<span class=\"hljs-meta\">@Override</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">registerBeanDefinitions</span><span class=\"hljs-params\">(</span><br><span class=\"hljs-params\">\t\t\tAnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br><br>\t\tAopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br><br>\t\t<span class=\"hljs-type\">AnnotationAttributes</span> <span class=\"hljs-variable\">enableAspectJAutoProxy</span> <span class=\"hljs-operator\">=</span><br>\t\t\t\tAnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>英文注释的意思是：</strong>通过指定注释<code>@EnableAspectJAutoProxy</code>并根据当前的<code>BeanDefinitionRegistry</code>来注册一个<code>AnnotationAwareAspectJAutoProxyCreator</code>；所以我们在加了注解后就可以启用ProxyCreator去为我们创建AOP代理对象；</p>\n<p>我们再去看<code>AnnotationAwareAspectJAutoProxyCreator</code>这个类它做了哪些工作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnnotationAwareAspectJAutoProxyCreator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AspectJAwareAdvisorAutoProxyCreator</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>        <span class=\"hljs-comment\">// 调用父类的方法初始化Bean工厂</span><br>        <span class=\"hljs-built_in\">super</span>.initBeanFactory(beanFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>追踪代码到<code>AbstractAutowireCapableBeanFactory</code>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowireCapableBeanFactory</span> &#123;<br>    <br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">initializeBean</span><span class=\"hljs-params\">(String beanName, Object bean, <span class=\"hljs-meta\">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">wrappedBean</span> <span class=\"hljs-operator\">=</span> bean;<br>        <span class=\"hljs-keyword\">if</span> (mbd == <span class=\"hljs-literal\">null</span> || !mbd.isSynthetic()) &#123;<br>            <span class=\"hljs-comment\">// 执行beanPostProcessorsBeforeInitialization</span><br>            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-comment\">// 初始化Bean</span><br>                invokeInitMethod(beanName, wrappedBean, mbd);<br>            &#125;<br>            <br>            <span class=\"hljs-keyword\">if</span> (mbd == <span class=\"hljs-literal\">null</span> || !mbd.isSynthetic()) &#123;<br>                <span class=\"hljs-comment\">// 执行beanPostProcessorsAfterInitialization</span><br>                wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> wrappedBean;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们看下通知是如何创建的，继续追踪源代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutoProxyCreator</span> &#123;<br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">wrapIfNecessary</span><span class=\"hljs-params\">(Object bean, String beanName, Object cacheKey)</span> &#123;<br>        <span class=\"hljs-comment\">// 省略其他不相关的代码...</span><br>        <span class=\"hljs-comment\">// Create proxy if we have advice</span><br>        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class=\"hljs-literal\">null</span>);<br>        <span class=\"hljs-keyword\">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<br>            <span class=\"hljs-built_in\">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">proxy</span> <span class=\"hljs-operator\">=</span> createProxy(<br>\t\t\t\t\tbean.getClass(), beanName, specificInterceptors, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SingletonTargetSource</span>(bean));<br>\t\t\t<span class=\"hljs-built_in\">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>\t\t\t<span class=\"hljs-keyword\">return</span> proxy;<br>        &#125;<br>        <br>        <span class=\"hljs-built_in\">this</span>.advisedBeans.put(cackeKey, Boolean.FALSE);<br>        <span class=\"hljs-keyword\">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>创建代理的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAdvisorAutoProxyCreator</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>\t<span class=\"hljs-meta\">@Nullable</span><br>\t<span class=\"hljs-keyword\">protected</span> Object[] getAdvicesAndAdvisorsForBean(<br>\t\t\tClass&lt;?&gt; beanClass, String beanName, <span class=\"hljs-meta\">@Nullable</span> TargetSource targetSource) &#123;<br><br>\t\tList&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);<br>\t\t<span class=\"hljs-keyword\">if</span> (advisors.isEmpty()) &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> DO_NOT_PROXY;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> advisors.toArray();<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我们用一张图再来回顾一下Bean的生命周期</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220306123615086.png\" alt=\"image-20220306123615086\"></p>\n<p>用自己的话概括一下就是：</p>\n<ol>\n<li>生成并且注册BeanDefinition对象；</li>\n<li>初始化IoC容器并且加载BeanDefinition对象；</li>\n<li>寻找对应的BeanFactory去实例化Bean;（实例化阶段）<ol>\n<li>使用简单工厂 + 反射去推断构造函数进行实例化</li>\n</ol>\n</li>\n<li>执行Bean的属性赋值动作<ol>\n<li>调用XXXAware接口回调方法；</li>\n<li>调用初始化生命周期的三种回调方法；</li>\n<li>假如Bean实现了AOP，会去创建动态代理对象；</li>\n</ol>\n</li>\n<li>销毁Bean<ol>\n<li>销毁Bean的对象实例，仅在Spring容器关闭的过程中执行销毁；</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":6525,"excerpt":"","more":"<h1 id=\"什么是Spring-AOP\"><a href=\"#什么是Spring-AOP\" class=\"headerlink\" title=\"什么是Spring AOP\"></a>什么是Spring AOP</h1><h2 id=\"你可能遇到过这样的需求\"><a href=\"#你可能遇到过这样的需求\" class=\"headerlink\" title=\"你可能遇到过这样的需求\"></a>你可能遇到过这样的需求</h2><p>假设要你统计一个方法执行的耗时情况，你会怎么做？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">runTask</span><span class=\"hljs-params\">()</span> &#123;<br>    doSomething();<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>相信这个肯定难不倒你，那还不简单，在这个方法的执行前后两个时间戳，方法执行结束计算一下不是就能知道耗时了吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">runTask</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">start</span> <span class=\"hljs-operator\">=</span> Syste.currentTimeMills();<br>    doSomething();<br>    System.out.println(<span class=\"hljs-string\">&quot;方法执行耗时：&quot;</span> + System.currentTimeMills() - start / <span class=\"hljs-number\">1000</span> + <span class=\"hljs-string\">&quot; s&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>但是弊端也非常明显，直接将非业务功能和业务功能耦合在一起，成本非常大；稍有不慎就会出错；那么解决这个问题的方法是什么呢？就是AOP（面向切面编程）；</p>\n<blockquote>\n<p>不用AOP，用你想到的设计模式怎么解决呢？</p>\n<ul>\n<li>将原对象通过组合包装到一个代理对象中；</li>\n<li>生成一个代理对象去包裹我们需要包含非业务的代码；</li>\n<li>在新创建的方法中再调用具体目标对象的方法；</li>\n</ul>\n</blockquote>\n<h2 id=\"AOP的基本概念\"><a href=\"#AOP的基本概念\" class=\"headerlink\" title=\"AOP的基本概念\"></a>AOP的基本概念</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>面向切面编程，是一种编程思想。用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装多个模块并命名为切面；面向切面编程使用的是动态代理实现的；</p>\n<blockquote>\n<p>我们常用的有：打印日志、权限认证等场景；并且AOP需要解决下面几个问题：</p>\n<ul>\n<li>在什么地方进行切面操作</li>\n<li>需要知道切面操作的具体内容</li>\n<li>如果存在多个切面，怎样定义执行先后顺序</li>\n</ul>\n</blockquote>\n<h3 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h3><p>AOP下包含几个重要的概念，需要理解：</p>\n<ul>\n<li><strong>JointPoint（连接点）：</strong>具体的切面点，可以是字段、方法、Spring具体表现为PointCut（切入点），仅作用在方法上；</li>\n<li><strong>Advice（通知）：</strong>在连接点进行的具体操作，如何进行处理增强，分为前置，后置，异常，最终和环绕；</li>\n<li><strong>目标对象：</strong>被AOP框架进行增强处理的对象，也被称为被增强对象；</li>\n<li><strong>AOP代理：</strong>AOP框架创建的代理对象，代理就是对被目标对象的加强，Spring中的代理既可以是JDK动态代理，也可以是cglib动态代理；</li>\n<li><strong>Weaving：</strong>将增强处理添加到目标对象中，创建一个被增强的对象过程；</li>\n</ul>\n<blockquote>\n<p>一句话总结：在目标对象（target object）上的某些方法（jointpoint）添加不同种类的操作（通知、增强处理），最后通过某些方法（weaving、织入）实现一个新的代理目标对象；</p>\n</blockquote>\n<h1 id=\"怎样实现Spring-AOP\"><a href=\"#怎样实现Spring-AOP\" class=\"headerlink\" title=\"怎样实现Spring AOP\"></a>怎样实现Spring AOP</h1><p>Spring AOP的使用非常简单，我们以Spring框架为例：</p>\n<h2 id=\"引入依赖\"><a href=\"#引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a>引入依赖</h2><p>比较关键的两个依赖是：</p>\n<ul>\n<li>spring-aop</li>\n<li>spring-aspects</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group <span class=\"hljs-string\">&#x27;org.example&#x27;</span><br>version <span class=\"hljs-string\">&#x27;1.0-SNAPSHOT&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-core:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-beans:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-tx:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-context:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-aop:5.3.16&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework:spring-aspects:5.3.16&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.junit.jupiter:junit-jupiter-api:5.6.0&#x27;</span><br>    testRuntimeOnly <span class=\"hljs-string\">&#x27;org.junit.jupiter:junit-jupiter-engine&#x27;</span><br>&#125;<br><br>test &#123;<br>    useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建目标Bean（被增强对象）\"><a href=\"#创建目标Bean（被增强对象）\" class=\"headerlink\" title=\"创建目标Bean（被增强对象）\"></a>创建目标Bean（被增强对象）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TestBean</span> &#123;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Testing&quot;</span>;<br><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getStr</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> str;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setStr</span><span class=\"hljs-params\">(String str)</span> &#123;<br>        <span class=\"hljs-built_in\">this</span>.str = str;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建切面（Aspect）\"><a href=\"#创建切面（Aspect）\" class=\"headerlink\" title=\"创建切面（Aspect）\"></a>创建切面（Aspect）</h2><p>这里需要注意几部分：</p>\n<ul>\n<li>切面要交给Spring容器管理，然后使用<code>@Aspect</code>注解来修饰；</li>\n<li>我们定义一个方法来存放切点，并且用<code>@Pointcut</code>注解修饰；</li>\n<li>创建Advice方法，也就是我们在被增强的对象执行前，后会做什么事情；这个就不再描述了；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Aspect</span><br><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LogAspect</span> &#123;<br><br>    <span class=\"hljs-comment\">// 这里的意思是当前包下的所有对象中的方法都会被增强</span><br>    <span class=\"hljs-meta\">@Pointcut(&quot;execution(* com.hhp.spring..*(..))&quot;)</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">allMethod</span><span class=\"hljs-params\">()</span> &#123;&#125;<br><br>    <span class=\"hljs-comment\">// 我们在这里获取被增强的类名和方法名，执行打印输出</span><br>    <span class=\"hljs-meta\">@Before(&quot;allMethod()&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">before</span><span class=\"hljs-params\">(JoinPoint joinPoint)</span> &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> joinPoint.getTarget().getClass().getName();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">methodName</span> <span class=\"hljs-operator\">=</span> joinPoint.getSignature().getName();<br>        System.out.println(className + <span class=\"hljs-string\">&quot;.&quot;</span> + methodName + <span class=\"hljs-string\">&quot;()开始执行...&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 此处同上，不再赘述</span><br>    <span class=\"hljs-meta\">@After(&quot;allMethod()&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">after</span><span class=\"hljs-params\">(JoinPoint joinPoint)</span> &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> joinPoint.getTarget().getClass().getName();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">methodName</span> <span class=\"hljs-operator\">=</span> joinPoint.getSignature().getName();<br>        System.out.println(className + <span class=\"hljs-string\">&quot;.&quot;</span> + methodName + <span class=\"hljs-string\">&quot;()执行结束...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"运行效果\"><a href=\"#运行效果\" class=\"headerlink\" title=\"运行效果\"></a>运行效果</h2><p>我们编写一个启动类看看效果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Application</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ApplicationContext</span> <span class=\"hljs-variable\">ctx</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>        <span class=\"hljs-type\">TestBean</span> <span class=\"hljs-variable\">testBean</span> <span class=\"hljs-operator\">=</span> (TestBean) ctx.getBean(<span class=\"hljs-string\">&quot;testBean&quot;</span>);<br>        System.out.println(testBean.getStr());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>控制台输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">com.hhp.spring.beans.TestBean.getStr()开始执行...<br>com.hhp.spring.beans.TestBean.getStr()执行结束...<br>Testing<br></code></pre></td></tr></table></figure>\n<h1 id=\"透过底层代码看Spring-AOP\"><a href=\"#透过底层代码看Spring-AOP\" class=\"headerlink\" title=\"透过底层代码看Spring AOP\"></a>透过底层代码看Spring AOP</h1><h2 id=\"它是怎么工作的？\"><a href=\"#它是怎么工作的？\" class=\"headerlink\" title=\"它是怎么工作的？\"></a>它是怎么工作的？</h2><p>我们透过源代码来看看在配置类上添加<code>@EnableAspectJAutoProxy</code>注解就可以实现AOP功能，Spring在背后帮我们做了什么工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// Registers an AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry as appropriate based on a given @EnableAspectJAutoProxy annotation.</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AspectJAutoProxyRegister</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">ImportBeanDefinitionRegistrar</span> &#123;<br>    \t<span class=\"hljs-meta\">@Override</span><br>\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">registerBeanDefinitions</span><span class=\"hljs-params\">(</span><br><span class=\"hljs-params\">\t\t\tAnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br><br>\t\tAopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br><br>\t\t<span class=\"hljs-type\">AnnotationAttributes</span> <span class=\"hljs-variable\">enableAspectJAutoProxy</span> <span class=\"hljs-operator\">=</span><br>\t\t\t\tAnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>英文注释的意思是：</strong>通过指定注释<code>@EnableAspectJAutoProxy</code>并根据当前的<code>BeanDefinitionRegistry</code>来注册一个<code>AnnotationAwareAspectJAutoProxyCreator</code>；所以我们在加了注解后就可以启用ProxyCreator去为我们创建AOP代理对象；</p>\n<p>我们再去看<code>AnnotationAwareAspectJAutoProxyCreator</code>这个类它做了哪些工作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnnotationAwareAspectJAutoProxyCreator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AspectJAwareAdvisorAutoProxyCreator</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>        <span class=\"hljs-comment\">// 调用父类的方法初始化Bean工厂</span><br>        <span class=\"hljs-built_in\">super</span>.initBeanFactory(beanFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>追踪代码到<code>AbstractAutowireCapableBeanFactory</code>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowireCapableBeanFactory</span> &#123;<br>    <br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">initializeBean</span><span class=\"hljs-params\">(String beanName, Object bean, <span class=\"hljs-meta\">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">wrappedBean</span> <span class=\"hljs-operator\">=</span> bean;<br>        <span class=\"hljs-keyword\">if</span> (mbd == <span class=\"hljs-literal\">null</span> || !mbd.isSynthetic()) &#123;<br>            <span class=\"hljs-comment\">// 执行beanPostProcessorsBeforeInitialization</span><br>            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-comment\">// 初始化Bean</span><br>                invokeInitMethod(beanName, wrappedBean, mbd);<br>            &#125;<br>            <br>            <span class=\"hljs-keyword\">if</span> (mbd == <span class=\"hljs-literal\">null</span> || !mbd.isSynthetic()) &#123;<br>                <span class=\"hljs-comment\">// 执行beanPostProcessorsAfterInitialization</span><br>                wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> wrappedBean;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们看下通知是如何创建的，继续追踪源代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutoProxyCreator</span> &#123;<br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">wrapIfNecessary</span><span class=\"hljs-params\">(Object bean, String beanName, Object cacheKey)</span> &#123;<br>        <span class=\"hljs-comment\">// 省略其他不相关的代码...</span><br>        <span class=\"hljs-comment\">// Create proxy if we have advice</span><br>        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class=\"hljs-literal\">null</span>);<br>        <span class=\"hljs-keyword\">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<br>            <span class=\"hljs-built_in\">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">proxy</span> <span class=\"hljs-operator\">=</span> createProxy(<br>\t\t\t\t\tbean.getClass(), beanName, specificInterceptors, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SingletonTargetSource</span>(bean));<br>\t\t\t<span class=\"hljs-built_in\">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>\t\t\t<span class=\"hljs-keyword\">return</span> proxy;<br>        &#125;<br>        <br>        <span class=\"hljs-built_in\">this</span>.advisedBeans.put(cackeKey, Boolean.FALSE);<br>        <span class=\"hljs-keyword\">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>创建代理的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAdvisorAutoProxyCreator</span> &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>\t<span class=\"hljs-meta\">@Nullable</span><br>\t<span class=\"hljs-keyword\">protected</span> Object[] getAdvicesAndAdvisorsForBean(<br>\t\t\tClass&lt;?&gt; beanClass, String beanName, <span class=\"hljs-meta\">@Nullable</span> TargetSource targetSource) &#123;<br><br>\t\tList&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);<br>\t\t<span class=\"hljs-keyword\">if</span> (advisors.isEmpty()) &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> DO_NOT_PROXY;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> advisors.toArray();<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我们用一张图再来回顾一下Bean的生命周期</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220306123615086.png\" alt=\"image-20220306123615086\"></p>\n<p>用自己的话概括一下就是：</p>\n<ol>\n<li>生成并且注册BeanDefinition对象；</li>\n<li>初始化IoC容器并且加载BeanDefinition对象；</li>\n<li>寻找对应的BeanFactory去实例化Bean;（实例化阶段）<ol>\n<li>使用简单工厂 + 反射去推断构造函数进行实例化</li>\n</ol>\n</li>\n<li>执行Bean的属性赋值动作<ol>\n<li>调用XXXAware接口回调方法；</li>\n<li>调用初始化生命周期的三种回调方法；</li>\n<li>假如Bean实现了AOP，会去创建动态代理对象；</li>\n</ol>\n</li>\n<li>销毁Bean<ol>\n<li>销毁Bean的对象实例，仅在Spring容器关闭的过程中执行销毁；</li>\n</ol>\n</li>\n</ol>\n"},{"title":"Spring Bean的生命周期学习","date":"2022-03-04T04:53:11.000Z","updated":"2022-03-04T04:53:11.000Z","_content":"\n# 什么是Spring Bean\n\n用一句话来讲解，Spring Bean就是由Spring的IoC容器所创建出来的对象，就称之为Bean；\n\nIoC（Inverse of Control）是Spring中最核心的理念。要理解什么是IoC容器，我们先从一个最简单的例子讲起：\n\n\n\n## Java中如何创建一个对象？\n\n相信你只要做过Java肯定都知道，用`new`关键字来创建一个对象，然后JVM会根据对象的构造函数去成这个对象，从而完成对象的创建。\n\n```java\nSomeObject someObject = new SomeObject();\n```\n\n除此之外，我们使用反射也可以创建出一个Java对象\n\n```java\nClass.forName(\"类的所在包的全路径\").newInstance();\n```\n\n这两种方法的本质都是：调用了我们对象的构造函数来实现的，并且需要注意的是：整个对象创建的过程都是有程序员自己手动完成的。\n\n\n\n## 在Spring中创建的对象跟手动创建的对象有什么区别的？\n\n也许你发现了，在使用Spring框架的过程中，我们从来都不需要显式地去自己创建对象，而是通过下面这样的代码来实现：\n\n```java\n// 创建Spring IoC容器\nApplicationContext context = new ClassPathXmlApplicationContext(\"spring.xml\");\n// 也可以是这样子\ncontext = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// 从Spring IoC容器中获取一个Bean\nUserService userService = (UserService) context.getBean(\"userService\");\n```\n\n可以看到，我们在指定的Spring IoC容器中通过名称就可以拿到我们的Bean对象；\n\n这说明，在Spring内部通过IoC设计思想已经帮助我们创建好了我们想要用的对象，这种设计思想就叫做“控制反转”。\n\n控制反转提现在两个概念：\n\n+ 控制：对象创建的控制权不再是程序员，而是Spring IoC容器；\n+ 反转：指的就是创建对象的这种控制权交给了第三方容器来实现；\n\nSpring使用了“依赖注入”的方式实现了这种机制。所以**总结下来：控制反转是设计思想，依赖注入是具体实现。并且依赖注入是控制反转的一种实现方式；**\n\n\n\n## 如何理解依赖注入呢\n\n我们再通过一个朴素的例子来说明这个问题：\n\n```java\n// 定义一个AppConfig类\n@ComponentScan(basePackages = \"当前类所在的包\")\npublic class AppConfig {}\n\n// UserService Bean\n@Component\npublic class UserService {\n    @Autowired\n    private OrderService orderService;\n}\n\n// OrderService\n@Component\npublic class OrderService {}\n\n// Main方法\npublic class Application {\n    \n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        UserService userService = (UserService) ctx.getBean(\"userService\");\n    }\n}\n```\n\n我们通过Debug来看下userService对象里面有什么内容？\n\n![image-20220304131346171](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220304131346171.png)\n\n可以看到我们在`UserService`中依赖了`OrderService`，在Spring Ioc容器中我们的`OrderService`也顺便被实例化了。这就是Spring IoC容器中依赖注入帮我们实现的业务逻辑；\n\n## 这是如何做到的呢？\n\n很简单，Spring中有个BeanFactory负责创建对象，创建完对象我们可以通过类名拿到对应的对象，这个是反射实现的。因此对于Spring IoC的机制也很简单。就是：\n\n简单工厂（BeanFactory + 动态代理）\n\n\n\n# Spring Bean的生命周期\n\n需要记住的是，Spring Bean的生命周期只有四个阶段：\n\n+ **实例化**\n  + 借助反射推断构造函数进行实例化；使用的是实例工厂和静态工程；\n+ **属性赋值**\n  + 解析自动装配（byName，byType，构造函数，none以及@Autowired）\n  + 此步骤也是依赖注入的实现机制\n  + 除此之外，赋值阶段会解决循环依赖的问题；\n+ **初始化**\n  + 调用XXXAware接口（BeanNameAware，BeanClassLoaderAware以及BeanFactoryAware）\n  + 调用初始化生命周期的三种回调方式；（@PostConstruct， InitializeBean以及init-method属性）\n  + 假设Bean实现了AOP，那么会去创建动态代理；\n+ **销毁**\n  + Spring关闭容器时调用并且销毁Bean对象；\n\n\n\n## 1. Bean对象创建的过程中\n\n我们对应到源码中看下具体的流程：\n\n```java\npublic abstract class AbstractAutowiredCapableBeanFactory {\n    \n    // 省略其他无关代码\n    protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n        BeanWrapper instanceWrapper = null;\n        if (instanceWrapper == null) {\n            // 实例化阶段\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n        Object bean = instanceWrapper.getWrappedInstance();\n        Object exposedObject = bean;\n        try {\n            // 属性赋值阶段\n            populateBean(beanName, mbd, instanceWrapper);\n            // 初始化阶段\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        } catch (Throwable ex) {\n            throw (BeanCreationException) ex;\n        }\n    }\n}\n```\n\n回到createBean方法我们继续看：\n\n```java\npublic abstract class AbstractAutowiredCapableBeanFactory {\n    \n    protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n        RootBeanDefinition mbdToUse = mbd;\n        try {\n            // 实例化之前\n            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n        }\n        \n        try {\n            // 创建Bean的位置\n            // 包括实例化、属性赋值和初始化阶段\n            Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n        }\n    }\n}\n\n@Nullable\nprotected Object resolveBeforeInstantiation(String beanName, RootDefinition mbd) {\n    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeforePostProcessors()) {\n            // 省略下列代码\n        }\n    }\n}\n\nprotected boolean hasInstantiationAwareBeforePostProcessors() {\n    return !getBeanPostProcessorCache().instantiationAware.isEmpty();\n}\n\n// Method in AbstractBeanFactory\nBeanPostProcessorCache getBeanPostProcessorCache() {\n    BeanPostProcessorCache bpCache = this.beanPostProcessorCache;\n    if (bpCache == null) {\n        bpCache = new BeanPostProcessorCache();\n        for (BeanPostProcessor pb : this.beanPostProcessors) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                // Ignore other code\n            }\n        }\n    }\n}\n```\n\n最后追踪的代码过程中，我们找到了`InstantiationAwareBeanPostProcessor`接口，看下它的实现：\n\n```java\npublic interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {\n    @Nullable\n\tdefault Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n\t\treturn null;\n\t}\n    \n    default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {\n\t\treturn true;\n\t}\n}\n```\n\n找到属性赋值的方法，源码如下：\n\n```java\npublic abstract class AbstractAutowireCapableBeanFactory {\n    protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n        // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n}\n```\n\n对此可以总结两点：\n\n+ postProcessBeforeInstantiation在doCreateBean之前调用，也就是在bean实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的Bean作为代理，这也是Aop等功能实现的关键点。\n+ postProcessAfterInstantiation在属性赋值方法内，但是在真正执行赋值操作之前，返回值为boolean为false时可以阻断属性赋值阶段；\n\n\n\n## 2. 无所不能的Aware\n\nAware之前的名字就是可以拿到什么资源，例如`BeanNameAware`可以拿到BeanName，一次类推。调用时机需要注意：所有Aware方法都是在初始化阶段之前就调用；\n\n## 第一组\n\n+ BeanNameAware\n+ BeanClassLoaderAware\n+ BeanFactoryAware\n\n\n\n## 第二组\n\n+ EnvironmentAware\n+ EmbeddedValueResolverAware\n+ ApplicationContextAware\n\n可以通过源码看下具体的内容：\n\n```java\npublic abstract class AbstractAutowiredCapableBeanFactory {\n    \n    protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n        // 调用第一组的三个Bean开头的Aware\n        invokeAwareMethods(beanName, bean);\n        \n        Object wrappedBean = bean;\n        // 调用第二组的几个Aware接口\n        // BeanPostProcessor调用点1\n        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        // InitializingBean的调用点\n        invokeInitMethods(beanName, wrappedBean, mbd);\n        // BeanPostProcessor调用点2\n        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        return wrappedBean;\n    }\n}\n```\n\n这里区别记忆：\n\n+ BeanxxxAware接口是在代码中直接调用的；\n+ ApplicationContext相关的Aware接口是通过在BeanPostProcessor下的postProcessBeforeInitialization()实现的；\n\n\n\n# 简单的两个生命周期接口\n\n剩下的两个接口就比较简单，一个是`initializingBean`，一个是`DisposableBean`；前者对应生命周期的初始化阶段；后者对应生命周期的销毁阶段；\n\n\n\n# 总结\n\nSpring Bean的生命周期分为`4个阶段`和`多个扩展点`。扩展点又可以分为`影响多个Bean`和`影响单个Bean`：\n\n## 4个阶段\n\n+ 实例化 Instanitiation\n+ 属性赋值 Populate\n+ 初始化 Initialization\n+ 销毁 Destruction\n\n\n\n## 多个扩展点\n\n+ 影响多个Bean\n  + BeanPostProcessor\n  + InstantiationAwareBeanPostProcessor\n+ 影响单个Bean\n  + Aware Group 1\n    + BeanNameAware\n    + BeanClassLoaderAware\n    + BeanFactoryAware\n  + Aware Group 2\n    + EnvironmentAware\n    + EmbeddedValueResolverAware\n    + ApplicationContextAware\n+ 生命周期\n  + InitializingBean\n  + DisposableBean\n","source":"_posts/spring/spring-bean-lifecycle.md","raw":"---\ntitle: Spring Bean的生命周期学习\ndate: 2022-03-04 12:53:11\nupdated: 2022-03-04 12:53:11\ntags: Spring框架\ncategories: Spring\n---\n\n# 什么是Spring Bean\n\n用一句话来讲解，Spring Bean就是由Spring的IoC容器所创建出来的对象，就称之为Bean；\n\nIoC（Inverse of Control）是Spring中最核心的理念。要理解什么是IoC容器，我们先从一个最简单的例子讲起：\n\n\n\n## Java中如何创建一个对象？\n\n相信你只要做过Java肯定都知道，用`new`关键字来创建一个对象，然后JVM会根据对象的构造函数去成这个对象，从而完成对象的创建。\n\n```java\nSomeObject someObject = new SomeObject();\n```\n\n除此之外，我们使用反射也可以创建出一个Java对象\n\n```java\nClass.forName(\"类的所在包的全路径\").newInstance();\n```\n\n这两种方法的本质都是：调用了我们对象的构造函数来实现的，并且需要注意的是：整个对象创建的过程都是有程序员自己手动完成的。\n\n\n\n## 在Spring中创建的对象跟手动创建的对象有什么区别的？\n\n也许你发现了，在使用Spring框架的过程中，我们从来都不需要显式地去自己创建对象，而是通过下面这样的代码来实现：\n\n```java\n// 创建Spring IoC容器\nApplicationContext context = new ClassPathXmlApplicationContext(\"spring.xml\");\n// 也可以是这样子\ncontext = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// 从Spring IoC容器中获取一个Bean\nUserService userService = (UserService) context.getBean(\"userService\");\n```\n\n可以看到，我们在指定的Spring IoC容器中通过名称就可以拿到我们的Bean对象；\n\n这说明，在Spring内部通过IoC设计思想已经帮助我们创建好了我们想要用的对象，这种设计思想就叫做“控制反转”。\n\n控制反转提现在两个概念：\n\n+ 控制：对象创建的控制权不再是程序员，而是Spring IoC容器；\n+ 反转：指的就是创建对象的这种控制权交给了第三方容器来实现；\n\nSpring使用了“依赖注入”的方式实现了这种机制。所以**总结下来：控制反转是设计思想，依赖注入是具体实现。并且依赖注入是控制反转的一种实现方式；**\n\n\n\n## 如何理解依赖注入呢\n\n我们再通过一个朴素的例子来说明这个问题：\n\n```java\n// 定义一个AppConfig类\n@ComponentScan(basePackages = \"当前类所在的包\")\npublic class AppConfig {}\n\n// UserService Bean\n@Component\npublic class UserService {\n    @Autowired\n    private OrderService orderService;\n}\n\n// OrderService\n@Component\npublic class OrderService {}\n\n// Main方法\npublic class Application {\n    \n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        UserService userService = (UserService) ctx.getBean(\"userService\");\n    }\n}\n```\n\n我们通过Debug来看下userService对象里面有什么内容？\n\n![image-20220304131346171](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220304131346171.png)\n\n可以看到我们在`UserService`中依赖了`OrderService`，在Spring Ioc容器中我们的`OrderService`也顺便被实例化了。这就是Spring IoC容器中依赖注入帮我们实现的业务逻辑；\n\n## 这是如何做到的呢？\n\n很简单，Spring中有个BeanFactory负责创建对象，创建完对象我们可以通过类名拿到对应的对象，这个是反射实现的。因此对于Spring IoC的机制也很简单。就是：\n\n简单工厂（BeanFactory + 动态代理）\n\n\n\n# Spring Bean的生命周期\n\n需要记住的是，Spring Bean的生命周期只有四个阶段：\n\n+ **实例化**\n  + 借助反射推断构造函数进行实例化；使用的是实例工厂和静态工程；\n+ **属性赋值**\n  + 解析自动装配（byName，byType，构造函数，none以及@Autowired）\n  + 此步骤也是依赖注入的实现机制\n  + 除此之外，赋值阶段会解决循环依赖的问题；\n+ **初始化**\n  + 调用XXXAware接口（BeanNameAware，BeanClassLoaderAware以及BeanFactoryAware）\n  + 调用初始化生命周期的三种回调方式；（@PostConstruct， InitializeBean以及init-method属性）\n  + 假设Bean实现了AOP，那么会去创建动态代理；\n+ **销毁**\n  + Spring关闭容器时调用并且销毁Bean对象；\n\n\n\n## 1. Bean对象创建的过程中\n\n我们对应到源码中看下具体的流程：\n\n```java\npublic abstract class AbstractAutowiredCapableBeanFactory {\n    \n    // 省略其他无关代码\n    protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n        BeanWrapper instanceWrapper = null;\n        if (instanceWrapper == null) {\n            // 实例化阶段\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n        Object bean = instanceWrapper.getWrappedInstance();\n        Object exposedObject = bean;\n        try {\n            // 属性赋值阶段\n            populateBean(beanName, mbd, instanceWrapper);\n            // 初始化阶段\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        } catch (Throwable ex) {\n            throw (BeanCreationException) ex;\n        }\n    }\n}\n```\n\n回到createBean方法我们继续看：\n\n```java\npublic abstract class AbstractAutowiredCapableBeanFactory {\n    \n    protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n        RootBeanDefinition mbdToUse = mbd;\n        try {\n            // 实例化之前\n            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n        }\n        \n        try {\n            // 创建Bean的位置\n            // 包括实例化、属性赋值和初始化阶段\n            Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n        }\n    }\n}\n\n@Nullable\nprotected Object resolveBeforeInstantiation(String beanName, RootDefinition mbd) {\n    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeforePostProcessors()) {\n            // 省略下列代码\n        }\n    }\n}\n\nprotected boolean hasInstantiationAwareBeforePostProcessors() {\n    return !getBeanPostProcessorCache().instantiationAware.isEmpty();\n}\n\n// Method in AbstractBeanFactory\nBeanPostProcessorCache getBeanPostProcessorCache() {\n    BeanPostProcessorCache bpCache = this.beanPostProcessorCache;\n    if (bpCache == null) {\n        bpCache = new BeanPostProcessorCache();\n        for (BeanPostProcessor pb : this.beanPostProcessors) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                // Ignore other code\n            }\n        }\n    }\n}\n```\n\n最后追踪的代码过程中，我们找到了`InstantiationAwareBeanPostProcessor`接口，看下它的实现：\n\n```java\npublic interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {\n    @Nullable\n\tdefault Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n\t\treturn null;\n\t}\n    \n    default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {\n\t\treturn true;\n\t}\n}\n```\n\n找到属性赋值的方法，源码如下：\n\n```java\npublic abstract class AbstractAutowireCapableBeanFactory {\n    protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n        // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n}\n```\n\n对此可以总结两点：\n\n+ postProcessBeforeInstantiation在doCreateBean之前调用，也就是在bean实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的Bean作为代理，这也是Aop等功能实现的关键点。\n+ postProcessAfterInstantiation在属性赋值方法内，但是在真正执行赋值操作之前，返回值为boolean为false时可以阻断属性赋值阶段；\n\n\n\n## 2. 无所不能的Aware\n\nAware之前的名字就是可以拿到什么资源，例如`BeanNameAware`可以拿到BeanName，一次类推。调用时机需要注意：所有Aware方法都是在初始化阶段之前就调用；\n\n## 第一组\n\n+ BeanNameAware\n+ BeanClassLoaderAware\n+ BeanFactoryAware\n\n\n\n## 第二组\n\n+ EnvironmentAware\n+ EmbeddedValueResolverAware\n+ ApplicationContextAware\n\n可以通过源码看下具体的内容：\n\n```java\npublic abstract class AbstractAutowiredCapableBeanFactory {\n    \n    protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n        // 调用第一组的三个Bean开头的Aware\n        invokeAwareMethods(beanName, bean);\n        \n        Object wrappedBean = bean;\n        // 调用第二组的几个Aware接口\n        // BeanPostProcessor调用点1\n        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n        // InitializingBean的调用点\n        invokeInitMethods(beanName, wrappedBean, mbd);\n        // BeanPostProcessor调用点2\n        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        return wrappedBean;\n    }\n}\n```\n\n这里区别记忆：\n\n+ BeanxxxAware接口是在代码中直接调用的；\n+ ApplicationContext相关的Aware接口是通过在BeanPostProcessor下的postProcessBeforeInitialization()实现的；\n\n\n\n# 简单的两个生命周期接口\n\n剩下的两个接口就比较简单，一个是`initializingBean`，一个是`DisposableBean`；前者对应生命周期的初始化阶段；后者对应生命周期的销毁阶段；\n\n\n\n# 总结\n\nSpring Bean的生命周期分为`4个阶段`和`多个扩展点`。扩展点又可以分为`影响多个Bean`和`影响单个Bean`：\n\n## 4个阶段\n\n+ 实例化 Instanitiation\n+ 属性赋值 Populate\n+ 初始化 Initialization\n+ 销毁 Destruction\n\n\n\n## 多个扩展点\n\n+ 影响多个Bean\n  + BeanPostProcessor\n  + InstantiationAwareBeanPostProcessor\n+ 影响单个Bean\n  + Aware Group 1\n    + BeanNameAware\n    + BeanClassLoaderAware\n    + BeanFactoryAware\n  + Aware Group 2\n    + EnvironmentAware\n    + EmbeddedValueResolverAware\n    + ApplicationContextAware\n+ 生命周期\n  + InitializingBean\n  + DisposableBean\n","slug":"spring/spring-bean-lifecycle","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vp002u4f6144ro3oxb","content":"<h1 id=\"什么是Spring-Bean\"><a href=\"#什么是Spring-Bean\" class=\"headerlink\" title=\"什么是Spring Bean\"></a>什么是Spring Bean</h1><p>用一句话来讲解，Spring Bean就是由Spring的IoC容器所创建出来的对象，就称之为Bean；</p>\n<p>IoC（Inverse of Control）是Spring中最核心的理念。要理解什么是IoC容器，我们先从一个最简单的例子讲起：</p>\n<h2 id=\"Java中如何创建一个对象？\"><a href=\"#Java中如何创建一个对象？\" class=\"headerlink\" title=\"Java中如何创建一个对象？\"></a>Java中如何创建一个对象？</h2><p>相信你只要做过Java肯定都知道，用<code>new</code>关键字来创建一个对象，然后JVM会根据对象的构造函数去成这个对象，从而完成对象的创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">SomeObject</span> <span class=\"hljs-variable\">someObject</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SomeObject</span>();<br></code></pre></td></tr></table></figure>\n<p>除此之外，我们使用反射也可以创建出一个Java对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Class.forName(<span class=\"hljs-string\">&quot;类的所在包的全路径&quot;</span>).newInstance();<br></code></pre></td></tr></table></figure>\n<p>这两种方法的本质都是：调用了我们对象的构造函数来实现的，并且需要注意的是：整个对象创建的过程都是有程序员自己手动完成的。</p>\n<h2 id=\"在Spring中创建的对象跟手动创建的对象有什么区别的？\"><a href=\"#在Spring中创建的对象跟手动创建的对象有什么区别的？\" class=\"headerlink\" title=\"在Spring中创建的对象跟手动创建的对象有什么区别的？\"></a>在Spring中创建的对象跟手动创建的对象有什么区别的？</h2><p>也许你发现了，在使用Spring框架的过程中，我们从来都不需要显式地去自己创建对象，而是通过下面这样的代码来实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 创建Spring IoC容器</span><br><span class=\"hljs-type\">ApplicationContext</span> <span class=\"hljs-variable\">context</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ClassPathXmlApplicationContext</span>(<span class=\"hljs-string\">&quot;spring.xml&quot;</span>);<br><span class=\"hljs-comment\">// 也可以是这样子</span><br>context = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);<br><br><span class=\"hljs-comment\">// 从Spring IoC容器中获取一个Bean</span><br><span class=\"hljs-type\">UserService</span> <span class=\"hljs-variable\">userService</span> <span class=\"hljs-operator\">=</span> (UserService) context.getBean(<span class=\"hljs-string\">&quot;userService&quot;</span>);<br></code></pre></td></tr></table></figure>\n<p>可以看到，我们在指定的Spring IoC容器中通过名称就可以拿到我们的Bean对象；</p>\n<p>这说明，在Spring内部通过IoC设计思想已经帮助我们创建好了我们想要用的对象，这种设计思想就叫做“控制反转”。</p>\n<p>控制反转提现在两个概念：</p>\n<ul>\n<li>控制：对象创建的控制权不再是程序员，而是Spring IoC容器；</li>\n<li>反转：指的就是创建对象的这种控制权交给了第三方容器来实现；</li>\n</ul>\n<p>Spring使用了“依赖注入”的方式实现了这种机制。所以<strong>总结下来：控制反转是设计思想，依赖注入是具体实现。并且依赖注入是控制反转的一种实现方式；</strong></p>\n<h2 id=\"如何理解依赖注入呢\"><a href=\"#如何理解依赖注入呢\" class=\"headerlink\" title=\"如何理解依赖注入呢\"></a>如何理解依赖注入呢</h2><p>我们再通过一个朴素的例子来说明这个问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 定义一个AppConfig类</span><br><span class=\"hljs-meta\">@ComponentScan(basePackages = &quot;当前类所在的包&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppConfig</span> &#123;&#125;<br><br><span class=\"hljs-comment\">// UserService Bean</span><br><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserService</span> &#123;<br>    <span class=\"hljs-meta\">@Autowired</span><br>    <span class=\"hljs-keyword\">private</span> OrderService orderService;<br>&#125;<br><br><span class=\"hljs-comment\">// OrderService</span><br><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrderService</span> &#123;&#125;<br><br><span class=\"hljs-comment\">// Main方法</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Application</span> &#123;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ApplicationContext</span> <span class=\"hljs-variable\">ctx</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>        <span class=\"hljs-type\">UserService</span> <span class=\"hljs-variable\">userService</span> <span class=\"hljs-operator\">=</span> (UserService) ctx.getBean(<span class=\"hljs-string\">&quot;userService&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们通过Debug来看下userService对象里面有什么内容？</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220304131346171.png\" alt=\"image-20220304131346171\"></p>\n<p>可以看到我们在<code>UserService</code>中依赖了<code>OrderService</code>，在Spring Ioc容器中我们的<code>OrderService</code>也顺便被实例化了。这就是Spring IoC容器中依赖注入帮我们实现的业务逻辑；</p>\n<h2 id=\"这是如何做到的呢？\"><a href=\"#这是如何做到的呢？\" class=\"headerlink\" title=\"这是如何做到的呢？\"></a>这是如何做到的呢？</h2><p>很简单，Spring中有个BeanFactory负责创建对象，创建完对象我们可以通过类名拿到对应的对象，这个是反射实现的。因此对于Spring IoC的机制也很简单。就是：</p>\n<p>简单工厂（BeanFactory + 动态代理）</p>\n<h1 id=\"Spring-Bean的生命周期\"><a href=\"#Spring-Bean的生命周期\" class=\"headerlink\" title=\"Spring Bean的生命周期\"></a>Spring Bean的生命周期</h1><p>需要记住的是，Spring Bean的生命周期只有四个阶段：</p>\n<ul>\n<li><strong>实例化</strong><ul>\n<li>借助反射推断构造函数进行实例化；使用的是实例工厂和静态工程；</li>\n</ul>\n</li>\n<li><strong>属性赋值</strong><ul>\n<li>解析自动装配（byName，byType，构造函数，none以及@Autowired）</li>\n<li>此步骤也是依赖注入的实现机制</li>\n<li>除此之外，赋值阶段会解决循环依赖的问题；</li>\n</ul>\n</li>\n<li><strong>初始化</strong><ul>\n<li>调用XXXAware接口（BeanNameAware，BeanClassLoaderAware以及BeanFactoryAware）</li>\n<li>调用初始化生命周期的三种回调方式；（@PostConstruct， InitializeBean以及init-method属性）</li>\n<li>假设Bean实现了AOP，那么会去创建动态代理；</li>\n</ul>\n</li>\n<li><strong>销毁</strong><ul>\n<li>Spring关闭容器时调用并且销毁Bean对象；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-Bean对象创建的过程中\"><a href=\"#1-Bean对象创建的过程中\" class=\"headerlink\" title=\"1. Bean对象创建的过程中\"></a>1. Bean对象创建的过程中</h2><p>我们对应到源码中看下具体的流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowiredCapableBeanFactory</span> &#123;<br>    <br>    <span class=\"hljs-comment\">// 省略其他无关代码</span><br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">doCreateBean</span><span class=\"hljs-params\">(String beanName, RootBeanDefinition mbd, <span class=\"hljs-meta\">@Nullable</span> Object[] args)</span> &#123;<br>        <span class=\"hljs-type\">BeanWrapper</span> <span class=\"hljs-variable\">instanceWrapper</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">if</span> (instanceWrapper == <span class=\"hljs-literal\">null</span>) &#123;<br>            <span class=\"hljs-comment\">// 实例化阶段</span><br>            instanceWrapper = createBeanInstance(beanName, mbd, args);<br>        &#125;<br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">bean</span> <span class=\"hljs-operator\">=</span> instanceWrapper.getWrappedInstance();<br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">exposedObject</span> <span class=\"hljs-operator\">=</span> bean;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 属性赋值阶段</span><br>            populateBean(beanName, mbd, instanceWrapper);<br>            <span class=\"hljs-comment\">// 初始化阶段</span><br>            exposedObject = initializeBean(beanName, exposedObject, mbd);<br>        &#125; <span class=\"hljs-keyword\">catch</span> (Throwable ex) &#123;<br>            <span class=\"hljs-keyword\">throw</span> (BeanCreationException) ex;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>回到createBean方法我们继续看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowiredCapableBeanFactory</span> &#123;<br>    <br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">createBean</span><span class=\"hljs-params\">(String beanName, RootBeanDefinition mbd, <span class=\"hljs-meta\">@Nullable</span> Object[] args)</span> &#123;<br>        <span class=\"hljs-type\">RootBeanDefinition</span> <span class=\"hljs-variable\">mbdToUse</span> <span class=\"hljs-operator\">=</span> mbd;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 实例化之前</span><br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">bean</span> <span class=\"hljs-operator\">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br>        &#125;<br>        <br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 创建Bean的位置</span><br>            <span class=\"hljs-comment\">// 包括实例化、属性赋值和初始化阶段</span><br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">beanInstance</span> <span class=\"hljs-operator\">=</span> doCreateBean(beanName, mbdToUse, args);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-meta\">@Nullable</span><br><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">resolveBeforeInstantiation</span><span class=\"hljs-params\">(String beanName, RootDefinition mbd)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeforePostProcessors()) &#123;<br>            <span class=\"hljs-comment\">// 省略下列代码</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">hasInstantiationAwareBeforePostProcessors</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> !getBeanPostProcessorCache().instantiationAware.isEmpty();<br>&#125;<br><br><span class=\"hljs-comment\">// Method in AbstractBeanFactory</span><br>BeanPostProcessorCache <span class=\"hljs-title function_\">getBeanPostProcessorCache</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">BeanPostProcessorCache</span> <span class=\"hljs-variable\">bpCache</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.beanPostProcessorCache;<br>    <span class=\"hljs-keyword\">if</span> (bpCache == <span class=\"hljs-literal\">null</span>) &#123;<br>        bpCache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BeanPostProcessorCache</span>();<br>        <span class=\"hljs-keyword\">for</span> (BeanPostProcessor pb : <span class=\"hljs-built_in\">this</span>.beanPostProcessors) &#123;<br>            <span class=\"hljs-keyword\">if</span> (bp <span class=\"hljs-keyword\">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;<br>                <span class=\"hljs-comment\">// Ignore other code</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>最后追踪的代码过程中，我们找到了<code>InstantiationAwareBeanPostProcessor</code>接口，看下它的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">InstantiationAwareBeanPostProcessor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BeanPostProcessor</span> &#123;<br>    <span class=\"hljs-meta\">@Nullable</span><br>\t<span class=\"hljs-keyword\">default</span> Object <span class=\"hljs-title function_\">postProcessBeforeInstantiation</span><span class=\"hljs-params\">(Class&lt;?&gt; beanClass, String beanName)</span> <span class=\"hljs-keyword\">throws</span> BeansException &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>\t&#125;<br>    <br>    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">postProcessAfterInstantiation</span><span class=\"hljs-params\">(Object bean, String beanName)</span> <span class=\"hljs-keyword\">throws</span> BeansException &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>找到属性赋值的方法，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowireCapableBeanFactory</span> &#123;<br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">populateBean</span><span class=\"hljs-params\">(String beanName, RootBeanDefinition mbd, <span class=\"hljs-meta\">@Nullable</span> BeanWrapper bw)</span> &#123;<br>        <span class=\"hljs-comment\">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span><br>\t\t<span class=\"hljs-comment\">// state of the bean before properties are set. This can be used, for example,</span><br>\t\t<span class=\"hljs-comment\">// to support styles of field injection.</span><br>        <span class=\"hljs-keyword\">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>对此可以总结两点：</p>\n<ul>\n<li>postProcessBeforeInstantiation在doCreateBean之前调用，也就是在bean实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的Bean作为代理，这也是Aop等功能实现的关键点。</li>\n<li>postProcessAfterInstantiation在属性赋值方法内，但是在真正执行赋值操作之前，返回值为boolean为false时可以阻断属性赋值阶段；</li>\n</ul>\n<h2 id=\"2-无所不能的Aware\"><a href=\"#2-无所不能的Aware\" class=\"headerlink\" title=\"2. 无所不能的Aware\"></a>2. 无所不能的Aware</h2><p>Aware之前的名字就是可以拿到什么资源，例如<code>BeanNameAware</code>可以拿到BeanName，一次类推。调用时机需要注意：所有Aware方法都是在初始化阶段之前就调用；</p>\n<h2 id=\"第一组\"><a href=\"#第一组\" class=\"headerlink\" title=\"第一组\"></a>第一组</h2><ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n<h2 id=\"第二组\"><a href=\"#第二组\" class=\"headerlink\" title=\"第二组\"></a>第二组</h2><ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware</li>\n<li>ApplicationContextAware</li>\n</ul>\n<p>可以通过源码看下具体的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowiredCapableBeanFactory</span> &#123;<br>    <br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">initializeBean</span><span class=\"hljs-params\">(String beanName, Object bean, <span class=\"hljs-meta\">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>        <span class=\"hljs-comment\">// 调用第一组的三个Bean开头的Aware</span><br>        invokeAwareMethods(beanName, bean);<br>        <br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">wrappedBean</span> <span class=\"hljs-operator\">=</span> bean;<br>        <span class=\"hljs-comment\">// 调用第二组的几个Aware接口</span><br>        <span class=\"hljs-comment\">// BeanPostProcessor调用点1</span><br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>        <span class=\"hljs-comment\">// InitializingBean的调用点</span><br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>        <span class=\"hljs-comment\">// BeanPostProcessor调用点2</span><br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>        <span class=\"hljs-keyword\">return</span> wrappedBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里区别记忆：</p>\n<ul>\n<li>BeanxxxAware接口是在代码中直接调用的；</li>\n<li>ApplicationContext相关的Aware接口是通过在BeanPostProcessor下的postProcessBeforeInitialization()实现的；</li>\n</ul>\n<h1 id=\"简单的两个生命周期接口\"><a href=\"#简单的两个生命周期接口\" class=\"headerlink\" title=\"简单的两个生命周期接口\"></a>简单的两个生命周期接口</h1><p>剩下的两个接口就比较简单，一个是<code>initializingBean</code>，一个是<code>DisposableBean</code>；前者对应生命周期的初始化阶段；后者对应生命周期的销毁阶段；</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Spring Bean的生命周期分为<code>4个阶段</code>和<code>多个扩展点</code>。扩展点又可以分为<code>影响多个Bean</code>和<code>影响单个Bean</code>：</p>\n<h2 id=\"4个阶段\"><a href=\"#4个阶段\" class=\"headerlink\" title=\"4个阶段\"></a>4个阶段</h2><ul>\n<li>实例化 Instanitiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<h2 id=\"多个扩展点\"><a href=\"#多个扩展点\" class=\"headerlink\" title=\"多个扩展点\"></a>多个扩展点</h2><ul>\n<li>影响多个Bean<ul>\n<li>BeanPostProcessor</li>\n<li>InstantiationAwareBeanPostProcessor</li>\n</ul>\n</li>\n<li>影响单个Bean<ul>\n<li>Aware Group 1<ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n</li>\n<li>Aware Group 2<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware</li>\n<li>ApplicationContextAware</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>InitializingBean</li>\n<li>DisposableBean</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":6614,"excerpt":"","more":"<h1 id=\"什么是Spring-Bean\"><a href=\"#什么是Spring-Bean\" class=\"headerlink\" title=\"什么是Spring Bean\"></a>什么是Spring Bean</h1><p>用一句话来讲解，Spring Bean就是由Spring的IoC容器所创建出来的对象，就称之为Bean；</p>\n<p>IoC（Inverse of Control）是Spring中最核心的理念。要理解什么是IoC容器，我们先从一个最简单的例子讲起：</p>\n<h2 id=\"Java中如何创建一个对象？\"><a href=\"#Java中如何创建一个对象？\" class=\"headerlink\" title=\"Java中如何创建一个对象？\"></a>Java中如何创建一个对象？</h2><p>相信你只要做过Java肯定都知道，用<code>new</code>关键字来创建一个对象，然后JVM会根据对象的构造函数去成这个对象，从而完成对象的创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">SomeObject</span> <span class=\"hljs-variable\">someObject</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SomeObject</span>();<br></code></pre></td></tr></table></figure>\n<p>除此之外，我们使用反射也可以创建出一个Java对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Class.forName(<span class=\"hljs-string\">&quot;类的所在包的全路径&quot;</span>).newInstance();<br></code></pre></td></tr></table></figure>\n<p>这两种方法的本质都是：调用了我们对象的构造函数来实现的，并且需要注意的是：整个对象创建的过程都是有程序员自己手动完成的。</p>\n<h2 id=\"在Spring中创建的对象跟手动创建的对象有什么区别的？\"><a href=\"#在Spring中创建的对象跟手动创建的对象有什么区别的？\" class=\"headerlink\" title=\"在Spring中创建的对象跟手动创建的对象有什么区别的？\"></a>在Spring中创建的对象跟手动创建的对象有什么区别的？</h2><p>也许你发现了，在使用Spring框架的过程中，我们从来都不需要显式地去自己创建对象，而是通过下面这样的代码来实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 创建Spring IoC容器</span><br><span class=\"hljs-type\">ApplicationContext</span> <span class=\"hljs-variable\">context</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ClassPathXmlApplicationContext</span>(<span class=\"hljs-string\">&quot;spring.xml&quot;</span>);<br><span class=\"hljs-comment\">// 也可以是这样子</span><br>context = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);<br><br><span class=\"hljs-comment\">// 从Spring IoC容器中获取一个Bean</span><br><span class=\"hljs-type\">UserService</span> <span class=\"hljs-variable\">userService</span> <span class=\"hljs-operator\">=</span> (UserService) context.getBean(<span class=\"hljs-string\">&quot;userService&quot;</span>);<br></code></pre></td></tr></table></figure>\n<p>可以看到，我们在指定的Spring IoC容器中通过名称就可以拿到我们的Bean对象；</p>\n<p>这说明，在Spring内部通过IoC设计思想已经帮助我们创建好了我们想要用的对象，这种设计思想就叫做“控制反转”。</p>\n<p>控制反转提现在两个概念：</p>\n<ul>\n<li>控制：对象创建的控制权不再是程序员，而是Spring IoC容器；</li>\n<li>反转：指的就是创建对象的这种控制权交给了第三方容器来实现；</li>\n</ul>\n<p>Spring使用了“依赖注入”的方式实现了这种机制。所以<strong>总结下来：控制反转是设计思想，依赖注入是具体实现。并且依赖注入是控制反转的一种实现方式；</strong></p>\n<h2 id=\"如何理解依赖注入呢\"><a href=\"#如何理解依赖注入呢\" class=\"headerlink\" title=\"如何理解依赖注入呢\"></a>如何理解依赖注入呢</h2><p>我们再通过一个朴素的例子来说明这个问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 定义一个AppConfig类</span><br><span class=\"hljs-meta\">@ComponentScan(basePackages = &quot;当前类所在的包&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppConfig</span> &#123;&#125;<br><br><span class=\"hljs-comment\">// UserService Bean</span><br><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserService</span> &#123;<br>    <span class=\"hljs-meta\">@Autowired</span><br>    <span class=\"hljs-keyword\">private</span> OrderService orderService;<br>&#125;<br><br><span class=\"hljs-comment\">// OrderService</span><br><span class=\"hljs-meta\">@Component</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrderService</span> &#123;&#125;<br><br><span class=\"hljs-comment\">// Main方法</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Application</span> &#123;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ApplicationContext</span> <span class=\"hljs-variable\">ctx</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>        <span class=\"hljs-type\">UserService</span> <span class=\"hljs-variable\">userService</span> <span class=\"hljs-operator\">=</span> (UserService) ctx.getBean(<span class=\"hljs-string\">&quot;userService&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>我们通过Debug来看下userService对象里面有什么内容？</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220304131346171.png\" alt=\"image-20220304131346171\"></p>\n<p>可以看到我们在<code>UserService</code>中依赖了<code>OrderService</code>，在Spring Ioc容器中我们的<code>OrderService</code>也顺便被实例化了。这就是Spring IoC容器中依赖注入帮我们实现的业务逻辑；</p>\n<h2 id=\"这是如何做到的呢？\"><a href=\"#这是如何做到的呢？\" class=\"headerlink\" title=\"这是如何做到的呢？\"></a>这是如何做到的呢？</h2><p>很简单，Spring中有个BeanFactory负责创建对象，创建完对象我们可以通过类名拿到对应的对象，这个是反射实现的。因此对于Spring IoC的机制也很简单。就是：</p>\n<p>简单工厂（BeanFactory + 动态代理）</p>\n<h1 id=\"Spring-Bean的生命周期\"><a href=\"#Spring-Bean的生命周期\" class=\"headerlink\" title=\"Spring Bean的生命周期\"></a>Spring Bean的生命周期</h1><p>需要记住的是，Spring Bean的生命周期只有四个阶段：</p>\n<ul>\n<li><strong>实例化</strong><ul>\n<li>借助反射推断构造函数进行实例化；使用的是实例工厂和静态工程；</li>\n</ul>\n</li>\n<li><strong>属性赋值</strong><ul>\n<li>解析自动装配（byName，byType，构造函数，none以及@Autowired）</li>\n<li>此步骤也是依赖注入的实现机制</li>\n<li>除此之外，赋值阶段会解决循环依赖的问题；</li>\n</ul>\n</li>\n<li><strong>初始化</strong><ul>\n<li>调用XXXAware接口（BeanNameAware，BeanClassLoaderAware以及BeanFactoryAware）</li>\n<li>调用初始化生命周期的三种回调方式；（@PostConstruct， InitializeBean以及init-method属性）</li>\n<li>假设Bean实现了AOP，那么会去创建动态代理；</li>\n</ul>\n</li>\n<li><strong>销毁</strong><ul>\n<li>Spring关闭容器时调用并且销毁Bean对象；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-Bean对象创建的过程中\"><a href=\"#1-Bean对象创建的过程中\" class=\"headerlink\" title=\"1. Bean对象创建的过程中\"></a>1. Bean对象创建的过程中</h2><p>我们对应到源码中看下具体的流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowiredCapableBeanFactory</span> &#123;<br>    <br>    <span class=\"hljs-comment\">// 省略其他无关代码</span><br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">doCreateBean</span><span class=\"hljs-params\">(String beanName, RootBeanDefinition mbd, <span class=\"hljs-meta\">@Nullable</span> Object[] args)</span> &#123;<br>        <span class=\"hljs-type\">BeanWrapper</span> <span class=\"hljs-variable\">instanceWrapper</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;<br>        <span class=\"hljs-keyword\">if</span> (instanceWrapper == <span class=\"hljs-literal\">null</span>) &#123;<br>            <span class=\"hljs-comment\">// 实例化阶段</span><br>            instanceWrapper = createBeanInstance(beanName, mbd, args);<br>        &#125;<br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">bean</span> <span class=\"hljs-operator\">=</span> instanceWrapper.getWrappedInstance();<br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">exposedObject</span> <span class=\"hljs-operator\">=</span> bean;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 属性赋值阶段</span><br>            populateBean(beanName, mbd, instanceWrapper);<br>            <span class=\"hljs-comment\">// 初始化阶段</span><br>            exposedObject = initializeBean(beanName, exposedObject, mbd);<br>        &#125; <span class=\"hljs-keyword\">catch</span> (Throwable ex) &#123;<br>            <span class=\"hljs-keyword\">throw</span> (BeanCreationException) ex;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>回到createBean方法我们继续看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowiredCapableBeanFactory</span> &#123;<br>    <br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">createBean</span><span class=\"hljs-params\">(String beanName, RootBeanDefinition mbd, <span class=\"hljs-meta\">@Nullable</span> Object[] args)</span> &#123;<br>        <span class=\"hljs-type\">RootBeanDefinition</span> <span class=\"hljs-variable\">mbdToUse</span> <span class=\"hljs-operator\">=</span> mbd;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 实例化之前</span><br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">bean</span> <span class=\"hljs-operator\">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br>        &#125;<br>        <br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 创建Bean的位置</span><br>            <span class=\"hljs-comment\">// 包括实例化、属性赋值和初始化阶段</span><br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">beanInstance</span> <span class=\"hljs-operator\">=</span> doCreateBean(beanName, mbdToUse, args);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-meta\">@Nullable</span><br><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">resolveBeforeInstantiation</span><span class=\"hljs-params\">(String beanName, RootDefinition mbd)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeforePostProcessors()) &#123;<br>            <span class=\"hljs-comment\">// 省略下列代码</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">hasInstantiationAwareBeforePostProcessors</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> !getBeanPostProcessorCache().instantiationAware.isEmpty();<br>&#125;<br><br><span class=\"hljs-comment\">// Method in AbstractBeanFactory</span><br>BeanPostProcessorCache <span class=\"hljs-title function_\">getBeanPostProcessorCache</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">BeanPostProcessorCache</span> <span class=\"hljs-variable\">bpCache</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.beanPostProcessorCache;<br>    <span class=\"hljs-keyword\">if</span> (bpCache == <span class=\"hljs-literal\">null</span>) &#123;<br>        bpCache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BeanPostProcessorCache</span>();<br>        <span class=\"hljs-keyword\">for</span> (BeanPostProcessor pb : <span class=\"hljs-built_in\">this</span>.beanPostProcessors) &#123;<br>            <span class=\"hljs-keyword\">if</span> (bp <span class=\"hljs-keyword\">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;<br>                <span class=\"hljs-comment\">// Ignore other code</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>最后追踪的代码过程中，我们找到了<code>InstantiationAwareBeanPostProcessor</code>接口，看下它的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">InstantiationAwareBeanPostProcessor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BeanPostProcessor</span> &#123;<br>    <span class=\"hljs-meta\">@Nullable</span><br>\t<span class=\"hljs-keyword\">default</span> Object <span class=\"hljs-title function_\">postProcessBeforeInstantiation</span><span class=\"hljs-params\">(Class&lt;?&gt; beanClass, String beanName)</span> <span class=\"hljs-keyword\">throws</span> BeansException &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>\t&#125;<br>    <br>    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">postProcessAfterInstantiation</span><span class=\"hljs-params\">(Object bean, String beanName)</span> <span class=\"hljs-keyword\">throws</span> BeansException &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>找到属性赋值的方法，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowireCapableBeanFactory</span> &#123;<br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">populateBean</span><span class=\"hljs-params\">(String beanName, RootBeanDefinition mbd, <span class=\"hljs-meta\">@Nullable</span> BeanWrapper bw)</span> &#123;<br>        <span class=\"hljs-comment\">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span><br>\t\t<span class=\"hljs-comment\">// state of the bean before properties are set. This can be used, for example,</span><br>\t\t<span class=\"hljs-comment\">// to support styles of field injection.</span><br>        <span class=\"hljs-keyword\">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>对此可以总结两点：</p>\n<ul>\n<li>postProcessBeforeInstantiation在doCreateBean之前调用，也就是在bean实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的Bean作为代理，这也是Aop等功能实现的关键点。</li>\n<li>postProcessAfterInstantiation在属性赋值方法内，但是在真正执行赋值操作之前，返回值为boolean为false时可以阻断属性赋值阶段；</li>\n</ul>\n<h2 id=\"2-无所不能的Aware\"><a href=\"#2-无所不能的Aware\" class=\"headerlink\" title=\"2. 无所不能的Aware\"></a>2. 无所不能的Aware</h2><p>Aware之前的名字就是可以拿到什么资源，例如<code>BeanNameAware</code>可以拿到BeanName，一次类推。调用时机需要注意：所有Aware方法都是在初始化阶段之前就调用；</p>\n<h2 id=\"第一组\"><a href=\"#第一组\" class=\"headerlink\" title=\"第一组\"></a>第一组</h2><ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n<h2 id=\"第二组\"><a href=\"#第二组\" class=\"headerlink\" title=\"第二组\"></a>第二组</h2><ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware</li>\n<li>ApplicationContextAware</li>\n</ul>\n<p>可以通过源码看下具体的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AbstractAutowiredCapableBeanFactory</span> &#123;<br>    <br>    <span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title function_\">initializeBean</span><span class=\"hljs-params\">(String beanName, Object bean, <span class=\"hljs-meta\">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>        <span class=\"hljs-comment\">// 调用第一组的三个Bean开头的Aware</span><br>        invokeAwareMethods(beanName, bean);<br>        <br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">wrappedBean</span> <span class=\"hljs-operator\">=</span> bean;<br>        <span class=\"hljs-comment\">// 调用第二组的几个Aware接口</span><br>        <span class=\"hljs-comment\">// BeanPostProcessor调用点1</span><br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>        <span class=\"hljs-comment\">// InitializingBean的调用点</span><br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>        <span class=\"hljs-comment\">// BeanPostProcessor调用点2</span><br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>        <span class=\"hljs-keyword\">return</span> wrappedBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里区别记忆：</p>\n<ul>\n<li>BeanxxxAware接口是在代码中直接调用的；</li>\n<li>ApplicationContext相关的Aware接口是通过在BeanPostProcessor下的postProcessBeforeInitialization()实现的；</li>\n</ul>\n<h1 id=\"简单的两个生命周期接口\"><a href=\"#简单的两个生命周期接口\" class=\"headerlink\" title=\"简单的两个生命周期接口\"></a>简单的两个生命周期接口</h1><p>剩下的两个接口就比较简单，一个是<code>initializingBean</code>，一个是<code>DisposableBean</code>；前者对应生命周期的初始化阶段；后者对应生命周期的销毁阶段；</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Spring Bean的生命周期分为<code>4个阶段</code>和<code>多个扩展点</code>。扩展点又可以分为<code>影响多个Bean</code>和<code>影响单个Bean</code>：</p>\n<h2 id=\"4个阶段\"><a href=\"#4个阶段\" class=\"headerlink\" title=\"4个阶段\"></a>4个阶段</h2><ul>\n<li>实例化 Instanitiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<h2 id=\"多个扩展点\"><a href=\"#多个扩展点\" class=\"headerlink\" title=\"多个扩展点\"></a>多个扩展点</h2><ul>\n<li>影响多个Bean<ul>\n<li>BeanPostProcessor</li>\n<li>InstantiationAwareBeanPostProcessor</li>\n</ul>\n</li>\n<li>影响单个Bean<ul>\n<li>Aware Group 1<ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n</li>\n<li>Aware Group 2<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware</li>\n<li>ApplicationContextAware</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>InitializingBean</li>\n<li>DisposableBean</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Spring Cloud配置中心","date":"2022-02-20T06:04:14.000Z","updated":"2022-02-20T06:04:14.000Z","_content":"\n# 什么是Spring Cloud Config\n\n是Spring Cloud团队创建的一个用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。\n\n+ 服务端：也称为分布式配置中心，是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口\n+ 客户端：微服务架构中各个微服务应用或者基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动时从配置中心获取和加载配置信息\n\n# 有什么特点\n\n+ 实现了对服务端和客户端中环境变量和属性配置的抽象映射；\n+ 除了适用于Spring构建的应用还可以在任何其他语言运行的应用程序中使用；\n+ 由于返回的配置结果为JSON，因此可以结合Git客户端工具管理和访问配置内容；\n\n# 具体实例\n\n下面构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其从配置中心获取配置信息并绑定到代码中的整个过程。\n\n## 构建配置中心\n\n准备一个git仓库，创建一个`config-server`的Spring Boot项目，假设我们需要读取的配置中心为`config-client`，那么我们声明git仓库中该项目的默认配置文件为`config-client.yml`\n\n默认环境\n\n```yaml\ninfo:\n  profile: default\n```\n\ndev环境\n\n```yaml\ninfo:\n  profile: dev\n```\n\n## 构建配置中心\n\n借助Spring Cloud Config构建一个分布式配置中心非常简单，只需要三步：\n\n+ 创建基础Spring Boot工程，命名为`config-server-git`，并且引入spring-cloud-config-server依赖；\n\n+ 在Spring Boot主类上添加`@EnableConfigServer`注解，开启Spring Cloud Config的服务端功能；\n\n+ 在`application.yml`添加配置服务的基本信息以及Git仓库信息：\n\n  ```yaml\n  spring:\n    application:\n      name: config-server\n    cloud:\n      config:\n        server:\n          git:\n            uri: <这里的git仓库uri只能写到目录层，不能包括仓库名>\n  server:\n    port: 1201\n  ```\n\n  至此，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心完成，可以先将应用启动起来，确保没问题再进行下面的操作。\n\n  完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：\n\n  + /{application}/{profile}[/{label}]\n  + /{application}-{profile}.yml\n  + /{label}/{application}-{profile}.yml\n  + /{application}-{profile}.properties\n  + /{label}/{application}-{profile}.properties\n\n  假设访问`http://localhost:1201/config-client/dev/master`，获得如下返回：\n\n  ```json\n  {\n      \"name\": \"config-client\",\n      \"profiles\": [\n          \"dev\"\n      ],\n      \"label\": \"master\",\n      \"version\": null,\n      \"state\": null,\n      \"propertySources\": [\n          {\n              \"name\": \"http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml\",\n              \"source\": {\n                  \"info.profile\": \"dev\"\n              }\n          },\n          {\n              \"name\": \"http://git.oschina.net/didispace/config-repo-demo/config-client.yml\",\n              \"source\": {\n                  \"info.profile\": \"default\"\n              }\n          }\n      ]\n  }\n  ```\n\n  ## 构建客户端\n\n  接下来构建客户端，确保配置中心正常运作。创建一个Spring Boot应用，命名为`config-client`，引入下述依赖：\n\n  ```groovy\n  plugins {\n      id 'org.springframework.boot' version '2.6.3'\n      id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n      id 'java'\n  }\n  \n  group = 'com.hhp.config'\n  version = '0.0.1'\n  sourceCompatibility = '1.8'\n  \n  repositories {\n      maven { url 'https://maven.aliyun.com/repository/public/' }\n      mavenLocal()\n      mavenCentral()\n  }\n  \n  ext {\n      set('springCloudVersion', \"2021.0.1\")\n  }\n  \n  dependencies {\n      implementation 'org.springframework.boot:spring-boot-starter-web'\n      implementation 'org.springframework.cloud:spring-cloud-starter-config'\n      // 从Spring Cloud 2.0.4开始起禁用了bootstrap，所以需要引入这个依赖才会生效\n      implementation 'org.springframework.cloud:spring-cloud-starter-bootstrap'\n      testImplementation 'org.springframework.boot:spring-boot-starter-test'\n  }\n  \n  dependencyManagement {\n      imports {\n          mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n      }\n  }\n  \n  tasks.named('test') {\n      useJUnitPlatform()\n  }\n  \n  ```\n\n  创建`bootstrap.yml`配置文件，制定获取配置文件中的config-server-git的位置：\n\n  ```yaml\n  spring:\n    application:\n      name: config-client\n    cloud:\n      config:\n        uri: http://localhost:1201/\n        profile: default\n        label: master\n  \n  server:\n    port: 2001\n  ```\n\n  上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：\n\n  + spring.application.name：对应配置文件规则中的`{application}`部分\n  + spring.cloud.config.profile：对应配置文件规则中的`{profile}`部分\n  + spring.cloud.config.label：对应配置文件规则中的`{label}`部分\n  + spring.cloud.config.uri：配置中心`config-server`的地址\n\n  另外，也可以通过修改config-client中的profile为dev观察加载配置的变化；\n","source":"_posts/spring/spring-cloud-config.md","raw":"---\ntitle: Spring Cloud配置中心\ndate: 2022-02-20 14:04:14\nupdated: 2022-02-20 14:04:14\ntags: Spring Cloud\ncategories: 微服务架构学习\n---\n\n# 什么是Spring Cloud Config\n\n是Spring Cloud团队创建的一个用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。\n\n+ 服务端：也称为分布式配置中心，是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口\n+ 客户端：微服务架构中各个微服务应用或者基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动时从配置中心获取和加载配置信息\n\n# 有什么特点\n\n+ 实现了对服务端和客户端中环境变量和属性配置的抽象映射；\n+ 除了适用于Spring构建的应用还可以在任何其他语言运行的应用程序中使用；\n+ 由于返回的配置结果为JSON，因此可以结合Git客户端工具管理和访问配置内容；\n\n# 具体实例\n\n下面构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其从配置中心获取配置信息并绑定到代码中的整个过程。\n\n## 构建配置中心\n\n准备一个git仓库，创建一个`config-server`的Spring Boot项目，假设我们需要读取的配置中心为`config-client`，那么我们声明git仓库中该项目的默认配置文件为`config-client.yml`\n\n默认环境\n\n```yaml\ninfo:\n  profile: default\n```\n\ndev环境\n\n```yaml\ninfo:\n  profile: dev\n```\n\n## 构建配置中心\n\n借助Spring Cloud Config构建一个分布式配置中心非常简单，只需要三步：\n\n+ 创建基础Spring Boot工程，命名为`config-server-git`，并且引入spring-cloud-config-server依赖；\n\n+ 在Spring Boot主类上添加`@EnableConfigServer`注解，开启Spring Cloud Config的服务端功能；\n\n+ 在`application.yml`添加配置服务的基本信息以及Git仓库信息：\n\n  ```yaml\n  spring:\n    application:\n      name: config-server\n    cloud:\n      config:\n        server:\n          git:\n            uri: <这里的git仓库uri只能写到目录层，不能包括仓库名>\n  server:\n    port: 1201\n  ```\n\n  至此，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心完成，可以先将应用启动起来，确保没问题再进行下面的操作。\n\n  完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：\n\n  + /{application}/{profile}[/{label}]\n  + /{application}-{profile}.yml\n  + /{label}/{application}-{profile}.yml\n  + /{application}-{profile}.properties\n  + /{label}/{application}-{profile}.properties\n\n  假设访问`http://localhost:1201/config-client/dev/master`，获得如下返回：\n\n  ```json\n  {\n      \"name\": \"config-client\",\n      \"profiles\": [\n          \"dev\"\n      ],\n      \"label\": \"master\",\n      \"version\": null,\n      \"state\": null,\n      \"propertySources\": [\n          {\n              \"name\": \"http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml\",\n              \"source\": {\n                  \"info.profile\": \"dev\"\n              }\n          },\n          {\n              \"name\": \"http://git.oschina.net/didispace/config-repo-demo/config-client.yml\",\n              \"source\": {\n                  \"info.profile\": \"default\"\n              }\n          }\n      ]\n  }\n  ```\n\n  ## 构建客户端\n\n  接下来构建客户端，确保配置中心正常运作。创建一个Spring Boot应用，命名为`config-client`，引入下述依赖：\n\n  ```groovy\n  plugins {\n      id 'org.springframework.boot' version '2.6.3'\n      id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n      id 'java'\n  }\n  \n  group = 'com.hhp.config'\n  version = '0.0.1'\n  sourceCompatibility = '1.8'\n  \n  repositories {\n      maven { url 'https://maven.aliyun.com/repository/public/' }\n      mavenLocal()\n      mavenCentral()\n  }\n  \n  ext {\n      set('springCloudVersion', \"2021.0.1\")\n  }\n  \n  dependencies {\n      implementation 'org.springframework.boot:spring-boot-starter-web'\n      implementation 'org.springframework.cloud:spring-cloud-starter-config'\n      // 从Spring Cloud 2.0.4开始起禁用了bootstrap，所以需要引入这个依赖才会生效\n      implementation 'org.springframework.cloud:spring-cloud-starter-bootstrap'\n      testImplementation 'org.springframework.boot:spring-boot-starter-test'\n  }\n  \n  dependencyManagement {\n      imports {\n          mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n      }\n  }\n  \n  tasks.named('test') {\n      useJUnitPlatform()\n  }\n  \n  ```\n\n  创建`bootstrap.yml`配置文件，制定获取配置文件中的config-server-git的位置：\n\n  ```yaml\n  spring:\n    application:\n      name: config-client\n    cloud:\n      config:\n        uri: http://localhost:1201/\n        profile: default\n        label: master\n  \n  server:\n    port: 2001\n  ```\n\n  上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：\n\n  + spring.application.name：对应配置文件规则中的`{application}`部分\n  + spring.cloud.config.profile：对应配置文件规则中的`{profile}`部分\n  + spring.cloud.config.label：对应配置文件规则中的`{label}`部分\n  + spring.cloud.config.uri：配置中心`config-server`的地址\n\n  另外，也可以通过修改config-client中的profile为dev观察加载配置的变化；\n","slug":"spring/spring-cloud-config","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vp002x4f6191fn02ao","content":"<h1 id=\"什么是Spring-Cloud-Config\"><a href=\"#什么是Spring-Cloud-Config\" class=\"headerlink\" title=\"什么是Spring Cloud Config\"></a>什么是Spring Cloud Config</h1><p>是Spring Cloud团队创建的一个用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。</p>\n<ul>\n<li>服务端：也称为分布式配置中心，是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口</li>\n<li>客户端：微服务架构中各个微服务应用或者基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动时从配置中心获取和加载配置信息</li>\n</ul>\n<h1 id=\"有什么特点\"><a href=\"#有什么特点\" class=\"headerlink\" title=\"有什么特点\"></a>有什么特点</h1><ul>\n<li>实现了对服务端和客户端中环境变量和属性配置的抽象映射；</li>\n<li>除了适用于Spring构建的应用还可以在任何其他语言运行的应用程序中使用；</li>\n<li>由于返回的配置结果为JSON，因此可以结合Git客户端工具管理和访问配置内容；</li>\n</ul>\n<h1 id=\"具体实例\"><a href=\"#具体实例\" class=\"headerlink\" title=\"具体实例\"></a>具体实例</h1><p>下面构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其从配置中心获取配置信息并绑定到代码中的整个过程。</p>\n<h2 id=\"构建配置中心\"><a href=\"#构建配置中心\" class=\"headerlink\" title=\"构建配置中心\"></a>构建配置中心</h2><p>准备一个git仓库，创建一个<code>config-server</code>的Spring Boot项目，假设我们需要读取的配置中心为<code>config-client</code>，那么我们声明git仓库中该项目的默认配置文件为<code>config-client.yml</code></p>\n<p>默认环境</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">info:</span><br>  <span class=\"hljs-attr\">profile:</span> <span class=\"hljs-string\">default</span><br></code></pre></td></tr></table></figure>\n<p>dev环境</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">info:</span><br>  <span class=\"hljs-attr\">profile:</span> <span class=\"hljs-string\">dev</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"构建配置中心-1\"><a href=\"#构建配置中心-1\" class=\"headerlink\" title=\"构建配置中心\"></a>构建配置中心</h2><p>借助Spring Cloud Config构建一个分布式配置中心非常简单，只需要三步：</p>\n<ul>\n<li><p>创建基础Spring Boot工程，命名为<code>config-server-git</code>，并且引入spring-cloud-config-server依赖；</p>\n</li>\n<li><p>在Spring Boot主类上添加<code>@EnableConfigServer</code>注解，开启Spring Cloud Config的服务端功能；</p>\n</li>\n<li><p>在<code>application.yml</code>添加配置服务的基本信息以及Git仓库信息：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">config-server</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">config:</span><br>      <span class=\"hljs-attr\">server:</span><br>        <span class=\"hljs-attr\">git:</span><br>          <span class=\"hljs-attr\">uri:</span> <span class=\"hljs-string\">&lt;这里的git仓库uri只能写到目录层，不能包括仓库名&gt;</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">1201</span><br></code></pre></td></tr></table></figure>\n<p>至此，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心完成，可以先将应用启动起来，确保没问题再进行下面的操作。</p>\n<p>完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：</p>\n<ul>\n<li>/{application}/{profile}[/{label}]</li>\n<li>/{application}-{profile}.yml</li>\n<li>/{label}/{application}-{profile}.yml</li>\n<li>/{application}-{profile}.properties</li>\n<li>/{label}/{application}-{profile}.properties</li>\n</ul>\n<p>假设访问<code>http://localhost:1201/config-client/dev/master</code>，获得如下返回：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>    <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;config-client&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;profiles&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>        <span class=\"hljs-string\">&quot;dev&quot;</span><br>    <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;label&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;master&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;version&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">null</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;state&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">null</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;propertySources&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>        <span class=\"hljs-punctuation\">&#123;</span><br>            <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml&quot;</span><span class=\"hljs-punctuation\">,</span><br>            <span class=\"hljs-attr\">&quot;source&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>                <span class=\"hljs-attr\">&quot;info.profile&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;dev&quot;</span><br>            <span class=\"hljs-punctuation\">&#125;</span><br>        <span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br>        <span class=\"hljs-punctuation\">&#123;</span><br>            <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;http://git.oschina.net/didispace/config-repo-demo/config-client.yml&quot;</span><span class=\"hljs-punctuation\">,</span><br>            <span class=\"hljs-attr\">&quot;source&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>                <span class=\"hljs-attr\">&quot;info.profile&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;default&quot;</span><br>            <span class=\"hljs-punctuation\">&#125;</span><br>        <span class=\"hljs-punctuation\">&#125;</span><br>    <span class=\"hljs-punctuation\">]</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"构建客户端\"><a href=\"#构建客户端\" class=\"headerlink\" title=\"构建客户端\"></a>构建客户端</h2><p>接下来构建客户端，确保配置中心正常运作。创建一个Spring Boot应用，命名为<code>config-client</code>，引入下述依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.config&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-config&#x27;</span><br>    <span class=\"hljs-comment\">// 从Spring Cloud 2.0.4开始起禁用了bootstrap，所以需要引入这个依赖才会生效</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>创建<code>bootstrap.yml</code>配置文件，制定获取配置文件中的config-server-git的位置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">config-client</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">config:</span><br>      <span class=\"hljs-attr\">uri:</span> <span class=\"hljs-string\">http://localhost:1201/</span><br>      <span class=\"hljs-attr\">profile:</span> <span class=\"hljs-string\">default</span><br>      <span class=\"hljs-attr\">label:</span> <span class=\"hljs-string\">master</span><br><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2001</span><br></code></pre></td></tr></table></figure>\n<p>上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：</p>\n<ul>\n<li>spring.application.name：对应配置文件规则中的<code>&#123;application&#125;</code>部分</li>\n<li>spring.cloud.config.profile：对应配置文件规则中的<code>&#123;profile&#125;</code>部分</li>\n<li>spring.cloud.config.label：对应配置文件规则中的<code>&#123;label&#125;</code>部分</li>\n<li>spring.cloud.config.uri：配置中心<code>config-server</code>的地址</li>\n</ul>\n<p>另外，也可以通过修改config-client中的profile为dev观察加载配置的变化；</p>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":3575,"excerpt":"","more":"<h1 id=\"什么是Spring-Cloud-Config\"><a href=\"#什么是Spring-Cloud-Config\" class=\"headerlink\" title=\"什么是Spring Cloud Config\"></a>什么是Spring Cloud Config</h1><p>是Spring Cloud团队创建的一个用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。</p>\n<ul>\n<li>服务端：也称为分布式配置中心，是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口</li>\n<li>客户端：微服务架构中各个微服务应用或者基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动时从配置中心获取和加载配置信息</li>\n</ul>\n<h1 id=\"有什么特点\"><a href=\"#有什么特点\" class=\"headerlink\" title=\"有什么特点\"></a>有什么特点</h1><ul>\n<li>实现了对服务端和客户端中环境变量和属性配置的抽象映射；</li>\n<li>除了适用于Spring构建的应用还可以在任何其他语言运行的应用程序中使用；</li>\n<li>由于返回的配置结果为JSON，因此可以结合Git客户端工具管理和访问配置内容；</li>\n</ul>\n<h1 id=\"具体实例\"><a href=\"#具体实例\" class=\"headerlink\" title=\"具体实例\"></a>具体实例</h1><p>下面构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其从配置中心获取配置信息并绑定到代码中的整个过程。</p>\n<h2 id=\"构建配置中心\"><a href=\"#构建配置中心\" class=\"headerlink\" title=\"构建配置中心\"></a>构建配置中心</h2><p>准备一个git仓库，创建一个<code>config-server</code>的Spring Boot项目，假设我们需要读取的配置中心为<code>config-client</code>，那么我们声明git仓库中该项目的默认配置文件为<code>config-client.yml</code></p>\n<p>默认环境</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">info:</span><br>  <span class=\"hljs-attr\">profile:</span> <span class=\"hljs-string\">default</span><br></code></pre></td></tr></table></figure>\n<p>dev环境</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">info:</span><br>  <span class=\"hljs-attr\">profile:</span> <span class=\"hljs-string\">dev</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"构建配置中心-1\"><a href=\"#构建配置中心-1\" class=\"headerlink\" title=\"构建配置中心\"></a>构建配置中心</h2><p>借助Spring Cloud Config构建一个分布式配置中心非常简单，只需要三步：</p>\n<ul>\n<li><p>创建基础Spring Boot工程，命名为<code>config-server-git</code>，并且引入spring-cloud-config-server依赖；</p>\n</li>\n<li><p>在Spring Boot主类上添加<code>@EnableConfigServer</code>注解，开启Spring Cloud Config的服务端功能；</p>\n</li>\n<li><p>在<code>application.yml</code>添加配置服务的基本信息以及Git仓库信息：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">config-server</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">config:</span><br>      <span class=\"hljs-attr\">server:</span><br>        <span class=\"hljs-attr\">git:</span><br>          <span class=\"hljs-attr\">uri:</span> <span class=\"hljs-string\">&lt;这里的git仓库uri只能写到目录层，不能包括仓库名&gt;</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">1201</span><br></code></pre></td></tr></table></figure>\n<p>至此，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心完成，可以先将应用启动起来，确保没问题再进行下面的操作。</p>\n<p>完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：</p>\n<ul>\n<li>/{application}/{profile}[/{label}]</li>\n<li>/{application}-{profile}.yml</li>\n<li>/{label}/{application}-{profile}.yml</li>\n<li>/{application}-{profile}.properties</li>\n<li>/{label}/{application}-{profile}.properties</li>\n</ul>\n<p>假设访问<code>http://localhost:1201/config-client/dev/master</code>，获得如下返回：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>    <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;config-client&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;profiles&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>        <span class=\"hljs-string\">&quot;dev&quot;</span><br>    <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;label&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;master&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;version&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">null</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;state&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">null</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;propertySources&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>        <span class=\"hljs-punctuation\">&#123;</span><br>            <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml&quot;</span><span class=\"hljs-punctuation\">,</span><br>            <span class=\"hljs-attr\">&quot;source&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>                <span class=\"hljs-attr\">&quot;info.profile&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;dev&quot;</span><br>            <span class=\"hljs-punctuation\">&#125;</span><br>        <span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br>        <span class=\"hljs-punctuation\">&#123;</span><br>            <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;http://git.oschina.net/didispace/config-repo-demo/config-client.yml&quot;</span><span class=\"hljs-punctuation\">,</span><br>            <span class=\"hljs-attr\">&quot;source&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>                <span class=\"hljs-attr\">&quot;info.profile&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;default&quot;</span><br>            <span class=\"hljs-punctuation\">&#125;</span><br>        <span class=\"hljs-punctuation\">&#125;</span><br>    <span class=\"hljs-punctuation\">]</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"构建客户端\"><a href=\"#构建客户端\" class=\"headerlink\" title=\"构建客户端\"></a>构建客户端</h2><p>接下来构建客户端，确保配置中心正常运作。创建一个Spring Boot应用，命名为<code>config-client</code>，引入下述依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.config&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-config&#x27;</span><br>    <span class=\"hljs-comment\">// 从Spring Cloud 2.0.4开始起禁用了bootstrap，所以需要引入这个依赖才会生效</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-bootstrap&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>创建<code>bootstrap.yml</code>配置文件，制定获取配置文件中的config-server-git的位置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">config-client</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">config:</span><br>      <span class=\"hljs-attr\">uri:</span> <span class=\"hljs-string\">http://localhost:1201/</span><br>      <span class=\"hljs-attr\">profile:</span> <span class=\"hljs-string\">default</span><br>      <span class=\"hljs-attr\">label:</span> <span class=\"hljs-string\">master</span><br><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2001</span><br></code></pre></td></tr></table></figure>\n<p>上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：</p>\n<ul>\n<li>spring.application.name：对应配置文件规则中的<code>&#123;application&#125;</code>部分</li>\n<li>spring.cloud.config.profile：对应配置文件规则中的<code>&#123;profile&#125;</code>部分</li>\n<li>spring.cloud.config.label：对应配置文件规则中的<code>&#123;label&#125;</code>部分</li>\n<li>spring.cloud.config.uri：配置中心<code>config-server</code>的地址</li>\n</ul>\n<p>另外，也可以通过修改config-client中的profile为dev观察加载配置的变化；</p>\n</li>\n</ul>\n"},{"title":"Spring Cloud分布式配置中心","date":"2022-02-20T09:37:20.000Z","updated":"2022-02-20T09:37:20.000Z","_content":"\n# 分布式配置中心\n\n我们回顾一下到目前为止已经接触过得微服务：\n\n+ 服务发现注册中心\n+ 服务消费者\n+ 服务提供者\n+ 配置中心\n+ 配置客户端\n\n所以可以发现：除了注册中心以外，其他的服务都可以抽象成一个微服务，因此也可以借鉴先前的经验做成高可用分布式架构。要做到上述配置，我们只需要遵守一个规则：将所有的Config Server都指向同一个Git仓库，这样所有配置的内容通过统一的共享文件系统来维护。\n\n![img](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/3-13.png)\n\n等到客户端指定Config Server位置时，只需要配置Config Server外的负载均衡即可。\n\n由此，我们可以得出一个结论：配置服务只是提供不同请求的一个微服务而已，所以只需要将其也注册为服务，这样所有客户端就可以通过服务的方式进行访问。\n\n# 配置刷新\n\n有时候需要对配置内容做实时更新，只需要集成Spring Boot Actuator即可。其中包括`/refresh`端点可以用于刷新配置。\n\n# 总结\n\n不难想到，当Git仓库的Web Hook与此功能进行关联。当Git提交变化时，就给对应配置主机发送`/refresh`请求实现配置信息的实时变更。\n\n当我们的系统发展壮大之后，维护这样的刷新清单也将成为一个非常大的负担，而且很容易犯错，那么有什么办法可以解决这个复杂度呢？后续我们将继续介绍如何通过Spring Cloud Bus来实现以消息总线的方式进行通知配置信息的变化，完成集群上的自动化更新。\n\n# 文章引用\n\n[1]: https://blog.didispace.com/springcloud4-2/\t\"Spring Cloud 构建微服务架构之分布式配置中心\"\n\n","source":"_posts/spring/spring-cloud-distribute-config.md","raw":"---\ntitle: Spring Cloud分布式配置中心\ndate: 2022-02-20 17:37:20\nupdated: 2022-02-20 17:37:20\ntags: Spring Cloud\ncategories: 微服务架构学习\n---\n\n# 分布式配置中心\n\n我们回顾一下到目前为止已经接触过得微服务：\n\n+ 服务发现注册中心\n+ 服务消费者\n+ 服务提供者\n+ 配置中心\n+ 配置客户端\n\n所以可以发现：除了注册中心以外，其他的服务都可以抽象成一个微服务，因此也可以借鉴先前的经验做成高可用分布式架构。要做到上述配置，我们只需要遵守一个规则：将所有的Config Server都指向同一个Git仓库，这样所有配置的内容通过统一的共享文件系统来维护。\n\n![img](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/3-13.png)\n\n等到客户端指定Config Server位置时，只需要配置Config Server外的负载均衡即可。\n\n由此，我们可以得出一个结论：配置服务只是提供不同请求的一个微服务而已，所以只需要将其也注册为服务，这样所有客户端就可以通过服务的方式进行访问。\n\n# 配置刷新\n\n有时候需要对配置内容做实时更新，只需要集成Spring Boot Actuator即可。其中包括`/refresh`端点可以用于刷新配置。\n\n# 总结\n\n不难想到，当Git仓库的Web Hook与此功能进行关联。当Git提交变化时，就给对应配置主机发送`/refresh`请求实现配置信息的实时变更。\n\n当我们的系统发展壮大之后，维护这样的刷新清单也将成为一个非常大的负担，而且很容易犯错，那么有什么办法可以解决这个复杂度呢？后续我们将继续介绍如何通过Spring Cloud Bus来实现以消息总线的方式进行通知配置信息的变化，完成集群上的自动化更新。\n\n# 文章引用\n\n[1]: https://blog.didispace.com/springcloud4-2/\t\"Spring Cloud 构建微服务架构之分布式配置中心\"\n\n","slug":"spring/spring-cloud-distribute-config","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vq00324f61fo4h38wi","content":"<h1 id=\"分布式配置中心\"><a href=\"#分布式配置中心\" class=\"headerlink\" title=\"分布式配置中心\"></a>分布式配置中心</h1><p>我们回顾一下到目前为止已经接触过得微服务：</p>\n<ul>\n<li>服务发现注册中心</li>\n<li>服务消费者</li>\n<li>服务提供者</li>\n<li>配置中心</li>\n<li>配置客户端</li>\n</ul>\n<p>所以可以发现：除了注册中心以外，其他的服务都可以抽象成一个微服务，因此也可以借鉴先前的经验做成高可用分布式架构。要做到上述配置，我们只需要遵守一个规则：将所有的Config Server都指向同一个Git仓库，这样所有配置的内容通过统一的共享文件系统来维护。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/3-13.png\" alt=\"img\"></p>\n<p>等到客户端指定Config Server位置时，只需要配置Config Server外的负载均衡即可。</p>\n<p>由此，我们可以得出一个结论：配置服务只是提供不同请求的一个微服务而已，所以只需要将其也注册为服务，这样所有客户端就可以通过服务的方式进行访问。</p>\n<h1 id=\"配置刷新\"><a href=\"#配置刷新\" class=\"headerlink\" title=\"配置刷新\"></a>配置刷新</h1><p>有时候需要对配置内容做实时更新，只需要集成Spring Boot Actuator即可。其中包括<code>/refresh</code>端点可以用于刷新配置。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>不难想到，当Git仓库的Web Hook与此功能进行关联。当Git提交变化时，就给对应配置主机发送<code>/refresh</code>请求实现配置信息的实时变更。</p>\n<p>当我们的系统发展壮大之后，维护这样的刷新清单也将成为一个非常大的负担，而且很容易犯错，那么有什么办法可以解决这个复杂度呢？后续我们将继续介绍如何通过Spring Cloud Bus来实现以消息总线的方式进行通知配置信息的变化，完成集群上的自动化更新。</p>\n<h1 id=\"文章引用\"><a href=\"#文章引用\" class=\"headerlink\" title=\"文章引用\"></a>文章引用</h1>","site":{"data":{}},"wordcount":571,"excerpt":"","more":"<h1 id=\"分布式配置中心\"><a href=\"#分布式配置中心\" class=\"headerlink\" title=\"分布式配置中心\"></a>分布式配置中心</h1><p>我们回顾一下到目前为止已经接触过得微服务：</p>\n<ul>\n<li>服务发现注册中心</li>\n<li>服务消费者</li>\n<li>服务提供者</li>\n<li>配置中心</li>\n<li>配置客户端</li>\n</ul>\n<p>所以可以发现：除了注册中心以外，其他的服务都可以抽象成一个微服务，因此也可以借鉴先前的经验做成高可用分布式架构。要做到上述配置，我们只需要遵守一个规则：将所有的Config Server都指向同一个Git仓库，这样所有配置的内容通过统一的共享文件系统来维护。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/3-13.png\" alt=\"img\"></p>\n<p>等到客户端指定Config Server位置时，只需要配置Config Server外的负载均衡即可。</p>\n<p>由此，我们可以得出一个结论：配置服务只是提供不同请求的一个微服务而已，所以只需要将其也注册为服务，这样所有客户端就可以通过服务的方式进行访问。</p>\n<h1 id=\"配置刷新\"><a href=\"#配置刷新\" class=\"headerlink\" title=\"配置刷新\"></a>配置刷新</h1><p>有时候需要对配置内容做实时更新，只需要集成Spring Boot Actuator即可。其中包括<code>/refresh</code>端点可以用于刷新配置。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>不难想到，当Git仓库的Web Hook与此功能进行关联。当Git提交变化时，就给对应配置主机发送<code>/refresh</code>请求实现配置信息的实时变更。</p>\n<p>当我们的系统发展壮大之后，维护这样的刷新清单也将成为一个非常大的负担，而且很容易犯错，那么有什么办法可以解决这个复杂度呢？后续我们将继续介绍如何通过Spring Cloud Bus来实现以消息总线的方式进行通知配置信息的变化，完成集群上的自动化更新。</p>\n<h1 id=\"文章引用\"><a href=\"#文章引用\" class=\"headerlink\" title=\"文章引用\"></a>文章引用</h1>"},{"title":"Spring Cloud服务消费（Feign)","date":"2022-02-20T05:16:17.000Z","updated":"2022-02-20T05:16:17.000Z","_content":"\n# Spring Cloud Open Feign\n\n一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它即可完成对Web服务接口的绑定，并且支持可插拔的支持。除此之外，Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供负载均衡的HTTP客户端。\n\n# 动手试试\n\n下面我们演示一下Spring Cloud Open Feign的基本使用：\n\n> 还是需要有eureka-server，eureka-client的支持\n\n复制一个项目，命名为`eureka-consumer-feign`，在Gradle配置文件中写入下列依赖：\n\n```groovy\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    implementation 'org.springframework.cloud:spring-cloud-starter-openfeign'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n```\n\n这里和普通的`eureka-client`不同的是，多了个`openfeign`的启动依赖；\n\n## 修改应用主类\n\n修改应用主类，通过`@EnableFeignClients`注解并且开启扫描Spring Cloud Feign客户端：\n\n```java\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaConsumerApplication {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaConsumerApplication.class, args);\n    }\n\n}\n```\n\n## 创建Feign客户端接口\n\n我们实现一个客户端接口，并且使用`@FeignClient`指定接口所需要调用的服务名称，接口中定义的各个函数使用Spring MVC注解就可以用来绑定服务提供方的REST接口\n\n```java\n@FeignClient(\"eureka-client\")\npublic interface DcClient {\n\n    @GetMapping(\"/dc\")\n    String consumer();\n}\n```\n\n## 修改Controller\n\n通过定义的feign客户端来调用服务提供方接口：\n\n```java\n@RestController\npublic class DcController {\n\n    @Resource\n    private DcClient dcClient;\n\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return dcClient.consumer();\n    }\n}\n```\n\n# 总结\n\n1. 在应用主类启用Open Feign服务\n2. 定义Feign客户端接口，接口中的函数只需要使用Spring MVC注解就可以绑定；\n3. 通过在控制器层定义feign客户端来调用服务提供方接口；\n\n# 运行结果\n\n跟之前一样，依次启动`eureka-server`, `eureka-client`以及`eureka-consumer-feign`来查看效果。\n","source":"_posts/spring/spring-cloud-open-feign.md","raw":"---\ntitle: Spring Cloud服务消费（Feign)\ndate: 2022-02-20 13:16:17\nupdated: 2022-02-20 13:16:17\ntags: Spring Cloud\ncategories: 微服务架构学习\n---\n\n# Spring Cloud Open Feign\n\n一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它即可完成对Web服务接口的绑定，并且支持可插拔的支持。除此之外，Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供负载均衡的HTTP客户端。\n\n# 动手试试\n\n下面我们演示一下Spring Cloud Open Feign的基本使用：\n\n> 还是需要有eureka-server，eureka-client的支持\n\n复制一个项目，命名为`eureka-consumer-feign`，在Gradle配置文件中写入下列依赖：\n\n```groovy\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    implementation 'org.springframework.cloud:spring-cloud-starter-openfeign'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n```\n\n这里和普通的`eureka-client`不同的是，多了个`openfeign`的启动依赖；\n\n## 修改应用主类\n\n修改应用主类，通过`@EnableFeignClients`注解并且开启扫描Spring Cloud Feign客户端：\n\n```java\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaConsumerApplication {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaConsumerApplication.class, args);\n    }\n\n}\n```\n\n## 创建Feign客户端接口\n\n我们实现一个客户端接口，并且使用`@FeignClient`指定接口所需要调用的服务名称，接口中定义的各个函数使用Spring MVC注解就可以用来绑定服务提供方的REST接口\n\n```java\n@FeignClient(\"eureka-client\")\npublic interface DcClient {\n\n    @GetMapping(\"/dc\")\n    String consumer();\n}\n```\n\n## 修改Controller\n\n通过定义的feign客户端来调用服务提供方接口：\n\n```java\n@RestController\npublic class DcController {\n\n    @Resource\n    private DcClient dcClient;\n\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return dcClient.consumer();\n    }\n}\n```\n\n# 总结\n\n1. 在应用主类启用Open Feign服务\n2. 定义Feign客户端接口，接口中的函数只需要使用Spring MVC注解就可以绑定；\n3. 通过在控制器层定义feign客户端来调用服务提供方接口；\n\n# 运行结果\n\n跟之前一样，依次启动`eureka-server`, `eureka-client`以及`eureka-consumer-feign`来查看效果。\n","slug":"spring/spring-cloud-open-feign","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vr00354f61871i82vb","content":"<h1 id=\"Spring-Cloud-Open-Feign\"><a href=\"#Spring-Cloud-Open-Feign\" class=\"headerlink\" title=\"Spring Cloud Open Feign\"></a>Spring Cloud Open Feign</h1><p>一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它即可完成对Web服务接口的绑定，并且支持可插拔的支持。除此之外，Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供负载均衡的HTTP客户端。</p>\n<h1 id=\"动手试试\"><a href=\"#动手试试\" class=\"headerlink\" title=\"动手试试\"></a>动手试试</h1><p>下面我们演示一下Spring Cloud Open Feign的基本使用：</p>\n<blockquote>\n<p>还是需要有eureka-server，eureka-client的支持</p>\n</blockquote>\n<p>复制一个项目，命名为<code>eureka-consumer-feign</code>，在Gradle配置文件中写入下列依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs groovy\">dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-openfeign&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里和普通的<code>eureka-client</code>不同的是，多了个<code>openfeign</code>的启动依赖；</p>\n<h2 id=\"修改应用主类\"><a href=\"#修改应用主类\" class=\"headerlink\" title=\"修改应用主类\"></a>修改应用主类</h2><p>修改应用主类，通过<code>@EnableFeignClients</code>注解并且开启扫描Spring Cloud Feign客户端：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableFeignClients</span><br><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaConsumerApplication</span> &#123;<br><br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-keyword\">public</span> RestTemplate <span class=\"hljs-title function_\">restTemplate</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建Feign客户端接口\"><a href=\"#创建Feign客户端接口\" class=\"headerlink\" title=\"创建Feign客户端接口\"></a>创建Feign客户端接口</h2><p>我们实现一个客户端接口，并且使用<code>@FeignClient</code>指定接口所需要调用的服务名称，接口中定义的各个函数使用Spring MVC注解就可以用来绑定服务提供方的REST接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@FeignClient(&quot;eureka-client&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">DcClient</span> &#123;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/dc&quot;)</span><br>    String <span class=\"hljs-title function_\">consumer</span><span class=\"hljs-params\">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"修改Controller\"><a href=\"#修改Controller\" class=\"headerlink\" title=\"修改Controller\"></a>修改Controller</h2><p>通过定义的feign客户端来调用服务提供方接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> DcClient dcClient;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/consumer&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> dcClient.consumer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>在应用主类启用Open Feign服务</li>\n<li>定义Feign客户端接口，接口中的函数只需要使用Spring MVC注解就可以绑定；</li>\n<li>通过在控制器层定义feign客户端来调用服务提供方接口；</li>\n</ol>\n<h1 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h1><p>跟之前一样，依次启动<code>eureka-server</code>, <code>eureka-client</code>以及<code>eureka-consumer-feign</code>来查看效果。</p>\n","site":{"data":{}},"wordcount":1771,"excerpt":"","more":"<h1 id=\"Spring-Cloud-Open-Feign\"><a href=\"#Spring-Cloud-Open-Feign\" class=\"headerlink\" title=\"Spring Cloud Open Feign\"></a>Spring Cloud Open Feign</h1><p>一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它即可完成对Web服务接口的绑定，并且支持可插拔的支持。除此之外，Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供负载均衡的HTTP客户端。</p>\n<h1 id=\"动手试试\"><a href=\"#动手试试\" class=\"headerlink\" title=\"动手试试\"></a>动手试试</h1><p>下面我们演示一下Spring Cloud Open Feign的基本使用：</p>\n<blockquote>\n<p>还是需要有eureka-server，eureka-client的支持</p>\n</blockquote>\n<p>复制一个项目，命名为<code>eureka-consumer-feign</code>，在Gradle配置文件中写入下列依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-openfeign&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里和普通的<code>eureka-client</code>不同的是，多了个<code>openfeign</code>的启动依赖；</p>\n<h2 id=\"修改应用主类\"><a href=\"#修改应用主类\" class=\"headerlink\" title=\"修改应用主类\"></a>修改应用主类</h2><p>修改应用主类，通过<code>@EnableFeignClients</code>注解并且开启扫描Spring Cloud Feign客户端：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableFeignClients</span><br><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaConsumerApplication</span> &#123;<br><br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-keyword\">public</span> RestTemplate <span class=\"hljs-title function_\">restTemplate</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建Feign客户端接口\"><a href=\"#创建Feign客户端接口\" class=\"headerlink\" title=\"创建Feign客户端接口\"></a>创建Feign客户端接口</h2><p>我们实现一个客户端接口，并且使用<code>@FeignClient</code>指定接口所需要调用的服务名称，接口中定义的各个函数使用Spring MVC注解就可以用来绑定服务提供方的REST接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@FeignClient(&quot;eureka-client&quot;)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">DcClient</span> &#123;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/dc&quot;)</span><br>    String <span class=\"hljs-title function_\">consumer</span><span class=\"hljs-params\">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"修改Controller\"><a href=\"#修改Controller\" class=\"headerlink\" title=\"修改Controller\"></a>修改Controller</h2><p>通过定义的feign客户端来调用服务提供方接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> DcClient dcClient;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/consumer&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> dcClient.consumer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>在应用主类启用Open Feign服务</li>\n<li>定义Feign客户端接口，接口中的函数只需要使用Spring MVC注解就可以绑定；</li>\n<li>通过在控制器层定义feign客户端来调用服务提供方接口；</li>\n</ol>\n<h1 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h1><p>跟之前一样，依次启动<code>eureka-server</code>, <code>eureka-client</code>以及<code>eureka-consumer-feign</code>来查看效果。</p>\n"},{"title":"Spring Cloud服务消费（Ribbon)","date":"2022-02-20T01:40:26.000Z","updated":"2022-02-20T01:40:26.000Z","_content":"\n# Spring Cloud Ribbon是什么\n\n是基于Netflix Ribbon实现的一套**客户端负载均衡工具**，是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问达到负载均衡的作用。\n\n# 具体操作\n\n我们将继续利用之前的`eureka-server`作为服务注册中心，`eureka-client`作为服务提供者。还是跟之前一样，使用Spring Initializer来新建Spring Boot应用。\n\n## 修改应用主类\n\n为`RestTemplate`增加`@LoadBalanced`注解：\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    \n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    \n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n## 修改Controller\n\n去掉原来通过`LoadBalancerClient`选取实例和拼接URL的步骤，直接通过RestTemplate来发起请求；\n\n```java\n@RestController\npublic class DcController {\n    \n    @Resource\n    private RestTemplate restTemplate;\n    \n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return restTemplate.getForObject(\"http://eureka-client/dc\", String.class);\n    }\n}\n```\n\n# 有什么不同呢？\n\n可以看到，我们去除了与`LoadBalancerClient`相关的逻辑之外，对于`RestTemplate`的使用，我们的第一个url参数有一些特别，直接采用了服务名的方式组成。\n\n这里的实现细节是Ribbon实现了一个拦截器，能够在进行实际调用的同时，自动选取服务实例。并将实际请求的IP地址和端口替换成服务名，从而完成服务接口的调用。\n","source":"_posts/spring/spring-cloud-ribbon.md","raw":"---\ntitle: Spring Cloud服务消费（Ribbon)\ndate: 2022-02-20 09:40:26\nupdated: 2022-02-20 09:40:26\ntags: Spring Cloud\ncategories: 微服务架构学习\n---\n\n# Spring Cloud Ribbon是什么\n\n是基于Netflix Ribbon实现的一套**客户端负载均衡工具**，是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问达到负载均衡的作用。\n\n# 具体操作\n\n我们将继续利用之前的`eureka-server`作为服务注册中心，`eureka-client`作为服务提供者。还是跟之前一样，使用Spring Initializer来新建Spring Boot应用。\n\n## 修改应用主类\n\n为`RestTemplate`增加`@LoadBalanced`注解：\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class Application {\n    \n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    \n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n## 修改Controller\n\n去掉原来通过`LoadBalancerClient`选取实例和拼接URL的步骤，直接通过RestTemplate来发起请求；\n\n```java\n@RestController\npublic class DcController {\n    \n    @Resource\n    private RestTemplate restTemplate;\n    \n    @GetMapping(\"/consumer\")\n    public String dc() {\n        return restTemplate.getForObject(\"http://eureka-client/dc\", String.class);\n    }\n}\n```\n\n# 有什么不同呢？\n\n可以看到，我们去除了与`LoadBalancerClient`相关的逻辑之外，对于`RestTemplate`的使用，我们的第一个url参数有一些特别，直接采用了服务名的方式组成。\n\n这里的实现细节是Ribbon实现了一个拦截器，能够在进行实际调用的同时，自动选取服务实例。并将实际请求的IP地址和端口替换成服务名，从而完成服务接口的调用。\n","slug":"spring/spring-cloud-ribbon","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vs003a4f6114060dmc","content":"<h1 id=\"Spring-Cloud-Ribbon是什么\"><a href=\"#Spring-Cloud-Ribbon是什么\" class=\"headerlink\" title=\"Spring Cloud Ribbon是什么\"></a>Spring Cloud Ribbon是什么</h1><p>是基于Netflix Ribbon实现的一套<strong>客户端负载均衡工具</strong>，是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问达到负载均衡的作用。</p>\n<h1 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h1><p>我们将继续利用之前的<code>eureka-server</code>作为服务注册中心，<code>eureka-client</code>作为服务提供者。还是跟之前一样，使用Spring Initializer来新建Spring Boot应用。</p>\n<h2 id=\"修改应用主类\"><a href=\"#修改应用主类\" class=\"headerlink\" title=\"修改应用主类\"></a>修改应用主类</h2><p>为<code>RestTemplate</code>增加<code>@LoadBalanced</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Application</span> &#123;<br>    <br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-meta\">@LoadBalanced</span><br>    <span class=\"hljs-keyword\">public</span> RestTemplate <span class=\"hljs-title function_\">restTemplate</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"修改Controller\"><a href=\"#修改Controller\" class=\"headerlink\" title=\"修改Controller\"></a>修改Controller</h2><p>去掉原来通过<code>LoadBalancerClient</code>选取实例和拼接URL的步骤，直接通过RestTemplate来发起请求；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br>    <br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> RestTemplate restTemplate;<br>    <br>    <span class=\"hljs-meta\">@GetMapping(&quot;/consumer&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> restTemplate.getForObject(<span class=\"hljs-string\">&quot;http://eureka-client/dc&quot;</span>, String.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"有什么不同呢？\"><a href=\"#有什么不同呢？\" class=\"headerlink\" title=\"有什么不同呢？\"></a>有什么不同呢？</h1><p>可以看到，我们去除了与<code>LoadBalancerClient</code>相关的逻辑之外，对于<code>RestTemplate</code>的使用，我们的第一个url参数有一些特别，直接采用了服务名的方式组成。</p>\n<p>这里的实现细节是Ribbon实现了一个拦截器，能够在进行实际调用的同时，自动选取服务实例。并将实际请求的IP地址和端口替换成服务名，从而完成服务接口的调用。</p>\n","site":{"data":{}},"wordcount":1028,"excerpt":"","more":"<h1 id=\"Spring-Cloud-Ribbon是什么\"><a href=\"#Spring-Cloud-Ribbon是什么\" class=\"headerlink\" title=\"Spring Cloud Ribbon是什么\"></a>Spring Cloud Ribbon是什么</h1><p>是基于Netflix Ribbon实现的一套<strong>客户端负载均衡工具</strong>，是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问达到负载均衡的作用。</p>\n<h1 id=\"具体操作\"><a href=\"#具体操作\" class=\"headerlink\" title=\"具体操作\"></a>具体操作</h1><p>我们将继续利用之前的<code>eureka-server</code>作为服务注册中心，<code>eureka-client</code>作为服务提供者。还是跟之前一样，使用Spring Initializer来新建Spring Boot应用。</p>\n<h2 id=\"修改应用主类\"><a href=\"#修改应用主类\" class=\"headerlink\" title=\"修改应用主类\"></a>修改应用主类</h2><p>为<code>RestTemplate</code>增加<code>@LoadBalanced</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Application</span> &#123;<br>    <br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-meta\">@LoadBalanced</span><br>    <span class=\"hljs-keyword\">public</span> RestTemplate <span class=\"hljs-title function_\">restTemplate</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"修改Controller\"><a href=\"#修改Controller\" class=\"headerlink\" title=\"修改Controller\"></a>修改Controller</h2><p>去掉原来通过<code>LoadBalancerClient</code>选取实例和拼接URL的步骤，直接通过RestTemplate来发起请求；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br>    <br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> RestTemplate restTemplate;<br>    <br>    <span class=\"hljs-meta\">@GetMapping(&quot;/consumer&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> restTemplate.getForObject(<span class=\"hljs-string\">&quot;http://eureka-client/dc&quot;</span>, String.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"有什么不同呢？\"><a href=\"#有什么不同呢？\" class=\"headerlink\" title=\"有什么不同呢？\"></a>有什么不同呢？</h1><p>可以看到，我们去除了与<code>LoadBalancerClient</code>相关的逻辑之外，对于<code>RestTemplate</code>的使用，我们的第一个url参数有一些特别，直接采用了服务名的方式组成。</p>\n<p>这里的实现细节是Ribbon实现了一个拦截器，能够在进行实际调用的同时，自动选取服务实例。并将实际请求的IP地址和端口替换成服务名，从而完成服务接口的调用。</p>\n"},{"title":"Spring知识汇总","date":"2022-02-24T11:45:04.000Z","updated":"2022-02-24T11:45:04.000Z","_content":"\n# 1. 为什么使用Spring\n\n+ IoC技术，容器帮忙管理依赖对象，不需要自己创建和管理依赖对象，更轻松实现程序解耦；\n+ 事务支持，使得操作事务更加方便；\n+ 提供面向切面的编程，可以更方便地处理某一类的问题；\n+ 更方便集成其他框架，比如Mybatis和Hibernate；\n\n\n\n# 2. 什么是AOP\n\n面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的技术；简单来说就是统一处理“切面”类问题的编程思想，比如统一处理日志，异常等；\n\n\n\n# 3. 什么是IoC\n\nIoC是Spring的核心，对于Spring框架来说，由Spring来负责控制对象的生命周期和对象之间的关系；\n\n控制指的是当前对象对内部成员的控制权；控制反转指的是这种控制权不由当前对象管理，由其他（类、第三方容器）来管理；\n\n\n\n# 4. Spring模块\n\n+ spring core：框架基础，提供IoC和依赖注入\n+ spring context：构建于core封装包基础上的context封装包，提供一种框架式的对象访问方法\n+ spring dao：提供JDBC抽象层\n+ spring aop：提供面向切面的编程实现，可以自定义拦截器、切点\n+ spring web：提供针对web开发的集成特性，例如文件上传，利用servlet listeners进行ioc容器初始化和针对web的ApplicationContext；\n+ spring web mvc：提供了web应用的Mode-View-Controller的实现；\n\n\n\n# 5. Spring常见的注入方式\n\n+ setter属性注入\n+ 构造方法注入\n+ 注解方式注入\n\n\n\n# 6. Spring的bean是线程安全的吗？\n\nSpring的bean默认是单例模式，并且Spring框架没有对单例bean进行多线程的封装处理；但由于大部分时候spring bean是无状态的，因此某种程度上来说bean也是安全的，如果bean有状态的话，就需要开发者自己保证线程安全。\n\n最简单的就是改变bean的作用域，将singleton变更为prototype，这样请求bean就相当于new Bean了，就可以保证线程安全；\n\n+ 有状态就是有数据存储功能\n+ 无状态就是不会保存数据\n\n\n\n# 7. Spring支持的Bean作用域\n\n+ singleton：Spring IoC容器只存在一个bean实例，bean以单例模式存在，是系统默认\n+ prototype：每次从容器调用bean都会创建一个新的实例；\n+ Web环境下的作用域\n  + request：每次http请求都会创建一个bean；\n  + session：同一个http session共享一个bean实例；\n  + global-session：用于portlet容器，每个portlet有单独的session，globalsession提供一个全局性的http session;\n\n**注意：**使用prototype作用域需要慎重考虑，因为频繁创建和销毁session会带来很大的性能开销；\n\n\n\n# 8. Spring自动装配Bean的方式\n\n+ no：默认值，没有自动装配，使用显式bean引用进行装配\n+ byName：根据bean名称注入对象依赖项；\n+ byType：根据类型注入对象依赖项；\n+ 构造函数：通过构造函数注入依赖，需要设置大量参数；\n\n\n\n# 9. Spring事务实现方式\n\n+ 声明式事务：基于XML配置文件和注解方式（在类上添加`@Transaction`注解）；\n+ 编码方式：提供编码的形式管理和维护事务；\n\n\n\n# 10. Spring事务的隔离\n\n+ ISOLATION_DEFAULT：使用底层数据库的隔离级别，数据库设置什么我就用什么；\n+ ISOLATION_READ_UNCOMMITED：未提交读，最低隔离级别，事务未提交时，就可被其他事务读取（出现幻读、脏读、不可重复读）；\n+ ISOLATION_READ_COMMITED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），sql server 的默认级别；\n+ ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），mysql 的默认级别；\n+ ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n\n\n# 11. Spring MVC的运行流程\n\n+ spring mvc 先将请求发送给 DispatcherServlet。\n+ DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。\n+ DispatcherServlet 再把请求提交到对应的 Controller。\n+ Controller 进行业务逻辑处理后，会返回一个ModelAndView。\n+ Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。\n+ 视图对象负责渲染返回给客户端。\n\n\n\n# 12. Spring MVC的组件\n\n+ 前置控制器 DispatcherServlet。\n+ 映射控制器 HandlerMapping。\n+ 处理器 Controller。\n+ 模型和视图 ModelAndView。\n+ 视图解析器 ViewResolver。\n\n\n\n# 13. @Autowired和Resource的区别\n\n## Autowired注解\n\n+ Autowired有一个问题：当一个类型有多个bean值的时候会造成无法选择具体注入哪一个的情况，此时需要配合@Qualifier使用；\n+ Autowired为Spring提供的注解；\n\n## Resource注解\n\n+ 由J2EE提供；\n+ 默认byName自动注入；\n+ 同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛异常；\n+ 指定了name，从上下文查找名称匹配的bean进行装配，找不到抛异常；\n+ 指定了type，从上下文找到类似匹配的唯一bean进行装配，找不到或者找到多个，都会抛异常；\n\n总结：使用@Resource可以减少代码和Spring之间的耦合\n\n\n\n# 14. 什么是Spring Boot\n\n为Spring服务，用来简化Spring应用的初始化搭建以及开发过程；\n\nSpring Boot有下列好处，这也是为什么现在流行广泛的原因；\n\n+ 配置简单\n+ 独立运行\n+ 自动装配\n+ 无代码生成和xml配置\n+ 提供应用监控\n+ 容易上手\n+ 提升开发效率\n\n\n\n# 15. Spring Boot的核心配置文件\n\nSpring Boot核心的两个配置文件：\n\n+ bootstrap.yml：有ApplicationContext加载，比application优先加载，且bootstrap里面的属性值不能被覆盖；\n+ application.yml：用于spring boot项目的自动化配置；\n\n\n\n# 16. Spring Boot实现热部署\n\n+ 使用Devtools启动热部署，添加devtools库，在配置文件中把spring.devtools.restart.enabled设置为true;\n+ 使用IntelliJ IDEA编译器，勾上自动编译或手动编译；\n","source":"_posts/spring/spring-summary.md","raw":"---\ntitle: Spring知识汇总\ndate: 2022-02-24 19:45:04\nupdated: 2022-02-24 19:45:04\ntags: Spring框架\ncategories: Spring\n---\n\n# 1. 为什么使用Spring\n\n+ IoC技术，容器帮忙管理依赖对象，不需要自己创建和管理依赖对象，更轻松实现程序解耦；\n+ 事务支持，使得操作事务更加方便；\n+ 提供面向切面的编程，可以更方便地处理某一类的问题；\n+ 更方便集成其他框架，比如Mybatis和Hibernate；\n\n\n\n# 2. 什么是AOP\n\n面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的技术；简单来说就是统一处理“切面”类问题的编程思想，比如统一处理日志，异常等；\n\n\n\n# 3. 什么是IoC\n\nIoC是Spring的核心，对于Spring框架来说，由Spring来负责控制对象的生命周期和对象之间的关系；\n\n控制指的是当前对象对内部成员的控制权；控制反转指的是这种控制权不由当前对象管理，由其他（类、第三方容器）来管理；\n\n\n\n# 4. Spring模块\n\n+ spring core：框架基础，提供IoC和依赖注入\n+ spring context：构建于core封装包基础上的context封装包，提供一种框架式的对象访问方法\n+ spring dao：提供JDBC抽象层\n+ spring aop：提供面向切面的编程实现，可以自定义拦截器、切点\n+ spring web：提供针对web开发的集成特性，例如文件上传，利用servlet listeners进行ioc容器初始化和针对web的ApplicationContext；\n+ spring web mvc：提供了web应用的Mode-View-Controller的实现；\n\n\n\n# 5. Spring常见的注入方式\n\n+ setter属性注入\n+ 构造方法注入\n+ 注解方式注入\n\n\n\n# 6. Spring的bean是线程安全的吗？\n\nSpring的bean默认是单例模式，并且Spring框架没有对单例bean进行多线程的封装处理；但由于大部分时候spring bean是无状态的，因此某种程度上来说bean也是安全的，如果bean有状态的话，就需要开发者自己保证线程安全。\n\n最简单的就是改变bean的作用域，将singleton变更为prototype，这样请求bean就相当于new Bean了，就可以保证线程安全；\n\n+ 有状态就是有数据存储功能\n+ 无状态就是不会保存数据\n\n\n\n# 7. Spring支持的Bean作用域\n\n+ singleton：Spring IoC容器只存在一个bean实例，bean以单例模式存在，是系统默认\n+ prototype：每次从容器调用bean都会创建一个新的实例；\n+ Web环境下的作用域\n  + request：每次http请求都会创建一个bean；\n  + session：同一个http session共享一个bean实例；\n  + global-session：用于portlet容器，每个portlet有单独的session，globalsession提供一个全局性的http session;\n\n**注意：**使用prototype作用域需要慎重考虑，因为频繁创建和销毁session会带来很大的性能开销；\n\n\n\n# 8. Spring自动装配Bean的方式\n\n+ no：默认值，没有自动装配，使用显式bean引用进行装配\n+ byName：根据bean名称注入对象依赖项；\n+ byType：根据类型注入对象依赖项；\n+ 构造函数：通过构造函数注入依赖，需要设置大量参数；\n\n\n\n# 9. Spring事务实现方式\n\n+ 声明式事务：基于XML配置文件和注解方式（在类上添加`@Transaction`注解）；\n+ 编码方式：提供编码的形式管理和维护事务；\n\n\n\n# 10. Spring事务的隔离\n\n+ ISOLATION_DEFAULT：使用底层数据库的隔离级别，数据库设置什么我就用什么；\n+ ISOLATION_READ_UNCOMMITED：未提交读，最低隔离级别，事务未提交时，就可被其他事务读取（出现幻读、脏读、不可重复读）；\n+ ISOLATION_READ_COMMITED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），sql server 的默认级别；\n+ ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），mysql 的默认级别；\n+ ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n\n\n# 11. Spring MVC的运行流程\n\n+ spring mvc 先将请求发送给 DispatcherServlet。\n+ DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。\n+ DispatcherServlet 再把请求提交到对应的 Controller。\n+ Controller 进行业务逻辑处理后，会返回一个ModelAndView。\n+ Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。\n+ 视图对象负责渲染返回给客户端。\n\n\n\n# 12. Spring MVC的组件\n\n+ 前置控制器 DispatcherServlet。\n+ 映射控制器 HandlerMapping。\n+ 处理器 Controller。\n+ 模型和视图 ModelAndView。\n+ 视图解析器 ViewResolver。\n\n\n\n# 13. @Autowired和Resource的区别\n\n## Autowired注解\n\n+ Autowired有一个问题：当一个类型有多个bean值的时候会造成无法选择具体注入哪一个的情况，此时需要配合@Qualifier使用；\n+ Autowired为Spring提供的注解；\n\n## Resource注解\n\n+ 由J2EE提供；\n+ 默认byName自动注入；\n+ 同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛异常；\n+ 指定了name，从上下文查找名称匹配的bean进行装配，找不到抛异常；\n+ 指定了type，从上下文找到类似匹配的唯一bean进行装配，找不到或者找到多个，都会抛异常；\n\n总结：使用@Resource可以减少代码和Spring之间的耦合\n\n\n\n# 14. 什么是Spring Boot\n\n为Spring服务，用来简化Spring应用的初始化搭建以及开发过程；\n\nSpring Boot有下列好处，这也是为什么现在流行广泛的原因；\n\n+ 配置简单\n+ 独立运行\n+ 自动装配\n+ 无代码生成和xml配置\n+ 提供应用监控\n+ 容易上手\n+ 提升开发效率\n\n\n\n# 15. Spring Boot的核心配置文件\n\nSpring Boot核心的两个配置文件：\n\n+ bootstrap.yml：有ApplicationContext加载，比application优先加载，且bootstrap里面的属性值不能被覆盖；\n+ application.yml：用于spring boot项目的自动化配置；\n\n\n\n# 16. Spring Boot实现热部署\n\n+ 使用Devtools启动热部署，添加devtools库，在配置文件中把spring.devtools.restart.enabled设置为true;\n+ 使用IntelliJ IDEA编译器，勾上自动编译或手动编译；\n","slug":"spring/spring-summary","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vs003d4f61ex76h9du","content":"<h1 id=\"1-为什么使用Spring\"><a href=\"#1-为什么使用Spring\" class=\"headerlink\" title=\"1. 为什么使用Spring\"></a>1. 为什么使用Spring</h1><ul>\n<li>IoC技术，容器帮忙管理依赖对象，不需要自己创建和管理依赖对象，更轻松实现程序解耦；</li>\n<li>事务支持，使得操作事务更加方便；</li>\n<li>提供面向切面的编程，可以更方便地处理某一类的问题；</li>\n<li>更方便集成其他框架，比如Mybatis和Hibernate；</li>\n</ul>\n<h1 id=\"2-什么是AOP\"><a href=\"#2-什么是AOP\" class=\"headerlink\" title=\"2. 什么是AOP\"></a>2. 什么是AOP</h1><p>面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的技术；简单来说就是统一处理“切面”类问题的编程思想，比如统一处理日志，异常等；</p>\n<h1 id=\"3-什么是IoC\"><a href=\"#3-什么是IoC\" class=\"headerlink\" title=\"3. 什么是IoC\"></a>3. 什么是IoC</h1><p>IoC是Spring的核心，对于Spring框架来说，由Spring来负责控制对象的生命周期和对象之间的关系；</p>\n<p>控制指的是当前对象对内部成员的控制权；控制反转指的是这种控制权不由当前对象管理，由其他（类、第三方容器）来管理；</p>\n<h1 id=\"4-Spring模块\"><a href=\"#4-Spring模块\" class=\"headerlink\" title=\"4. Spring模块\"></a>4. Spring模块</h1><ul>\n<li>spring core：框架基础，提供IoC和依赖注入</li>\n<li>spring context：构建于core封装包基础上的context封装包，提供一种框架式的对象访问方法</li>\n<li>spring dao：提供JDBC抽象层</li>\n<li>spring aop：提供面向切面的编程实现，可以自定义拦截器、切点</li>\n<li>spring web：提供针对web开发的集成特性，例如文件上传，利用servlet listeners进行ioc容器初始化和针对web的ApplicationContext；</li>\n<li>spring web mvc：提供了web应用的Mode-View-Controller的实现；</li>\n</ul>\n<h1 id=\"5-Spring常见的注入方式\"><a href=\"#5-Spring常见的注入方式\" class=\"headerlink\" title=\"5. Spring常见的注入方式\"></a>5. Spring常见的注入方式</h1><ul>\n<li>setter属性注入</li>\n<li>构造方法注入</li>\n<li>注解方式注入</li>\n</ul>\n<h1 id=\"6-Spring的bean是线程安全的吗？\"><a href=\"#6-Spring的bean是线程安全的吗？\" class=\"headerlink\" title=\"6. Spring的bean是线程安全的吗？\"></a>6. Spring的bean是线程安全的吗？</h1><p>Spring的bean默认是单例模式，并且Spring框架没有对单例bean进行多线程的封装处理；但由于大部分时候spring bean是无状态的，因此某种程度上来说bean也是安全的，如果bean有状态的话，就需要开发者自己保证线程安全。</p>\n<p>最简单的就是改变bean的作用域，将singleton变更为prototype，这样请求bean就相当于new Bean了，就可以保证线程安全；</p>\n<ul>\n<li>有状态就是有数据存储功能</li>\n<li>无状态就是不会保存数据</li>\n</ul>\n<h1 id=\"7-Spring支持的Bean作用域\"><a href=\"#7-Spring支持的Bean作用域\" class=\"headerlink\" title=\"7. Spring支持的Bean作用域\"></a>7. Spring支持的Bean作用域</h1><ul>\n<li>singleton：Spring IoC容器只存在一个bean实例，bean以单例模式存在，是系统默认</li>\n<li>prototype：每次从容器调用bean都会创建一个新的实例；</li>\n<li>Web环境下的作用域<ul>\n<li>request：每次http请求都会创建一个bean；</li>\n<li>session：同一个http session共享一个bean实例；</li>\n<li>global-session：用于portlet容器，每个portlet有单独的session，globalsession提供一个全局性的http session;</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：</strong>使用prototype作用域需要慎重考虑，因为频繁创建和销毁session会带来很大的性能开销；</p>\n<h1 id=\"8-Spring自动装配Bean的方式\"><a href=\"#8-Spring自动装配Bean的方式\" class=\"headerlink\" title=\"8. Spring自动装配Bean的方式\"></a>8. Spring自动装配Bean的方式</h1><ul>\n<li>no：默认值，没有自动装配，使用显式bean引用进行装配</li>\n<li>byName：根据bean名称注入对象依赖项；</li>\n<li>byType：根据类型注入对象依赖项；</li>\n<li>构造函数：通过构造函数注入依赖，需要设置大量参数；</li>\n</ul>\n<h1 id=\"9-Spring事务实现方式\"><a href=\"#9-Spring事务实现方式\" class=\"headerlink\" title=\"9. Spring事务实现方式\"></a>9. Spring事务实现方式</h1><ul>\n<li>声明式事务：基于XML配置文件和注解方式（在类上添加<code>@Transaction</code>注解）；</li>\n<li>编码方式：提供编码的形式管理和维护事务；</li>\n</ul>\n<h1 id=\"10-Spring事务的隔离\"><a href=\"#10-Spring事务的隔离\" class=\"headerlink\" title=\"10. Spring事务的隔离\"></a>10. Spring事务的隔离</h1><ul>\n<li>ISOLATION_DEFAULT：使用底层数据库的隔离级别，数据库设置什么我就用什么；</li>\n<li>ISOLATION_READ_UNCOMMITED：未提交读，最低隔离级别，事务未提交时，就可被其他事务读取（出现幻读、脏读、不可重复读）；</li>\n<li>ISOLATION_READ_COMMITED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），sql server 的默认级别；</li>\n<li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），mysql 的默认级别；</li>\n<li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ul>\n<h1 id=\"11-Spring-MVC的运行流程\"><a href=\"#11-Spring-MVC的运行流程\" class=\"headerlink\" title=\"11. Spring MVC的运行流程\"></a>11. Spring MVC的运行流程</h1><ul>\n<li>spring mvc 先将请求发送给 DispatcherServlet。</li>\n<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>\n<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>\n<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>\n<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>\n<li>视图对象负责渲染返回给客户端。</li>\n</ul>\n<h1 id=\"12-Spring-MVC的组件\"><a href=\"#12-Spring-MVC的组件\" class=\"headerlink\" title=\"12. Spring MVC的组件\"></a>12. Spring MVC的组件</h1><ul>\n<li>前置控制器 DispatcherServlet。</li>\n<li>映射控制器 HandlerMapping。</li>\n<li>处理器 Controller。</li>\n<li>模型和视图 ModelAndView。</li>\n<li>视图解析器 ViewResolver。</li>\n</ul>\n<h1 id=\"13-Autowired和Resource的区别\"><a href=\"#13-Autowired和Resource的区别\" class=\"headerlink\" title=\"13. @Autowired和Resource的区别\"></a>13. @Autowired和Resource的区别</h1><h2 id=\"Autowired注解\"><a href=\"#Autowired注解\" class=\"headerlink\" title=\"Autowired注解\"></a>Autowired注解</h2><ul>\n<li>Autowired有一个问题：当一个类型有多个bean值的时候会造成无法选择具体注入哪一个的情况，此时需要配合@Qualifier使用；</li>\n<li>Autowired为Spring提供的注解；</li>\n</ul>\n<h2 id=\"Resource注解\"><a href=\"#Resource注解\" class=\"headerlink\" title=\"Resource注解\"></a>Resource注解</h2><ul>\n<li>由J2EE提供；</li>\n<li>默认byName自动注入；</li>\n<li>同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛异常；</li>\n<li>指定了name，从上下文查找名称匹配的bean进行装配，找不到抛异常；</li>\n<li>指定了type，从上下文找到类似匹配的唯一bean进行装配，找不到或者找到多个，都会抛异常；</li>\n</ul>\n<p>总结：使用@Resource可以减少代码和Spring之间的耦合</p>\n<h1 id=\"14-什么是Spring-Boot\"><a href=\"#14-什么是Spring-Boot\" class=\"headerlink\" title=\"14. 什么是Spring Boot\"></a>14. 什么是Spring Boot</h1><p>为Spring服务，用来简化Spring应用的初始化搭建以及开发过程；</p>\n<p>Spring Boot有下列好处，这也是为什么现在流行广泛的原因；</p>\n<ul>\n<li>配置简单</li>\n<li>独立运行</li>\n<li>自动装配</li>\n<li>无代码生成和xml配置</li>\n<li>提供应用监控</li>\n<li>容易上手</li>\n<li>提升开发效率</li>\n</ul>\n<h1 id=\"15-Spring-Boot的核心配置文件\"><a href=\"#15-Spring-Boot的核心配置文件\" class=\"headerlink\" title=\"15. Spring Boot的核心配置文件\"></a>15. Spring Boot的核心配置文件</h1><p>Spring Boot核心的两个配置文件：</p>\n<ul>\n<li>bootstrap.yml：有ApplicationContext加载，比application优先加载，且bootstrap里面的属性值不能被覆盖；</li>\n<li>application.yml：用于spring boot项目的自动化配置；</li>\n</ul>\n<h1 id=\"16-Spring-Boot实现热部署\"><a href=\"#16-Spring-Boot实现热部署\" class=\"headerlink\" title=\"16. Spring Boot实现热部署\"></a>16. Spring Boot实现热部署</h1><ul>\n<li>使用Devtools启动热部署，添加devtools库，在配置文件中把spring.devtools.restart.enabled设置为true;</li>\n<li>使用IntelliJ IDEA编译器，勾上自动编译或手动编译；</li>\n</ul>\n","site":{"data":{}},"wordcount":2804,"excerpt":"","more":"<h1 id=\"1-为什么使用Spring\"><a href=\"#1-为什么使用Spring\" class=\"headerlink\" title=\"1. 为什么使用Spring\"></a>1. 为什么使用Spring</h1><ul>\n<li>IoC技术，容器帮忙管理依赖对象，不需要自己创建和管理依赖对象，更轻松实现程序解耦；</li>\n<li>事务支持，使得操作事务更加方便；</li>\n<li>提供面向切面的编程，可以更方便地处理某一类的问题；</li>\n<li>更方便集成其他框架，比如Mybatis和Hibernate；</li>\n</ul>\n<h1 id=\"2-什么是AOP\"><a href=\"#2-什么是AOP\" class=\"headerlink\" title=\"2. 什么是AOP\"></a>2. 什么是AOP</h1><p>面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的技术；简单来说就是统一处理“切面”类问题的编程思想，比如统一处理日志，异常等；</p>\n<h1 id=\"3-什么是IoC\"><a href=\"#3-什么是IoC\" class=\"headerlink\" title=\"3. 什么是IoC\"></a>3. 什么是IoC</h1><p>IoC是Spring的核心，对于Spring框架来说，由Spring来负责控制对象的生命周期和对象之间的关系；</p>\n<p>控制指的是当前对象对内部成员的控制权；控制反转指的是这种控制权不由当前对象管理，由其他（类、第三方容器）来管理；</p>\n<h1 id=\"4-Spring模块\"><a href=\"#4-Spring模块\" class=\"headerlink\" title=\"4. Spring模块\"></a>4. Spring模块</h1><ul>\n<li>spring core：框架基础，提供IoC和依赖注入</li>\n<li>spring context：构建于core封装包基础上的context封装包，提供一种框架式的对象访问方法</li>\n<li>spring dao：提供JDBC抽象层</li>\n<li>spring aop：提供面向切面的编程实现，可以自定义拦截器、切点</li>\n<li>spring web：提供针对web开发的集成特性，例如文件上传，利用servlet listeners进行ioc容器初始化和针对web的ApplicationContext；</li>\n<li>spring web mvc：提供了web应用的Mode-View-Controller的实现；</li>\n</ul>\n<h1 id=\"5-Spring常见的注入方式\"><a href=\"#5-Spring常见的注入方式\" class=\"headerlink\" title=\"5. Spring常见的注入方式\"></a>5. Spring常见的注入方式</h1><ul>\n<li>setter属性注入</li>\n<li>构造方法注入</li>\n<li>注解方式注入</li>\n</ul>\n<h1 id=\"6-Spring的bean是线程安全的吗？\"><a href=\"#6-Spring的bean是线程安全的吗？\" class=\"headerlink\" title=\"6. Spring的bean是线程安全的吗？\"></a>6. Spring的bean是线程安全的吗？</h1><p>Spring的bean默认是单例模式，并且Spring框架没有对单例bean进行多线程的封装处理；但由于大部分时候spring bean是无状态的，因此某种程度上来说bean也是安全的，如果bean有状态的话，就需要开发者自己保证线程安全。</p>\n<p>最简单的就是改变bean的作用域，将singleton变更为prototype，这样请求bean就相当于new Bean了，就可以保证线程安全；</p>\n<ul>\n<li>有状态就是有数据存储功能</li>\n<li>无状态就是不会保存数据</li>\n</ul>\n<h1 id=\"7-Spring支持的Bean作用域\"><a href=\"#7-Spring支持的Bean作用域\" class=\"headerlink\" title=\"7. Spring支持的Bean作用域\"></a>7. Spring支持的Bean作用域</h1><ul>\n<li>singleton：Spring IoC容器只存在一个bean实例，bean以单例模式存在，是系统默认</li>\n<li>prototype：每次从容器调用bean都会创建一个新的实例；</li>\n<li>Web环境下的作用域<ul>\n<li>request：每次http请求都会创建一个bean；</li>\n<li>session：同一个http session共享一个bean实例；</li>\n<li>global-session：用于portlet容器，每个portlet有单独的session，globalsession提供一个全局性的http session;</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：</strong>使用prototype作用域需要慎重考虑，因为频繁创建和销毁session会带来很大的性能开销；</p>\n<h1 id=\"8-Spring自动装配Bean的方式\"><a href=\"#8-Spring自动装配Bean的方式\" class=\"headerlink\" title=\"8. Spring自动装配Bean的方式\"></a>8. Spring自动装配Bean的方式</h1><ul>\n<li>no：默认值，没有自动装配，使用显式bean引用进行装配</li>\n<li>byName：根据bean名称注入对象依赖项；</li>\n<li>byType：根据类型注入对象依赖项；</li>\n<li>构造函数：通过构造函数注入依赖，需要设置大量参数；</li>\n</ul>\n<h1 id=\"9-Spring事务实现方式\"><a href=\"#9-Spring事务实现方式\" class=\"headerlink\" title=\"9. Spring事务实现方式\"></a>9. Spring事务实现方式</h1><ul>\n<li>声明式事务：基于XML配置文件和注解方式（在类上添加<code>@Transaction</code>注解）；</li>\n<li>编码方式：提供编码的形式管理和维护事务；</li>\n</ul>\n<h1 id=\"10-Spring事务的隔离\"><a href=\"#10-Spring事务的隔离\" class=\"headerlink\" title=\"10. Spring事务的隔离\"></a>10. Spring事务的隔离</h1><ul>\n<li>ISOLATION_DEFAULT：使用底层数据库的隔离级别，数据库设置什么我就用什么；</li>\n<li>ISOLATION_READ_UNCOMMITED：未提交读，最低隔离级别，事务未提交时，就可被其他事务读取（出现幻读、脏读、不可重复读）；</li>\n<li>ISOLATION_READ_COMMITED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），sql server 的默认级别；</li>\n<li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），mysql 的默认级别；</li>\n<li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ul>\n<h1 id=\"11-Spring-MVC的运行流程\"><a href=\"#11-Spring-MVC的运行流程\" class=\"headerlink\" title=\"11. Spring MVC的运行流程\"></a>11. Spring MVC的运行流程</h1><ul>\n<li>spring mvc 先将请求发送给 DispatcherServlet。</li>\n<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>\n<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>\n<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>\n<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>\n<li>视图对象负责渲染返回给客户端。</li>\n</ul>\n<h1 id=\"12-Spring-MVC的组件\"><a href=\"#12-Spring-MVC的组件\" class=\"headerlink\" title=\"12. Spring MVC的组件\"></a>12. Spring MVC的组件</h1><ul>\n<li>前置控制器 DispatcherServlet。</li>\n<li>映射控制器 HandlerMapping。</li>\n<li>处理器 Controller。</li>\n<li>模型和视图 ModelAndView。</li>\n<li>视图解析器 ViewResolver。</li>\n</ul>\n<h1 id=\"13-Autowired和Resource的区别\"><a href=\"#13-Autowired和Resource的区别\" class=\"headerlink\" title=\"13. @Autowired和Resource的区别\"></a>13. @Autowired和Resource的区别</h1><h2 id=\"Autowired注解\"><a href=\"#Autowired注解\" class=\"headerlink\" title=\"Autowired注解\"></a>Autowired注解</h2><ul>\n<li>Autowired有一个问题：当一个类型有多个bean值的时候会造成无法选择具体注入哪一个的情况，此时需要配合@Qualifier使用；</li>\n<li>Autowired为Spring提供的注解；</li>\n</ul>\n<h2 id=\"Resource注解\"><a href=\"#Resource注解\" class=\"headerlink\" title=\"Resource注解\"></a>Resource注解</h2><ul>\n<li>由J2EE提供；</li>\n<li>默认byName自动注入；</li>\n<li>同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛异常；</li>\n<li>指定了name，从上下文查找名称匹配的bean进行装配，找不到抛异常；</li>\n<li>指定了type，从上下文找到类似匹配的唯一bean进行装配，找不到或者找到多个，都会抛异常；</li>\n</ul>\n<p>总结：使用@Resource可以减少代码和Spring之间的耦合</p>\n<h1 id=\"14-什么是Spring-Boot\"><a href=\"#14-什么是Spring-Boot\" class=\"headerlink\" title=\"14. 什么是Spring Boot\"></a>14. 什么是Spring Boot</h1><p>为Spring服务，用来简化Spring应用的初始化搭建以及开发过程；</p>\n<p>Spring Boot有下列好处，这也是为什么现在流行广泛的原因；</p>\n<ul>\n<li>配置简单</li>\n<li>独立运行</li>\n<li>自动装配</li>\n<li>无代码生成和xml配置</li>\n<li>提供应用监控</li>\n<li>容易上手</li>\n<li>提升开发效率</li>\n</ul>\n<h1 id=\"15-Spring-Boot的核心配置文件\"><a href=\"#15-Spring-Boot的核心配置文件\" class=\"headerlink\" title=\"15. Spring Boot的核心配置文件\"></a>15. Spring Boot的核心配置文件</h1><p>Spring Boot核心的两个配置文件：</p>\n<ul>\n<li>bootstrap.yml：有ApplicationContext加载，比application优先加载，且bootstrap里面的属性值不能被覆盖；</li>\n<li>application.yml：用于spring boot项目的自动化配置；</li>\n</ul>\n<h1 id=\"16-Spring-Boot实现热部署\"><a href=\"#16-Spring-Boot实现热部署\" class=\"headerlink\" title=\"16. Spring Boot实现热部署\"></a>16. Spring Boot实现热部署</h1><ul>\n<li>使用Devtools启动热部署，添加devtools库，在配置文件中把spring.devtools.restart.enabled设置为true;</li>\n<li>使用IntelliJ IDEA编译器，勾上自动编译或手动编译；</li>\n</ul>\n"},{"title":"初识Spring Cloud","date":"2022-02-19T03:21:30.000Z","updated":"2022-02-19T03:21:30.000Z","_content":"\n# Spring Cloud是什么？\n\n一个基于Spring Boot实现的云应用开发工具，为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话以及集群状态管理等操作提供了一种简单的开发方式。\n\n# 微服务架构\n\n“微服务架构”这几年非常火热，以至于关注微服务架构相关的开源产品被反复提及（比如：Netflix和Dubbo），Spring Cloud也因Spring社区强大的知名度和影响力被广大架构师和开发者备受关注。\n\n简单来说：微服务架构是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每隔服务都能独立部署、独立维护、独立扩展，服务之间通过诸如RESTful API的方式相互调用。\n\n# 服务治理\n\n服务治理就是提供了微服务架构中各个微服务实例的快速上线或下线且保持各服务能正常通信的能力方案总称。\n\n## 服务治理可以带来什么好处呢\n\n+ **更高的可用性**\n\n  支持动态的服务实例集群环境，任何服务实例都可以随时上线下线。并且当一个微服务实例不可用时，治理服务器可以将请求转发其他服务提供者，当新服务上线时，也能够快速分担服务调用请求；\n\n  \n\n+ **负载均衡**\n\n  提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；\n\n  \n\n+ **提升应用弹性**\n\n  服务治理客户端定时从服务治理服务器中复制一份实例信息缓存到本地，即使当服务治理服务器不可用时，服务消费者也可以使用本地的缓存去访问相应的服务，而不至于中断服务。通过这种机制，极大提高应用的弹性；\n\n  \n\n+ **高可用性集群**\n\n  可以构建服务治理集群，通过互相注册机制，将每隔治理服务器所管辖的服务信息列表进行交换，使服务治理拥有更高的可用性；\n\n# Spring Cloud的基本使用\n\n从上面对于微服务的治理和定义，我们搭建一个最基础和简单的微服务架构：\n\n+ 服务注册中心\n+ 服务提供方\n\n这里我们使用Spring Cloud Eureka的基础服务来搭建，下面按照操作手册来做一下看看。\n\n## 创建服务发现中心\n\n使用IntelliJ IDEA创建一个Spring Boot项目，依赖管理工具选择Gradle。你可以使用Spring Initializer来生成项目：\n\n<img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-143445@2x.png\" alt=\"s\" style=\"zoom:50%;\" />\n\n生成项目后，我们找到项目目录的启动入口文件\n\n```java\n// 新增EnableEurekaServer注解，将该工程标识为一个服务注册中心\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n\n}\n```\n\n找到`application.properties`文件，将其更改为`application.yml`（只是习惯用YML文件），修改一下Eureka Server的配置如下：\n\n```yaml\n# 服务注册中心的名称\nspring:\n  application:\n    name: eureka-server\n\n# 服务注册中心监听的端口\nserver:\n  port: 1001\n\n# 暂时禁用服务端注册客户端的行为\neureka:\n  instance:\n    hostname: 127.0.0.1\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n到此，服务注册中心搭建完成，运行这个项目并且打开浏览器输入`http://localhost:1001/`就可以看到服务注册中心的基本页面了：\n\n![](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-144301@2x.png)\n\n## 创建服务提供方\n\n如法炮制，我们通过Spring Initializer再创建一个Spring Boot项目，名为eureka-client，对应的gradle依赖如下：\n\n主要提供的是：\n\n+ spring-cloud-starter-netflix-eureka-client\n+ spring-boot-starter-web\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.6.3'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'com.hhp.registry'\nversion = '0.0.1'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\next {\n    set('springCloudVersion', \"2021.0.1\")\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n\n```\n\n我们新建一个Rest接口：\n\n> 需要注意的是：这里的DiscoveryClient会出现Netflix和Spring Cloud的，选择Spring Cloud的官方依赖\n\n```java\n@RestController\npublic class DcController {\n\n    // 选择Spring Cloud的依赖包导入\n    @Resource\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping(\"/dc\")\n    public String dc() {\n        String services = \"Service: \" + discoveryClient.getServices();\n        System.out.println(services);\n        return services;\n    }\n}\n```\n\n回到eureka-client的启动类，我们加上`@EnableDiscoveryClient`注解\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaClientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n```\n\n打开eureka-client的`application.yml`文件，将下列的配置贴进去：\n\n```yaml\nspring:\n  application:\n    name: eureka-client\nserver:\n  port: 2001\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1001/eureka/\n```\n\n至此，服务提供方也创建成功。将服务注册中心和服务提供方都运行起来，打开注册中心可以看到eureka-client已经成功被注册。\n\n![image-20220219162841266](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220219162841266.png)\n\n# Spring Cloud Consul服务注册\n\n使用Spring Cloud Consul实现，可以轻松将基于Spring Boot的微服务应用注册到Consul上，并通此实现微服务架构中的服务治理。\n\n如果需要将上述的eureka-client转换成使用consul来，只需要按照下面2步操作即可：\n\n+ 将spring-cloud-eureka-client依赖替换成spring-cloud-consul-discovery依赖\n+ 修改application.yml中的配置\n\n```yaml\nspring:\n  cloud:\n    consul:\n      host: 127.0.0.1\n      port: 8500\n```\n\n其他配置不需要更改，并且由于Consul本身已经集成了服务端，所以不需要额外创建`eureka-server`这样的服务。直接通过下载consul服务端程序即可使用。此过程不再赘述。\n\n更多关于Consul的使用指南，可以查看官方文档：https://www.consul.io/\n","source":"_posts/spring/springcloud-getting-started.md","raw":"---\ntitle: 初识Spring Cloud\ndate: 2022-02-19 11:21:30\nupdated: 2022-02-19 11:21:30\ntags: Spring Cloud\ncategories: 微服务架构学习\n---\n\n# Spring Cloud是什么？\n\n一个基于Spring Boot实现的云应用开发工具，为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话以及集群状态管理等操作提供了一种简单的开发方式。\n\n# 微服务架构\n\n“微服务架构”这几年非常火热，以至于关注微服务架构相关的开源产品被反复提及（比如：Netflix和Dubbo），Spring Cloud也因Spring社区强大的知名度和影响力被广大架构师和开发者备受关注。\n\n简单来说：微服务架构是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每隔服务都能独立部署、独立维护、独立扩展，服务之间通过诸如RESTful API的方式相互调用。\n\n# 服务治理\n\n服务治理就是提供了微服务架构中各个微服务实例的快速上线或下线且保持各服务能正常通信的能力方案总称。\n\n## 服务治理可以带来什么好处呢\n\n+ **更高的可用性**\n\n  支持动态的服务实例集群环境，任何服务实例都可以随时上线下线。并且当一个微服务实例不可用时，治理服务器可以将请求转发其他服务提供者，当新服务上线时，也能够快速分担服务调用请求；\n\n  \n\n+ **负载均衡**\n\n  提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；\n\n  \n\n+ **提升应用弹性**\n\n  服务治理客户端定时从服务治理服务器中复制一份实例信息缓存到本地，即使当服务治理服务器不可用时，服务消费者也可以使用本地的缓存去访问相应的服务，而不至于中断服务。通过这种机制，极大提高应用的弹性；\n\n  \n\n+ **高可用性集群**\n\n  可以构建服务治理集群，通过互相注册机制，将每隔治理服务器所管辖的服务信息列表进行交换，使服务治理拥有更高的可用性；\n\n# Spring Cloud的基本使用\n\n从上面对于微服务的治理和定义，我们搭建一个最基础和简单的微服务架构：\n\n+ 服务注册中心\n+ 服务提供方\n\n这里我们使用Spring Cloud Eureka的基础服务来搭建，下面按照操作手册来做一下看看。\n\n## 创建服务发现中心\n\n使用IntelliJ IDEA创建一个Spring Boot项目，依赖管理工具选择Gradle。你可以使用Spring Initializer来生成项目：\n\n<img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-143445@2x.png\" alt=\"s\" style=\"zoom:50%;\" />\n\n生成项目后，我们找到项目目录的启动入口文件\n\n```java\n// 新增EnableEurekaServer注解，将该工程标识为一个服务注册中心\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n\n}\n```\n\n找到`application.properties`文件，将其更改为`application.yml`（只是习惯用YML文件），修改一下Eureka Server的配置如下：\n\n```yaml\n# 服务注册中心的名称\nspring:\n  application:\n    name: eureka-server\n\n# 服务注册中心监听的端口\nserver:\n  port: 1001\n\n# 暂时禁用服务端注册客户端的行为\neureka:\n  instance:\n    hostname: 127.0.0.1\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n到此，服务注册中心搭建完成，运行这个项目并且打开浏览器输入`http://localhost:1001/`就可以看到服务注册中心的基本页面了：\n\n![](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-144301@2x.png)\n\n## 创建服务提供方\n\n如法炮制，我们通过Spring Initializer再创建一个Spring Boot项目，名为eureka-client，对应的gradle依赖如下：\n\n主要提供的是：\n\n+ spring-cloud-starter-netflix-eureka-client\n+ spring-boot-starter-web\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.6.3'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'com.hhp.registry'\nversion = '0.0.1'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\next {\n    set('springCloudVersion', \"2021.0.1\")\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n\n```\n\n我们新建一个Rest接口：\n\n> 需要注意的是：这里的DiscoveryClient会出现Netflix和Spring Cloud的，选择Spring Cloud的官方依赖\n\n```java\n@RestController\npublic class DcController {\n\n    // 选择Spring Cloud的依赖包导入\n    @Resource\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping(\"/dc\")\n    public String dc() {\n        String services = \"Service: \" + discoveryClient.getServices();\n        System.out.println(services);\n        return services;\n    }\n}\n```\n\n回到eureka-client的启动类，我们加上`@EnableDiscoveryClient`注解\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaClientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n```\n\n打开eureka-client的`application.yml`文件，将下列的配置贴进去：\n\n```yaml\nspring:\n  application:\n    name: eureka-client\nserver:\n  port: 2001\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1001/eureka/\n```\n\n至此，服务提供方也创建成功。将服务注册中心和服务提供方都运行起来，打开注册中心可以看到eureka-client已经成功被注册。\n\n![image-20220219162841266](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220219162841266.png)\n\n# Spring Cloud Consul服务注册\n\n使用Spring Cloud Consul实现，可以轻松将基于Spring Boot的微服务应用注册到Consul上，并通此实现微服务架构中的服务治理。\n\n如果需要将上述的eureka-client转换成使用consul来，只需要按照下面2步操作即可：\n\n+ 将spring-cloud-eureka-client依赖替换成spring-cloud-consul-discovery依赖\n+ 修改application.yml中的配置\n\n```yaml\nspring:\n  cloud:\n    consul:\n      host: 127.0.0.1\n      port: 8500\n```\n\n其他配置不需要更改，并且由于Consul本身已经集成了服务端，所以不需要额外创建`eureka-server`这样的服务。直接通过下载consul服务端程序即可使用。此过程不再赘述。\n\n更多关于Consul的使用指南，可以查看官方文档：https://www.consul.io/\n","slug":"spring/springcloud-getting-started","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vt003h4f619iik93ns","content":"<h1 id=\"Spring-Cloud是什么？\"><a href=\"#Spring-Cloud是什么？\" class=\"headerlink\" title=\"Spring Cloud是什么？\"></a>Spring Cloud是什么？</h1><p>一个基于Spring Boot实现的云应用开发工具，为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话以及集群状态管理等操作提供了一种简单的开发方式。</p>\n<h1 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h1><p>“微服务架构”这几年非常火热，以至于关注微服务架构相关的开源产品被反复提及（比如：Netflix和Dubbo），Spring Cloud也因Spring社区强大的知名度和影响力被广大架构师和开发者备受关注。</p>\n<p>简单来说：微服务架构是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每隔服务都能独立部署、独立维护、独立扩展，服务之间通过诸如RESTful API的方式相互调用。</p>\n<h1 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h1><p>服务治理就是提供了微服务架构中各个微服务实例的快速上线或下线且保持各服务能正常通信的能力方案总称。</p>\n<h2 id=\"服务治理可以带来什么好处呢\"><a href=\"#服务治理可以带来什么好处呢\" class=\"headerlink\" title=\"服务治理可以带来什么好处呢\"></a>服务治理可以带来什么好处呢</h2><ul>\n<li><p><strong>更高的可用性</strong></p>\n<p>支持动态的服务实例集群环境，任何服务实例都可以随时上线下线。并且当一个微服务实例不可用时，治理服务器可以将请求转发其他服务提供者，当新服务上线时，也能够快速分担服务调用请求；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>负载均衡</strong></p>\n<p>提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>提升应用弹性</strong></p>\n<p>服务治理客户端定时从服务治理服务器中复制一份实例信息缓存到本地，即使当服务治理服务器不可用时，服务消费者也可以使用本地的缓存去访问相应的服务，而不至于中断服务。通过这种机制，极大提高应用的弹性；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>高可用性集群</strong></p>\n<p>可以构建服务治理集群，通过互相注册机制，将每隔治理服务器所管辖的服务信息列表进行交换，使服务治理拥有更高的可用性；</p>\n</li>\n</ul>\n<h1 id=\"Spring-Cloud的基本使用\"><a href=\"#Spring-Cloud的基本使用\" class=\"headerlink\" title=\"Spring Cloud的基本使用\"></a>Spring Cloud的基本使用</h1><p>从上面对于微服务的治理和定义，我们搭建一个最基础和简单的微服务架构：</p>\n<ul>\n<li>服务注册中心</li>\n<li>服务提供方</li>\n</ul>\n<p>这里我们使用Spring Cloud Eureka的基础服务来搭建，下面按照操作手册来做一下看看。</p>\n<h2 id=\"创建服务发现中心\"><a href=\"#创建服务发现中心\" class=\"headerlink\" title=\"创建服务发现中心\"></a>创建服务发现中心</h2><p>使用IntelliJ IDEA创建一个Spring Boot项目，依赖管理工具选择Gradle。你可以使用Spring Initializer来生成项目：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-143445@2x.png\" alt=\"s\" style=\"zoom:50%;\" /></p>\n<p>生成项目后，我们找到项目目录的启动入口文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 新增EnableEurekaServer注解，将该工程标识为一个服务注册中心</span><br><span class=\"hljs-meta\">@EnableEurekaServer</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaServerApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>找到<code>application.properties</code>文件，将其更改为<code>application.yml</code>（只是习惯用YML文件），修改一下Eureka Server的配置如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\"># 服务注册中心的名称</span><br><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-server</span><br><br><span class=\"hljs-comment\"># 服务注册中心监听的端口</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">1001</span><br><br><span class=\"hljs-comment\"># 暂时禁用服务端注册客户端的行为</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">instance:</span><br>    <span class=\"hljs-attr\">hostname:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">register-with-eureka:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">fetch-registry:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>到此，服务注册中心搭建完成，运行这个项目并且打开浏览器输入<code>http://localhost:1001/</code>就可以看到服务注册中心的基本页面了：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-144301@2x.png\" alt=\"\"></p>\n<h2 id=\"创建服务提供方\"><a href=\"#创建服务提供方\" class=\"headerlink\" title=\"创建服务提供方\"></a>创建服务提供方</h2><p>如法炮制，我们通过Spring Initializer再创建一个Spring Boot项目，名为eureka-client，对应的gradle依赖如下：</p>\n<p>主要提供的是：</p>\n<ul>\n<li>spring-cloud-starter-netflix-eureka-client</li>\n<li>spring-boot-starter-web</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.registry&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>我们新建一个Rest接口：</p>\n<blockquote>\n<p>需要注意的是：这里的DiscoveryClient会出现Netflix和Spring Cloud的，选择Spring Cloud的官方依赖</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-comment\">// 选择Spring Cloud的依赖包导入</span><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> DiscoveryClient discoveryClient;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/dc&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">services</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Service: &quot;</span> + discoveryClient.getServices();<br>        System.out.println(services);<br>        <span class=\"hljs-keyword\">return</span> services;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>回到eureka-client的启动类，我们加上<code>@EnableDiscoveryClient</code>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaClientApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaClientApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>打开eureka-client的<code>application.yml</code>文件，将下列的配置贴进去：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-client</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2001</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://localhost:1001/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>至此，服务提供方也创建成功。将服务注册中心和服务提供方都运行起来，打开注册中心可以看到eureka-client已经成功被注册。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220219162841266.png\" alt=\"image-20220219162841266\"></p>\n<h1 id=\"Spring-Cloud-Consul服务注册\"><a href=\"#Spring-Cloud-Consul服务注册\" class=\"headerlink\" title=\"Spring Cloud Consul服务注册\"></a>Spring Cloud Consul服务注册</h1><p>使用Spring Cloud Consul实现，可以轻松将基于Spring Boot的微服务应用注册到Consul上，并通此实现微服务架构中的服务治理。</p>\n<p>如果需要将上述的eureka-client转换成使用consul来，只需要按照下面2步操作即可：</p>\n<ul>\n<li>将spring-cloud-eureka-client依赖替换成spring-cloud-consul-discovery依赖</li>\n<li>修改application.yml中的配置</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">consul:</span><br>      <span class=\"hljs-attr\">host:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><br>      <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">8500</span><br></code></pre></td></tr></table></figure>\n<p>其他配置不需要更改，并且由于Consul本身已经集成了服务端，所以不需要额外创建<code>eureka-server</code>这样的服务。直接通过下载consul服务端程序即可使用。此过程不再赘述。</p>\n<p>更多关于Consul的使用指南，可以查看官方文档：<a href=\"https://www.consul.io/\">https://www.consul.io/</a></p>\n","site":{"data":{}},"wordcount":4042,"excerpt":"","more":"<h1 id=\"Spring-Cloud是什么？\"><a href=\"#Spring-Cloud是什么？\" class=\"headerlink\" title=\"Spring Cloud是什么？\"></a>Spring Cloud是什么？</h1><p>一个基于Spring Boot实现的云应用开发工具，为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话以及集群状态管理等操作提供了一种简单的开发方式。</p>\n<h1 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h1><p>“微服务架构”这几年非常火热，以至于关注微服务架构相关的开源产品被反复提及（比如：Netflix和Dubbo），Spring Cloud也因Spring社区强大的知名度和影响力被广大架构师和开发者备受关注。</p>\n<p>简单来说：微服务架构是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每隔服务都能独立部署、独立维护、独立扩展，服务之间通过诸如RESTful API的方式相互调用。</p>\n<h1 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h1><p>服务治理就是提供了微服务架构中各个微服务实例的快速上线或下线且保持各服务能正常通信的能力方案总称。</p>\n<h2 id=\"服务治理可以带来什么好处呢\"><a href=\"#服务治理可以带来什么好处呢\" class=\"headerlink\" title=\"服务治理可以带来什么好处呢\"></a>服务治理可以带来什么好处呢</h2><ul>\n<li><p><strong>更高的可用性</strong></p>\n<p>支持动态的服务实例集群环境，任何服务实例都可以随时上线下线。并且当一个微服务实例不可用时，治理服务器可以将请求转发其他服务提供者，当新服务上线时，也能够快速分担服务调用请求；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>负载均衡</strong></p>\n<p>提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>提升应用弹性</strong></p>\n<p>服务治理客户端定时从服务治理服务器中复制一份实例信息缓存到本地，即使当服务治理服务器不可用时，服务消费者也可以使用本地的缓存去访问相应的服务，而不至于中断服务。通过这种机制，极大提高应用的弹性；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>高可用性集群</strong></p>\n<p>可以构建服务治理集群，通过互相注册机制，将每隔治理服务器所管辖的服务信息列表进行交换，使服务治理拥有更高的可用性；</p>\n</li>\n</ul>\n<h1 id=\"Spring-Cloud的基本使用\"><a href=\"#Spring-Cloud的基本使用\" class=\"headerlink\" title=\"Spring Cloud的基本使用\"></a>Spring Cloud的基本使用</h1><p>从上面对于微服务的治理和定义，我们搭建一个最基础和简单的微服务架构：</p>\n<ul>\n<li>服务注册中心</li>\n<li>服务提供方</li>\n</ul>\n<p>这里我们使用Spring Cloud Eureka的基础服务来搭建，下面按照操作手册来做一下看看。</p>\n<h2 id=\"创建服务发现中心\"><a href=\"#创建服务发现中心\" class=\"headerlink\" title=\"创建服务发现中心\"></a>创建服务发现中心</h2><p>使用IntelliJ IDEA创建一个Spring Boot项目，依赖管理工具选择Gradle。你可以使用Spring Initializer来生成项目：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-143445@2x.png\" alt=\"s\" style=\"zoom:50%;\" /></p>\n<p>生成项目后，我们找到项目目录的启动入口文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 新增EnableEurekaServer注解，将该工程标识为一个服务注册中心</span><br><span class=\"hljs-meta\">@EnableEurekaServer</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaServerApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>找到<code>application.properties</code>文件，将其更改为<code>application.yml</code>（只是习惯用YML文件），修改一下Eureka Server的配置如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\"># 服务注册中心的名称</span><br><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-server</span><br><br><span class=\"hljs-comment\"># 服务注册中心监听的端口</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">1001</span><br><br><span class=\"hljs-comment\"># 暂时禁用服务端注册客户端的行为</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">instance:</span><br>    <span class=\"hljs-attr\">hostname:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">register-with-eureka:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">fetch-registry:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>到此，服务注册中心搭建完成，运行这个项目并且打开浏览器输入<code>http://localhost:1001/</code>就可以看到服务注册中心的基本页面了：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-144301@2x.png\" alt=\"\"></p>\n<h2 id=\"创建服务提供方\"><a href=\"#创建服务提供方\" class=\"headerlink\" title=\"创建服务提供方\"></a>创建服务提供方</h2><p>如法炮制，我们通过Spring Initializer再创建一个Spring Boot项目，名为eureka-client，对应的gradle依赖如下：</p>\n<p>主要提供的是：</p>\n<ul>\n<li>spring-cloud-starter-netflix-eureka-client</li>\n<li>spring-boot-starter-web</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.registry&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>我们新建一个Rest接口：</p>\n<blockquote>\n<p>需要注意的是：这里的DiscoveryClient会出现Netflix和Spring Cloud的，选择Spring Cloud的官方依赖</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-comment\">// 选择Spring Cloud的依赖包导入</span><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> DiscoveryClient discoveryClient;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/dc&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">services</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Service: &quot;</span> + discoveryClient.getServices();<br>        System.out.println(services);<br>        <span class=\"hljs-keyword\">return</span> services;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>回到eureka-client的启动类，我们加上<code>@EnableDiscoveryClient</code>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaClientApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaClientApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>打开eureka-client的<code>application.yml</code>文件，将下列的配置贴进去：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-client</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2001</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://localhost:1001/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>至此，服务提供方也创建成功。将服务注册中心和服务提供方都运行起来，打开注册中心可以看到eureka-client已经成功被注册。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220219162841266.png\" alt=\"image-20220219162841266\"></p>\n<h1 id=\"Spring-Cloud-Consul服务注册\"><a href=\"#Spring-Cloud-Consul服务注册\" class=\"headerlink\" title=\"Spring Cloud Consul服务注册\"></a>Spring Cloud Consul服务注册</h1><p>使用Spring Cloud Consul实现，可以轻松将基于Spring Boot的微服务应用注册到Consul上，并通此实现微服务架构中的服务治理。</p>\n<p>如果需要将上述的eureka-client转换成使用consul来，只需要按照下面2步操作即可：</p>\n<ul>\n<li>将spring-cloud-eureka-client依赖替换成spring-cloud-consul-discovery依赖</li>\n<li>修改application.yml中的配置</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">consul:</span><br>      <span class=\"hljs-attr\">host:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><br>      <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">8500</span><br></code></pre></td></tr></table></figure>\n<p>其他配置不需要更改，并且由于Consul本身已经集成了服务端，所以不需要额外创建<code>eureka-server</code>这样的服务。直接通过下载consul服务端程序即可使用。此过程不再赘述。</p>\n<p>更多关于Consul的使用指南，可以查看官方文档：<a href=\"https://www.consul.io/\">https://www.consul.io/</a></p>\n"},{"title":"Spring Cloud服务消费（基础）","date":"2022-02-19T13:02:44.000Z","updated":"2022-02-19T13:02:44.000Z","_content":"\n# 使用LoadBalancerClient\n\n这是一个负载均衡客户端的抽象定义，负载均衡的好处在于：\n\n+ 提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；\n\n所以在分布式系统设计中，负载均衡可以用来实现系统的高可用、集群扩容等功能。负载均衡也分为“客户端负载均衡”和“服务端负载均衡”两种模式。\n\n我们的Spring Cloud Eureka属于客户端负载均衡的情况，所以这里我们用一个具体的例子来演示客户端负载均衡的具体实现。\n\n> 此Demo需要结合前面已有的eureka-server和eureka-client一起看效果\n\n# 创建消费服务\n\n还是按照之前的套路，使用Spring Initializer新建一个Spring Boot工程，叫`eureka-consumer`。\n\n## 添加依赖\n\n对应的gradle文件如下：\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.6.3'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'com.hhp.registry'\nversion = '0.0.1'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\next {\n    set('springCloudVersion', \"2021.0.1\")\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n```\n\n## 配置服务发现\n\n打开`application.yml`文件，贴入下列配置：\n\n```yaml\nspring:\n  application:\n    name: eureka-consumer\nserver:\n  port: 2101\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1001/eureka/\n```\n\n找到Spring Boot启动入口类，在上面加上`@EnableDiscoveryClient`注解，这里我们把RestTemplate带入我们的配置中：\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaConsumerApplication {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaConsumerApplication.class, args);\n    }\n\n}\n```\n\n## 创建服务消费接口\n\n我们新建一个接口来消费eureka-client服务\n\n```java\n@RestController\npublic class DcController {\n\n    @Resource\n    private LoadBalancerClient loadBalancerClient;\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        ServiceInstance serviceInstance = loadBalancerClient.choose(\"eureka-client\");\n        String url = \"http://\" + serviceInstance.getHost() + \":\" + serviceInstance.getPort() + \"/dc\";\n        System.out.println(url);\n        return restTemplate.getForObject(url, String.class);\n    }\n}\n```\n\n可以看出：\n\n1. 我们注入了`LoadBalancerClient`和`RestTemplate`，并在`/consumer`接口中实现；\n2. 通过`LoadBalancerClient.choose`选择出`eureka-client`的服务实例；\n3. 然后通过`ServiceInstance`服务的信息拼接出`/dc`接口的详细地址；\n4. 利用`RestTemplate`对象实现对服务提供者接口的调用；\n\n# 最终效果\n\n将`eureka-server`，`eureka-client`和`eureka-consumer`三个服务同时运行起来，然后访问`http://localhost:2101/consumer`。可以看到当服务器请求过程中，真正调用的是`eureka-client`，而`eureka-consumer`会把请求通过网络分发出去。\n","source":"_posts/spring/springcloud-service-consumer.md","raw":"---\ntitle: Spring Cloud服务消费（基础）\ndate: 2022-02-19 21:02:44\nupdated: 2022-02-19 21:02:44\ntags: Spring Cloud\ncategories: 微服务架构学习\n---\n\n# 使用LoadBalancerClient\n\n这是一个负载均衡客户端的抽象定义，负载均衡的好处在于：\n\n+ 提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；\n\n所以在分布式系统设计中，负载均衡可以用来实现系统的高可用、集群扩容等功能。负载均衡也分为“客户端负载均衡”和“服务端负载均衡”两种模式。\n\n我们的Spring Cloud Eureka属于客户端负载均衡的情况，所以这里我们用一个具体的例子来演示客户端负载均衡的具体实现。\n\n> 此Demo需要结合前面已有的eureka-server和eureka-client一起看效果\n\n# 创建消费服务\n\n还是按照之前的套路，使用Spring Initializer新建一个Spring Boot工程，叫`eureka-consumer`。\n\n## 添加依赖\n\n对应的gradle文件如下：\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.6.3'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'com.hhp.registry'\nversion = '0.0.1'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\next {\n    set('springCloudVersion', \"2021.0.1\")\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n```\n\n## 配置服务发现\n\n打开`application.yml`文件，贴入下列配置：\n\n```yaml\nspring:\n  application:\n    name: eureka-consumer\nserver:\n  port: 2101\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1001/eureka/\n```\n\n找到Spring Boot启动入口类，在上面加上`@EnableDiscoveryClient`注解，这里我们把RestTemplate带入我们的配置中：\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaConsumerApplication {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaConsumerApplication.class, args);\n    }\n\n}\n```\n\n## 创建服务消费接口\n\n我们新建一个接口来消费eureka-client服务\n\n```java\n@RestController\npublic class DcController {\n\n    @Resource\n    private LoadBalancerClient loadBalancerClient;\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        ServiceInstance serviceInstance = loadBalancerClient.choose(\"eureka-client\");\n        String url = \"http://\" + serviceInstance.getHost() + \":\" + serviceInstance.getPort() + \"/dc\";\n        System.out.println(url);\n        return restTemplate.getForObject(url, String.class);\n    }\n}\n```\n\n可以看出：\n\n1. 我们注入了`LoadBalancerClient`和`RestTemplate`，并在`/consumer`接口中实现；\n2. 通过`LoadBalancerClient.choose`选择出`eureka-client`的服务实例；\n3. 然后通过`ServiceInstance`服务的信息拼接出`/dc`接口的详细地址；\n4. 利用`RestTemplate`对象实现对服务提供者接口的调用；\n\n# 最终效果\n\n将`eureka-server`，`eureka-client`和`eureka-consumer`三个服务同时运行起来，然后访问`http://localhost:2101/consumer`。可以看到当服务器请求过程中，真正调用的是`eureka-client`，而`eureka-consumer`会把请求通过网络分发出去。\n","slug":"spring/springcloud-service-consumer","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vt003k4f61f2u1f3fy","content":"<h1 id=\"使用LoadBalancerClient\"><a href=\"#使用LoadBalancerClient\" class=\"headerlink\" title=\"使用LoadBalancerClient\"></a>使用LoadBalancerClient</h1><p>这是一个负载均衡客户端的抽象定义，负载均衡的好处在于：</p>\n<ul>\n<li>提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；</li>\n</ul>\n<p>所以在分布式系统设计中，负载均衡可以用来实现系统的高可用、集群扩容等功能。负载均衡也分为“客户端负载均衡”和“服务端负载均衡”两种模式。</p>\n<p>我们的Spring Cloud Eureka属于客户端负载均衡的情况，所以这里我们用一个具体的例子来演示客户端负载均衡的具体实现。</p>\n<blockquote>\n<p>此Demo需要结合前面已有的eureka-server和eureka-client一起看效果</p>\n</blockquote>\n<h1 id=\"创建消费服务\"><a href=\"#创建消费服务\" class=\"headerlink\" title=\"创建消费服务\"></a>创建消费服务</h1><p>还是按照之前的套路，使用Spring Initializer新建一个Spring Boot工程，叫<code>eureka-consumer</code>。</p>\n<h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><p>对应的gradle文件如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.registry&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置服务发现\"><a href=\"#配置服务发现\" class=\"headerlink\" title=\"配置服务发现\"></a>配置服务发现</h2><p>打开<code>application.yml</code>文件，贴入下列配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-consumer</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2101</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://localhost:1001/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>找到Spring Boot启动入口类，在上面加上<code>@EnableDiscoveryClient</code>注解，这里我们把RestTemplate带入我们的配置中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaConsumerApplication</span> &#123;<br><br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-keyword\">public</span> RestTemplate <span class=\"hljs-title function_\">restTemplate</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建服务消费接口\"><a href=\"#创建服务消费接口\" class=\"headerlink\" title=\"创建服务消费接口\"></a>创建服务消费接口</h2><p>我们新建一个接口来消费eureka-client服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> LoadBalancerClient loadBalancerClient;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> RestTemplate restTemplate;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/consumer&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">ServiceInstance</span> <span class=\"hljs-variable\">serviceInstance</span> <span class=\"hljs-operator\">=</span> loadBalancerClient.choose(<span class=\"hljs-string\">&quot;eureka-client&quot;</span>);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">url</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;http://&quot;</span> + serviceInstance.getHost() + <span class=\"hljs-string\">&quot;:&quot;</span> + serviceInstance.getPort() + <span class=\"hljs-string\">&quot;/dc&quot;</span>;<br>        System.out.println(url);<br>        <span class=\"hljs-keyword\">return</span> restTemplate.getForObject(url, String.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看出：</p>\n<ol>\n<li>我们注入了<code>LoadBalancerClient</code>和<code>RestTemplate</code>，并在<code>/consumer</code>接口中实现；</li>\n<li>通过<code>LoadBalancerClient.choose</code>选择出<code>eureka-client</code>的服务实例；</li>\n<li>然后通过<code>ServiceInstance</code>服务的信息拼接出<code>/dc</code>接口的详细地址；</li>\n<li>利用<code>RestTemplate</code>对象实现对服务提供者接口的调用；</li>\n</ol>\n<h1 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h1><p>将<code>eureka-server</code>，<code>eureka-client</code>和<code>eureka-consumer</code>三个服务同时运行起来，然后访问<code>http://localhost:2101/consumer</code>。可以看到当服务器请求过程中，真正调用的是<code>eureka-client</code>，而<code>eureka-consumer</code>会把请求通过网络分发出去。</p>\n","site":{"data":{}},"wordcount":2841,"excerpt":"","more":"<h1 id=\"使用LoadBalancerClient\"><a href=\"#使用LoadBalancerClient\" class=\"headerlink\" title=\"使用LoadBalancerClient\"></a>使用LoadBalancerClient</h1><p>这是一个负载均衡客户端的抽象定义，负载均衡的好处在于：</p>\n<ul>\n<li>提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；</li>\n</ul>\n<p>所以在分布式系统设计中，负载均衡可以用来实现系统的高可用、集群扩容等功能。负载均衡也分为“客户端负载均衡”和“服务端负载均衡”两种模式。</p>\n<p>我们的Spring Cloud Eureka属于客户端负载均衡的情况，所以这里我们用一个具体的例子来演示客户端负载均衡的具体实现。</p>\n<blockquote>\n<p>此Demo需要结合前面已有的eureka-server和eureka-client一起看效果</p>\n</blockquote>\n<h1 id=\"创建消费服务\"><a href=\"#创建消费服务\" class=\"headerlink\" title=\"创建消费服务\"></a>创建消费服务</h1><p>还是按照之前的套路，使用Spring Initializer新建一个Spring Boot工程，叫<code>eureka-consumer</code>。</p>\n<h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><p>对应的gradle文件如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.registry&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置服务发现\"><a href=\"#配置服务发现\" class=\"headerlink\" title=\"配置服务发现\"></a>配置服务发现</h2><p>打开<code>application.yml</code>文件，贴入下列配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-consumer</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2101</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://localhost:1001/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>找到Spring Boot启动入口类，在上面加上<code>@EnableDiscoveryClient</code>注解，这里我们把RestTemplate带入我们的配置中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaConsumerApplication</span> &#123;<br><br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-keyword\">public</span> RestTemplate <span class=\"hljs-title function_\">restTemplate</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建服务消费接口\"><a href=\"#创建服务消费接口\" class=\"headerlink\" title=\"创建服务消费接口\"></a>创建服务消费接口</h2><p>我们新建一个接口来消费eureka-client服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> LoadBalancerClient loadBalancerClient;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> RestTemplate restTemplate;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/consumer&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">ServiceInstance</span> <span class=\"hljs-variable\">serviceInstance</span> <span class=\"hljs-operator\">=</span> loadBalancerClient.choose(<span class=\"hljs-string\">&quot;eureka-client&quot;</span>);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">url</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;http://&quot;</span> + serviceInstance.getHost() + <span class=\"hljs-string\">&quot;:&quot;</span> + serviceInstance.getPort() + <span class=\"hljs-string\">&quot;/dc&quot;</span>;<br>        System.out.println(url);<br>        <span class=\"hljs-keyword\">return</span> restTemplate.getForObject(url, String.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看出：</p>\n<ol>\n<li>我们注入了<code>LoadBalancerClient</code>和<code>RestTemplate</code>，并在<code>/consumer</code>接口中实现；</li>\n<li>通过<code>LoadBalancerClient.choose</code>选择出<code>eureka-client</code>的服务实例；</li>\n<li>然后通过<code>ServiceInstance</code>服务的信息拼接出<code>/dc</code>接口的详细地址；</li>\n<li>利用<code>RestTemplate</code>对象实现对服务提供者接口的调用；</li>\n</ol>\n<h1 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h1><p>将<code>eureka-server</code>，<code>eureka-client</code>和<code>eureka-consumer</code>三个服务同时运行起来，然后访问<code>http://localhost:2101/consumer</code>。可以看到当服务器请求过程中，真正调用的是<code>eureka-client</code>，而<code>eureka-consumer</code>会把请求通过网络分发出去。</p>\n"},{"title":"分布式概念基础","date":"2022-03-03T12:14:50.000Z","updated":"2022-03-03T12:14:50.000Z","_content":"\n# 一、CAP理论\n\n**（C）数据一致性：**写操作成功，所有读都能成功；写操作失败，所有读都不能成功；\n\n**（A）服务可用：**所有读写请求在一定时间内得到响应，可终止，不会一直等待；\n\n**（P）分区容错性：**网络分区的情况下，被分隔的节点依然能正常对外服务；\n\n单体应用下，CA原则是完全没问题的（不存在P）；但是在分布式下架构下只能保证CP或者AP。\n\n\n\n# 二、Base理论\n\nCAP理论的一种折衷，由于在分布式架构下CAP只能二选其一，所以Base理论降低了发生分区容错时对可用性和一致性的要求；\n\n1. **基本可用：**允许可用性降低（可能延长响应时间、可能进行服务降级）\n2. **软状态：**允许系统中的数据存在中间状态，并且认为中间状态不会影响系统整体的可用性；\n3. **最终一致性：**节点数据同步可以存在延时，但在一定期限后必须达成数据一致性，状态变为最终态；\n\n\n\n# 三、数据一致性模型\n\n+ **强一致性：**用户上一次写了什么，下一次就能保证读到什么；\n+ **弱一致性：**系统写入数据不承诺立即读到最新写入，也不承诺多久后可以读到；\n+ **最终一致性：**弱一致性的特例，所有数据副本在经过一段时间的同步后最终都能达到一致；\n+ **因果一致性：**要求所有因果关系的操作顺序得到保证，非因果关系的操作顺序无所谓；\n+ **会话一致性：**对系统数据的访问过程框定在一个会话中，约定系统能保证在同一个有效会话中实现读已之所写的一致性；\n\n\n\n# 四、Quorum机制\n\n## 定义\n\n10个副本，一次成功更新3个，那么至少需要读取8个副本的数据，可以保证读到了最新的数据。无法保证强一致性，也就无法实现任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据。需要配合一个获取最新成功提交的版本号metadata服务，这样可以确定最新已经成功提交的版本号，然后从已经读到的数据中可以确认最新写入的数据；\n\n> 至少读取副本节点数 = 总副本节点数 - 一次成功更新副本数 + 1\n>\n> 例如上面的例子：\n>\n>  8 = 10 - 3 + 1\n\n\n\n# 五、WARO（Write All Read One）机制\n\n## 定义\n\n一种简单的副本控制协议。写操作时、只有当所有副本都更新成功后，本次写操作才算成功；否则视为失败；\n\n优先保证读、任何节点读到的数据都是最新数据，牺牲了更新服务的可用性。\n\n> 只要有一个副本宕机了，写服务就不会成功，但只要有一个节点存活，仍能提供读写服务\n\n\n\n# 六、负载均衡策略\n\n## 1. 轮询法\n\n将请求按顺序轮流分配到后端服务上，均衡地等待后端的每台服务器，而不关心服务器的实际连接数和当前的系统负载；\n\n## 2. 加权轮询法\n\n不同的后端服务器可能的配置与当前系统的负载均衡并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；反之给配置低，负载高的机器配置更低的权重，降低系统负载；\n\n## 3. 随机法\n\n借助于随机算法，根据后端服务器的列表大小值随机选取其中一台服务器进行访问，随着客户端请求次数的增多，实际效果会越来越接近于平均分配调用到后端的每台服务器；\n\n## 4. 加权随机法\n\n类似于加权轮询法，也是根据后端机器的配置，系统负载分配不同的权重，不同的是权重值随机请求后端服务器，而非顺序；\n\n## 5. 源地址哈希法\n\n根据获取客户端的IP地址，借助哈希算法计算除一个数值，用数值对服务器列表的大小进行取模运算，得到的结果是客户端要访问服务器的序号\n\n> 采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，每次都会映射到同一台后端服务器进行访问\n\n## 6. 最小连接数法\n\n根据后端服务的当前连接情况，动态选取其中当前积压连接数最小的一台服务器来作为处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器；\n\n> 一句话概括：谁空闲谁去处理\n\n\n\n# 七、分布式系统设计\n\n+ **可扩展：**通过对服务、存储的扩展，提高系统的处理能力。通过对多台服务器协同工作，来完成单台服务器无法处理的任务、尤其是高并发或者大数据量的任务；\n+ **高可用：**单点故障不影响整体，单点故障指的是系统中某个组件一旦失效，会让整个系统瘫痪无法工作；\n+ **无状态：**无状态的服务才能满足部分机器宕机不影响全部，可以随时进行扩展的需求；\n+ **可管理：**便于运维，出问题能否及时发现定位\n+ **高可靠：**同样的请求返回同样的数据，更新能够持久化，数据不丢失；\n\n\n\n# 八、分布式事务的解决方案\n\n+ **基于XA协议：**两阶段提交和三阶段提交，需要数据库层面支持；\n\n+ **基于事务补偿机制：**TCC（Try-Confirm-Cancel），基于业务层面实现；\n\n  > TCC事务模型：也称为两阶段补偿事务。第一阶段Try只预留资源，第二阶段明确告诉服务提供者，这个资源你到底要不要，对应第二阶段的confirm / cancel。\n  >\n  > **直白一点就是：你要这个资源，我先帮你留着，然后要的话我就给你，不要我就扔掉了；**\n\n+ **本地消息表：**基于本地数据库 + MQ，维护本地表状态（进行中），通过MQ调用服务，完成响应后回一条消息回调；将状态更改为完成。需要配合定时任务扫表，重新发送消息调用服务，保证幂等性；\n\n  > **消息幂等**：当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响\n  >\n  > MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依赖，并且ID是全局唯一且与业务无关，对消息发送方和接收方都屏蔽\n\n+ 基于事务消息：例如MQ服务；\n\n\n\n# 九、讲讲TCC事务模型\n\nTCC补偿事务：Try、Confirm、Cancel\n\n针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作；\n\n+ Try：操作业务检查以及资源预留；\n+ Confirm：业务确认操作；\n+ Cancel：实现一个与Try相反的操作（即回滚操作）\n\nTCC模型对业务的侵入行较强，改造难度较大，每个操作都需要TCC操作；\n\nTCC会增加事务日志，如果Confirm或者Cancel阶段出错，则会进行重试，所以这两个截断需要支持幂等；如果充实失败，则需要人工介入进行恢复和处理；\n\n\n\n# 十、如何理解RPC\n\n远程过程调用（Remote Process Callable）\n\nRPC要求在调用方中放置被调用的方法接口，调用方只需要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用。于是调用方可以像调用内部接口一样调用远程方法，而不是封装参数名和参数值等操作；\n\n包含：\n\n+ 动态代理，封装调用细节；\n+ 序列化与翻序列化，数据传输与接收；\n+ 通信，可以选择七层http协议，四层tcp/udp协议；\n+ 异常处理机制\n\n首先，调用方调用的是接口，必须为接口构造一个假的实现，因此需要使用动态代理。这样，调用方的调用就被动态代理接收了。\n\n其次，动态代理接收到调用后，应该想办法调用远程的实际实现，包括下面几步：\n\n+ 识别具体要调用的远程方法IP、端口；\n+ 将调用方法的入参进行序列化；\n+ 通过通信将请求发送到远程方法中；\n\n这样，远程的服务就接收到了调用方法的请求，应该：\n\n+ 反序列化各个调用参数\n+ 定位到实际要调用的方法，然后输入参数，执行方法；\n+ 按照调用的路径返回调用的结果；\n\n\n\n# 十一、zookeeper分布式锁实现原理\n","source":"_posts/distribute/distribute-concept.md","raw":"---\ntitle: 分布式概念基础\ndate: 2022-03-03 20:14:50\nupdated: 2022-03-03 20:14:50\ntags: 分布式\ncategories: 分布式架构设计\n---\n\n# 一、CAP理论\n\n**（C）数据一致性：**写操作成功，所有读都能成功；写操作失败，所有读都不能成功；\n\n**（A）服务可用：**所有读写请求在一定时间内得到响应，可终止，不会一直等待；\n\n**（P）分区容错性：**网络分区的情况下，被分隔的节点依然能正常对外服务；\n\n单体应用下，CA原则是完全没问题的（不存在P）；但是在分布式下架构下只能保证CP或者AP。\n\n\n\n# 二、Base理论\n\nCAP理论的一种折衷，由于在分布式架构下CAP只能二选其一，所以Base理论降低了发生分区容错时对可用性和一致性的要求；\n\n1. **基本可用：**允许可用性降低（可能延长响应时间、可能进行服务降级）\n2. **软状态：**允许系统中的数据存在中间状态，并且认为中间状态不会影响系统整体的可用性；\n3. **最终一致性：**节点数据同步可以存在延时，但在一定期限后必须达成数据一致性，状态变为最终态；\n\n\n\n# 三、数据一致性模型\n\n+ **强一致性：**用户上一次写了什么，下一次就能保证读到什么；\n+ **弱一致性：**系统写入数据不承诺立即读到最新写入，也不承诺多久后可以读到；\n+ **最终一致性：**弱一致性的特例，所有数据副本在经过一段时间的同步后最终都能达到一致；\n+ **因果一致性：**要求所有因果关系的操作顺序得到保证，非因果关系的操作顺序无所谓；\n+ **会话一致性：**对系统数据的访问过程框定在一个会话中，约定系统能保证在同一个有效会话中实现读已之所写的一致性；\n\n\n\n# 四、Quorum机制\n\n## 定义\n\n10个副本，一次成功更新3个，那么至少需要读取8个副本的数据，可以保证读到了最新的数据。无法保证强一致性，也就无法实现任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据。需要配合一个获取最新成功提交的版本号metadata服务，这样可以确定最新已经成功提交的版本号，然后从已经读到的数据中可以确认最新写入的数据；\n\n> 至少读取副本节点数 = 总副本节点数 - 一次成功更新副本数 + 1\n>\n> 例如上面的例子：\n>\n>  8 = 10 - 3 + 1\n\n\n\n# 五、WARO（Write All Read One）机制\n\n## 定义\n\n一种简单的副本控制协议。写操作时、只有当所有副本都更新成功后，本次写操作才算成功；否则视为失败；\n\n优先保证读、任何节点读到的数据都是最新数据，牺牲了更新服务的可用性。\n\n> 只要有一个副本宕机了，写服务就不会成功，但只要有一个节点存活，仍能提供读写服务\n\n\n\n# 六、负载均衡策略\n\n## 1. 轮询法\n\n将请求按顺序轮流分配到后端服务上，均衡地等待后端的每台服务器，而不关心服务器的实际连接数和当前的系统负载；\n\n## 2. 加权轮询法\n\n不同的后端服务器可能的配置与当前系统的负载均衡并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；反之给配置低，负载高的机器配置更低的权重，降低系统负载；\n\n## 3. 随机法\n\n借助于随机算法，根据后端服务器的列表大小值随机选取其中一台服务器进行访问，随着客户端请求次数的增多，实际效果会越来越接近于平均分配调用到后端的每台服务器；\n\n## 4. 加权随机法\n\n类似于加权轮询法，也是根据后端机器的配置，系统负载分配不同的权重，不同的是权重值随机请求后端服务器，而非顺序；\n\n## 5. 源地址哈希法\n\n根据获取客户端的IP地址，借助哈希算法计算除一个数值，用数值对服务器列表的大小进行取模运算，得到的结果是客户端要访问服务器的序号\n\n> 采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，每次都会映射到同一台后端服务器进行访问\n\n## 6. 最小连接数法\n\n根据后端服务的当前连接情况，动态选取其中当前积压连接数最小的一台服务器来作为处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器；\n\n> 一句话概括：谁空闲谁去处理\n\n\n\n# 七、分布式系统设计\n\n+ **可扩展：**通过对服务、存储的扩展，提高系统的处理能力。通过对多台服务器协同工作，来完成单台服务器无法处理的任务、尤其是高并发或者大数据量的任务；\n+ **高可用：**单点故障不影响整体，单点故障指的是系统中某个组件一旦失效，会让整个系统瘫痪无法工作；\n+ **无状态：**无状态的服务才能满足部分机器宕机不影响全部，可以随时进行扩展的需求；\n+ **可管理：**便于运维，出问题能否及时发现定位\n+ **高可靠：**同样的请求返回同样的数据，更新能够持久化，数据不丢失；\n\n\n\n# 八、分布式事务的解决方案\n\n+ **基于XA协议：**两阶段提交和三阶段提交，需要数据库层面支持；\n\n+ **基于事务补偿机制：**TCC（Try-Confirm-Cancel），基于业务层面实现；\n\n  > TCC事务模型：也称为两阶段补偿事务。第一阶段Try只预留资源，第二阶段明确告诉服务提供者，这个资源你到底要不要，对应第二阶段的confirm / cancel。\n  >\n  > **直白一点就是：你要这个资源，我先帮你留着，然后要的话我就给你，不要我就扔掉了；**\n\n+ **本地消息表：**基于本地数据库 + MQ，维护本地表状态（进行中），通过MQ调用服务，完成响应后回一条消息回调；将状态更改为完成。需要配合定时任务扫表，重新发送消息调用服务，保证幂等性；\n\n  > **消息幂等**：当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响\n  >\n  > MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依赖，并且ID是全局唯一且与业务无关，对消息发送方和接收方都屏蔽\n\n+ 基于事务消息：例如MQ服务；\n\n\n\n# 九、讲讲TCC事务模型\n\nTCC补偿事务：Try、Confirm、Cancel\n\n针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作；\n\n+ Try：操作业务检查以及资源预留；\n+ Confirm：业务确认操作；\n+ Cancel：实现一个与Try相反的操作（即回滚操作）\n\nTCC模型对业务的侵入行较强，改造难度较大，每个操作都需要TCC操作；\n\nTCC会增加事务日志，如果Confirm或者Cancel阶段出错，则会进行重试，所以这两个截断需要支持幂等；如果充实失败，则需要人工介入进行恢复和处理；\n\n\n\n# 十、如何理解RPC\n\n远程过程调用（Remote Process Callable）\n\nRPC要求在调用方中放置被调用的方法接口，调用方只需要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用。于是调用方可以像调用内部接口一样调用远程方法，而不是封装参数名和参数值等操作；\n\n包含：\n\n+ 动态代理，封装调用细节；\n+ 序列化与翻序列化，数据传输与接收；\n+ 通信，可以选择七层http协议，四层tcp/udp协议；\n+ 异常处理机制\n\n首先，调用方调用的是接口，必须为接口构造一个假的实现，因此需要使用动态代理。这样，调用方的调用就被动态代理接收了。\n\n其次，动态代理接收到调用后，应该想办法调用远程的实际实现，包括下面几步：\n\n+ 识别具体要调用的远程方法IP、端口；\n+ 将调用方法的入参进行序列化；\n+ 通过通信将请求发送到远程方法中；\n\n这样，远程的服务就接收到了调用方法的请求，应该：\n\n+ 反序列化各个调用参数\n+ 定位到实际要调用的方法，然后输入参数，执行方法；\n+ 按照调用的路径返回调用的结果；\n\n\n\n# 十一、zookeeper分布式锁实现原理\n","slug":"distribute/distribute-concept","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vu003o4f617gel2u7h","content":"<h1 id=\"一、CAP理论\"><a href=\"#一、CAP理论\" class=\"headerlink\" title=\"一、CAP理论\"></a>一、CAP理论</h1><p><strong>（C）数据一致性：</strong>写操作成功，所有读都能成功；写操作失败，所有读都不能成功；</p>\n<p><strong>（A）服务可用：</strong>所有读写请求在一定时间内得到响应，可终止，不会一直等待；</p>\n<p><strong>（P）分区容错性：</strong>网络分区的情况下，被分隔的节点依然能正常对外服务；</p>\n<p>单体应用下，CA原则是完全没问题的（不存在P）；但是在分布式下架构下只能保证CP或者AP。</p>\n<h1 id=\"二、Base理论\"><a href=\"#二、Base理论\" class=\"headerlink\" title=\"二、Base理论\"></a>二、Base理论</h1><p>CAP理论的一种折衷，由于在分布式架构下CAP只能二选其一，所以Base理论降低了发生分区容错时对可用性和一致性的要求；</p>\n<ol>\n<li><strong>基本可用：</strong>允许可用性降低（可能延长响应时间、可能进行服务降级）</li>\n<li><strong>软状态：</strong>允许系统中的数据存在中间状态，并且认为中间状态不会影响系统整体的可用性；</li>\n<li><strong>最终一致性：</strong>节点数据同步可以存在延时，但在一定期限后必须达成数据一致性，状态变为最终态；</li>\n</ol>\n<h1 id=\"三、数据一致性模型\"><a href=\"#三、数据一致性模型\" class=\"headerlink\" title=\"三、数据一致性模型\"></a>三、数据一致性模型</h1><ul>\n<li><strong>强一致性：</strong>用户上一次写了什么，下一次就能保证读到什么；</li>\n<li><strong>弱一致性：</strong>系统写入数据不承诺立即读到最新写入，也不承诺多久后可以读到；</li>\n<li><strong>最终一致性：</strong>弱一致性的特例，所有数据副本在经过一段时间的同步后最终都能达到一致；</li>\n<li><strong>因果一致性：</strong>要求所有因果关系的操作顺序得到保证，非因果关系的操作顺序无所谓；</li>\n<li><strong>会话一致性：</strong>对系统数据的访问过程框定在一个会话中，约定系统能保证在同一个有效会话中实现读已之所写的一致性；</li>\n</ul>\n<h1 id=\"四、Quorum机制\"><a href=\"#四、Quorum机制\" class=\"headerlink\" title=\"四、Quorum机制\"></a>四、Quorum机制</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>10个副本，一次成功更新3个，那么至少需要读取8个副本的数据，可以保证读到了最新的数据。无法保证强一致性，也就无法实现任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据。需要配合一个获取最新成功提交的版本号metadata服务，这样可以确定最新已经成功提交的版本号，然后从已经读到的数据中可以确认最新写入的数据；</p>\n<blockquote>\n<p>至少读取副本节点数 = 总副本节点数 - 一次成功更新副本数 + 1</p>\n<p>例如上面的例子：</p>\n<p> 8 = 10 - 3 + 1</p>\n</blockquote>\n<h1 id=\"五、WARO（Write-All-Read-One）机制\"><a href=\"#五、WARO（Write-All-Read-One）机制\" class=\"headerlink\" title=\"五、WARO（Write All Read One）机制\"></a>五、WARO（Write All Read One）机制</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>一种简单的副本控制协议。写操作时、只有当所有副本都更新成功后，本次写操作才算成功；否则视为失败；</p>\n<p>优先保证读、任何节点读到的数据都是最新数据，牺牲了更新服务的可用性。</p>\n<blockquote>\n<p>只要有一个副本宕机了，写服务就不会成功，但只要有一个节点存活，仍能提供读写服务</p>\n</blockquote>\n<h1 id=\"六、负载均衡策略\"><a href=\"#六、负载均衡策略\" class=\"headerlink\" title=\"六、负载均衡策略\"></a>六、负载均衡策略</h1><h2 id=\"1-轮询法\"><a href=\"#1-轮询法\" class=\"headerlink\" title=\"1. 轮询法\"></a>1. 轮询法</h2><p>将请求按顺序轮流分配到后端服务上，均衡地等待后端的每台服务器，而不关心服务器的实际连接数和当前的系统负载；</p>\n<h2 id=\"2-加权轮询法\"><a href=\"#2-加权轮询法\" class=\"headerlink\" title=\"2. 加权轮询法\"></a>2. 加权轮询法</h2><p>不同的后端服务器可能的配置与当前系统的负载均衡并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；反之给配置低，负载高的机器配置更低的权重，降低系统负载；</p>\n<h2 id=\"3-随机法\"><a href=\"#3-随机法\" class=\"headerlink\" title=\"3. 随机法\"></a>3. 随机法</h2><p>借助于随机算法，根据后端服务器的列表大小值随机选取其中一台服务器进行访问，随着客户端请求次数的增多，实际效果会越来越接近于平均分配调用到后端的每台服务器；</p>\n<h2 id=\"4-加权随机法\"><a href=\"#4-加权随机法\" class=\"headerlink\" title=\"4. 加权随机法\"></a>4. 加权随机法</h2><p>类似于加权轮询法，也是根据后端机器的配置，系统负载分配不同的权重，不同的是权重值随机请求后端服务器，而非顺序；</p>\n<h2 id=\"5-源地址哈希法\"><a href=\"#5-源地址哈希法\" class=\"headerlink\" title=\"5. 源地址哈希法\"></a>5. 源地址哈希法</h2><p>根据获取客户端的IP地址，借助哈希算法计算除一个数值，用数值对服务器列表的大小进行取模运算，得到的结果是客户端要访问服务器的序号</p>\n<blockquote>\n<p>采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，每次都会映射到同一台后端服务器进行访问</p>\n</blockquote>\n<h2 id=\"6-最小连接数法\"><a href=\"#6-最小连接数法\" class=\"headerlink\" title=\"6. 最小连接数法\"></a>6. 最小连接数法</h2><p>根据后端服务的当前连接情况，动态选取其中当前积压连接数最小的一台服务器来作为处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器；</p>\n<blockquote>\n<p>一句话概括：谁空闲谁去处理</p>\n</blockquote>\n<h1 id=\"七、分布式系统设计\"><a href=\"#七、分布式系统设计\" class=\"headerlink\" title=\"七、分布式系统设计\"></a>七、分布式系统设计</h1><ul>\n<li><strong>可扩展：</strong>通过对服务、存储的扩展，提高系统的处理能力。通过对多台服务器协同工作，来完成单台服务器无法处理的任务、尤其是高并发或者大数据量的任务；</li>\n<li><strong>高可用：</strong>单点故障不影响整体，单点故障指的是系统中某个组件一旦失效，会让整个系统瘫痪无法工作；</li>\n<li><strong>无状态：</strong>无状态的服务才能满足部分机器宕机不影响全部，可以随时进行扩展的需求；</li>\n<li><strong>可管理：</strong>便于运维，出问题能否及时发现定位</li>\n<li><strong>高可靠：</strong>同样的请求返回同样的数据，更新能够持久化，数据不丢失；</li>\n</ul>\n<h1 id=\"八、分布式事务的解决方案\"><a href=\"#八、分布式事务的解决方案\" class=\"headerlink\" title=\"八、分布式事务的解决方案\"></a>八、分布式事务的解决方案</h1><ul>\n<li><p><strong>基于XA协议：</strong>两阶段提交和三阶段提交，需要数据库层面支持；</p>\n</li>\n<li><p><strong>基于事务补偿机制：</strong>TCC（Try-Confirm-Cancel），基于业务层面实现；</p>\n<blockquote>\n<p>TCC事务模型：也称为两阶段补偿事务。第一阶段Try只预留资源，第二阶段明确告诉服务提供者，这个资源你到底要不要，对应第二阶段的confirm / cancel。</p>\n<p><strong>直白一点就是：你要这个资源，我先帮你留着，然后要的话我就给你，不要我就扔掉了；</strong></p>\n</blockquote>\n</li>\n<li><p><strong>本地消息表：</strong>基于本地数据库 + MQ，维护本地表状态（进行中），通过MQ调用服务，完成响应后回一条消息回调；将状态更改为完成。需要配合定时任务扫表，重新发送消息调用服务，保证幂等性；</p>\n<blockquote>\n<p><strong>消息幂等</strong>：当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响</p>\n<p>MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依赖，并且ID是全局唯一且与业务无关，对消息发送方和接收方都屏蔽</p>\n</blockquote>\n</li>\n<li><p>基于事务消息：例如MQ服务；</p>\n</li>\n</ul>\n<h1 id=\"九、讲讲TCC事务模型\"><a href=\"#九、讲讲TCC事务模型\" class=\"headerlink\" title=\"九、讲讲TCC事务模型\"></a>九、讲讲TCC事务模型</h1><p>TCC补偿事务：Try、Confirm、Cancel</p>\n<p>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作；</p>\n<ul>\n<li>Try：操作业务检查以及资源预留；</li>\n<li>Confirm：业务确认操作；</li>\n<li>Cancel：实现一个与Try相反的操作（即回滚操作）</li>\n</ul>\n<p>TCC模型对业务的侵入行较强，改造难度较大，每个操作都需要TCC操作；</p>\n<p>TCC会增加事务日志，如果Confirm或者Cancel阶段出错，则会进行重试，所以这两个截断需要支持幂等；如果充实失败，则需要人工介入进行恢复和处理；</p>\n<h1 id=\"十、如何理解RPC\"><a href=\"#十、如何理解RPC\" class=\"headerlink\" title=\"十、如何理解RPC\"></a>十、如何理解RPC</h1><p>远程过程调用（Remote Process Callable）</p>\n<p>RPC要求在调用方中放置被调用的方法接口，调用方只需要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用。于是调用方可以像调用内部接口一样调用远程方法，而不是封装参数名和参数值等操作；</p>\n<p>包含：</p>\n<ul>\n<li>动态代理，封装调用细节；</li>\n<li>序列化与翻序列化，数据传输与接收；</li>\n<li>通信，可以选择七层http协议，四层tcp/udp协议；</li>\n<li>异常处理机制</li>\n</ul>\n<p>首先，调用方调用的是接口，必须为接口构造一个假的实现，因此需要使用动态代理。这样，调用方的调用就被动态代理接收了。</p>\n<p>其次，动态代理接收到调用后，应该想办法调用远程的实际实现，包括下面几步：</p>\n<ul>\n<li>识别具体要调用的远程方法IP、端口；</li>\n<li>将调用方法的入参进行序列化；</li>\n<li>通过通信将请求发送到远程方法中；</li>\n</ul>\n<p>这样，远程的服务就接收到了调用方法的请求，应该：</p>\n<ul>\n<li>反序列化各个调用参数</li>\n<li>定位到实际要调用的方法，然后输入参数，执行方法；</li>\n<li>按照调用的路径返回调用的结果；</li>\n</ul>\n<h1 id=\"十一、zookeeper分布式锁实现原理\"><a href=\"#十一、zookeeper分布式锁实现原理\" class=\"headerlink\" title=\"十一、zookeeper分布式锁实现原理\"></a>十一、zookeeper分布式锁实现原理</h1>","site":{"data":{}},"wordcount":2774,"excerpt":"","more":"<h1 id=\"一、CAP理论\"><a href=\"#一、CAP理论\" class=\"headerlink\" title=\"一、CAP理论\"></a>一、CAP理论</h1><p><strong>（C）数据一致性：</strong>写操作成功，所有读都能成功；写操作失败，所有读都不能成功；</p>\n<p><strong>（A）服务可用：</strong>所有读写请求在一定时间内得到响应，可终止，不会一直等待；</p>\n<p><strong>（P）分区容错性：</strong>网络分区的情况下，被分隔的节点依然能正常对外服务；</p>\n<p>单体应用下，CA原则是完全没问题的（不存在P）；但是在分布式下架构下只能保证CP或者AP。</p>\n<h1 id=\"二、Base理论\"><a href=\"#二、Base理论\" class=\"headerlink\" title=\"二、Base理论\"></a>二、Base理论</h1><p>CAP理论的一种折衷，由于在分布式架构下CAP只能二选其一，所以Base理论降低了发生分区容错时对可用性和一致性的要求；</p>\n<ol>\n<li><strong>基本可用：</strong>允许可用性降低（可能延长响应时间、可能进行服务降级）</li>\n<li><strong>软状态：</strong>允许系统中的数据存在中间状态，并且认为中间状态不会影响系统整体的可用性；</li>\n<li><strong>最终一致性：</strong>节点数据同步可以存在延时，但在一定期限后必须达成数据一致性，状态变为最终态；</li>\n</ol>\n<h1 id=\"三、数据一致性模型\"><a href=\"#三、数据一致性模型\" class=\"headerlink\" title=\"三、数据一致性模型\"></a>三、数据一致性模型</h1><ul>\n<li><strong>强一致性：</strong>用户上一次写了什么，下一次就能保证读到什么；</li>\n<li><strong>弱一致性：</strong>系统写入数据不承诺立即读到最新写入，也不承诺多久后可以读到；</li>\n<li><strong>最终一致性：</strong>弱一致性的特例，所有数据副本在经过一段时间的同步后最终都能达到一致；</li>\n<li><strong>因果一致性：</strong>要求所有因果关系的操作顺序得到保证，非因果关系的操作顺序无所谓；</li>\n<li><strong>会话一致性：</strong>对系统数据的访问过程框定在一个会话中，约定系统能保证在同一个有效会话中实现读已之所写的一致性；</li>\n</ul>\n<h1 id=\"四、Quorum机制\"><a href=\"#四、Quorum机制\" class=\"headerlink\" title=\"四、Quorum机制\"></a>四、Quorum机制</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>10个副本，一次成功更新3个，那么至少需要读取8个副本的数据，可以保证读到了最新的数据。无法保证强一致性，也就无法实现任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据。需要配合一个获取最新成功提交的版本号metadata服务，这样可以确定最新已经成功提交的版本号，然后从已经读到的数据中可以确认最新写入的数据；</p>\n<blockquote>\n<p>至少读取副本节点数 = 总副本节点数 - 一次成功更新副本数 + 1</p>\n<p>例如上面的例子：</p>\n<p> 8 = 10 - 3 + 1</p>\n</blockquote>\n<h1 id=\"五、WARO（Write-All-Read-One）机制\"><a href=\"#五、WARO（Write-All-Read-One）机制\" class=\"headerlink\" title=\"五、WARO（Write All Read One）机制\"></a>五、WARO（Write All Read One）机制</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>一种简单的副本控制协议。写操作时、只有当所有副本都更新成功后，本次写操作才算成功；否则视为失败；</p>\n<p>优先保证读、任何节点读到的数据都是最新数据，牺牲了更新服务的可用性。</p>\n<blockquote>\n<p>只要有一个副本宕机了，写服务就不会成功，但只要有一个节点存活，仍能提供读写服务</p>\n</blockquote>\n<h1 id=\"六、负载均衡策略\"><a href=\"#六、负载均衡策略\" class=\"headerlink\" title=\"六、负载均衡策略\"></a>六、负载均衡策略</h1><h2 id=\"1-轮询法\"><a href=\"#1-轮询法\" class=\"headerlink\" title=\"1. 轮询法\"></a>1. 轮询法</h2><p>将请求按顺序轮流分配到后端服务上，均衡地等待后端的每台服务器，而不关心服务器的实际连接数和当前的系统负载；</p>\n<h2 id=\"2-加权轮询法\"><a href=\"#2-加权轮询法\" class=\"headerlink\" title=\"2. 加权轮询法\"></a>2. 加权轮询法</h2><p>不同的后端服务器可能的配置与当前系统的负载均衡并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；反之给配置低，负载高的机器配置更低的权重，降低系统负载；</p>\n<h2 id=\"3-随机法\"><a href=\"#3-随机法\" class=\"headerlink\" title=\"3. 随机法\"></a>3. 随机法</h2><p>借助于随机算法，根据后端服务器的列表大小值随机选取其中一台服务器进行访问，随着客户端请求次数的增多，实际效果会越来越接近于平均分配调用到后端的每台服务器；</p>\n<h2 id=\"4-加权随机法\"><a href=\"#4-加权随机法\" class=\"headerlink\" title=\"4. 加权随机法\"></a>4. 加权随机法</h2><p>类似于加权轮询法，也是根据后端机器的配置，系统负载分配不同的权重，不同的是权重值随机请求后端服务器，而非顺序；</p>\n<h2 id=\"5-源地址哈希法\"><a href=\"#5-源地址哈希法\" class=\"headerlink\" title=\"5. 源地址哈希法\"></a>5. 源地址哈希法</h2><p>根据获取客户端的IP地址，借助哈希算法计算除一个数值，用数值对服务器列表的大小进行取模运算，得到的结果是客户端要访问服务器的序号</p>\n<blockquote>\n<p>采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，每次都会映射到同一台后端服务器进行访问</p>\n</blockquote>\n<h2 id=\"6-最小连接数法\"><a href=\"#6-最小连接数法\" class=\"headerlink\" title=\"6. 最小连接数法\"></a>6. 最小连接数法</h2><p>根据后端服务的当前连接情况，动态选取其中当前积压连接数最小的一台服务器来作为处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器；</p>\n<blockquote>\n<p>一句话概括：谁空闲谁去处理</p>\n</blockquote>\n<h1 id=\"七、分布式系统设计\"><a href=\"#七、分布式系统设计\" class=\"headerlink\" title=\"七、分布式系统设计\"></a>七、分布式系统设计</h1><ul>\n<li><strong>可扩展：</strong>通过对服务、存储的扩展，提高系统的处理能力。通过对多台服务器协同工作，来完成单台服务器无法处理的任务、尤其是高并发或者大数据量的任务；</li>\n<li><strong>高可用：</strong>单点故障不影响整体，单点故障指的是系统中某个组件一旦失效，会让整个系统瘫痪无法工作；</li>\n<li><strong>无状态：</strong>无状态的服务才能满足部分机器宕机不影响全部，可以随时进行扩展的需求；</li>\n<li><strong>可管理：</strong>便于运维，出问题能否及时发现定位</li>\n<li><strong>高可靠：</strong>同样的请求返回同样的数据，更新能够持久化，数据不丢失；</li>\n</ul>\n<h1 id=\"八、分布式事务的解决方案\"><a href=\"#八、分布式事务的解决方案\" class=\"headerlink\" title=\"八、分布式事务的解决方案\"></a>八、分布式事务的解决方案</h1><ul>\n<li><p><strong>基于XA协议：</strong>两阶段提交和三阶段提交，需要数据库层面支持；</p>\n</li>\n<li><p><strong>基于事务补偿机制：</strong>TCC（Try-Confirm-Cancel），基于业务层面实现；</p>\n<blockquote>\n<p>TCC事务模型：也称为两阶段补偿事务。第一阶段Try只预留资源，第二阶段明确告诉服务提供者，这个资源你到底要不要，对应第二阶段的confirm / cancel。</p>\n<p><strong>直白一点就是：你要这个资源，我先帮你留着，然后要的话我就给你，不要我就扔掉了；</strong></p>\n</blockquote>\n</li>\n<li><p><strong>本地消息表：</strong>基于本地数据库 + MQ，维护本地表状态（进行中），通过MQ调用服务，完成响应后回一条消息回调；将状态更改为完成。需要配合定时任务扫表，重新发送消息调用服务，保证幂等性；</p>\n<blockquote>\n<p><strong>消息幂等</strong>：当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响</p>\n<p>MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依赖，并且ID是全局唯一且与业务无关，对消息发送方和接收方都屏蔽</p>\n</blockquote>\n</li>\n<li><p>基于事务消息：例如MQ服务；</p>\n</li>\n</ul>\n<h1 id=\"九、讲讲TCC事务模型\"><a href=\"#九、讲讲TCC事务模型\" class=\"headerlink\" title=\"九、讲讲TCC事务模型\"></a>九、讲讲TCC事务模型</h1><p>TCC补偿事务：Try、Confirm、Cancel</p>\n<p>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作；</p>\n<ul>\n<li>Try：操作业务检查以及资源预留；</li>\n<li>Confirm：业务确认操作；</li>\n<li>Cancel：实现一个与Try相反的操作（即回滚操作）</li>\n</ul>\n<p>TCC模型对业务的侵入行较强，改造难度较大，每个操作都需要TCC操作；</p>\n<p>TCC会增加事务日志，如果Confirm或者Cancel阶段出错，则会进行重试，所以这两个截断需要支持幂等；如果充实失败，则需要人工介入进行恢复和处理；</p>\n<h1 id=\"十、如何理解RPC\"><a href=\"#十、如何理解RPC\" class=\"headerlink\" title=\"十、如何理解RPC\"></a>十、如何理解RPC</h1><p>远程过程调用（Remote Process Callable）</p>\n<p>RPC要求在调用方中放置被调用的方法接口，调用方只需要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用。于是调用方可以像调用内部接口一样调用远程方法，而不是封装参数名和参数值等操作；</p>\n<p>包含：</p>\n<ul>\n<li>动态代理，封装调用细节；</li>\n<li>序列化与翻序列化，数据传输与接收；</li>\n<li>通信，可以选择七层http协议，四层tcp/udp协议；</li>\n<li>异常处理机制</li>\n</ul>\n<p>首先，调用方调用的是接口，必须为接口构造一个假的实现，因此需要使用动态代理。这样，调用方的调用就被动态代理接收了。</p>\n<p>其次，动态代理接收到调用后，应该想办法调用远程的实际实现，包括下面几步：</p>\n<ul>\n<li>识别具体要调用的远程方法IP、端口；</li>\n<li>将调用方法的入参进行序列化；</li>\n<li>通过通信将请求发送到远程方法中；</li>\n</ul>\n<p>这样，远程的服务就接收到了调用方法的请求，应该：</p>\n<ul>\n<li>反序列化各个调用参数</li>\n<li>定位到实际要调用的方法，然后输入参数，执行方法；</li>\n<li>按照调用的路径返回调用的结果；</li>\n</ul>\n<h1 id=\"十一、zookeeper分布式锁实现原理\"><a href=\"#十一、zookeeper分布式锁实现原理\" class=\"headerlink\" title=\"十一、zookeeper分布式锁实现原理\"></a>十一、zookeeper分布式锁实现原理</h1>"},{"title":"CSS3基础回顾","date":"2022-02-18T12:50:23.000Z","updated":"2022-02-18T12:50:23.000Z","_content":"\n# CSS3 基础回顾\n\n## 简介\n\n全称“层叠样式表”（Cascade Style Sheet），用来修饰HTML元素的外观：包括大小、位置、颜色和形状等等；\n\n## 语法\n\n语法如下：\n\n```css\nselector {\n  property-type: property-value;\n}\n```\n\n简单来说：需要对哪个元素做修饰，首先要选中需要修饰的元素，然后再使用CSS对其作修改。\n\n## 选择器\n\n### 基本\n\n比较常用的选择器有：class选择器和id选择器，除此之外还有一些高级的选择器，在日常使用中我们可以通过查阅文档来了解一些更高级的选择器用法。\n\n- class选择器\n- id选择器\n- nth-child选择器等\n\n一个例子来说明这些选择器的用法：\n\n```css\n.className {\n  width: 200px;\n  height: 150px;\n}\n\n#id-name {\n  width: 200px;\n  height: 150px;\n}\n\n.box:nth-child(2n) {\n  background: #4f5b62;\n}\n```\n\n上面列举了三个选择器的语法：可以看到class选择器的语法是`.className`，id选择器的语法是`#idName`；掌握这两个基本就能满足90%以上的应用场景了；\n\n最后还有一个选择器值得关注：它的语义是：选择className为box并且顺序为偶数序的元素。这属于高级选择器中的其中一个，还有其他的一些可以通过上网查阅来了解；\n\n一般在前端开发中会遵循一个编码规范：就是class选择器专门用来修饰样式；id选择器专门用来编写逻辑；\n\n### 属性选择器\n\n具有特定属性的HTML元素样式不仅仅是class和id，语法如下：\n\n```css\n[title] {\n    color: blue;\n}\n```\n\n举个例子：\n\n```css\ninput[type=\"text\"] {\n    width: 150px;\n    display: block;\n    margin-bottom: 10px;\n    background-color: yellow;\n}\n\ninput[type=\"button\"] {\n    width: 120px;\n    margin-left: 35px;\n    display: block;\n}\n```\n\n### 嵌套和分组\n\n给很多样式相同的元素设置样式，可以使用分组选择器，语法如下：\n\n```css\nh1,\nh2,\np {\n  color: green;\n}\n```\n\n嵌套选择器可以用于选择器内部的样式，有下面几种实践：\n\n- `p{}`：为所有p元素指定一个样式；\n- `.marked {}`：为所有`class=\"marked\"`的元素设置样式；\n- `.marked p {}`为所有`class=\"marked\"`元素内部的`p`元素设置样式；\n- `p.marked {}`为所有`p`元素内部`class=\"marked\"`的元素设置样式；\n\n## 盒子模型\n\n所有的HTML元素都可以看作是盒子，在CSS中，“box model”是用来设计和布局使用的；\n\n一个盒子有下列几部分构成：\n\n- 外边距(margin)：清除边框外的区域，外边距是透明的；\n- 边框(border)：围绕在内边距和内容外的边框，这部分是可以看见的；\n- 内边距(padding)：清除内容周围的区域，内边距是透明的；\n- 内容(content)：盒子的内容，显示文本和图像；\n\n所以你需要知道：给一个元素设置宽高的时候要加上它的外边距、边框、内边距的宽高，这样才是一个元素的宽高；\n\n盒子模型可以通过浏览器的开发者工具看到，如果需要检视页面上的HTML元素，你可以通过查看元素在控制台的信息来查看它的边距情况。\n\n总结一下：最终元素的总宽高计算公式是这样的；\n\n- 总元素的宽度：宽度 + 左右填充 + 左右边框 + 左右边距；\n- 总元素的高度：高度 + 上下填充 + 上下边框 + 上下边距；\n\n## 样式设置\n\n### 颜色\n\n可以给字体，盒子设置颜色，下面举一部分例子：\n\n- 盒子背景：`background-color`，背景有一个简写的属性叫`background`;\n- 字体颜色：`font-color`，同样地，字体也有一个简写属性叫`font`;\n- 边框：边框使用`border`属性也可以给其上色，具体语法可以查阅相关文档；\n- 还有一个CSS属性叫`color`，这个是给文本设置颜色的；\n\n### 字体\n\n字体是HTML中的重要显示元素，CSS中字体的设置有下列几个：\n\n- font：all in one属性，可以设置字体的所有属性\n- font-family：字体\n- font-size：字体大小\n- font-style：字体样式，粗体和斜体之类的\n- font-variant：以小型大写字体或者正常字体显示文本；\n- font-weight：指定字体的粗细；\n\n介绍一下all-on-one属性的语法：\n\n```css\nfont: \"<font-style> <font-variant> <font-weight> <font-size> / <line-height> <font-family>\"\n```\n\n### All-in-one 属性语法\n\n#### 外边距（margin）\n\n语法：\n\n```css\nh1 {\n  marign: 15px 30px 15px 30px; // 次序分别为上、右、下、左\n}\n\nh1 {\n  margin: 15px 30px 15px; // 次序分别为上，左右，下\n}\n\nh1 {\n  margin: 15px 30px; // 上下，左右\n}\n\nh1 {\n  margin: 15px; //上下左右全都一样\n}\n```\n\n#### 填充（padding）\n\n语法：\n\n```css\nh1 {\n  padding: 15px 30px 15px 30px; // 次序分别为上、右、下、左\n}\n\nh1 {\n  padidng: 15px 30px 15px; // 次序为上，左右，下\n}\n\nh1 {\n  padding: 15px; 30px; // 上下，左右\n}\n\nh1 {\n  padding: 25px; // 上下左右全都一样\n}\n```\n\n\n\n## 显示\n\ndisplay设置一个元素该如何在页面上显示，visibility属性指定一个元素应可见还是隐藏；\n\n#### 隐藏元素\n\n这里提供两种方法：\n\n- `display: none`：除了会隐藏，还会清除元素原本占用的页面空间；\n- `visibility: hidden`：虽然也能隐藏，但是并不会清除元素原本占用的页面空间；\n\n#### 块级元素和内联元素\n\n需要注意的是：块级元素默认占用一行，元素在页面上垂直排列；可以设置宽度和高度；\n\n内联元素则相反：其大小由内容决定，只有填满了一行才会在换行继续，默认情况下不能设置宽和高；但是可以设置边距和填充并且只在水平方向有效；\n\n了解了上面的知识以后，我们就会知道，使用display方法可以改变元素的显示方式是以块级来显示还是以内联方式来显示。相应的属性如下：\n\n- block\n- inline\n\n举个例子：加入你想给`<span>`设置元素宽高，但由于其为内联元素，无法设置宽高；这个时候你可以使用display属性为其设置显示模式为`block`，然后就可以给`<span>`设置宽高了；\n\n## 定位\n\n定位属性叫`position`，其指定了元素的定位类型，属性有5个值；\n\n- static：默认设置，没有定位，遵循正常的文档流（即从上到下，从左到右）\n- relative：相对定位元素的定位是相对其正常位置\n- fixed：元素的位置相对于浏览器窗口是固定的\n- absolute：相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于`html`；\n- stickly：基于用户的滚动位置来定位；\n\n除此之外，还有一个元素叫做`z-index`，其指定了一个元素的堆叠顺序（哪个元素该放在前面，哪个元素该放在后面），一个元素可以有正数和负数的堆叠顺序；\n\n## 溢出\n\nCSS overflow属性用于控制内容溢出元素框时的显示方式，有下面5个属性值；\n\n- visible：默认值，内容不会被裁剪，会显示在元素框之外\n- hidden：内容会被裁剪，并且其余部分的内容是不可见的；\n- scroll：内容会被裁剪，但是浏览器会显示滚动条以便于查看其余内容\n- auto：如果内容被裁剪，浏览器会显示滚动条以便于查看其余内容\n- inherit：规定应该从父元素继承overflow属性的值\n\n## 浮动\n\n浮动的框可以向左或者向右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档流的普通流中，所以文档的普通流中的浮动框之后的块框表现地像浮动框不存在一样。\n\n需要注意的是：当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，因此float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。\n\n于是在浮动布局中会存在下面这个现象：\n\n- 如果元素A是浮动元素并且其上一个元素也是浮动元素，那么A元素就会跟随在上一个元素的后边；（如果一行放不下就会挤到下一行）\n- 如果元素A是浮动元素，但是其上一个元素是标准流元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐；\n- 浮动框之后的block元素会认为这个框不存在，但其中的文本依然会认为这个元素让出位置。浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列；\n\n使用浮动的原则如下：\n\n要么都使用浮动，要么都不使用浮动；要么对没使用浮动的DIV设置margin样式；\n\n## 清除浮动\n\n在非IE浏览器的环境下，当容器高度为auto，且容器内容有浮动的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至是破坏）布局的现象。这个现象就叫做浮动溢出，为了防止这个现象出现而进行的CSS处理，就叫做CSS清除浮动。\n\n引用W3C的一个例子来解释浮动溢出：\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news: {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n        </style>\n    </head>\n    <!--虽然从HTML上看news是包裹着图片和文字的-->\n    <div class=\"news\">\n        <!--实际上由于浮动元素不占据空间，所以news的高度直接塌陷了-->\n        <img src=\"news-pic.jpg\"/>\n\t    <p>some text</p>\n    </div>\n</html>\n```\n\n既然出现了元素的“高度塌陷”，那么可以使用清除浮动的方法来解决这个问题：\n\n**方法1：在浮动元素后使用一个空元素，并在CSS中赋予`.clear {clear: both}`属性即可清除浮动；例如：**\n\n```html\n<html>\n    <head>\n    </head>\n    \n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some Text</p>\n            <div class=\"clear\"/>\n        </div>\n    </body>\n</html>\n```\n\n优点：简单、代码少，浏览器兼容性好；\n\n缺点：需要添加大量无语义的html元素，代码不够优雅，后期也不容易维护；\n\n\n\n**方法2：使用CSS的overflow属性（BFC机制）**\n\n给浮动元素的容器添加`overflow: hidden`或者`overflow: auto`可以清除浮动，在添加了相关属性后，浮动元素又回到了容器层，把容器高度撑起，达到清除浮动的效果。\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n                overflow: hidden;\n                /* 触发IE6 / IE7的haslayout机制 */\n                *zoom: 1;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n        </style>\n    </head>\n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>some text</p>\n        </div>\n    </body>\n</html>\n```\n\n\n\n**方法3：给浮动元素的容器添加浮动**\n\n给浮动元素的容器添加浮动属性即可清除内部浮动，但是这样做会使其整体浮动，影响布局，不推荐使用；\n\n\n\n**方法4：使用邻接元素处理**\n\n什么都不做，给浮动元素后面的元素添加clear属性；\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n            \n            .content {\n                clear: both;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some text</p>\n            <div class=\"content\"></div>\n        </div>\n    </body>\n</html>\n```\n\n\n\n**方法5：使用CSS的:after伪元素**\n\n给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个`:after`伪元素实现方法1的那种效果。此方法兼容性好；推荐这种方法；\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n            \n            .clearfix:after {\n                content: \"020\";\n                display: block;\n                height: 0;\n                clear: both;\n                visibility: hidden;\n            }\n            \n            .clearfix {\n                /* 触发 IE6/IE7的haslayout机制 */\n                zoom: 1;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"news clearfix\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some text</p>\n        </div>\n    </body>\n</html>\n```\n\n## 伪类\n\nCSS伪类是用来添加一些选择器的特殊效果，语法如下：\n\n```css\n/* 基础语法 */\nselector:pseudo-class { property: value; }\n\n/* CSS类选择器 */\nselector.class:pseudo-class { property: value; }\n```\n\n### anchor伪类\n\n链接的不同状态都可以以不同的方式显示，例如：\n\n- `a:link`：未访问的链接\n- `a:visited`：已访问的链接\n- `a:hover`：鼠标划过的链接\n- `a:active`：已选中的链接\n\n### CSS伪元素\n\nCSS伪元素用来添加一些选择器的特殊效果，语法如下：\n\n```CSS\n/* 伪元素语法 */\nselector:pseudo-element { property: value; }\n\n/* CSS类也可以使用伪元素 */\nselector.class:pseudo-element { property: value; }\n```\n\n下面列举一些伪元素的使用：\n\n- `:first-line`：用于向文本的首行设置特殊样式；\n- `:first-letter`：用于向文本的首字母设置特殊样式；\n- `:before`：可以在元素的内容前插入新内容；\n- `:after`：可以在元素的内容后插入新内容；\n","source":"_posts/frontend/css3/css3-ch01.md","raw":"---\ntitle: CSS3基础回顾\ndate: 2022-02-18 20:50:23\nupdated: 2022-02-18 20:50:23\ntags: CSS3\ncategories: 前端\n---\n\n# CSS3 基础回顾\n\n## 简介\n\n全称“层叠样式表”（Cascade Style Sheet），用来修饰HTML元素的外观：包括大小、位置、颜色和形状等等；\n\n## 语法\n\n语法如下：\n\n```css\nselector {\n  property-type: property-value;\n}\n```\n\n简单来说：需要对哪个元素做修饰，首先要选中需要修饰的元素，然后再使用CSS对其作修改。\n\n## 选择器\n\n### 基本\n\n比较常用的选择器有：class选择器和id选择器，除此之外还有一些高级的选择器，在日常使用中我们可以通过查阅文档来了解一些更高级的选择器用法。\n\n- class选择器\n- id选择器\n- nth-child选择器等\n\n一个例子来说明这些选择器的用法：\n\n```css\n.className {\n  width: 200px;\n  height: 150px;\n}\n\n#id-name {\n  width: 200px;\n  height: 150px;\n}\n\n.box:nth-child(2n) {\n  background: #4f5b62;\n}\n```\n\n上面列举了三个选择器的语法：可以看到class选择器的语法是`.className`，id选择器的语法是`#idName`；掌握这两个基本就能满足90%以上的应用场景了；\n\n最后还有一个选择器值得关注：它的语义是：选择className为box并且顺序为偶数序的元素。这属于高级选择器中的其中一个，还有其他的一些可以通过上网查阅来了解；\n\n一般在前端开发中会遵循一个编码规范：就是class选择器专门用来修饰样式；id选择器专门用来编写逻辑；\n\n### 属性选择器\n\n具有特定属性的HTML元素样式不仅仅是class和id，语法如下：\n\n```css\n[title] {\n    color: blue;\n}\n```\n\n举个例子：\n\n```css\ninput[type=\"text\"] {\n    width: 150px;\n    display: block;\n    margin-bottom: 10px;\n    background-color: yellow;\n}\n\ninput[type=\"button\"] {\n    width: 120px;\n    margin-left: 35px;\n    display: block;\n}\n```\n\n### 嵌套和分组\n\n给很多样式相同的元素设置样式，可以使用分组选择器，语法如下：\n\n```css\nh1,\nh2,\np {\n  color: green;\n}\n```\n\n嵌套选择器可以用于选择器内部的样式，有下面几种实践：\n\n- `p{}`：为所有p元素指定一个样式；\n- `.marked {}`：为所有`class=\"marked\"`的元素设置样式；\n- `.marked p {}`为所有`class=\"marked\"`元素内部的`p`元素设置样式；\n- `p.marked {}`为所有`p`元素内部`class=\"marked\"`的元素设置样式；\n\n## 盒子模型\n\n所有的HTML元素都可以看作是盒子，在CSS中，“box model”是用来设计和布局使用的；\n\n一个盒子有下列几部分构成：\n\n- 外边距(margin)：清除边框外的区域，外边距是透明的；\n- 边框(border)：围绕在内边距和内容外的边框，这部分是可以看见的；\n- 内边距(padding)：清除内容周围的区域，内边距是透明的；\n- 内容(content)：盒子的内容，显示文本和图像；\n\n所以你需要知道：给一个元素设置宽高的时候要加上它的外边距、边框、内边距的宽高，这样才是一个元素的宽高；\n\n盒子模型可以通过浏览器的开发者工具看到，如果需要检视页面上的HTML元素，你可以通过查看元素在控制台的信息来查看它的边距情况。\n\n总结一下：最终元素的总宽高计算公式是这样的；\n\n- 总元素的宽度：宽度 + 左右填充 + 左右边框 + 左右边距；\n- 总元素的高度：高度 + 上下填充 + 上下边框 + 上下边距；\n\n## 样式设置\n\n### 颜色\n\n可以给字体，盒子设置颜色，下面举一部分例子：\n\n- 盒子背景：`background-color`，背景有一个简写的属性叫`background`;\n- 字体颜色：`font-color`，同样地，字体也有一个简写属性叫`font`;\n- 边框：边框使用`border`属性也可以给其上色，具体语法可以查阅相关文档；\n- 还有一个CSS属性叫`color`，这个是给文本设置颜色的；\n\n### 字体\n\n字体是HTML中的重要显示元素，CSS中字体的设置有下列几个：\n\n- font：all in one属性，可以设置字体的所有属性\n- font-family：字体\n- font-size：字体大小\n- font-style：字体样式，粗体和斜体之类的\n- font-variant：以小型大写字体或者正常字体显示文本；\n- font-weight：指定字体的粗细；\n\n介绍一下all-on-one属性的语法：\n\n```css\nfont: \"<font-style> <font-variant> <font-weight> <font-size> / <line-height> <font-family>\"\n```\n\n### All-in-one 属性语法\n\n#### 外边距（margin）\n\n语法：\n\n```css\nh1 {\n  marign: 15px 30px 15px 30px; // 次序分别为上、右、下、左\n}\n\nh1 {\n  margin: 15px 30px 15px; // 次序分别为上，左右，下\n}\n\nh1 {\n  margin: 15px 30px; // 上下，左右\n}\n\nh1 {\n  margin: 15px; //上下左右全都一样\n}\n```\n\n#### 填充（padding）\n\n语法：\n\n```css\nh1 {\n  padding: 15px 30px 15px 30px; // 次序分别为上、右、下、左\n}\n\nh1 {\n  padidng: 15px 30px 15px; // 次序为上，左右，下\n}\n\nh1 {\n  padding: 15px; 30px; // 上下，左右\n}\n\nh1 {\n  padding: 25px; // 上下左右全都一样\n}\n```\n\n\n\n## 显示\n\ndisplay设置一个元素该如何在页面上显示，visibility属性指定一个元素应可见还是隐藏；\n\n#### 隐藏元素\n\n这里提供两种方法：\n\n- `display: none`：除了会隐藏，还会清除元素原本占用的页面空间；\n- `visibility: hidden`：虽然也能隐藏，但是并不会清除元素原本占用的页面空间；\n\n#### 块级元素和内联元素\n\n需要注意的是：块级元素默认占用一行，元素在页面上垂直排列；可以设置宽度和高度；\n\n内联元素则相反：其大小由内容决定，只有填满了一行才会在换行继续，默认情况下不能设置宽和高；但是可以设置边距和填充并且只在水平方向有效；\n\n了解了上面的知识以后，我们就会知道，使用display方法可以改变元素的显示方式是以块级来显示还是以内联方式来显示。相应的属性如下：\n\n- block\n- inline\n\n举个例子：加入你想给`<span>`设置元素宽高，但由于其为内联元素，无法设置宽高；这个时候你可以使用display属性为其设置显示模式为`block`，然后就可以给`<span>`设置宽高了；\n\n## 定位\n\n定位属性叫`position`，其指定了元素的定位类型，属性有5个值；\n\n- static：默认设置，没有定位，遵循正常的文档流（即从上到下，从左到右）\n- relative：相对定位元素的定位是相对其正常位置\n- fixed：元素的位置相对于浏览器窗口是固定的\n- absolute：相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于`html`；\n- stickly：基于用户的滚动位置来定位；\n\n除此之外，还有一个元素叫做`z-index`，其指定了一个元素的堆叠顺序（哪个元素该放在前面，哪个元素该放在后面），一个元素可以有正数和负数的堆叠顺序；\n\n## 溢出\n\nCSS overflow属性用于控制内容溢出元素框时的显示方式，有下面5个属性值；\n\n- visible：默认值，内容不会被裁剪，会显示在元素框之外\n- hidden：内容会被裁剪，并且其余部分的内容是不可见的；\n- scroll：内容会被裁剪，但是浏览器会显示滚动条以便于查看其余内容\n- auto：如果内容被裁剪，浏览器会显示滚动条以便于查看其余内容\n- inherit：规定应该从父元素继承overflow属性的值\n\n## 浮动\n\n浮动的框可以向左或者向右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档流的普通流中，所以文档的普通流中的浮动框之后的块框表现地像浮动框不存在一样。\n\n需要注意的是：当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，因此float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。\n\n于是在浮动布局中会存在下面这个现象：\n\n- 如果元素A是浮动元素并且其上一个元素也是浮动元素，那么A元素就会跟随在上一个元素的后边；（如果一行放不下就会挤到下一行）\n- 如果元素A是浮动元素，但是其上一个元素是标准流元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐；\n- 浮动框之后的block元素会认为这个框不存在，但其中的文本依然会认为这个元素让出位置。浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列；\n\n使用浮动的原则如下：\n\n要么都使用浮动，要么都不使用浮动；要么对没使用浮动的DIV设置margin样式；\n\n## 清除浮动\n\n在非IE浏览器的环境下，当容器高度为auto，且容器内容有浮动的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至是破坏）布局的现象。这个现象就叫做浮动溢出，为了防止这个现象出现而进行的CSS处理，就叫做CSS清除浮动。\n\n引用W3C的一个例子来解释浮动溢出：\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news: {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n        </style>\n    </head>\n    <!--虽然从HTML上看news是包裹着图片和文字的-->\n    <div class=\"news\">\n        <!--实际上由于浮动元素不占据空间，所以news的高度直接塌陷了-->\n        <img src=\"news-pic.jpg\"/>\n\t    <p>some text</p>\n    </div>\n</html>\n```\n\n既然出现了元素的“高度塌陷”，那么可以使用清除浮动的方法来解决这个问题：\n\n**方法1：在浮动元素后使用一个空元素，并在CSS中赋予`.clear {clear: both}`属性即可清除浮动；例如：**\n\n```html\n<html>\n    <head>\n    </head>\n    \n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some Text</p>\n            <div class=\"clear\"/>\n        </div>\n    </body>\n</html>\n```\n\n优点：简单、代码少，浏览器兼容性好；\n\n缺点：需要添加大量无语义的html元素，代码不够优雅，后期也不容易维护；\n\n\n\n**方法2：使用CSS的overflow属性（BFC机制）**\n\n给浮动元素的容器添加`overflow: hidden`或者`overflow: auto`可以清除浮动，在添加了相关属性后，浮动元素又回到了容器层，把容器高度撑起，达到清除浮动的效果。\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n                overflow: hidden;\n                /* 触发IE6 / IE7的haslayout机制 */\n                *zoom: 1;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n        </style>\n    </head>\n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>some text</p>\n        </div>\n    </body>\n</html>\n```\n\n\n\n**方法3：给浮动元素的容器添加浮动**\n\n给浮动元素的容器添加浮动属性即可清除内部浮动，但是这样做会使其整体浮动，影响布局，不推荐使用；\n\n\n\n**方法4：使用邻接元素处理**\n\n什么都不做，给浮动元素后面的元素添加clear属性；\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n            \n            .content {\n                clear: both;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some text</p>\n            <div class=\"content\"></div>\n        </div>\n    </body>\n</html>\n```\n\n\n\n**方法5：使用CSS的:after伪元素**\n\n给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个`:after`伪元素实现方法1的那种效果。此方法兼容性好；推荐这种方法；\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n            \n            .clearfix:after {\n                content: \"020\";\n                display: block;\n                height: 0;\n                clear: both;\n                visibility: hidden;\n            }\n            \n            .clearfix {\n                /* 触发 IE6/IE7的haslayout机制 */\n                zoom: 1;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"news clearfix\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some text</p>\n        </div>\n    </body>\n</html>\n```\n\n## 伪类\n\nCSS伪类是用来添加一些选择器的特殊效果，语法如下：\n\n```css\n/* 基础语法 */\nselector:pseudo-class { property: value; }\n\n/* CSS类选择器 */\nselector.class:pseudo-class { property: value; }\n```\n\n### anchor伪类\n\n链接的不同状态都可以以不同的方式显示，例如：\n\n- `a:link`：未访问的链接\n- `a:visited`：已访问的链接\n- `a:hover`：鼠标划过的链接\n- `a:active`：已选中的链接\n\n### CSS伪元素\n\nCSS伪元素用来添加一些选择器的特殊效果，语法如下：\n\n```CSS\n/* 伪元素语法 */\nselector:pseudo-element { property: value; }\n\n/* CSS类也可以使用伪元素 */\nselector.class:pseudo-element { property: value; }\n```\n\n下面列举一些伪元素的使用：\n\n- `:first-line`：用于向文本的首行设置特殊样式；\n- `:first-letter`：用于向文本的首字母设置特殊样式；\n- `:before`：可以在元素的内容前插入新内容；\n- `:after`：可以在元素的内容后插入新内容；\n","slug":"frontend/css3/css3-ch01","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vv003r4f610nheeeed","content":"<h1 id=\"CSS3-基础回顾\"><a href=\"#CSS3-基础回顾\" class=\"headerlink\" title=\"CSS3 基础回顾\"></a>CSS3 基础回顾</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>全称“层叠样式表”（Cascade Style Sheet），用来修饰HTML元素的外观：包括大小、位置、颜色和形状等等；</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs css\">selector &#123;<br>  property-type: property-value;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>简单来说：需要对哪个元素做修饰，首先要选中需要修饰的元素，然后再使用CSS对其作修改。</p>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><h3 id=\"基本\"><a href=\"#基本\" class=\"headerlink\" title=\"基本\"></a>基本</h3><p>比较常用的选择器有：class选择器和id选择器，除此之外还有一些高级的选择器，在日常使用中我们可以通过查阅文档来了解一些更高级的选择器用法。</p>\n<ul>\n<li>class选择器</li>\n<li>id选择器</li>\n<li>nth-child选择器等</li>\n</ul>\n<p>一个例子来说明这些选择器的用法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.className</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#id-name</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.box</span><span class=\"hljs-selector-pseudo\">:nth-child</span>(<span class=\"hljs-number\">2</span>n) &#123;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#4f5b62</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面列举了三个选择器的语法：可以看到class选择器的语法是<code>.className</code>，id选择器的语法是<code>#idName</code>；掌握这两个基本就能满足90%以上的应用场景了；</p>\n<p>最后还有一个选择器值得关注：它的语义是：选择className为box并且顺序为偶数序的元素。这属于高级选择器中的其中一个，还有其他的一些可以通过上网查阅来了解；</p>\n<p>一般在前端开发中会遵循一个编码规范：就是class选择器专门用来修饰样式；id选择器专门用来编写逻辑；</p>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>具有特定属性的HTML元素样式不仅仅是class和id，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[title]</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-attr\">[type=<span class=\"hljs-string\">&quot;text&quot;</span>]</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">10px</span>;<br>    <span class=\"hljs-attribute\">background-color</span>: yellow;<br>&#125;<br><br><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-attr\">[type=<span class=\"hljs-string\">&quot;button&quot;</span>]</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">120px</span>;<br>    <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">35px</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"嵌套和分组\"><a href=\"#嵌套和分组\" class=\"headerlink\" title=\"嵌套和分组\"></a>嵌套和分组</h3><p>给很多样式相同的元素设置样式，可以使用分组选择器，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span>,<br><span class=\"hljs-selector-tag\">h2</span>,<br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>嵌套选择器可以用于选择器内部的样式，有下面几种实践：</p>\n<ul>\n<li><code>p&#123;&#125;</code>：为所有p元素指定一个样式；</li>\n<li><code>.marked &#123;&#125;</code>：为所有<code>class=&quot;marked&quot;</code>的元素设置样式；</li>\n<li><code>.marked p &#123;&#125;</code>为所有<code>class=&quot;marked&quot;</code>元素内部的<code>p</code>元素设置样式；</li>\n<li><code>p.marked &#123;&#125;</code>为所有<code>p</code>元素内部<code>class=&quot;marked&quot;</code>的元素设置样式；</li>\n</ul>\n<h2 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h2><p>所有的HTML元素都可以看作是盒子，在CSS中，“box model”是用来设计和布局使用的；</p>\n<p>一个盒子有下列几部分构成：</p>\n<ul>\n<li>外边距(margin)：清除边框外的区域，外边距是透明的；</li>\n<li>边框(border)：围绕在内边距和内容外的边框，这部分是可以看见的；</li>\n<li>内边距(padding)：清除内容周围的区域，内边距是透明的；</li>\n<li>内容(content)：盒子的内容，显示文本和图像；</li>\n</ul>\n<p>所以你需要知道：给一个元素设置宽高的时候要加上它的外边距、边框、内边距的宽高，这样才是一个元素的宽高；</p>\n<p>盒子模型可以通过浏览器的开发者工具看到，如果需要检视页面上的HTML元素，你可以通过查看元素在控制台的信息来查看它的边距情况。</p>\n<p>总结一下：最终元素的总宽高计算公式是这样的；</p>\n<ul>\n<li>总元素的宽度：宽度 + 左右填充 + 左右边框 + 左右边距；</li>\n<li>总元素的高度：高度 + 上下填充 + 上下边框 + 上下边距；</li>\n</ul>\n<h2 id=\"样式设置\"><a href=\"#样式设置\" class=\"headerlink\" title=\"样式设置\"></a>样式设置</h2><h3 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h3><p>可以给字体，盒子设置颜色，下面举一部分例子：</p>\n<ul>\n<li>盒子背景：<code>background-color</code>，背景有一个简写的属性叫<code>background</code>;</li>\n<li>字体颜色：<code>font-color</code>，同样地，字体也有一个简写属性叫<code>font</code>;</li>\n<li>边框：边框使用<code>border</code>属性也可以给其上色，具体语法可以查阅相关文档；</li>\n<li>还有一个CSS属性叫<code>color</code>，这个是给文本设置颜色的；</li>\n</ul>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><p>字体是HTML中的重要显示元素，CSS中字体的设置有下列几个：</p>\n<ul>\n<li>font：all in one属性，可以设置字体的所有属性</li>\n<li>font-family：字体</li>\n<li>font-size：字体大小</li>\n<li>font-style：字体样式，粗体和斜体之类的</li>\n<li>font-variant：以小型大写字体或者正常字体显示文本；</li>\n<li>font-weight：指定字体的粗细；</li>\n</ul>\n<p>介绍一下all-on-one属性的语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">font</span>: <span class=\"hljs-string\">&quot;&lt;font-style&gt; &lt;font-variant&gt; &lt;font-weight&gt; &lt;font-size&gt; / &lt;line-height&gt; &lt;font-family&gt;&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"All-in-one-属性语法\"><a href=\"#All-in-one-属性语法\" class=\"headerlink\" title=\"All-in-one 属性语法\"></a>All-in-one 属性语法</h3><h4 id=\"外边距（margin）\"><a href=\"#外边距（margin）\" class=\"headerlink\" title=\"外边距（margin）\"></a>外边距（margin）</h4><p>语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  marign: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 次序分别为上、右、下、左<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span>; // 次序分别为上，左右，下<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 上下，左右<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span>; //上下左右全都一样<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"填充（padding）\"><a href=\"#填充（padding）\" class=\"headerlink\" title=\"填充（padding）\"></a>填充（padding）</h4><p>语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 次序分别为上、右、下、左<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  padidng: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span>; // 次序为上，左右，下<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span>; <span class=\"hljs-number\">30px</span>; // 上下，左右<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">25px</span>; // 上下左右全都一样<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"显示\"><a href=\"#显示\" class=\"headerlink\" title=\"显示\"></a>显示</h2><p>display设置一个元素该如何在页面上显示，visibility属性指定一个元素应可见还是隐藏；</p>\n<h4 id=\"隐藏元素\"><a href=\"#隐藏元素\" class=\"headerlink\" title=\"隐藏元素\"></a>隐藏元素</h4><p>这里提供两种方法：</p>\n<ul>\n<li><code>display: none</code>：除了会隐藏，还会清除元素原本占用的页面空间；</li>\n<li><code>visibility: hidden</code>：虽然也能隐藏，但是并不会清除元素原本占用的页面空间；</li>\n</ul>\n<h4 id=\"块级元素和内联元素\"><a href=\"#块级元素和内联元素\" class=\"headerlink\" title=\"块级元素和内联元素\"></a>块级元素和内联元素</h4><p>需要注意的是：块级元素默认占用一行，元素在页面上垂直排列；可以设置宽度和高度；</p>\n<p>内联元素则相反：其大小由内容决定，只有填满了一行才会在换行继续，默认情况下不能设置宽和高；但是可以设置边距和填充并且只在水平方向有效；</p>\n<p>了解了上面的知识以后，我们就会知道，使用display方法可以改变元素的显示方式是以块级来显示还是以内联方式来显示。相应的属性如下：</p>\n<ul>\n<li>block</li>\n<li>inline</li>\n</ul>\n<p>举个例子：加入你想给<code>&lt;span&gt;</code>设置元素宽高，但由于其为内联元素，无法设置宽高；这个时候你可以使用display属性为其设置显示模式为<code>block</code>，然后就可以给<code>&lt;span&gt;</code>设置宽高了；</p>\n<h2 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h2><p>定位属性叫<code>position</code>，其指定了元素的定位类型，属性有5个值；</p>\n<ul>\n<li>static：默认设置，没有定位，遵循正常的文档流（即从上到下，从左到右）</li>\n<li>relative：相对定位元素的定位是相对其正常位置</li>\n<li>fixed：元素的位置相对于浏览器窗口是固定的</li>\n<li>absolute：相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>html</code>；</li>\n<li>stickly：基于用户的滚动位置来定位；</li>\n</ul>\n<p>除此之外，还有一个元素叫做<code>z-index</code>，其指定了一个元素的堆叠顺序（哪个元素该放在前面，哪个元素该放在后面），一个元素可以有正数和负数的堆叠顺序；</p>\n<h2 id=\"溢出\"><a href=\"#溢出\" class=\"headerlink\" title=\"溢出\"></a>溢出</h2><p>CSS overflow属性用于控制内容溢出元素框时的显示方式，有下面5个属性值；</p>\n<ul>\n<li>visible：默认值，内容不会被裁剪，会显示在元素框之外</li>\n<li>hidden：内容会被裁剪，并且其余部分的内容是不可见的；</li>\n<li>scroll：内容会被裁剪，但是浏览器会显示滚动条以便于查看其余内容</li>\n<li>auto：如果内容被裁剪，浏览器会显示滚动条以便于查看其余内容</li>\n<li>inherit：规定应该从父元素继承overflow属性的值</li>\n</ul>\n<h2 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h2><p>浮动的框可以向左或者向右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档流的普通流中，所以文档的普通流中的浮动框之后的块框表现地像浮动框不存在一样。</p>\n<p>需要注意的是：当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，因此float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。</p>\n<p>于是在浮动布局中会存在下面这个现象：</p>\n<ul>\n<li>如果元素A是浮动元素并且其上一个元素也是浮动元素，那么A元素就会跟随在上一个元素的后边；（如果一行放不下就会挤到下一行）</li>\n<li>如果元素A是浮动元素，但是其上一个元素是标准流元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐；</li>\n<li>浮动框之后的block元素会认为这个框不存在，但其中的文本依然会认为这个元素让出位置。浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列；</li>\n</ul>\n<p>使用浮动的原则如下：</p>\n<p>要么都使用浮动，要么都不使用浮动；要么对没使用浮动的DIV设置margin样式；</p>\n<h2 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h2><p>在非IE浏览器的环境下，当容器高度为auto，且容器内容有浮动的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至是破坏）布局的现象。这个现象就叫做浮动溢出，为了防止这个现象出现而进行的CSS处理，就叫做CSS清除浮动。</p>\n<p>引用W3C的一个例子来解释浮动溢出：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span>: &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!--虽然从HTML上看news是包裹着图片和文字的--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!--实际上由于浮动元素不占据空间，所以news的高度直接塌陷了--&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>\t    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>既然出现了元素的“高度塌陷”，那么可以使用清除浮动的方法来解决这个问题：</p>\n<p><strong>方法1：在浮动元素后使用一个空元素，并在CSS中赋予<code>.clear &#123;clear: both&#125;</code>属性即可清除浮动；例如：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some Text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clear&quot;</span>/&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>优点：简单、代码少，浏览器兼容性好；</p>\n<p>缺点：需要添加大量无语义的html元素，代码不够优雅，后期也不容易维护；</p>\n<p><strong>方法2：使用CSS的overflow属性（BFC机制）</strong></p>\n<p>给浮动元素的容器添加<code>overflow: hidden</code>或者<code>overflow: auto</code>可以清除浮动，在添加了相关属性后，浮动元素又回到了容器层，把容器高度撑起，达到清除浮动的效果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">overflow</span>: hidden;</span><br><span class=\"language-css\">                <span class=\"hljs-comment\">/* 触发IE6 / IE7的haslayout机制 */</span></span><br><span class=\"language-css\">                *zoom: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>方法3：给浮动元素的容器添加浮动</strong></p>\n<p>给浮动元素的容器添加浮动属性即可清除内部浮动，但是这样做会使其整体浮动，影响布局，不推荐使用；</p>\n<p><strong>方法4：使用邻接元素处理</strong></p>\n<p>什么都不做，给浮动元素后面的元素添加clear属性；</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.content</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">clear</span>: both;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>方法5：使用CSS的:after伪元素</strong></p>\n<p>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个<code>:after</code>伪元素实现方法1的那种效果。此方法兼容性好；推荐这种方法；</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.clearfix</span><span class=\"hljs-selector-pseudo\">:after</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;020&quot;</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">display</span>: block;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">clear</span>: both;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">visibility</span>: hidden;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.clearfix</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-comment\">/* 触发 IE6/IE7的haslayout机制 */</span></span><br><span class=\"language-css\">                zoom: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news clearfix&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"伪类\"><a href=\"#伪类\" class=\"headerlink\" title=\"伪类\"></a>伪类</h2><p>CSS伪类是用来添加一些选择器的特殊效果，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 基础语法 */</span><br>selector:pseudo-class &#123; property: value; &#125;<br><br><span class=\"hljs-comment\">/* CSS类选择器 */</span><br>selector<span class=\"hljs-selector-class\">.class</span>:pseudo-class &#123; property: value; &#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"anchor伪类\"><a href=\"#anchor伪类\" class=\"headerlink\" title=\"anchor伪类\"></a>anchor伪类</h3><p>链接的不同状态都可以以不同的方式显示，例如：</p>\n<ul>\n<li><code>a:link</code>：未访问的链接</li>\n<li><code>a:visited</code>：已访问的链接</li>\n<li><code>a:hover</code>：鼠标划过的链接</li>\n<li><code>a:active</code>：已选中的链接</li>\n</ul>\n<h3 id=\"CSS伪元素\"><a href=\"#CSS伪元素\" class=\"headerlink\" title=\"CSS伪元素\"></a>CSS伪元素</h3><p>CSS伪元素用来添加一些选择器的特殊效果，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs CSS\"><span class=\"hljs-comment\">/* 伪元素语法 */</span><br>selector:pseudo-element &#123; property: value; &#125;<br><br><span class=\"hljs-comment\">/* CSS类也可以使用伪元素 */</span><br>selector<span class=\"hljs-selector-class\">.class</span>:pseudo-element &#123; property: value; &#125;<br></code></pre></td></tr></table></figure>\n<p>下面列举一些伪元素的使用：</p>\n<ul>\n<li><code>:first-line</code>：用于向文本的首行设置特殊样式；</li>\n<li><code>:first-letter</code>：用于向文本的首字母设置特殊样式；</li>\n<li><code>:before</code>：可以在元素的内容前插入新内容；</li>\n<li><code>:after</code>：可以在元素的内容后插入新内容；</li>\n</ul>\n","site":{"data":{}},"wordcount":7273,"excerpt":"","more":"<h1 id=\"CSS3-基础回顾\"><a href=\"#CSS3-基础回顾\" class=\"headerlink\" title=\"CSS3 基础回顾\"></a>CSS3 基础回顾</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>全称“层叠样式表”（Cascade Style Sheet），用来修饰HTML元素的外观：包括大小、位置、颜色和形状等等；</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">selector &#123;<br>  property-type: property-value;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>简单来说：需要对哪个元素做修饰，首先要选中需要修饰的元素，然后再使用CSS对其作修改。</p>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><h3 id=\"基本\"><a href=\"#基本\" class=\"headerlink\" title=\"基本\"></a>基本</h3><p>比较常用的选择器有：class选择器和id选择器，除此之外还有一些高级的选择器，在日常使用中我们可以通过查阅文档来了解一些更高级的选择器用法。</p>\n<ul>\n<li>class选择器</li>\n<li>id选择器</li>\n<li>nth-child选择器等</li>\n</ul>\n<p>一个例子来说明这些选择器的用法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.className</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#id-name</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.box</span><span class=\"hljs-selector-pseudo\">:nth-child</span>(<span class=\"hljs-number\">2</span>n) &#123;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#4f5b62</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面列举了三个选择器的语法：可以看到class选择器的语法是<code>.className</code>，id选择器的语法是<code>#idName</code>；掌握这两个基本就能满足90%以上的应用场景了；</p>\n<p>最后还有一个选择器值得关注：它的语义是：选择className为box并且顺序为偶数序的元素。这属于高级选择器中的其中一个，还有其他的一些可以通过上网查阅来了解；</p>\n<p>一般在前端开发中会遵循一个编码规范：就是class选择器专门用来修饰样式；id选择器专门用来编写逻辑；</p>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>具有特定属性的HTML元素样式不仅仅是class和id，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[title]</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-attr\">[type=<span class=\"hljs-string\">&quot;text&quot;</span>]</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">10px</span>;<br>    <span class=\"hljs-attribute\">background-color</span>: yellow;<br>&#125;<br><br><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-attr\">[type=<span class=\"hljs-string\">&quot;button&quot;</span>]</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">120px</span>;<br>    <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">35px</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"嵌套和分组\"><a href=\"#嵌套和分组\" class=\"headerlink\" title=\"嵌套和分组\"></a>嵌套和分组</h3><p>给很多样式相同的元素设置样式，可以使用分组选择器，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span>,<br><span class=\"hljs-selector-tag\">h2</span>,<br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>嵌套选择器可以用于选择器内部的样式，有下面几种实践：</p>\n<ul>\n<li><code>p&#123;&#125;</code>：为所有p元素指定一个样式；</li>\n<li><code>.marked &#123;&#125;</code>：为所有<code>class=&quot;marked&quot;</code>的元素设置样式；</li>\n<li><code>.marked p &#123;&#125;</code>为所有<code>class=&quot;marked&quot;</code>元素内部的<code>p</code>元素设置样式；</li>\n<li><code>p.marked &#123;&#125;</code>为所有<code>p</code>元素内部<code>class=&quot;marked&quot;</code>的元素设置样式；</li>\n</ul>\n<h2 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h2><p>所有的HTML元素都可以看作是盒子，在CSS中，“box model”是用来设计和布局使用的；</p>\n<p>一个盒子有下列几部分构成：</p>\n<ul>\n<li>外边距(margin)：清除边框外的区域，外边距是透明的；</li>\n<li>边框(border)：围绕在内边距和内容外的边框，这部分是可以看见的；</li>\n<li>内边距(padding)：清除内容周围的区域，内边距是透明的；</li>\n<li>内容(content)：盒子的内容，显示文本和图像；</li>\n</ul>\n<p>所以你需要知道：给一个元素设置宽高的时候要加上它的外边距、边框、内边距的宽高，这样才是一个元素的宽高；</p>\n<p>盒子模型可以通过浏览器的开发者工具看到，如果需要检视页面上的HTML元素，你可以通过查看元素在控制台的信息来查看它的边距情况。</p>\n<p>总结一下：最终元素的总宽高计算公式是这样的；</p>\n<ul>\n<li>总元素的宽度：宽度 + 左右填充 + 左右边框 + 左右边距；</li>\n<li>总元素的高度：高度 + 上下填充 + 上下边框 + 上下边距；</li>\n</ul>\n<h2 id=\"样式设置\"><a href=\"#样式设置\" class=\"headerlink\" title=\"样式设置\"></a>样式设置</h2><h3 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h3><p>可以给字体，盒子设置颜色，下面举一部分例子：</p>\n<ul>\n<li>盒子背景：<code>background-color</code>，背景有一个简写的属性叫<code>background</code>;</li>\n<li>字体颜色：<code>font-color</code>，同样地，字体也有一个简写属性叫<code>font</code>;</li>\n<li>边框：边框使用<code>border</code>属性也可以给其上色，具体语法可以查阅相关文档；</li>\n<li>还有一个CSS属性叫<code>color</code>，这个是给文本设置颜色的；</li>\n</ul>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><p>字体是HTML中的重要显示元素，CSS中字体的设置有下列几个：</p>\n<ul>\n<li>font：all in one属性，可以设置字体的所有属性</li>\n<li>font-family：字体</li>\n<li>font-size：字体大小</li>\n<li>font-style：字体样式，粗体和斜体之类的</li>\n<li>font-variant：以小型大写字体或者正常字体显示文本；</li>\n<li>font-weight：指定字体的粗细；</li>\n</ul>\n<p>介绍一下all-on-one属性的语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">font</span>: <span class=\"hljs-string\">&quot;&lt;font-style&gt; &lt;font-variant&gt; &lt;font-weight&gt; &lt;font-size&gt; / &lt;line-height&gt; &lt;font-family&gt;&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"All-in-one-属性语法\"><a href=\"#All-in-one-属性语法\" class=\"headerlink\" title=\"All-in-one 属性语法\"></a>All-in-one 属性语法</h3><h4 id=\"外边距（margin）\"><a href=\"#外边距（margin）\" class=\"headerlink\" title=\"外边距（margin）\"></a>外边距（margin）</h4><p>语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  marign: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 次序分别为上、右、下、左<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span>; // 次序分别为上，左右，下<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 上下，左右<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span>; //上下左右全都一样<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"填充（padding）\"><a href=\"#填充（padding）\" class=\"headerlink\" title=\"填充（padding）\"></a>填充（padding）</h4><p>语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 次序分别为上、右、下、左<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  padidng: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span>; // 次序为上，左右，下<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span>; <span class=\"hljs-number\">30px</span>; // 上下，左右<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">25px</span>; // 上下左右全都一样<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"显示\"><a href=\"#显示\" class=\"headerlink\" title=\"显示\"></a>显示</h2><p>display设置一个元素该如何在页面上显示，visibility属性指定一个元素应可见还是隐藏；</p>\n<h4 id=\"隐藏元素\"><a href=\"#隐藏元素\" class=\"headerlink\" title=\"隐藏元素\"></a>隐藏元素</h4><p>这里提供两种方法：</p>\n<ul>\n<li><code>display: none</code>：除了会隐藏，还会清除元素原本占用的页面空间；</li>\n<li><code>visibility: hidden</code>：虽然也能隐藏，但是并不会清除元素原本占用的页面空间；</li>\n</ul>\n<h4 id=\"块级元素和内联元素\"><a href=\"#块级元素和内联元素\" class=\"headerlink\" title=\"块级元素和内联元素\"></a>块级元素和内联元素</h4><p>需要注意的是：块级元素默认占用一行，元素在页面上垂直排列；可以设置宽度和高度；</p>\n<p>内联元素则相反：其大小由内容决定，只有填满了一行才会在换行继续，默认情况下不能设置宽和高；但是可以设置边距和填充并且只在水平方向有效；</p>\n<p>了解了上面的知识以后，我们就会知道，使用display方法可以改变元素的显示方式是以块级来显示还是以内联方式来显示。相应的属性如下：</p>\n<ul>\n<li>block</li>\n<li>inline</li>\n</ul>\n<p>举个例子：加入你想给<code>&lt;span&gt;</code>设置元素宽高，但由于其为内联元素，无法设置宽高；这个时候你可以使用display属性为其设置显示模式为<code>block</code>，然后就可以给<code>&lt;span&gt;</code>设置宽高了；</p>\n<h2 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h2><p>定位属性叫<code>position</code>，其指定了元素的定位类型，属性有5个值；</p>\n<ul>\n<li>static：默认设置，没有定位，遵循正常的文档流（即从上到下，从左到右）</li>\n<li>relative：相对定位元素的定位是相对其正常位置</li>\n<li>fixed：元素的位置相对于浏览器窗口是固定的</li>\n<li>absolute：相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>html</code>；</li>\n<li>stickly：基于用户的滚动位置来定位；</li>\n</ul>\n<p>除此之外，还有一个元素叫做<code>z-index</code>，其指定了一个元素的堆叠顺序（哪个元素该放在前面，哪个元素该放在后面），一个元素可以有正数和负数的堆叠顺序；</p>\n<h2 id=\"溢出\"><a href=\"#溢出\" class=\"headerlink\" title=\"溢出\"></a>溢出</h2><p>CSS overflow属性用于控制内容溢出元素框时的显示方式，有下面5个属性值；</p>\n<ul>\n<li>visible：默认值，内容不会被裁剪，会显示在元素框之外</li>\n<li>hidden：内容会被裁剪，并且其余部分的内容是不可见的；</li>\n<li>scroll：内容会被裁剪，但是浏览器会显示滚动条以便于查看其余内容</li>\n<li>auto：如果内容被裁剪，浏览器会显示滚动条以便于查看其余内容</li>\n<li>inherit：规定应该从父元素继承overflow属性的值</li>\n</ul>\n<h2 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h2><p>浮动的框可以向左或者向右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档流的普通流中，所以文档的普通流中的浮动框之后的块框表现地像浮动框不存在一样。</p>\n<p>需要注意的是：当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，因此float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。</p>\n<p>于是在浮动布局中会存在下面这个现象：</p>\n<ul>\n<li>如果元素A是浮动元素并且其上一个元素也是浮动元素，那么A元素就会跟随在上一个元素的后边；（如果一行放不下就会挤到下一行）</li>\n<li>如果元素A是浮动元素，但是其上一个元素是标准流元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐；</li>\n<li>浮动框之后的block元素会认为这个框不存在，但其中的文本依然会认为这个元素让出位置。浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列；</li>\n</ul>\n<p>使用浮动的原则如下：</p>\n<p>要么都使用浮动，要么都不使用浮动；要么对没使用浮动的DIV设置margin样式；</p>\n<h2 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h2><p>在非IE浏览器的环境下，当容器高度为auto，且容器内容有浮动的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至是破坏）布局的现象。这个现象就叫做浮动溢出，为了防止这个现象出现而进行的CSS处理，就叫做CSS清除浮动。</p>\n<p>引用W3C的一个例子来解释浮动溢出：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span>: &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!--虽然从HTML上看news是包裹着图片和文字的--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!--实际上由于浮动元素不占据空间，所以news的高度直接塌陷了--&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>\t    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>既然出现了元素的“高度塌陷”，那么可以使用清除浮动的方法来解决这个问题：</p>\n<p><strong>方法1：在浮动元素后使用一个空元素，并在CSS中赋予<code>.clear &#123;clear: both&#125;</code>属性即可清除浮动；例如：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some Text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clear&quot;</span>/&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>优点：简单、代码少，浏览器兼容性好；</p>\n<p>缺点：需要添加大量无语义的html元素，代码不够优雅，后期也不容易维护；</p>\n<p><strong>方法2：使用CSS的overflow属性（BFC机制）</strong></p>\n<p>给浮动元素的容器添加<code>overflow: hidden</code>或者<code>overflow: auto</code>可以清除浮动，在添加了相关属性后，浮动元素又回到了容器层，把容器高度撑起，达到清除浮动的效果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">overflow</span>: hidden;</span><br><span class=\"language-css\">                <span class=\"hljs-comment\">/* 触发IE6 / IE7的haslayout机制 */</span></span><br><span class=\"language-css\">                *zoom: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>方法3：给浮动元素的容器添加浮动</strong></p>\n<p>给浮动元素的容器添加浮动属性即可清除内部浮动，但是这样做会使其整体浮动，影响布局，不推荐使用；</p>\n<p><strong>方法4：使用邻接元素处理</strong></p>\n<p>什么都不做，给浮动元素后面的元素添加clear属性；</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.content</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">clear</span>: both;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>方法5：使用CSS的:after伪元素</strong></p>\n<p>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个<code>:after</code>伪元素实现方法1的那种效果。此方法兼容性好；推荐这种方法；</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.clearfix</span><span class=\"hljs-selector-pseudo\">:after</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;020&quot;</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">display</span>: block;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">clear</span>: both;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">visibility</span>: hidden;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.clearfix</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-comment\">/* 触发 IE6/IE7的haslayout机制 */</span></span><br><span class=\"language-css\">                zoom: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news clearfix&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"伪类\"><a href=\"#伪类\" class=\"headerlink\" title=\"伪类\"></a>伪类</h2><p>CSS伪类是用来添加一些选择器的特殊效果，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 基础语法 */</span><br>selector:pseudo-class &#123; property: value; &#125;<br><br><span class=\"hljs-comment\">/* CSS类选择器 */</span><br>selector<span class=\"hljs-selector-class\">.class</span>:pseudo-class &#123; property: value; &#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"anchor伪类\"><a href=\"#anchor伪类\" class=\"headerlink\" title=\"anchor伪类\"></a>anchor伪类</h3><p>链接的不同状态都可以以不同的方式显示，例如：</p>\n<ul>\n<li><code>a:link</code>：未访问的链接</li>\n<li><code>a:visited</code>：已访问的链接</li>\n<li><code>a:hover</code>：鼠标划过的链接</li>\n<li><code>a:active</code>：已选中的链接</li>\n</ul>\n<h3 id=\"CSS伪元素\"><a href=\"#CSS伪元素\" class=\"headerlink\" title=\"CSS伪元素\"></a>CSS伪元素</h3><p>CSS伪元素用来添加一些选择器的特殊效果，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs CSS\"><span class=\"hljs-comment\">/* 伪元素语法 */</span><br>selector:pseudo-element &#123; property: value; &#125;<br><br><span class=\"hljs-comment\">/* CSS类也可以使用伪元素 */</span><br>selector<span class=\"hljs-selector-class\">.class</span>:pseudo-element &#123; property: value; &#125;<br></code></pre></td></tr></table></figure>\n<p>下面列举一些伪元素的使用：</p>\n<ul>\n<li><code>:first-line</code>：用于向文本的首行设置特殊样式；</li>\n<li><code>:first-letter</code>：用于向文本的首字母设置特殊样式；</li>\n<li><code>:before</code>：可以在元素的内容前插入新内容；</li>\n<li><code>:after</code>：可以在元素的内容后插入新内容；</li>\n</ul>\n"},{"title":"CSS3进阶操作","date":"2022-02-18T12:50:27.000Z","updated":"2022-02-18T12:50:27.000Z","_content":"\n# CSS3 进阶操作\n\n## CSS3 边框\n\n在CSS3中你可以创建圆角边框、阴影边框。属性如下：\n\n- border-radius：边框圆角\n- box-shadow：盒子阴影\n- border-image：边框图片\n\n## CSS3 圆角\n\n举个例子：\n\n```css\n#cornenr1 {\n  border-radius: 25px;\n  background: #a8bcf4;\n  padding: 20px;\n  width: 200px;\n  height: 150px;\n}\n\n#corner2 {\n  border-radius:15px 50px 30px 5px;\n  background: #fe5cb9;\n  padding: 10px;\n  width: 150px;\n  height: 100px;\n}\n```\n\n可以发现第二个例子有四个值：顺序为：左上、右上、右下和左下；\n\n一个值就是默认四个角都是一样的，没什么毛病。\n\n初次之外还有其他属性，可以自己熟悉一下：\n\n- border-top-left-radius\n- border-top-right-radius\n- border-bottom-left-radius\n- border-bottom-right-radis\n\n## CSS3 背景\n\nCSS3中新增几个背景属性，提供了更大背景元素控制；\n\n- background-image：添加背景图片，不同背景用逗号分隔开；\n- background-size：指定背景图像的大小；\n- background-origin：指定背景图像的位置区域，有：border-box, padding-box和content-box;\n- background-clip：从指定位置开始绘制背景图形；\n\n## CSS3 渐变\n\n可以在两个或者多个指定的颜色之间显示平稳的过渡，CSS3中定义了两种类型的渐变（gradients）：\n\n- 线性渐变：向上下左右对角方向\n- 径向渐变：由中心定义\n\n语法如下：\n\n```css\nbackground-image: linear-gradient(direction, color-stop1, color-stop2, ...)\n\n/* \n  direction: 默认上下，左右为to right\n  对角渐变：to bottom right\n  还可以使用角度：angle (这里指的是弧度)\n*/\n```\n\n重复的线性渐变\n\n```css\nbackground-image: repeating-linear-gradient(red, yellow 10%, green 20%);\n```\n\n径向渐变\n\n```css\nbackground-image: radial-gradient(shape size at position, start-color, ... ,last-color);\n```\n\nshape参数定义了形状。可以是circle和ellipse，圆形和椭圆形；\n\n和重复地线性渐变一样，径向渐变也有重复地属性，这里就不再演示了。\n\n## CSS3 文本效果 & 字体\n\n文本效果包括下面的这几个：\n\n- text-shadow：文本阴影，可以定义多个，可以做字体发光效果\n- box-shadow：盒子阴影，可以定义多个，做成发光盒子\n- text-overflow：指定用户如何显示溢出内容；\n- word-wrap：自动换行属性允许强制文本换行，这意味着分裂它中间的一个字；\n- word-break：单词拆分换行属性指定换行规则；\n\n需要使用自定义字体可以使用`@font-face`属性。例子如下：\n\n```css\n@font-face {\n  font-family: myFirstFont;\n  src url(font.ttf);\n}\n\ndiv {\n  font-family: myFirstFont;\n}\n```\n\n## CSS3 2D & 3D转换\n\n### 2D转换\n\n2D变换方法有下面5种：\n\n- translate：根据x轴和y轴位置给定的参数，从当前元素位置移动；\n- rotate：在一个给定读书顺时针旋转元素，负值代表逆时针旋转；\n- scale：该元素增加或者减少大小，取决于宽度（x轴）和高度（y轴）的参数；\n- skew：表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负数表示像反方向倾斜；\n- matrix：和2D变换方法合并成一个，一共有六个参数，包括：旋转、缩放、移动和倾斜的功能；\n\n具体语法可以再查阅\n\n### 3D转换\n\n3D转换会使用到两个方法：\n\n- rotateX：围绕其在一个给定度数X轴旋转的元素；\n- rotateY：围绕其在一个给定读书Y轴旋转的元素；\n\n你也可以使用transform属性做2D和3D变换，一般来说建议使用transform属性，特别是在使用一些库来实现高级动画效果的时候；\n\n```css\ndiv {\n    transform: none | transform-functions;\n}\n/*\ntransform-functions包括：\nmatrix, matrix3d;\ntranslate, translate3d, translateX, translateY, translateZ;\nscale, scale3d, scaleX, scaleY, scaleZ;\nrotate, rotate3d, rotateX, rotateY, rotateX;\nskew, skewX, skewY;\nperspective：为3D转换元素定义透视视图；\n*/\n```\n\n## CSS3 过渡\n\nCSS3过渡是元素从一种样式逐渐改变为另一种效果，要实现这一点，必须规定两项内容；\n\n- 指定要添加效果的CSS属性；\n- 指定效果的持续时间；\n\n例子如下：\n\n```css\ndiv {\n    transition: width 2s;\n    -webkit-transition: width 2s; /* Safari or Chrome */\n}\n\n/* 要添加多个样式的变换效果，可以使用逗号分隔属性 */\ndiv {\n    transition: width 2s, height 2s, transform 2s;\n    -webkit-transform: width 2s, height 2s, transform 2s;\n}\n```\n\n## CSS3 动画\n\nCSS3可以创建动画，可以取代一些JavaScript实现的动画效果；\n\nCSS3使用`@keyframes`创建动画，语法如下：\n\n```css\n@keyframes myfirst {\n    from { background: red; }\n    to { background: yellow; }\n}\n\n@-webkit-keyframes myfirst {\n    from { background: red; }\n    to { background: yellow; }\n}\n\ndiv {\n    animation: myfirst 5s;\n}\n\n/* 除此之外还可以这样定义 */\n@keyframes myfirst {\n    0% { background: red; }\n    25% { background: yellow; }\n    50% { background: blue; }\n    100% { background: green; }\n}\n\n@-webkit-keyframes myfirst {\n    0% { background: red; }\n    25% { background: yellow; }\n    50% { background: blue; }\n    100% { background: green; }\n}\n\ndiv {\n    animation: myfirst 5s;\n}\n```\n\n## CSS3媒体查询\n\n顾名思义，针对不同媒体类型的设备定制不同的样式规则，例如：手机、电视、平板、电脑以及阅读器设置不同的样式规则；语法如下：\n\n```css\n@media not | only mediatype and (expression) {\n    /* Write CSS Code here... */\n}\n```\n\n解释一下参数的含义：\n\n- not：用于排除某些特定设备的；\n- only：用来指定某种特别的媒体设备；\n- all：适用于所有媒体设备，这个最常见；\n\n举个例子：\n\n```css\n@media screen and (min-width: 480px) {\n    #leftsidebar { width: 200px; float: left; }\n    #main { margin-left: 216px; }\n}\n```\n\n以上实例在屏幕可视窗口尺寸大于480px像素时将菜单浮动到页面左侧；\n\n## CSS3 Flex布局\n\n弹性布局是CSS3的一种新布局模式，当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为布局方式，引入弹性布局模型的目的是提供一种更加有效地方式来对一个容器中的元素进行排列、对齐和分配空白空间；\n\n下面以例子来说明：\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .flex-container {\n                display: flex;\n                width: 400px;\n                height: 250px;\n                background: lightgray;\n            }\n            \n            .flex-item {\n                background-color: cornflowerblue;\n                width: 100px;\n                height: 100px;\n                margin: 10px;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"flex-container\">\n            <div class=\"flex-item\">flex item 1</div>\n            <div class=\"flex-item\">flex item 2</div>\n            <div class=\"flex-item\">flex item 3</div>\n        </div>\n    </body>\n</html>\n```\n\n### 弹性容器布局属性\n\n#### flex-direction\n\n指定了弹性子元素在父容器中的位置，值有：\n\n- row：默认值，从左到右排列；\n- row-reverse：反转横向排列，从右到左排列；\n- column：纵向排列；\n- column-reverse：反转纵向排列，从后往前排；\n\n#### justify-content\n\n内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐，值有：\n\n- flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。\n- flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。\n- center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。\n- space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。\n- space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。\n\n#### align-items\n\n设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式；值有：\n\n- flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n- strench：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n\n#### flex-wrap\n\n指定弹性盒子的子元素换行方式，值有：\n\n- nowrap：默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\n- wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\n- wrap-reverse：反转 wrap 排列。\n\n#### align-content\n\n用于修改flex-wrap属性的行为，类似align-items，但它不是设置弹性子元素的对齐，而是设置各个行的对齐，值有：\n\n- strench：默认。各行将会伸展以占用剩余的空间。\n- flex-start：各行向弹性盒容器的起始位置堆叠。\n- flex-end：各行向弹性盒容器的结束位置堆叠。\n- center：各行向弹性盒容器的中间位置堆叠。\n- space-between：各行在弹性盒容器中平均分布。\n- space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。\n\n### 弹性元素布局属性\n\n#### 排序order\n\n用整数值来定义排列顺序，数值小的排在前面，可以为负值；例子如下：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 100px;\n    height: 100px;\n    margin: 10px;\n}\n\n.flex-item:first-child {\n    order: -1;\n    -webkit-order: -1;\n}\n```\n\n#### 对齐\n\n设置margin值为auto，自动获取弹性容器中剩余空间，因此设置垂直方向margin值为'auto'\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: 10px;\n}\n\n.flex-item:first-child {\n    margin-right: auto;\n}\n```\n\n#### 完美居中\n\n可以看出，使用弹性盒子后，居中变得非常简单。下面演示一下完美居中的实现方法；\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: auto;\n}\n```\n\n#### align-self\n\n用于设置弹性元素自身在纵轴方向上的对齐方式，值有：\n\n- auto：如果'align-self'的值为'auto'，则其计算值为元素的父元素的'align-items'值，如果其没有父元素，则计算值为'stretch'。\n- flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n- strench：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n\n以下演示了不同值的效果，可以在[Code Pen](https://codepen.io)上直接试验：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 60px;\n    min-height: 100px;\n    margin: 10px;\n}\n\n.item1 {\n    align-self: flex-start;\n    -webkit-align-self: flex-start;\n}\n\n.item2 {\n    align-self: flex-end;\n    -webkit-align-self: flex-end;\n}\n\n.item3 {\n    align-self: center;\n    -webkit-align-self: center;\n}\n\n.item4 {\n    align-self: baseline;\n    -webkit-align-self: baseline;\n}\n\n.item5 {\n    align-self: strench;\n    -webkit-align-self: strench;\n}\n```\n\n#### flex\n\n用于指定弹性子元素如何分配空间，值有：\n\n- auto：计算值为1 1 auto\n- initial：计算值为0 1 auto\n- none：计算值为0 0 auto\n- inherit：从父元素继承\n- flex-grow：定义弹性盒子元素的扩展比率\n- flex-shrink：定义弹性盒子元素的搜索比率\n- flex-basis：定义弹性盒子元素的默认基准值\n\n例子：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    margin: 10px;\n}\n\n.item1 {\n    -webkit-flex: 2;\n    flex: 2;\n}\n\n.item2 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n\n.item3 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n```\n","source":"_posts/frontend/css3/css3-ch02.md","raw":"---\ntitle: CSS3进阶操作\ndate: 2022-02-18 20:50:27\nupdated: 2022-02-18 20:50:27\ntags: CSS3\ncategories: 前端\n---\n\n# CSS3 进阶操作\n\n## CSS3 边框\n\n在CSS3中你可以创建圆角边框、阴影边框。属性如下：\n\n- border-radius：边框圆角\n- box-shadow：盒子阴影\n- border-image：边框图片\n\n## CSS3 圆角\n\n举个例子：\n\n```css\n#cornenr1 {\n  border-radius: 25px;\n  background: #a8bcf4;\n  padding: 20px;\n  width: 200px;\n  height: 150px;\n}\n\n#corner2 {\n  border-radius:15px 50px 30px 5px;\n  background: #fe5cb9;\n  padding: 10px;\n  width: 150px;\n  height: 100px;\n}\n```\n\n可以发现第二个例子有四个值：顺序为：左上、右上、右下和左下；\n\n一个值就是默认四个角都是一样的，没什么毛病。\n\n初次之外还有其他属性，可以自己熟悉一下：\n\n- border-top-left-radius\n- border-top-right-radius\n- border-bottom-left-radius\n- border-bottom-right-radis\n\n## CSS3 背景\n\nCSS3中新增几个背景属性，提供了更大背景元素控制；\n\n- background-image：添加背景图片，不同背景用逗号分隔开；\n- background-size：指定背景图像的大小；\n- background-origin：指定背景图像的位置区域，有：border-box, padding-box和content-box;\n- background-clip：从指定位置开始绘制背景图形；\n\n## CSS3 渐变\n\n可以在两个或者多个指定的颜色之间显示平稳的过渡，CSS3中定义了两种类型的渐变（gradients）：\n\n- 线性渐变：向上下左右对角方向\n- 径向渐变：由中心定义\n\n语法如下：\n\n```css\nbackground-image: linear-gradient(direction, color-stop1, color-stop2, ...)\n\n/* \n  direction: 默认上下，左右为to right\n  对角渐变：to bottom right\n  还可以使用角度：angle (这里指的是弧度)\n*/\n```\n\n重复的线性渐变\n\n```css\nbackground-image: repeating-linear-gradient(red, yellow 10%, green 20%);\n```\n\n径向渐变\n\n```css\nbackground-image: radial-gradient(shape size at position, start-color, ... ,last-color);\n```\n\nshape参数定义了形状。可以是circle和ellipse，圆形和椭圆形；\n\n和重复地线性渐变一样，径向渐变也有重复地属性，这里就不再演示了。\n\n## CSS3 文本效果 & 字体\n\n文本效果包括下面的这几个：\n\n- text-shadow：文本阴影，可以定义多个，可以做字体发光效果\n- box-shadow：盒子阴影，可以定义多个，做成发光盒子\n- text-overflow：指定用户如何显示溢出内容；\n- word-wrap：自动换行属性允许强制文本换行，这意味着分裂它中间的一个字；\n- word-break：单词拆分换行属性指定换行规则；\n\n需要使用自定义字体可以使用`@font-face`属性。例子如下：\n\n```css\n@font-face {\n  font-family: myFirstFont;\n  src url(font.ttf);\n}\n\ndiv {\n  font-family: myFirstFont;\n}\n```\n\n## CSS3 2D & 3D转换\n\n### 2D转换\n\n2D变换方法有下面5种：\n\n- translate：根据x轴和y轴位置给定的参数，从当前元素位置移动；\n- rotate：在一个给定读书顺时针旋转元素，负值代表逆时针旋转；\n- scale：该元素增加或者减少大小，取决于宽度（x轴）和高度（y轴）的参数；\n- skew：表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负数表示像反方向倾斜；\n- matrix：和2D变换方法合并成一个，一共有六个参数，包括：旋转、缩放、移动和倾斜的功能；\n\n具体语法可以再查阅\n\n### 3D转换\n\n3D转换会使用到两个方法：\n\n- rotateX：围绕其在一个给定度数X轴旋转的元素；\n- rotateY：围绕其在一个给定读书Y轴旋转的元素；\n\n你也可以使用transform属性做2D和3D变换，一般来说建议使用transform属性，特别是在使用一些库来实现高级动画效果的时候；\n\n```css\ndiv {\n    transform: none | transform-functions;\n}\n/*\ntransform-functions包括：\nmatrix, matrix3d;\ntranslate, translate3d, translateX, translateY, translateZ;\nscale, scale3d, scaleX, scaleY, scaleZ;\nrotate, rotate3d, rotateX, rotateY, rotateX;\nskew, skewX, skewY;\nperspective：为3D转换元素定义透视视图；\n*/\n```\n\n## CSS3 过渡\n\nCSS3过渡是元素从一种样式逐渐改变为另一种效果，要实现这一点，必须规定两项内容；\n\n- 指定要添加效果的CSS属性；\n- 指定效果的持续时间；\n\n例子如下：\n\n```css\ndiv {\n    transition: width 2s;\n    -webkit-transition: width 2s; /* Safari or Chrome */\n}\n\n/* 要添加多个样式的变换效果，可以使用逗号分隔属性 */\ndiv {\n    transition: width 2s, height 2s, transform 2s;\n    -webkit-transform: width 2s, height 2s, transform 2s;\n}\n```\n\n## CSS3 动画\n\nCSS3可以创建动画，可以取代一些JavaScript实现的动画效果；\n\nCSS3使用`@keyframes`创建动画，语法如下：\n\n```css\n@keyframes myfirst {\n    from { background: red; }\n    to { background: yellow; }\n}\n\n@-webkit-keyframes myfirst {\n    from { background: red; }\n    to { background: yellow; }\n}\n\ndiv {\n    animation: myfirst 5s;\n}\n\n/* 除此之外还可以这样定义 */\n@keyframes myfirst {\n    0% { background: red; }\n    25% { background: yellow; }\n    50% { background: blue; }\n    100% { background: green; }\n}\n\n@-webkit-keyframes myfirst {\n    0% { background: red; }\n    25% { background: yellow; }\n    50% { background: blue; }\n    100% { background: green; }\n}\n\ndiv {\n    animation: myfirst 5s;\n}\n```\n\n## CSS3媒体查询\n\n顾名思义，针对不同媒体类型的设备定制不同的样式规则，例如：手机、电视、平板、电脑以及阅读器设置不同的样式规则；语法如下：\n\n```css\n@media not | only mediatype and (expression) {\n    /* Write CSS Code here... */\n}\n```\n\n解释一下参数的含义：\n\n- not：用于排除某些特定设备的；\n- only：用来指定某种特别的媒体设备；\n- all：适用于所有媒体设备，这个最常见；\n\n举个例子：\n\n```css\n@media screen and (min-width: 480px) {\n    #leftsidebar { width: 200px; float: left; }\n    #main { margin-left: 216px; }\n}\n```\n\n以上实例在屏幕可视窗口尺寸大于480px像素时将菜单浮动到页面左侧；\n\n## CSS3 Flex布局\n\n弹性布局是CSS3的一种新布局模式，当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为布局方式，引入弹性布局模型的目的是提供一种更加有效地方式来对一个容器中的元素进行排列、对齐和分配空白空间；\n\n下面以例子来说明：\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .flex-container {\n                display: flex;\n                width: 400px;\n                height: 250px;\n                background: lightgray;\n            }\n            \n            .flex-item {\n                background-color: cornflowerblue;\n                width: 100px;\n                height: 100px;\n                margin: 10px;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"flex-container\">\n            <div class=\"flex-item\">flex item 1</div>\n            <div class=\"flex-item\">flex item 2</div>\n            <div class=\"flex-item\">flex item 3</div>\n        </div>\n    </body>\n</html>\n```\n\n### 弹性容器布局属性\n\n#### flex-direction\n\n指定了弹性子元素在父容器中的位置，值有：\n\n- row：默认值，从左到右排列；\n- row-reverse：反转横向排列，从右到左排列；\n- column：纵向排列；\n- column-reverse：反转纵向排列，从后往前排；\n\n#### justify-content\n\n内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐，值有：\n\n- flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。\n- flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。\n- center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。\n- space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。\n- space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。\n\n#### align-items\n\n设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式；值有：\n\n- flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n- strench：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n\n#### flex-wrap\n\n指定弹性盒子的子元素换行方式，值有：\n\n- nowrap：默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\n- wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\n- wrap-reverse：反转 wrap 排列。\n\n#### align-content\n\n用于修改flex-wrap属性的行为，类似align-items，但它不是设置弹性子元素的对齐，而是设置各个行的对齐，值有：\n\n- strench：默认。各行将会伸展以占用剩余的空间。\n- flex-start：各行向弹性盒容器的起始位置堆叠。\n- flex-end：各行向弹性盒容器的结束位置堆叠。\n- center：各行向弹性盒容器的中间位置堆叠。\n- space-between：各行在弹性盒容器中平均分布。\n- space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。\n\n### 弹性元素布局属性\n\n#### 排序order\n\n用整数值来定义排列顺序，数值小的排在前面，可以为负值；例子如下：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 100px;\n    height: 100px;\n    margin: 10px;\n}\n\n.flex-item:first-child {\n    order: -1;\n    -webkit-order: -1;\n}\n```\n\n#### 对齐\n\n设置margin值为auto，自动获取弹性容器中剩余空间，因此设置垂直方向margin值为'auto'\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: 10px;\n}\n\n.flex-item:first-child {\n    margin-right: auto;\n}\n```\n\n#### 完美居中\n\n可以看出，使用弹性盒子后，居中变得非常简单。下面演示一下完美居中的实现方法；\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: auto;\n}\n```\n\n#### align-self\n\n用于设置弹性元素自身在纵轴方向上的对齐方式，值有：\n\n- auto：如果'align-self'的值为'auto'，则其计算值为元素的父元素的'align-items'值，如果其没有父元素，则计算值为'stretch'。\n- flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n- strench：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n\n以下演示了不同值的效果，可以在[Code Pen](https://codepen.io)上直接试验：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 60px;\n    min-height: 100px;\n    margin: 10px;\n}\n\n.item1 {\n    align-self: flex-start;\n    -webkit-align-self: flex-start;\n}\n\n.item2 {\n    align-self: flex-end;\n    -webkit-align-self: flex-end;\n}\n\n.item3 {\n    align-self: center;\n    -webkit-align-self: center;\n}\n\n.item4 {\n    align-self: baseline;\n    -webkit-align-self: baseline;\n}\n\n.item5 {\n    align-self: strench;\n    -webkit-align-self: strench;\n}\n```\n\n#### flex\n\n用于指定弹性子元素如何分配空间，值有：\n\n- auto：计算值为1 1 auto\n- initial：计算值为0 1 auto\n- none：计算值为0 0 auto\n- inherit：从父元素继承\n- flex-grow：定义弹性盒子元素的扩展比率\n- flex-shrink：定义弹性盒子元素的搜索比率\n- flex-basis：定义弹性盒子元素的默认基准值\n\n例子：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    margin: 10px;\n}\n\n.item1 {\n    -webkit-flex: 2;\n    flex: 2;\n}\n\n.item2 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n\n.item3 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n```\n","slug":"frontend/css3/css3-ch02","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vv003v4f619y1a7ib5","content":"<h1 id=\"CSS3-进阶操作\"><a href=\"#CSS3-进阶操作\" class=\"headerlink\" title=\"CSS3 进阶操作\"></a>CSS3 进阶操作</h1><h2 id=\"CSS3-边框\"><a href=\"#CSS3-边框\" class=\"headerlink\" title=\"CSS3 边框\"></a>CSS3 边框</h2><p>在CSS3中你可以创建圆角边框、阴影边框。属性如下：</p>\n<ul>\n<li>border-radius：边框圆角</li>\n<li>box-shadow：盒子阴影</li>\n<li>border-image：边框图片</li>\n</ul>\n<h2 id=\"CSS3-圆角\"><a href=\"#CSS3-圆角\" class=\"headerlink\" title=\"CSS3 圆角\"></a>CSS3 圆角</h2><p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#cornenr1</span> &#123;<br>  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">25px</span>;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#a8bcf4</span>;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#corner2</span> &#123;<br>  <span class=\"hljs-attribute\">border-radius</span>:<span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">50px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">5px</span>;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#fe5cb9</span>;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">10px</span>;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以发现第二个例子有四个值：顺序为：左上、右上、右下和左下；</p>\n<p>一个值就是默认四个角都是一样的，没什么毛病。</p>\n<p>初次之外还有其他属性，可以自己熟悉一下：</p>\n<ul>\n<li>border-top-left-radius</li>\n<li>border-top-right-radius</li>\n<li>border-bottom-left-radius</li>\n<li>border-bottom-right-radis</li>\n</ul>\n<h2 id=\"CSS3-背景\"><a href=\"#CSS3-背景\" class=\"headerlink\" title=\"CSS3 背景\"></a>CSS3 背景</h2><p>CSS3中新增几个背景属性，提供了更大背景元素控制；</p>\n<ul>\n<li>background-image：添加背景图片，不同背景用逗号分隔开；</li>\n<li>background-size：指定背景图像的大小；</li>\n<li>background-origin：指定背景图像的位置区域，有：border-box, padding-box和content-box;</li>\n<li>background-clip：从指定位置开始绘制背景图形；</li>\n</ul>\n<h2 id=\"CSS3-渐变\"><a href=\"#CSS3-渐变\" class=\"headerlink\" title=\"CSS3 渐变\"></a>CSS3 渐变</h2><p>可以在两个或者多个指定的颜色之间显示平稳的过渡，CSS3中定义了两种类型的渐变（gradients）：</p>\n<ul>\n<li>线性渐变：向上下左右对角方向</li>\n<li>径向渐变：由中心定义</li>\n</ul>\n<p>语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(direction, color-stop1, color-stop2, ...)<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">  direction: 默认上下，左右为to right</span><br><span class=\"hljs-comment\">  对角渐变：to bottom right</span><br><span class=\"hljs-comment\">  还可以使用角度：angle (这里指的是弧度)</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p>重复的线性渐变</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">repeating-linear-gradient</span>(red, yellow <span class=\"hljs-number\">10%</span>, green <span class=\"hljs-number\">20%</span>);<br></code></pre></td></tr></table></figure>\n<p>径向渐变</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">radial-gradient</span>(shape size at position, start-color, ... ,last-color);<br></code></pre></td></tr></table></figure>\n<p>shape参数定义了形状。可以是circle和ellipse，圆形和椭圆形；</p>\n<p>和重复地线性渐变一样，径向渐变也有重复地属性，这里就不再演示了。</p>\n<h2 id=\"CSS3-文本效果-amp-字体\"><a href=\"#CSS3-文本效果-amp-字体\" class=\"headerlink\" title=\"CSS3 文本效果 &amp; 字体\"></a>CSS3 文本效果 &amp; 字体</h2><p>文本效果包括下面的这几个：</p>\n<ul>\n<li>text-shadow：文本阴影，可以定义多个，可以做字体发光效果</li>\n<li>box-shadow：盒子阴影，可以定义多个，做成发光盒子</li>\n<li>text-overflow：指定用户如何显示溢出内容；</li>\n<li>word-wrap：自动换行属性允许强制文本换行，这意味着分裂它中间的一个字；</li>\n<li>word-break：单词拆分换行属性指定换行规则；</li>\n</ul>\n<p>需要使用自定义字体可以使用<code>@font-face</code>属性。例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@font-face</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: myFirstFont;<br>  <span class=\"hljs-attribute\">src</span> url(<span class=\"hljs-attribute\">font</span><span class=\"hljs-selector-class\">.ttf</span>);<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: myFirstFont;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-2D-amp-3D转换\"><a href=\"#CSS3-2D-amp-3D转换\" class=\"headerlink\" title=\"CSS3 2D &amp; 3D转换\"></a>CSS3 2D &amp; 3D转换</h2><h3 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a>2D转换</h3><p>2D变换方法有下面5种：</p>\n<ul>\n<li>translate：根据x轴和y轴位置给定的参数，从当前元素位置移动；</li>\n<li>rotate：在一个给定读书顺时针旋转元素，负值代表逆时针旋转；</li>\n<li>scale：该元素增加或者减少大小，取决于宽度（x轴）和高度（y轴）的参数；</li>\n<li>skew：表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负数表示像反方向倾斜；</li>\n<li>matrix：和2D变换方法合并成一个，一共有六个参数，包括：旋转、缩放、移动和倾斜的功能；</li>\n</ul>\n<p>具体语法可以再查阅</p>\n<h3 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a>3D转换</h3><p>3D转换会使用到两个方法：</p>\n<ul>\n<li>rotateX：围绕其在一个给定度数X轴旋转的元素；</li>\n<li>rotateY：围绕其在一个给定读书Y轴旋转的元素；</li>\n</ul>\n<p>你也可以使用transform属性做2D和3D变换，一般来说建议使用transform属性，特别是在使用一些库来实现高级动画效果的时候；</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transform</span>: none | transform-functions;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">transform-functions包括：</span><br><span class=\"hljs-comment\">matrix, matrix3d;</span><br><span class=\"hljs-comment\">translate, translate3d, translateX, translateY, translateZ;</span><br><span class=\"hljs-comment\">scale, scale3d, scaleX, scaleY, scaleZ;</span><br><span class=\"hljs-comment\">rotate, rotate3d, rotateX, rotateY, rotateX;</span><br><span class=\"hljs-comment\">skew, skewX, skewY;</span><br><span class=\"hljs-comment\">perspective：为3D转换元素定义透视视图；</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-过渡\"><a href=\"#CSS3-过渡\" class=\"headerlink\" title=\"CSS3 过渡\"></a>CSS3 过渡</h2><p>CSS3过渡是元素从一种样式逐渐改变为另一种效果，要实现这一点，必须规定两项内容；</p>\n<ul>\n<li>指定要添加效果的CSS属性；</li>\n<li>指定效果的持续时间；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>;<br>    -webkit-<span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>; <span class=\"hljs-comment\">/* Safari or Chrome */</span><br>&#125;<br><br><span class=\"hljs-comment\">/* 要添加多个样式的变换效果，可以使用逗号分隔属性 */</span><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>, height <span class=\"hljs-number\">2s</span>, transform <span class=\"hljs-number\">2s</span>;<br>    -webkit-<span class=\"hljs-attribute\">transform</span>: width <span class=\"hljs-number\">2s</span>, height <span class=\"hljs-number\">2s</span>, transform <span class=\"hljs-number\">2s</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-动画\"><a href=\"#CSS3-动画\" class=\"headerlink\" title=\"CSS3 动画\"></a>CSS3 动画</h2><p>CSS3可以创建动画，可以取代一些JavaScript实现的动画效果；</p>\n<p>CSS3使用<code>@keyframes</code>创建动画，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@keyframes</span> myfirst &#123;<br>    <span class=\"hljs-selector-tag\">from</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-selector-tag\">to</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">@-webkit-keyframes</span> myfirst &#123;<br>    <span class=\"hljs-selector-tag\">from</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-selector-tag\">to</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">animation</span>: myfirst <span class=\"hljs-number\">5s</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 除此之外还可以这样定义 */</span><br><span class=\"hljs-keyword\">@keyframes</span> myfirst &#123;<br>    <span class=\"hljs-number\">0%</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-number\">25%</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>    <span class=\"hljs-number\">50%</span> &#123; <span class=\"hljs-attribute\">background</span>: blue; &#125;<br>    <span class=\"hljs-number\">100%</span> &#123; <span class=\"hljs-attribute\">background</span>: green; &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">@-webkit-keyframes</span> myfirst &#123;<br>    <span class=\"hljs-number\">0%</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-number\">25%</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>    <span class=\"hljs-number\">50%</span> &#123; <span class=\"hljs-attribute\">background</span>: blue; &#125;<br>    <span class=\"hljs-number\">100%</span> &#123; <span class=\"hljs-attribute\">background</span>: green; &#125;<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">animation</span>: myfirst <span class=\"hljs-number\">5s</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3媒体查询\"><a href=\"#CSS3媒体查询\" class=\"headerlink\" title=\"CSS3媒体查询\"></a>CSS3媒体查询</h2><p>顾名思义，针对不同媒体类型的设备定制不同的样式规则，例如：手机、电视、平板、电脑以及阅读器设置不同的样式规则；语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">not</span> | <span class=\"hljs-keyword\">only</span> mediatype <span class=\"hljs-keyword\">and</span> (expression) &#123;<br>    <span class=\"hljs-comment\">/* Write CSS Code here... */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>解释一下参数的含义：</p>\n<ul>\n<li>not：用于排除某些特定设备的；</li>\n<li>only：用来指定某种特别的媒体设备；</li>\n<li>all：适用于所有媒体设备，这个最常见；</li>\n</ul>\n<p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">480px</span>) &#123;<br>    <span class=\"hljs-selector-id\">#leftsidebar</span> &#123; <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>; <span class=\"hljs-attribute\">float</span>: left; &#125;<br>    <span class=\"hljs-selector-id\">#main</span> &#123; <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">216px</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上实例在屏幕可视窗口尺寸大于480px像素时将菜单浮动到页面左侧；</p>\n<h2 id=\"CSS3-Flex布局\"><a href=\"#CSS3-Flex布局\" class=\"headerlink\" title=\"CSS3 Flex布局\"></a>CSS3 Flex布局</h2><p>弹性布局是CSS3的一种新布局模式，当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为布局方式，引入弹性布局模型的目的是提供一种更加有效地方式来对一个容器中的元素进行排列、对齐和分配空白空间；</p>\n<p>下面以例子来说明：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.flex-container</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">400px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">250px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background</span>: lightgray;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.flex-item</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-container&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"弹性容器布局属性\"><a href=\"#弹性容器布局属性\" class=\"headerlink\" title=\"弹性容器布局属性\"></a>弹性容器布局属性</h3><h4 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a>flex-direction</h4><p>指定了弹性子元素在父容器中的位置，值有：</p>\n<ul>\n<li>row：默认值，从左到右排列；</li>\n<li>row-reverse：反转横向排列，从右到左排列；</li>\n<li>column：纵向排列；</li>\n<li>column-reverse：反转纵向排列，从后往前排；</li>\n</ul>\n<h4 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h4><p>内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐，值有：</p>\n<ul>\n<li>flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。</li>\n<li>flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。</li>\n<li>center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。</li>\n<li>space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。</li>\n<li>space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。</li>\n</ul>\n<h4 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h4><p>设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式；值有：</p>\n<ul>\n<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>\n<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>\n<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>\n<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>\n<li>strench：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>\n</ul>\n<h4 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a>flex-wrap</h4><p>指定弹性盒子的子元素换行方式，值有：</p>\n<ul>\n<li>nowrap：默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>\n<li>wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse：反转 wrap 排列。</li>\n</ul>\n<h4 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a>align-content</h4><p>用于修改flex-wrap属性的行为，类似align-items，但它不是设置弹性子元素的对齐，而是设置各个行的对齐，值有：</p>\n<ul>\n<li>strench：默认。各行将会伸展以占用剩余的空间。</li>\n<li>flex-start：各行向弹性盒容器的起始位置堆叠。</li>\n<li>flex-end：各行向弹性盒容器的结束位置堆叠。</li>\n<li>center：各行向弹性盒容器的中间位置堆叠。</li>\n<li>space-between：各行在弹性盒容器中平均分布。</li>\n<li>space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。</li>\n</ul>\n<h3 id=\"弹性元素布局属性\"><a href=\"#弹性元素布局属性\" class=\"headerlink\" title=\"弹性元素布局属性\"></a>弹性元素布局属性</h3><h4 id=\"排序order\"><a href=\"#排序order\" class=\"headerlink\" title=\"排序order\"></a>排序order</h4><p>用整数值来定义排列顺序，数值小的排在前面，可以为负值；例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.flex-item</span><span class=\"hljs-selector-pseudo\">:first</span>-child &#123;<br>    <span class=\"hljs-attribute\">order</span>: -<span class=\"hljs-number\">1</span>;<br>    -webkit-<span class=\"hljs-attribute\">order</span>: -<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h4><p>设置margin值为auto，自动获取弹性容器中剩余空间，因此设置垂直方向margin值为’auto’</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.flex-item</span><span class=\"hljs-selector-pseudo\">:first</span>-child &#123;<br>    <span class=\"hljs-attribute\">margin-right</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"完美居中\"><a href=\"#完美居中\" class=\"headerlink\" title=\"完美居中\"></a>完美居中</h4><p>可以看出，使用弹性盒子后，居中变得非常简单。下面演示一下完美居中的实现方法；</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a>align-self</h4><p>用于设置弹性元素自身在纵轴方向上的对齐方式，值有：</p>\n<ul>\n<li>auto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。</li>\n<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>\n<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>\n<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>\n<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>\n<li>strench：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>\n</ul>\n<p>以下演示了不同值的效果，可以在<a href=\"https://codepen.io\">Code Pen</a>上直接试验：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">60px</span>;<br>    <span class=\"hljs-attribute\">min-height</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item1</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: flex-start;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: flex-start;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item2</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: flex-end;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: flex-end;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item3</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: center;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: center;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item4</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: baseline;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: baseline;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item5</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: strench;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: strench;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h4><p>用于指定弹性子元素如何分配空间，值有：</p>\n<ul>\n<li>auto：计算值为1 1 auto</li>\n<li>initial：计算值为0 1 auto</li>\n<li>none：计算值为0 0 auto</li>\n<li>inherit：从父元素继承</li>\n<li>flex-grow：定义弹性盒子元素的扩展比率</li>\n<li>flex-shrink：定义弹性盒子元素的搜索比率</li>\n<li>flex-basis：定义弹性盒子元素的默认基准值</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item1</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item2</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item3</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":7454,"excerpt":"","more":"<h1 id=\"CSS3-进阶操作\"><a href=\"#CSS3-进阶操作\" class=\"headerlink\" title=\"CSS3 进阶操作\"></a>CSS3 进阶操作</h1><h2 id=\"CSS3-边框\"><a href=\"#CSS3-边框\" class=\"headerlink\" title=\"CSS3 边框\"></a>CSS3 边框</h2><p>在CSS3中你可以创建圆角边框、阴影边框。属性如下：</p>\n<ul>\n<li>border-radius：边框圆角</li>\n<li>box-shadow：盒子阴影</li>\n<li>border-image：边框图片</li>\n</ul>\n<h2 id=\"CSS3-圆角\"><a href=\"#CSS3-圆角\" class=\"headerlink\" title=\"CSS3 圆角\"></a>CSS3 圆角</h2><p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#cornenr1</span> &#123;<br>  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">25px</span>;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#a8bcf4</span>;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#corner2</span> &#123;<br>  <span class=\"hljs-attribute\">border-radius</span>:<span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">50px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">5px</span>;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#fe5cb9</span>;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">10px</span>;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以发现第二个例子有四个值：顺序为：左上、右上、右下和左下；</p>\n<p>一个值就是默认四个角都是一样的，没什么毛病。</p>\n<p>初次之外还有其他属性，可以自己熟悉一下：</p>\n<ul>\n<li>border-top-left-radius</li>\n<li>border-top-right-radius</li>\n<li>border-bottom-left-radius</li>\n<li>border-bottom-right-radis</li>\n</ul>\n<h2 id=\"CSS3-背景\"><a href=\"#CSS3-背景\" class=\"headerlink\" title=\"CSS3 背景\"></a>CSS3 背景</h2><p>CSS3中新增几个背景属性，提供了更大背景元素控制；</p>\n<ul>\n<li>background-image：添加背景图片，不同背景用逗号分隔开；</li>\n<li>background-size：指定背景图像的大小；</li>\n<li>background-origin：指定背景图像的位置区域，有：border-box, padding-box和content-box;</li>\n<li>background-clip：从指定位置开始绘制背景图形；</li>\n</ul>\n<h2 id=\"CSS3-渐变\"><a href=\"#CSS3-渐变\" class=\"headerlink\" title=\"CSS3 渐变\"></a>CSS3 渐变</h2><p>可以在两个或者多个指定的颜色之间显示平稳的过渡，CSS3中定义了两种类型的渐变（gradients）：</p>\n<ul>\n<li>线性渐变：向上下左右对角方向</li>\n<li>径向渐变：由中心定义</li>\n</ul>\n<p>语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(direction, color-stop1, color-stop2, ...)<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">  direction: 默认上下，左右为to right</span><br><span class=\"hljs-comment\">  对角渐变：to bottom right</span><br><span class=\"hljs-comment\">  还可以使用角度：angle (这里指的是弧度)</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p>重复的线性渐变</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">repeating-linear-gradient</span>(red, yellow <span class=\"hljs-number\">10%</span>, green <span class=\"hljs-number\">20%</span>);<br></code></pre></td></tr></table></figure>\n<p>径向渐变</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">radial-gradient</span>(shape size at position, start-color, ... ,last-color);<br></code></pre></td></tr></table></figure>\n<p>shape参数定义了形状。可以是circle和ellipse，圆形和椭圆形；</p>\n<p>和重复地线性渐变一样，径向渐变也有重复地属性，这里就不再演示了。</p>\n<h2 id=\"CSS3-文本效果-amp-字体\"><a href=\"#CSS3-文本效果-amp-字体\" class=\"headerlink\" title=\"CSS3 文本效果 &amp; 字体\"></a>CSS3 文本效果 &amp; 字体</h2><p>文本效果包括下面的这几个：</p>\n<ul>\n<li>text-shadow：文本阴影，可以定义多个，可以做字体发光效果</li>\n<li>box-shadow：盒子阴影，可以定义多个，做成发光盒子</li>\n<li>text-overflow：指定用户如何显示溢出内容；</li>\n<li>word-wrap：自动换行属性允许强制文本换行，这意味着分裂它中间的一个字；</li>\n<li>word-break：单词拆分换行属性指定换行规则；</li>\n</ul>\n<p>需要使用自定义字体可以使用<code>@font-face</code>属性。例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@font-face</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: myFirstFont;<br>  <span class=\"hljs-attribute\">src</span> url(<span class=\"hljs-attribute\">font</span><span class=\"hljs-selector-class\">.ttf</span>);<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: myFirstFont;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-2D-amp-3D转换\"><a href=\"#CSS3-2D-amp-3D转换\" class=\"headerlink\" title=\"CSS3 2D &amp; 3D转换\"></a>CSS3 2D &amp; 3D转换</h2><h3 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a>2D转换</h3><p>2D变换方法有下面5种：</p>\n<ul>\n<li>translate：根据x轴和y轴位置给定的参数，从当前元素位置移动；</li>\n<li>rotate：在一个给定读书顺时针旋转元素，负值代表逆时针旋转；</li>\n<li>scale：该元素增加或者减少大小，取决于宽度（x轴）和高度（y轴）的参数；</li>\n<li>skew：表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负数表示像反方向倾斜；</li>\n<li>matrix：和2D变换方法合并成一个，一共有六个参数，包括：旋转、缩放、移动和倾斜的功能；</li>\n</ul>\n<p>具体语法可以再查阅</p>\n<h3 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a>3D转换</h3><p>3D转换会使用到两个方法：</p>\n<ul>\n<li>rotateX：围绕其在一个给定度数X轴旋转的元素；</li>\n<li>rotateY：围绕其在一个给定读书Y轴旋转的元素；</li>\n</ul>\n<p>你也可以使用transform属性做2D和3D变换，一般来说建议使用transform属性，特别是在使用一些库来实现高级动画效果的时候；</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transform</span>: none | transform-functions;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">transform-functions包括：</span><br><span class=\"hljs-comment\">matrix, matrix3d;</span><br><span class=\"hljs-comment\">translate, translate3d, translateX, translateY, translateZ;</span><br><span class=\"hljs-comment\">scale, scale3d, scaleX, scaleY, scaleZ;</span><br><span class=\"hljs-comment\">rotate, rotate3d, rotateX, rotateY, rotateX;</span><br><span class=\"hljs-comment\">skew, skewX, skewY;</span><br><span class=\"hljs-comment\">perspective：为3D转换元素定义透视视图；</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-过渡\"><a href=\"#CSS3-过渡\" class=\"headerlink\" title=\"CSS3 过渡\"></a>CSS3 过渡</h2><p>CSS3过渡是元素从一种样式逐渐改变为另一种效果，要实现这一点，必须规定两项内容；</p>\n<ul>\n<li>指定要添加效果的CSS属性；</li>\n<li>指定效果的持续时间；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>;<br>    -webkit-<span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>; <span class=\"hljs-comment\">/* Safari or Chrome */</span><br>&#125;<br><br><span class=\"hljs-comment\">/* 要添加多个样式的变换效果，可以使用逗号分隔属性 */</span><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>, height <span class=\"hljs-number\">2s</span>, transform <span class=\"hljs-number\">2s</span>;<br>    -webkit-<span class=\"hljs-attribute\">transform</span>: width <span class=\"hljs-number\">2s</span>, height <span class=\"hljs-number\">2s</span>, transform <span class=\"hljs-number\">2s</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-动画\"><a href=\"#CSS3-动画\" class=\"headerlink\" title=\"CSS3 动画\"></a>CSS3 动画</h2><p>CSS3可以创建动画，可以取代一些JavaScript实现的动画效果；</p>\n<p>CSS3使用<code>@keyframes</code>创建动画，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@keyframes</span> myfirst &#123;<br>    <span class=\"hljs-selector-tag\">from</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-selector-tag\">to</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">@-webkit-keyframes</span> myfirst &#123;<br>    <span class=\"hljs-selector-tag\">from</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-selector-tag\">to</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">animation</span>: myfirst <span class=\"hljs-number\">5s</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 除此之外还可以这样定义 */</span><br><span class=\"hljs-keyword\">@keyframes</span> myfirst &#123;<br>    <span class=\"hljs-number\">0%</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-number\">25%</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>    <span class=\"hljs-number\">50%</span> &#123; <span class=\"hljs-attribute\">background</span>: blue; &#125;<br>    <span class=\"hljs-number\">100%</span> &#123; <span class=\"hljs-attribute\">background</span>: green; &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">@-webkit-keyframes</span> myfirst &#123;<br>    <span class=\"hljs-number\">0%</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-number\">25%</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>    <span class=\"hljs-number\">50%</span> &#123; <span class=\"hljs-attribute\">background</span>: blue; &#125;<br>    <span class=\"hljs-number\">100%</span> &#123; <span class=\"hljs-attribute\">background</span>: green; &#125;<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">animation</span>: myfirst <span class=\"hljs-number\">5s</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3媒体查询\"><a href=\"#CSS3媒体查询\" class=\"headerlink\" title=\"CSS3媒体查询\"></a>CSS3媒体查询</h2><p>顾名思义，针对不同媒体类型的设备定制不同的样式规则，例如：手机、电视、平板、电脑以及阅读器设置不同的样式规则；语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">not</span> | <span class=\"hljs-keyword\">only</span> mediatype <span class=\"hljs-keyword\">and</span> (expression) &#123;<br>    <span class=\"hljs-comment\">/* Write CSS Code here... */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>解释一下参数的含义：</p>\n<ul>\n<li>not：用于排除某些特定设备的；</li>\n<li>only：用来指定某种特别的媒体设备；</li>\n<li>all：适用于所有媒体设备，这个最常见；</li>\n</ul>\n<p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">480px</span>) &#123;<br>    <span class=\"hljs-selector-id\">#leftsidebar</span> &#123; <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>; <span class=\"hljs-attribute\">float</span>: left; &#125;<br>    <span class=\"hljs-selector-id\">#main</span> &#123; <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">216px</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上实例在屏幕可视窗口尺寸大于480px像素时将菜单浮动到页面左侧；</p>\n<h2 id=\"CSS3-Flex布局\"><a href=\"#CSS3-Flex布局\" class=\"headerlink\" title=\"CSS3 Flex布局\"></a>CSS3 Flex布局</h2><p>弹性布局是CSS3的一种新布局模式，当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为布局方式，引入弹性布局模型的目的是提供一种更加有效地方式来对一个容器中的元素进行排列、对齐和分配空白空间；</p>\n<p>下面以例子来说明：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.flex-container</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">400px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">250px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background</span>: lightgray;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.flex-item</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-container&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"弹性容器布局属性\"><a href=\"#弹性容器布局属性\" class=\"headerlink\" title=\"弹性容器布局属性\"></a>弹性容器布局属性</h3><h4 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a>flex-direction</h4><p>指定了弹性子元素在父容器中的位置，值有：</p>\n<ul>\n<li>row：默认值，从左到右排列；</li>\n<li>row-reverse：反转横向排列，从右到左排列；</li>\n<li>column：纵向排列；</li>\n<li>column-reverse：反转纵向排列，从后往前排；</li>\n</ul>\n<h4 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h4><p>内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐，值有：</p>\n<ul>\n<li>flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。</li>\n<li>flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。</li>\n<li>center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。</li>\n<li>space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。</li>\n<li>space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。</li>\n</ul>\n<h4 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h4><p>设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式；值有：</p>\n<ul>\n<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>\n<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>\n<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>\n<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>\n<li>strench：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>\n</ul>\n<h4 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a>flex-wrap</h4><p>指定弹性盒子的子元素换行方式，值有：</p>\n<ul>\n<li>nowrap：默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>\n<li>wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse：反转 wrap 排列。</li>\n</ul>\n<h4 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a>align-content</h4><p>用于修改flex-wrap属性的行为，类似align-items，但它不是设置弹性子元素的对齐，而是设置各个行的对齐，值有：</p>\n<ul>\n<li>strench：默认。各行将会伸展以占用剩余的空间。</li>\n<li>flex-start：各行向弹性盒容器的起始位置堆叠。</li>\n<li>flex-end：各行向弹性盒容器的结束位置堆叠。</li>\n<li>center：各行向弹性盒容器的中间位置堆叠。</li>\n<li>space-between：各行在弹性盒容器中平均分布。</li>\n<li>space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。</li>\n</ul>\n<h3 id=\"弹性元素布局属性\"><a href=\"#弹性元素布局属性\" class=\"headerlink\" title=\"弹性元素布局属性\"></a>弹性元素布局属性</h3><h4 id=\"排序order\"><a href=\"#排序order\" class=\"headerlink\" title=\"排序order\"></a>排序order</h4><p>用整数值来定义排列顺序，数值小的排在前面，可以为负值；例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.flex-item</span><span class=\"hljs-selector-pseudo\">:first</span>-child &#123;<br>    <span class=\"hljs-attribute\">order</span>: -<span class=\"hljs-number\">1</span>;<br>    -webkit-<span class=\"hljs-attribute\">order</span>: -<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h4><p>设置margin值为auto，自动获取弹性容器中剩余空间，因此设置垂直方向margin值为’auto’</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.flex-item</span><span class=\"hljs-selector-pseudo\">:first</span>-child &#123;<br>    <span class=\"hljs-attribute\">margin-right</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"完美居中\"><a href=\"#完美居中\" class=\"headerlink\" title=\"完美居中\"></a>完美居中</h4><p>可以看出，使用弹性盒子后，居中变得非常简单。下面演示一下完美居中的实现方法；</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a>align-self</h4><p>用于设置弹性元素自身在纵轴方向上的对齐方式，值有：</p>\n<ul>\n<li>auto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。</li>\n<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>\n<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>\n<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>\n<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>\n<li>strench：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>\n</ul>\n<p>以下演示了不同值的效果，可以在<a href=\"https://codepen.io\">Code Pen</a>上直接试验：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">60px</span>;<br>    <span class=\"hljs-attribute\">min-height</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item1</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: flex-start;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: flex-start;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item2</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: flex-end;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: flex-end;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item3</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: center;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: center;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item4</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: baseline;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: baseline;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item5</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: strench;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: strench;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h4><p>用于指定弹性子元素如何分配空间，值有：</p>\n<ul>\n<li>auto：计算值为1 1 auto</li>\n<li>initial：计算值为0 1 auto</li>\n<li>none：计算值为0 0 auto</li>\n<li>inherit：从父元素继承</li>\n<li>flex-grow：定义弹性盒子元素的扩展比率</li>\n<li>flex-shrink：定义弹性盒子元素的搜索比率</li>\n<li>flex-basis：定义弹性盒子元素的默认基准值</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item1</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item2</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item3</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"CSS3之Sass学习","date":"2022-02-18T12:50:30.000Z","updated":"2022-02-18T12:50:30.000Z","_content":"\n# Sass 基本教程\n\n## 简介\n\nSass一个CSS预处理器，属于CSS的扩展语言，因此语法完全兼容CSS；最早是由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass全称（Syntactically Awesome Stylesheets）\n\nSass的文件后缀为`.scss`，因此Scss生成的格式化良好的代码，易于组织和维护；出现Scss的原因是CSS原本的语法不够强大，导致重复编写一些代码，无法实现复用，而且维护起来也不方便；\n\n## 环境安装\n\n安装也非常简单，可以用NPM来安装，如果是苹果用户可以用Homebrew；\n\n```sh\n$ npm install -g sass\n\n$ brew install sass/sass/sass\n```\n\n## 语法\n\n### 基础示例\n\n安装好scss后就可以使用了，可以贴上一个例子：\n\n```scss\n$bgcolor: lightblue;\n$textcolor: darkblue;\n$fontsize: 18px;\n\nbody {\n    background-color: $bgcolor;\n    color: $textcolor;\n    font-size: $fontsize;\n}\n```\n\n### 变量\n\n变量用于存储一些信息，它可以重复使用，可以存储以下信息：\n\n- 字符串\n- 数字\n- 颜色值\n- 布尔值\n- 列表\n- null值\n\nSass变量使用`$`符号，Sass变量的作用域只能在当前层级上有效果\n\n如果要设置全局作用域，可以使用`!global`关键词来设置，例子如下：\n\n```scss\n$myColor: red;\n\nh1 {\n    $myColor: green !global;\n    color: $myColor;\n}\n```\n\n## 嵌套规则与属性\n\nSass嵌套CSS选择器类似于HTML的嵌套规则，例如：\n\n```scss\nnav {\n    ul {\n        margin: 0;\n        padding: 0;\n        list-style: none;\n    }\n    \n    li {\n        display: inline-block;\n    }\n    \n    a {\n        display: block;\n        padding: 6px 12px;\n        text-decoration: none;\n    }\n}\n```\n\n很多CSS属性都有同样的前缀，例如font-family，font-size和font-weight，text-align，text-transform和text-overflow，在Sass中可以使用嵌套属性来编写，例如：\n\n```scss\nfont: {\n    family: Helvetica, sans-serif;\n    size: 18px;\n    weight: bold;\n}\n\ntext: {\n    align: center;\n    transform: lowercase;\n    overflow: hidden;\n}\n```\n\n以上代码会被转换成如下：\n\n```css\nfont-family: Helvetica, sans-serif;\nfont-size: 18px;\nfont-weight: bold;\n\ntext-align: center;\ntext-transform: lowercase;\ntext-overflow: hidden;\n```\n\n## @import 和 Partials\n\n### @import\n\nSass可以帮助减少重复的CSS代码，节省开发时间。\n\n类似CSS，Sass支持`@import`指令，可以让我们导入其他文件等内容；例如：\n\n创建一个`reset.scss`文件\n\n```scss\nhtml,\nbody,\nul,\nol {\n    margin: 0;\n    padding: 0;\n}\n```\n\n然后在`standard.scss`文件中使用`@import`指令导入`reser.scss`文件；\n\n```scss\n@import \"reset\";\n\nbody {\n    font-family: Helvetica, sans-serif;\n    font-size: 18px;\n    color: red;\n}\n```\n\n### Partials\n\n如果你不希望将一个Sass代码编译到CSS文件中，可以在文件名的开头添加一个下划线。这将告诉Sass不要将Sass编译到CSS文件中。\n\n例如我创建一个`_colors.sass`文件，但是不会被编译成`_colors.css`；\n\n```scss\n$myPink: #ee82ee;\n$myBlue: #4169e1;\n$myGreen: #8fbc8f;\n```\n\n如果需要导入该文件，则不需要使用下划线；\n\n```scss\n@import \"colors\";\n\nbody {\n    font-family: Helvetica, sans-serif;\n    font-size: 18px;\n    color: $myBlue;\n}\n```\n\n需要注意的是：不要将待下划线与不带下划线的同名文件放置在同一个文件目录下，比如：`_colors.scss`和`colors.scss`不能同时存在于一个目录下，否则带下划线的文件将会被忽略；\n\n## @mixin 和 @include\n\n`@mixin`指令允许我们定义一个可以在争个光样式表中重复使用的样式，语法为`@mixin name {property: value}`\n\n```scss\n@mixin important-text {\n    color: red;\n    font-size: 25px;\n    font-weight: bold;\n    border: 1px solid blue;\n}\n```\n\n`@include`指令可以将混入（mixin）引入文档中；同样地，包含important-text混入代码如下：\n\n```scss\n.danger {\n    @include important-text;\n    background-color: green;\n}\n```\n\n除此之外，混入可以接收参数，我们可以向混入传递变量，定义可以接收参数的混入：\n\n```scss\n@mixin bordered($color, $width) {\n    border: $width solid $color;\n}\n\n.myArticle {\n    @include bordered(blue, 1px);\n}\n\n.myNotes {\n    @include bordered(red, 2px);\n}\n```\n\n除此之外，混入也可以定义默认值，语法格式如下：\n\n```scss\n@mixin bordered($color: blue, $width: 1px) {\n    border: $width solid $color;\n}\n```\n\n有时候不能确定混入（mixin）或者一个函数（function）使用多少个参数，这个时候我们就可以使用`...`来设置可变参数，例如：\n\n```scss\n@mixin box-shadow($shadows...) {\n    -moz-box-shadow: $shadows;\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n}\n\n.shadows {\n    @include: box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n浏览器前缀使用混入也是十分方便的；\n\n```scss\n@mixin transform($property) {\n    -webkit-transform: $property;\n    -ms-transform: $property;\n    transform: $property;\n}\n\n.myBox {\n    @include: transform(rotate(20deg));\n}\n```\n\n## @extend 和继承\n\n`@extend`指令告诉Sass一个选择器的样式从另一个选择器继承；\n\n如果一个样式与另一个样式几乎相同，只有少量区别，则使用@extend就显得更有用；例如：\n\n```scss\n.button-basic {\n    border: none;\n    padding: 15px 30px;\n    text-align: center;\n    font-size: 16px;\n    cursor: pointer;\n}\n\n.button-reporter {\n    @extend .button-basic;\n    background-color: red;\n}\n\n.button-submit {\n    @extend .button-basic;\n    background-color: green;\n    color: white;\n}\n```\n\n通过将公共代码抽离出来公用给其他CSS样式从而实现代码的复用，真棒；\n\n## Sass函数\n\nSass定义了各种类型的函数，可以通过CSS语句直接调用；这里就不再赘述，有需要可以自行查询文档了解；\n\n- 字符串相关函数\n- 数字相关函数\n- 列表相关函数\n- 映射相关函数\n- 选择器相关函数\n- Introspection相关函数\n- 颜色相关函数\n","source":"_posts/frontend/css3/css3-ch03.md","raw":"---\ntitle: CSS3之Sass学习\ndate: 2022-02-18 20:50:30\nupdated: 2022-02-18 20:50:30\ntags: CSS3\ncategories: 前端\n---\n\n# Sass 基本教程\n\n## 简介\n\nSass一个CSS预处理器，属于CSS的扩展语言，因此语法完全兼容CSS；最早是由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass全称（Syntactically Awesome Stylesheets）\n\nSass的文件后缀为`.scss`，因此Scss生成的格式化良好的代码，易于组织和维护；出现Scss的原因是CSS原本的语法不够强大，导致重复编写一些代码，无法实现复用，而且维护起来也不方便；\n\n## 环境安装\n\n安装也非常简单，可以用NPM来安装，如果是苹果用户可以用Homebrew；\n\n```sh\n$ npm install -g sass\n\n$ brew install sass/sass/sass\n```\n\n## 语法\n\n### 基础示例\n\n安装好scss后就可以使用了，可以贴上一个例子：\n\n```scss\n$bgcolor: lightblue;\n$textcolor: darkblue;\n$fontsize: 18px;\n\nbody {\n    background-color: $bgcolor;\n    color: $textcolor;\n    font-size: $fontsize;\n}\n```\n\n### 变量\n\n变量用于存储一些信息，它可以重复使用，可以存储以下信息：\n\n- 字符串\n- 数字\n- 颜色值\n- 布尔值\n- 列表\n- null值\n\nSass变量使用`$`符号，Sass变量的作用域只能在当前层级上有效果\n\n如果要设置全局作用域，可以使用`!global`关键词来设置，例子如下：\n\n```scss\n$myColor: red;\n\nh1 {\n    $myColor: green !global;\n    color: $myColor;\n}\n```\n\n## 嵌套规则与属性\n\nSass嵌套CSS选择器类似于HTML的嵌套规则，例如：\n\n```scss\nnav {\n    ul {\n        margin: 0;\n        padding: 0;\n        list-style: none;\n    }\n    \n    li {\n        display: inline-block;\n    }\n    \n    a {\n        display: block;\n        padding: 6px 12px;\n        text-decoration: none;\n    }\n}\n```\n\n很多CSS属性都有同样的前缀，例如font-family，font-size和font-weight，text-align，text-transform和text-overflow，在Sass中可以使用嵌套属性来编写，例如：\n\n```scss\nfont: {\n    family: Helvetica, sans-serif;\n    size: 18px;\n    weight: bold;\n}\n\ntext: {\n    align: center;\n    transform: lowercase;\n    overflow: hidden;\n}\n```\n\n以上代码会被转换成如下：\n\n```css\nfont-family: Helvetica, sans-serif;\nfont-size: 18px;\nfont-weight: bold;\n\ntext-align: center;\ntext-transform: lowercase;\ntext-overflow: hidden;\n```\n\n## @import 和 Partials\n\n### @import\n\nSass可以帮助减少重复的CSS代码，节省开发时间。\n\n类似CSS，Sass支持`@import`指令，可以让我们导入其他文件等内容；例如：\n\n创建一个`reset.scss`文件\n\n```scss\nhtml,\nbody,\nul,\nol {\n    margin: 0;\n    padding: 0;\n}\n```\n\n然后在`standard.scss`文件中使用`@import`指令导入`reser.scss`文件；\n\n```scss\n@import \"reset\";\n\nbody {\n    font-family: Helvetica, sans-serif;\n    font-size: 18px;\n    color: red;\n}\n```\n\n### Partials\n\n如果你不希望将一个Sass代码编译到CSS文件中，可以在文件名的开头添加一个下划线。这将告诉Sass不要将Sass编译到CSS文件中。\n\n例如我创建一个`_colors.sass`文件，但是不会被编译成`_colors.css`；\n\n```scss\n$myPink: #ee82ee;\n$myBlue: #4169e1;\n$myGreen: #8fbc8f;\n```\n\n如果需要导入该文件，则不需要使用下划线；\n\n```scss\n@import \"colors\";\n\nbody {\n    font-family: Helvetica, sans-serif;\n    font-size: 18px;\n    color: $myBlue;\n}\n```\n\n需要注意的是：不要将待下划线与不带下划线的同名文件放置在同一个文件目录下，比如：`_colors.scss`和`colors.scss`不能同时存在于一个目录下，否则带下划线的文件将会被忽略；\n\n## @mixin 和 @include\n\n`@mixin`指令允许我们定义一个可以在争个光样式表中重复使用的样式，语法为`@mixin name {property: value}`\n\n```scss\n@mixin important-text {\n    color: red;\n    font-size: 25px;\n    font-weight: bold;\n    border: 1px solid blue;\n}\n```\n\n`@include`指令可以将混入（mixin）引入文档中；同样地，包含important-text混入代码如下：\n\n```scss\n.danger {\n    @include important-text;\n    background-color: green;\n}\n```\n\n除此之外，混入可以接收参数，我们可以向混入传递变量，定义可以接收参数的混入：\n\n```scss\n@mixin bordered($color, $width) {\n    border: $width solid $color;\n}\n\n.myArticle {\n    @include bordered(blue, 1px);\n}\n\n.myNotes {\n    @include bordered(red, 2px);\n}\n```\n\n除此之外，混入也可以定义默认值，语法格式如下：\n\n```scss\n@mixin bordered($color: blue, $width: 1px) {\n    border: $width solid $color;\n}\n```\n\n有时候不能确定混入（mixin）或者一个函数（function）使用多少个参数，这个时候我们就可以使用`...`来设置可变参数，例如：\n\n```scss\n@mixin box-shadow($shadows...) {\n    -moz-box-shadow: $shadows;\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n}\n\n.shadows {\n    @include: box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n浏览器前缀使用混入也是十分方便的；\n\n```scss\n@mixin transform($property) {\n    -webkit-transform: $property;\n    -ms-transform: $property;\n    transform: $property;\n}\n\n.myBox {\n    @include: transform(rotate(20deg));\n}\n```\n\n## @extend 和继承\n\n`@extend`指令告诉Sass一个选择器的样式从另一个选择器继承；\n\n如果一个样式与另一个样式几乎相同，只有少量区别，则使用@extend就显得更有用；例如：\n\n```scss\n.button-basic {\n    border: none;\n    padding: 15px 30px;\n    text-align: center;\n    font-size: 16px;\n    cursor: pointer;\n}\n\n.button-reporter {\n    @extend .button-basic;\n    background-color: red;\n}\n\n.button-submit {\n    @extend .button-basic;\n    background-color: green;\n    color: white;\n}\n```\n\n通过将公共代码抽离出来公用给其他CSS样式从而实现代码的复用，真棒；\n\n## Sass函数\n\nSass定义了各种类型的函数，可以通过CSS语句直接调用；这里就不再赘述，有需要可以自行查询文档了解；\n\n- 字符串相关函数\n- 数字相关函数\n- 列表相关函数\n- 映射相关函数\n- 选择器相关函数\n- Introspection相关函数\n- 颜色相关函数\n","slug":"frontend/css3/css3-ch03","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vw003x4f61cbzi5cvg","content":"<h1 id=\"Sass-基本教程\"><a href=\"#Sass-基本教程\" class=\"headerlink\" title=\"Sass 基本教程\"></a>Sass 基本教程</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sass一个CSS预处理器，属于CSS的扩展语言，因此语法完全兼容CSS；最早是由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass全称（Syntactically Awesome Stylesheets）</p>\n<p>Sass的文件后缀为<code>.scss</code>，因此Scss生成的格式化良好的代码，易于组织和维护；出现Scss的原因是CSS原本的语法不够强大，导致重复编写一些代码，无法实现复用，而且维护起来也不方便；</p>\n<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><p>安装也非常简单，可以用NPM来安装，如果是苹果用户可以用Homebrew；</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs sh\">$ npm install -g sass<br><br>$ brew install sass/sass/sass<br></code></pre></td></tr></table></figure>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h3><p>安装好scss后就可以使用了，可以贴上一个例子：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$bgcolor</span>: lightblue;<br><span class=\"hljs-variable\">$textcolor</span>: darkblue;<br><span class=\"hljs-variable\">$fontsize</span>: <span class=\"hljs-number\">18px</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-variable\">$bgcolor</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$textcolor</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-variable\">$fontsize</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>变量用于存储一些信息，它可以重复使用，可以存储以下信息：</p>\n<ul>\n<li>字符串</li>\n<li>数字</li>\n<li>颜色值</li>\n<li>布尔值</li>\n<li>列表</li>\n<li>null值</li>\n</ul>\n<p>Sass变量使用<code>$</code>符号，Sass变量的作用域只能在当前层级上有效果</p>\n<p>如果要设置全局作用域，可以使用<code>!global</code>关键词来设置，例子如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$myColor</span>: red;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>    <span class=\"hljs-variable\">$myColor</span>: green !global;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$myColor</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"嵌套规则与属性\"><a href=\"#嵌套规则与属性\" class=\"headerlink\" title=\"嵌套规则与属性\"></a>嵌套规则与属性</h2><p>Sass嵌套CSS选择器类似于HTML的嵌套规则，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">nav</span> &#123;<br>    <span class=\"hljs-selector-tag\">ul</span> &#123;<br>        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-attribute\">list-style</span>: none;<br>    &#125;<br>    <br>    <span class=\"hljs-selector-tag\">li</span> &#123;<br>        <span class=\"hljs-attribute\">display</span>: inline-block;<br>    &#125;<br>    <br>    <span class=\"hljs-selector-tag\">a</span> &#123;<br>        <span class=\"hljs-attribute\">display</span>: block;<br>        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">12px</span>;<br>        <span class=\"hljs-attribute\">text-decoration</span>: none;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>很多CSS属性都有同样的前缀，例如font-family，font-size和font-weight，text-align，text-transform和text-overflow，在Sass中可以使用嵌套属性来编写，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-attribute\">font</span>: &#123;<br>    family: Helvetica, sans-serif;<br>    size: <span class=\"hljs-number\">18px</span>;<br>    weight: bold;<br>&#125;<br><br>text: &#123;<br>    align: center;<br>    <span class=\"hljs-attribute\">transform</span>: lowercase;<br>    <span class=\"hljs-attribute\">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上代码会被转换成如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br><span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br><span class=\"hljs-attribute\">font-weight</span>: bold;<br><br><span class=\"hljs-attribute\">text-align</span>: center;<br><span class=\"hljs-attribute\">text-transform</span>: lowercase;<br><span class=\"hljs-attribute\">text-overflow</span>: hidden;<br></code></pre></td></tr></table></figure>\n<h2 id=\"import-和-Partials\"><a href=\"#import-和-Partials\" class=\"headerlink\" title=\"@import 和 Partials\"></a>@import 和 Partials</h2><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"@import\"></a>@import</h3><p>Sass可以帮助减少重复的CSS代码，节省开发时间。</p>\n<p>类似CSS，Sass支持<code>@import</code>指令，可以让我们导入其他文件等内容；例如：</p>\n<p>创建一个<code>reset.scss</code>文件</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">html</span>,<br><span class=\"hljs-selector-tag\">body</span>,<br><span class=\"hljs-selector-tag\">ul</span>,<br><span class=\"hljs-selector-tag\">ol</span> &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>然后在<code>standard.scss</code>文件中使用<code>@import</code>指令导入<code>reser.scss</code>文件；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;reset&quot;</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Partials\"><a href=\"#Partials\" class=\"headerlink\" title=\"Partials\"></a>Partials</h3><p>如果你不希望将一个Sass代码编译到CSS文件中，可以在文件名的开头添加一个下划线。这将告诉Sass不要将Sass编译到CSS文件中。</p>\n<p>例如我创建一个<code>_colors.sass</code>文件，但是不会被编译成<code>_colors.css</code>；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$myPink</span>: <span class=\"hljs-number\">#ee82ee</span>;<br><span class=\"hljs-variable\">$myBlue</span>: <span class=\"hljs-number\">#4169e1</span>;<br><span class=\"hljs-variable\">$myGreen</span>: <span class=\"hljs-number\">#8fbc8f</span>;<br></code></pre></td></tr></table></figure>\n<p>如果需要导入该文件，则不需要使用下划线；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;colors&quot;</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$myBlue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：不要将待下划线与不带下划线的同名文件放置在同一个文件目录下，比如：<code>_colors.scss</code>和<code>colors.scss</code>不能同时存在于一个目录下，否则带下划线的文件将会被忽略；</p>\n<h2 id=\"mixin-和-include\"><a href=\"#mixin-和-include\" class=\"headerlink\" title=\"@mixin 和 @include\"></a>@mixin 和 @include</h2><p><code>@mixin</code>指令允许我们定义一个可以在争个光样式表中重复使用的样式，语法为<code>@mixin name &#123;property: value&#125;</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> important-text &#123;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">25px</span>;<br>    <span class=\"hljs-attribute\">font-weight</span>: bold;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>@include</code>指令可以将混入（mixin）引入文档中；同样地，包含important-text混入代码如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.danger</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> important-text;<br>    <span class=\"hljs-attribute\">background-color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，混入可以接收参数，我们可以向混入传递变量，定义可以接收参数的混入：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> bordered(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-variable\">$width</span>) &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-variable\">$width</span> solid <span class=\"hljs-variable\">$color</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.myArticle</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> bordered(blue, <span class=\"hljs-number\">1px</span>);<br>&#125;<br><br><span class=\"hljs-selector-class\">.myNotes</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> bordered(red, <span class=\"hljs-number\">2px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，混入也可以定义默认值，语法格式如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> bordered(<span class=\"hljs-variable\">$color</span>: blue, <span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">1px</span>) &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-variable\">$width</span> solid <span class=\"hljs-variable\">$color</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>有时候不能确定混入（mixin）或者一个函数（function）使用多少个参数，这个时候我们就可以使用<code>...</code>来设置可变参数，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> box-shadow(<span class=\"hljs-variable\">$shadows</span>...) &#123;<br>    -moz-<span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>    -webkit-<span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>    <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.shadows</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span>: box-shadow(<span class=\"hljs-number\">0px</span> <span class=\"hljs-number\">4px</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">#666</span>, <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">#999</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>浏览器前缀使用混入也是十分方便的；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> transform(<span class=\"hljs-variable\">$property</span>) &#123;<br>    -webkit-<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>    -ms-<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.myBox</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span>: transform(rotate(<span class=\"hljs-number\">20deg</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"extend-和继承\"><a href=\"#extend-和继承\" class=\"headerlink\" title=\"@extend 和继承\"></a>@extend 和继承</h2><p><code>@extend</code>指令告诉Sass一个选择器的样式从另一个选择器继承；</p>\n<p>如果一个样式与另一个样式几乎相同，只有少量区别，则使用@extend就显得更有用；例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.button-basic</span> &#123;<br>    <span class=\"hljs-attribute\">border</span>: none;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>;<br>    <span class=\"hljs-attribute\">text-align</span>: center;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;<br>    <span class=\"hljs-attribute\">cursor</span>: pointer;<br>&#125;<br><br><span class=\"hljs-selector-class\">.button-reporter</span> &#123;<br>    <span class=\"hljs-keyword\">@extend</span> .button-basic;<br>    <span class=\"hljs-attribute\">background-color</span>: red;<br>&#125;<br><br><span class=\"hljs-selector-class\">.button-submit</span> &#123;<br>    <span class=\"hljs-keyword\">@extend</span> .button-basic;<br>    <span class=\"hljs-attribute\">background-color</span>: green;<br>    <span class=\"hljs-attribute\">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通过将公共代码抽离出来公用给其他CSS样式从而实现代码的复用，真棒；</p>\n<h2 id=\"Sass函数\"><a href=\"#Sass函数\" class=\"headerlink\" title=\"Sass函数\"></a>Sass函数</h2><p>Sass定义了各种类型的函数，可以通过CSS语句直接调用；这里就不再赘述，有需要可以自行查询文档了解；</p>\n<ul>\n<li>字符串相关函数</li>\n<li>数字相关函数</li>\n<li>列表相关函数</li>\n<li>映射相关函数</li>\n<li>选择器相关函数</li>\n<li>Introspection相关函数</li>\n<li>颜色相关函数</li>\n</ul>\n","site":{"data":{}},"wordcount":3588,"excerpt":"","more":"<h1 id=\"Sass-基本教程\"><a href=\"#Sass-基本教程\" class=\"headerlink\" title=\"Sass 基本教程\"></a>Sass 基本教程</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sass一个CSS预处理器，属于CSS的扩展语言，因此语法完全兼容CSS；最早是由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass全称（Syntactically Awesome Stylesheets）</p>\n<p>Sass的文件后缀为<code>.scss</code>，因此Scss生成的格式化良好的代码，易于组织和维护；出现Scss的原因是CSS原本的语法不够强大，导致重复编写一些代码，无法实现复用，而且维护起来也不方便；</p>\n<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><p>安装也非常简单，可以用NPM来安装，如果是苹果用户可以用Homebrew；</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ npm install -g sass<br><br>$ brew install sass/sass/sass<br></code></pre></td></tr></table></figure>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h3><p>安装好scss后就可以使用了，可以贴上一个例子：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$bgcolor</span>: lightblue;<br><span class=\"hljs-variable\">$textcolor</span>: darkblue;<br><span class=\"hljs-variable\">$fontsize</span>: <span class=\"hljs-number\">18px</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-variable\">$bgcolor</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$textcolor</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-variable\">$fontsize</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>变量用于存储一些信息，它可以重复使用，可以存储以下信息：</p>\n<ul>\n<li>字符串</li>\n<li>数字</li>\n<li>颜色值</li>\n<li>布尔值</li>\n<li>列表</li>\n<li>null值</li>\n</ul>\n<p>Sass变量使用<code>$</code>符号，Sass变量的作用域只能在当前层级上有效果</p>\n<p>如果要设置全局作用域，可以使用<code>!global</code>关键词来设置，例子如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$myColor</span>: red;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>    <span class=\"hljs-variable\">$myColor</span>: green !global;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$myColor</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"嵌套规则与属性\"><a href=\"#嵌套规则与属性\" class=\"headerlink\" title=\"嵌套规则与属性\"></a>嵌套规则与属性</h2><p>Sass嵌套CSS选择器类似于HTML的嵌套规则，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">nav</span> &#123;<br>    <span class=\"hljs-selector-tag\">ul</span> &#123;<br>        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-attribute\">list-style</span>: none;<br>    &#125;<br>    <br>    <span class=\"hljs-selector-tag\">li</span> &#123;<br>        <span class=\"hljs-attribute\">display</span>: inline-block;<br>    &#125;<br>    <br>    <span class=\"hljs-selector-tag\">a</span> &#123;<br>        <span class=\"hljs-attribute\">display</span>: block;<br>        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">12px</span>;<br>        <span class=\"hljs-attribute\">text-decoration</span>: none;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>很多CSS属性都有同样的前缀，例如font-family，font-size和font-weight，text-align，text-transform和text-overflow，在Sass中可以使用嵌套属性来编写，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-attribute\">font</span>: &#123;<br>    family: Helvetica, sans-serif;<br>    size: <span class=\"hljs-number\">18px</span>;<br>    weight: bold;<br>&#125;<br><br>text: &#123;<br>    align: center;<br>    <span class=\"hljs-attribute\">transform</span>: lowercase;<br>    <span class=\"hljs-attribute\">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上代码会被转换成如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br><span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br><span class=\"hljs-attribute\">font-weight</span>: bold;<br><br><span class=\"hljs-attribute\">text-align</span>: center;<br><span class=\"hljs-attribute\">text-transform</span>: lowercase;<br><span class=\"hljs-attribute\">text-overflow</span>: hidden;<br></code></pre></td></tr></table></figure>\n<h2 id=\"import-和-Partials\"><a href=\"#import-和-Partials\" class=\"headerlink\" title=\"@import 和 Partials\"></a>@import 和 Partials</h2><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"@import\"></a>@import</h3><p>Sass可以帮助减少重复的CSS代码，节省开发时间。</p>\n<p>类似CSS，Sass支持<code>@import</code>指令，可以让我们导入其他文件等内容；例如：</p>\n<p>创建一个<code>reset.scss</code>文件</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">html</span>,<br><span class=\"hljs-selector-tag\">body</span>,<br><span class=\"hljs-selector-tag\">ul</span>,<br><span class=\"hljs-selector-tag\">ol</span> &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>然后在<code>standard.scss</code>文件中使用<code>@import</code>指令导入<code>reser.scss</code>文件；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;reset&quot;</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Partials\"><a href=\"#Partials\" class=\"headerlink\" title=\"Partials\"></a>Partials</h3><p>如果你不希望将一个Sass代码编译到CSS文件中，可以在文件名的开头添加一个下划线。这将告诉Sass不要将Sass编译到CSS文件中。</p>\n<p>例如我创建一个<code>_colors.sass</code>文件，但是不会被编译成<code>_colors.css</code>；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$myPink</span>: <span class=\"hljs-number\">#ee82ee</span>;<br><span class=\"hljs-variable\">$myBlue</span>: <span class=\"hljs-number\">#4169e1</span>;<br><span class=\"hljs-variable\">$myGreen</span>: <span class=\"hljs-number\">#8fbc8f</span>;<br></code></pre></td></tr></table></figure>\n<p>如果需要导入该文件，则不需要使用下划线；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;colors&quot;</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$myBlue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：不要将待下划线与不带下划线的同名文件放置在同一个文件目录下，比如：<code>_colors.scss</code>和<code>colors.scss</code>不能同时存在于一个目录下，否则带下划线的文件将会被忽略；</p>\n<h2 id=\"mixin-和-include\"><a href=\"#mixin-和-include\" class=\"headerlink\" title=\"@mixin 和 @include\"></a>@mixin 和 @include</h2><p><code>@mixin</code>指令允许我们定义一个可以在争个光样式表中重复使用的样式，语法为<code>@mixin name &#123;property: value&#125;</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> important-text &#123;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">25px</span>;<br>    <span class=\"hljs-attribute\">font-weight</span>: bold;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>@include</code>指令可以将混入（mixin）引入文档中；同样地，包含important-text混入代码如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.danger</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> important-text;<br>    <span class=\"hljs-attribute\">background-color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，混入可以接收参数，我们可以向混入传递变量，定义可以接收参数的混入：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> bordered(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-variable\">$width</span>) &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-variable\">$width</span> solid <span class=\"hljs-variable\">$color</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.myArticle</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> bordered(blue, <span class=\"hljs-number\">1px</span>);<br>&#125;<br><br><span class=\"hljs-selector-class\">.myNotes</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> bordered(red, <span class=\"hljs-number\">2px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，混入也可以定义默认值，语法格式如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> bordered(<span class=\"hljs-variable\">$color</span>: blue, <span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">1px</span>) &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-variable\">$width</span> solid <span class=\"hljs-variable\">$color</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>有时候不能确定混入（mixin）或者一个函数（function）使用多少个参数，这个时候我们就可以使用<code>...</code>来设置可变参数，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> box-shadow(<span class=\"hljs-variable\">$shadows</span>...) &#123;<br>    -moz-<span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>    -webkit-<span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>    <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.shadows</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span>: box-shadow(<span class=\"hljs-number\">0px</span> <span class=\"hljs-number\">4px</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">#666</span>, <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">#999</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>浏览器前缀使用混入也是十分方便的；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> transform(<span class=\"hljs-variable\">$property</span>) &#123;<br>    -webkit-<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>    -ms-<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.myBox</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span>: transform(rotate(<span class=\"hljs-number\">20deg</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"extend-和继承\"><a href=\"#extend-和继承\" class=\"headerlink\" title=\"@extend 和继承\"></a>@extend 和继承</h2><p><code>@extend</code>指令告诉Sass一个选择器的样式从另一个选择器继承；</p>\n<p>如果一个样式与另一个样式几乎相同，只有少量区别，则使用@extend就显得更有用；例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.button-basic</span> &#123;<br>    <span class=\"hljs-attribute\">border</span>: none;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>;<br>    <span class=\"hljs-attribute\">text-align</span>: center;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;<br>    <span class=\"hljs-attribute\">cursor</span>: pointer;<br>&#125;<br><br><span class=\"hljs-selector-class\">.button-reporter</span> &#123;<br>    <span class=\"hljs-keyword\">@extend</span> .button-basic;<br>    <span class=\"hljs-attribute\">background-color</span>: red;<br>&#125;<br><br><span class=\"hljs-selector-class\">.button-submit</span> &#123;<br>    <span class=\"hljs-keyword\">@extend</span> .button-basic;<br>    <span class=\"hljs-attribute\">background-color</span>: green;<br>    <span class=\"hljs-attribute\">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通过将公共代码抽离出来公用给其他CSS样式从而实现代码的复用，真棒；</p>\n<h2 id=\"Sass函数\"><a href=\"#Sass函数\" class=\"headerlink\" title=\"Sass函数\"></a>Sass函数</h2><p>Sass定义了各种类型的函数，可以通过CSS语句直接调用；这里就不再赘述，有需要可以自行查询文档了解；</p>\n<ul>\n<li>字符串相关函数</li>\n<li>数字相关函数</li>\n<li>列表相关函数</li>\n<li>映射相关函数</li>\n<li>选择器相关函数</li>\n<li>Introspection相关函数</li>\n<li>颜色相关函数</li>\n</ul>\n"},{"title":"Canvas非零环绕原则","date":"2022-02-18T02:59:52.000Z","updated":"2022-02-18T02:59:52.000Z","_content":"\n# 非零环绕原则\n\n## 概述\n\n非零环绕原则描述了一种计算机该如何给封闭图形上色的规则，非常简单，我们只需要记住一个下面一条规则就行。\n\n给封闭图形设置一个渲染方向（假如你的图形是一笔成画的），比如顺时针，那么与之相反的逆时针就是反方向。根据线条的方向来按照下列规则判断：\n\n- 从封闭图形画一条射线，如果与之相交的线条中正向和逆向不等（正多逆少或者逆多正少，只要不是0即可），那么就认为图形内部；\n- 从封闭图形画一条射线，如果与之相交的线条中正向和逆向相等（例如圆环，一正一逆，正好抵消为0），那么就认为图形外部；\n\n这就是“非零环绕原则”。这样说还不直观，我们可以用一个例子来说明这个。\n\n## 圆环\n\n接着之前的代码片段，我们来画一个圆环：\n\n```javascript\nwindow.onload = function() {\n  let canvas = document.getElementById(\"canvas\");\n  canvas.width = 800;\n  canvas.height = 600;\n  \n  let context = canvas.getContext(\"2d\");\n  \n  context.shadowColor = \"#545454\";\n  context.shadowOffsetX = 5;\n  context.shadowOffsetY = 5;\n  context.shadowBlur = 2;\n  \n  context.arc(400, 300, 200, 0, Math.PI * 2, false); // 顺时针画圆\n  context.arc(400, 300, 230, 0, Math.PI * 2, true); // 逆时针画圆\n  \n  context.fillStyle = \"#00AAAA\";\n  context.fill();\n};\n```\n\n 按照“非零环绕”原则，内部圆的方向是顺时针，外部圆的方向是逆时针，正好两个圆的中间部分才是需要填充的部分。这样就完成了一个圆环。是不是非常简单。\n\n## 镂空图形绘制\n\n我们再做一个复杂一些的图形，你可以将其拷贝到浏览器中看效果：\n\n```javascript\nwindow.onload = function() {\n  var canvas = document.getElementById(\"canvas\");\n  canvas.width = 800;\n  canvas.height = 600;\n  var context = canvas.getContext(\"2d\");\n  context.fillStyle = \"#FFF\";\n  context.fillRect(0,0,800,600);\n\n  context.beginPath();\n  context.rect(200,100,400,400);\n  drawPathRect(context, 250, 150, 300, 150);\n  drawPathTriangle(context, 345, 350, 420, 450, 270, 450);\n  context.arc(500, 400, 50, 0, Math.PI * 2, true);\n  context.closePath();\n\n  context.fillStyle = \"#058\";\n  context.shadowColor = \"gray\";\n  context.shadowOffsetX = 10;\n  context.shadowOffsetY = 10;\n  context.shadowBlur = 10;\n  context.fill();\n\n};\n\n//逆时针绘制矩形\nfunction drawPathRect(cxt, x, y, w, h){\n  /**\n         * 这里不能使用beginPath和closePath，\n         * 不然就不属于子路径而是另一个全新的路径，\n         * 无法使用非零环绕原则\n         */\n  cxt.moveTo(x, y);\n  cxt.lineTo(x, y + h);\n  cxt.lineTo(x + w, y + h);\n  cxt.lineTo(x + w, y);\n  cxt.lineTo(x, y);\n\n}\n\n//逆时针绘制三角形\nfunction drawPathTriangle(cxt, x1, y1, x2, y2, x3, y3){\n  cxt.moveTo(x1,y1);\n  cxt.lineTo(x3,y3);\n  cxt.lineTo(x2,y2);\n  cxt.lineTo(x1,y1);\n}\n```\n\n## 结束\n\n就这些\n","source":"_posts/frontend/canvas/canvas-around-principle.md","raw":"---\ntitle: Canvas非零环绕原则\ndate: 2022-02-18 10:59:52\nupdated: 2022-02-18 10:59:52\ntags: HTML\ncategories: 前端\n---\n\n# 非零环绕原则\n\n## 概述\n\n非零环绕原则描述了一种计算机该如何给封闭图形上色的规则，非常简单，我们只需要记住一个下面一条规则就行。\n\n给封闭图形设置一个渲染方向（假如你的图形是一笔成画的），比如顺时针，那么与之相反的逆时针就是反方向。根据线条的方向来按照下列规则判断：\n\n- 从封闭图形画一条射线，如果与之相交的线条中正向和逆向不等（正多逆少或者逆多正少，只要不是0即可），那么就认为图形内部；\n- 从封闭图形画一条射线，如果与之相交的线条中正向和逆向相等（例如圆环，一正一逆，正好抵消为0），那么就认为图形外部；\n\n这就是“非零环绕原则”。这样说还不直观，我们可以用一个例子来说明这个。\n\n## 圆环\n\n接着之前的代码片段，我们来画一个圆环：\n\n```javascript\nwindow.onload = function() {\n  let canvas = document.getElementById(\"canvas\");\n  canvas.width = 800;\n  canvas.height = 600;\n  \n  let context = canvas.getContext(\"2d\");\n  \n  context.shadowColor = \"#545454\";\n  context.shadowOffsetX = 5;\n  context.shadowOffsetY = 5;\n  context.shadowBlur = 2;\n  \n  context.arc(400, 300, 200, 0, Math.PI * 2, false); // 顺时针画圆\n  context.arc(400, 300, 230, 0, Math.PI * 2, true); // 逆时针画圆\n  \n  context.fillStyle = \"#00AAAA\";\n  context.fill();\n};\n```\n\n 按照“非零环绕”原则，内部圆的方向是顺时针，外部圆的方向是逆时针，正好两个圆的中间部分才是需要填充的部分。这样就完成了一个圆环。是不是非常简单。\n\n## 镂空图形绘制\n\n我们再做一个复杂一些的图形，你可以将其拷贝到浏览器中看效果：\n\n```javascript\nwindow.onload = function() {\n  var canvas = document.getElementById(\"canvas\");\n  canvas.width = 800;\n  canvas.height = 600;\n  var context = canvas.getContext(\"2d\");\n  context.fillStyle = \"#FFF\";\n  context.fillRect(0,0,800,600);\n\n  context.beginPath();\n  context.rect(200,100,400,400);\n  drawPathRect(context, 250, 150, 300, 150);\n  drawPathTriangle(context, 345, 350, 420, 450, 270, 450);\n  context.arc(500, 400, 50, 0, Math.PI * 2, true);\n  context.closePath();\n\n  context.fillStyle = \"#058\";\n  context.shadowColor = \"gray\";\n  context.shadowOffsetX = 10;\n  context.shadowOffsetY = 10;\n  context.shadowBlur = 10;\n  context.fill();\n\n};\n\n//逆时针绘制矩形\nfunction drawPathRect(cxt, x, y, w, h){\n  /**\n         * 这里不能使用beginPath和closePath，\n         * 不然就不属于子路径而是另一个全新的路径，\n         * 无法使用非零环绕原则\n         */\n  cxt.moveTo(x, y);\n  cxt.lineTo(x, y + h);\n  cxt.lineTo(x + w, y + h);\n  cxt.lineTo(x + w, y);\n  cxt.lineTo(x, y);\n\n}\n\n//逆时针绘制三角形\nfunction drawPathTriangle(cxt, x1, y1, x2, y2, x3, y3){\n  cxt.moveTo(x1,y1);\n  cxt.lineTo(x3,y3);\n  cxt.lineTo(x2,y2);\n  cxt.lineTo(x1,y1);\n}\n```\n\n## 结束\n\n就这些\n","slug":"frontend/canvas/canvas-around-principle","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vx00414f61enbhaapb","content":"<h1 id=\"非零环绕原则\"><a href=\"#非零环绕原则\" class=\"headerlink\" title=\"非零环绕原则\"></a>非零环绕原则</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>非零环绕原则描述了一种计算机该如何给封闭图形上色的规则，非常简单，我们只需要记住一个下面一条规则就行。</p>\n<p>给封闭图形设置一个渲染方向（假如你的图形是一笔成画的），比如顺时针，那么与之相反的逆时针就是反方向。根据线条的方向来按照下列规则判断：</p>\n<ul>\n<li>从封闭图形画一条射线，如果与之相交的线条中正向和逆向不等（正多逆少或者逆多正少，只要不是0即可），那么就认为图形内部；</li>\n<li>从封闭图形画一条射线，如果与之相交的线条中正向和逆向相等（例如圆环，一正一逆，正好抵消为0），那么就认为图形外部；</li>\n</ul>\n<p>这就是“非零环绕原则”。这样说还不直观，我们可以用一个例子来说明这个。</p>\n<h2 id=\"圆环\"><a href=\"#圆环\" class=\"headerlink\" title=\"圆环\"></a>圆环</h2><p>接着之前的代码片段，我们来画一个圆环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>  canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>  canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>  <br>  <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>  <br>  context.<span class=\"hljs-property\">shadowColor</span> = <span class=\"hljs-string\">&quot;#545454&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetX</span> = <span class=\"hljs-number\">5</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetY</span> = <span class=\"hljs-number\">5</span>;<br>  context.<span class=\"hljs-property\">shadowBlur</span> = <span class=\"hljs-number\">2</span>;<br>  <br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">false</span>); <span class=\"hljs-comment\">// 顺时针画圆</span><br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">230</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 逆时针画圆</span><br>  <br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>  context.<span class=\"hljs-title function_\">fill</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p> 按照“非零环绕”原则，内部圆的方向是顺时针，外部圆的方向是逆时针，正好两个圆的中间部分才是需要填充的部分。这样就完成了一个圆环。是不是非常简单。</p>\n<h2 id=\"镂空图形绘制\"><a href=\"#镂空图形绘制\" class=\"headerlink\" title=\"镂空图形绘制\"></a>镂空图形绘制</h2><p>我们再做一个复杂一些的图形，你可以将其拷贝到浏览器中看效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>  canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>  canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>  <span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#FFF&quot;</span>;<br>  context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">800</span>,<span class=\"hljs-number\">600</span>);<br><br>  context.<span class=\"hljs-title function_\">beginPath</span>();<br>  context.<span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-number\">200</span>,<span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">400</span>,<span class=\"hljs-number\">400</span>);<br>  <span class=\"hljs-title function_\">drawPathRect</span>(context, <span class=\"hljs-number\">250</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">150</span>);<br>  <span class=\"hljs-title function_\">drawPathTriangle</span>(context, <span class=\"hljs-number\">345</span>, <span class=\"hljs-number\">350</span>, <span class=\"hljs-number\">420</span>, <span class=\"hljs-number\">450</span>, <span class=\"hljs-number\">270</span>, <span class=\"hljs-number\">450</span>);<br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>);<br>  context.<span class=\"hljs-title function_\">closePath</span>();<br><br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#058&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowColor</span> = <span class=\"hljs-string\">&quot;gray&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetX</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetY</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-property\">shadowBlur</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-title function_\">fill</span>();<br><br>&#125;;<br><br><span class=\"hljs-comment\">//逆时针绘制矩形</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawPathRect</span>(<span class=\"hljs-params\">cxt, x, y, w, h</span>)&#123;<br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">         * 这里不能使用beginPath和closePath，</span><br><span class=\"hljs-comment\">         * 不然就不属于子路径而是另一个全新的路径，</span><br><span class=\"hljs-comment\">         * 无法使用非零环绕原则</span><br><span class=\"hljs-comment\">         */</span><br>  cxt.<span class=\"hljs-title function_\">moveTo</span>(x, y);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x, y + h);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x + w, y + h);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x + w, y);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x, y);<br><br>&#125;<br><br><span class=\"hljs-comment\">//逆时针绘制三角形</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawPathTriangle</span>(<span class=\"hljs-params\">cxt, x1, y1, x2, y2, x3, y3</span>)&#123;<br>  cxt.<span class=\"hljs-title function_\">moveTo</span>(x1,y1);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x3,y3);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x2,y2);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x1,y1);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h2><p>就这些</p>\n","site":{"data":{}},"wordcount":1894,"excerpt":"","more":"<h1 id=\"非零环绕原则\"><a href=\"#非零环绕原则\" class=\"headerlink\" title=\"非零环绕原则\"></a>非零环绕原则</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>非零环绕原则描述了一种计算机该如何给封闭图形上色的规则，非常简单，我们只需要记住一个下面一条规则就行。</p>\n<p>给封闭图形设置一个渲染方向（假如你的图形是一笔成画的），比如顺时针，那么与之相反的逆时针就是反方向。根据线条的方向来按照下列规则判断：</p>\n<ul>\n<li>从封闭图形画一条射线，如果与之相交的线条中正向和逆向不等（正多逆少或者逆多正少，只要不是0即可），那么就认为图形内部；</li>\n<li>从封闭图形画一条射线，如果与之相交的线条中正向和逆向相等（例如圆环，一正一逆，正好抵消为0），那么就认为图形外部；</li>\n</ul>\n<p>这就是“非零环绕原则”。这样说还不直观，我们可以用一个例子来说明这个。</p>\n<h2 id=\"圆环\"><a href=\"#圆环\" class=\"headerlink\" title=\"圆环\"></a>圆环</h2><p>接着之前的代码片段，我们来画一个圆环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>  canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>  canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>  <br>  <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>  <br>  context.<span class=\"hljs-property\">shadowColor</span> = <span class=\"hljs-string\">&quot;#545454&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetX</span> = <span class=\"hljs-number\">5</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetY</span> = <span class=\"hljs-number\">5</span>;<br>  context.<span class=\"hljs-property\">shadowBlur</span> = <span class=\"hljs-number\">2</span>;<br>  <br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">false</span>); <span class=\"hljs-comment\">// 顺时针画圆</span><br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">230</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 逆时针画圆</span><br>  <br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>  context.<span class=\"hljs-title function_\">fill</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p> 按照“非零环绕”原则，内部圆的方向是顺时针，外部圆的方向是逆时针，正好两个圆的中间部分才是需要填充的部分。这样就完成了一个圆环。是不是非常简单。</p>\n<h2 id=\"镂空图形绘制\"><a href=\"#镂空图形绘制\" class=\"headerlink\" title=\"镂空图形绘制\"></a>镂空图形绘制</h2><p>我们再做一个复杂一些的图形，你可以将其拷贝到浏览器中看效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>  canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>  canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>  <span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#FFF&quot;</span>;<br>  context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">800</span>,<span class=\"hljs-number\">600</span>);<br><br>  context.<span class=\"hljs-title function_\">beginPath</span>();<br>  context.<span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-number\">200</span>,<span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">400</span>,<span class=\"hljs-number\">400</span>);<br>  <span class=\"hljs-title function_\">drawPathRect</span>(context, <span class=\"hljs-number\">250</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">150</span>);<br>  <span class=\"hljs-title function_\">drawPathTriangle</span>(context, <span class=\"hljs-number\">345</span>, <span class=\"hljs-number\">350</span>, <span class=\"hljs-number\">420</span>, <span class=\"hljs-number\">450</span>, <span class=\"hljs-number\">270</span>, <span class=\"hljs-number\">450</span>);<br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>);<br>  context.<span class=\"hljs-title function_\">closePath</span>();<br><br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#058&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowColor</span> = <span class=\"hljs-string\">&quot;gray&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetX</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetY</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-property\">shadowBlur</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-title function_\">fill</span>();<br><br>&#125;;<br><br><span class=\"hljs-comment\">//逆时针绘制矩形</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawPathRect</span>(<span class=\"hljs-params\">cxt, x, y, w, h</span>)&#123;<br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">         * 这里不能使用beginPath和closePath，</span><br><span class=\"hljs-comment\">         * 不然就不属于子路径而是另一个全新的路径，</span><br><span class=\"hljs-comment\">         * 无法使用非零环绕原则</span><br><span class=\"hljs-comment\">         */</span><br>  cxt.<span class=\"hljs-title function_\">moveTo</span>(x, y);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x, y + h);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x + w, y + h);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x + w, y);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x, y);<br><br>&#125;<br><br><span class=\"hljs-comment\">//逆时针绘制三角形</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawPathTriangle</span>(<span class=\"hljs-params\">cxt, x1, y1, x2, y2, x3, y3</span>)&#123;<br>  cxt.<span class=\"hljs-title function_\">moveTo</span>(x1,y1);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x3,y3);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x2,y2);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x1,y1);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h2><p>就这些</p>\n"},{"title":"Canvas绘制图形","date":"2022-02-18T02:59:22.000Z","updated":"2022-02-18T02:59:22.000Z","_content":"\n# Canvas绘图\n\n## 回顾\n\n前一章讲了如何创建绘图的几个基本要素，它们分别是：\n\n- 画布\n- 画笔\n- 颜色\n- 橡皮擦（这个现在还用不着）\n\n光有这些还不够，一幅画主要由线条，形状（圆形或者矩形），弧线组成，所以要学会用代码画图，那么得先知道如何在电脑上画出这些线条。我们直接拿之前的HTML 5页面来使用：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n\t<div id=\"canvas-wrap\">\n\t\t<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n\t</div>\n</body>\n\n<script type=\"text/javascript\">\n\t// 创建画布\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    // 创建画笔\n    let context = canvas.getContext(\"2d\");\n</script>\n</html>\n```\n\n好了，接下来，我们将开始学习如何画出线条、矩形、圆形和弧形；\n\n## 线条\n\n线条比较简单，中学的时候我们都知道，两点就能确定一条直线，所以在计算机中也是一样，只要我给定两个点的坐标，那么他们之间的轨迹就是一条直线。所以直线的绘制方法如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.moveTo(100, 100);\ncontext.lineTo(500, 100);\ncontext.stroke();\n```\n\n其中`moveTo(x, y)`代表了直线的绘制起点，`lineTo(x, y)`代表了直线的绘制终点；\n\n由于canvas是基于状态绘制的，所以每绘制一个图形，都要以`context.beginPath()`起头，如果要上色，可以使用`context.strokeStyle = <color>`给线条上色。\n\n这里的坐标用的同样是笛卡尔坐标系，但是跟我们中学课本上的不一样。在计算机中，屏幕的左上角是坐标顶点，横向是x正轴，纵向是y正轴；\n\n## 矩形\n\n要绘制矩形，可以使用两种办法：\n\n（1）使用之前的`moveTo`和`lineTo`方法，一次性绘制4条直线，那自然就围城了一个矩形；\n\n（2）直接调用canvas封装的API：`rect(x, y, width, height)`来绘制矩形；\n\n这两种方法都可以在页面上绘制出一个矩形，但是使用方法（1）的时候必须要在绘制结束后加上`context.closePath()`，否则图形看上去就会有缺口；\n\n你可以把下面这两段直接拷贝到自己的代码中，就可以看到效果了：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\nlet context = canvas.getContext(\"2d\");\n\n// 方法（1）绘制矩形\ncontext.beginPath();\ncontext.moveTo(100, 100);\ncontext.lineTo(400, 100);\ncontext.lineTo(400, 400);\ncontext.lineTo(100, 400);\ncontext.closePath(); // 要想图形闭合，需要加上这句话\ncontext.strokeStyle = \"blue\";\ncontext.stroke();\n\n// 方法(2)绘制矩形\ncontext.beginPath();\ncontext.rect(100, 100, 300, 300);\ncontext.strokeStyle = \"red\";\ncontext.stroke();\n```\n\n最后，我们再说一下线条属性：\n\n- lineCap：定义上下文中线的端点样式：可以是：butt、round和square；\n- lineJoin：定义两条线相交产生的拐角，可以称为连接，可以是：miter、bevel和round；\n- lindWidth：定义线条宽度，默认是1.0；\n- strokeStyle：定义线和形状边框的颜色样式；\n\n## 弧线\n\n熟悉PS的同学也会知道，绘制圆弧常用的工具有预设的圆弧工具和钢笔工具（贝塞尔曲线）；那么在canvas中也是一样的：\n\n- 标准圆弧：`arc()`\n- 复杂圆弧：`arcTo()`\n- 2阶贝塞尔曲线：`quadraticCurveTo()`\n- 3阶贝塞尔曲线：`bezierCurveTo()`\n\n### `context.arc(x, y, radius, startAngle, endAngle, antiClockWise)`\n\n参数代表的含义分别为：圆心坐标，圆心半径，起始弧度，结束弧度以及是否逆时针；\n\n这里的弧度和中学课本里面讲的弧度是同一个概念，只不过坐标系的参考位置是不一样的；\n\n### `context.arcTo(x1, y1, x2, y2, radius)`\n\n参数代表的含义分别为：两个切点的坐标和圆弧半径。这个方法是依据切线来画弧线，即两条切线就能确定一条弧线；例子如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.moveTo(200, 200);\ncontext.arcTo(600, 200, 600, 400, 100);\n\ncontext.lineWidth = 6;\ncontext.strokeStyle = \"red\";\ncontext.stroke();\n\ncontext.beginPath();\ncontext.moveTo(200, 200);\ncontext.lineTo(600, 200);\ncontext.lineTo(600, 400);\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = \"#0088AA\";\ncontext.stroke();\n```\n\n## 圆形\n\n有了上面绘制圆弧的基础知识，我们就可以绘制圆形了，其实也非常简单。\n\n```javascript\nconst PI = Math.PI;\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.arc(200, 200, 50, 0, PI * 2); // 顺时针绘制\ncontext.arc(400, 400, 50, 0, PI * 2, true); // 逆时针绘制\n```\n\n记住计算机上圆形的弧度顺序：时钟3点对应的是0(PI * 2)，时钟6点对应的是PI / 2，时钟9点对应的是PI，时钟12点对应的是PI * 3 / 2；默认情况下绘图顺序是顺时针方向；\n\n## 曲线\n\n如果你用过PS的钢笔工具，那么一定也画过曲线，钢笔工具画出来的曲线就叫做贝塞尔曲线，这是发过数学家贝塞尔于1962年发现，并以他的名字命名了这种曲线。\n\n曲线由起始点、终止点和控制点组成，每条曲线都具备这三个点。控制点为曲线阶数 - 1，也就是说2阶贝塞尔曲线有2 - 1 = 1个控制点。\n\n### 2阶贝塞尔曲线\n\ncanvas中，绘制二阶贝塞尔曲线的API如下：\n\n```javascript\ncontext.quadraticCurveTo(cpx, cpy, x, y); // 2阶\n```\n\n一个控制点（cpx, cpy）和一个终止点（x, y）；\n\n### 3阶贝塞尔曲线\n\n绘制三阶贝塞尔曲线的API如下：\n\n```javascript\ncontext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); // 3阶\n```\n\n两个控制点（cp1x, cp1y）和（cp2x, cp2y）和终止点（x, y）\n","source":"_posts/frontend/canvas/canvas-draw-shape.md","raw":"---\ntitle: Canvas绘制图形\ndate: 2022-02-18 10:59:22\nupdated: 2022-02-18 10:59:22\ntags: HTML\ncategories: 前端\n---\n\n# Canvas绘图\n\n## 回顾\n\n前一章讲了如何创建绘图的几个基本要素，它们分别是：\n\n- 画布\n- 画笔\n- 颜色\n- 橡皮擦（这个现在还用不着）\n\n光有这些还不够，一幅画主要由线条，形状（圆形或者矩形），弧线组成，所以要学会用代码画图，那么得先知道如何在电脑上画出这些线条。我们直接拿之前的HTML 5页面来使用：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n\t<div id=\"canvas-wrap\">\n\t\t<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n\t</div>\n</body>\n\n<script type=\"text/javascript\">\n\t// 创建画布\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    // 创建画笔\n    let context = canvas.getContext(\"2d\");\n</script>\n</html>\n```\n\n好了，接下来，我们将开始学习如何画出线条、矩形、圆形和弧形；\n\n## 线条\n\n线条比较简单，中学的时候我们都知道，两点就能确定一条直线，所以在计算机中也是一样，只要我给定两个点的坐标，那么他们之间的轨迹就是一条直线。所以直线的绘制方法如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.moveTo(100, 100);\ncontext.lineTo(500, 100);\ncontext.stroke();\n```\n\n其中`moveTo(x, y)`代表了直线的绘制起点，`lineTo(x, y)`代表了直线的绘制终点；\n\n由于canvas是基于状态绘制的，所以每绘制一个图形，都要以`context.beginPath()`起头，如果要上色，可以使用`context.strokeStyle = <color>`给线条上色。\n\n这里的坐标用的同样是笛卡尔坐标系，但是跟我们中学课本上的不一样。在计算机中，屏幕的左上角是坐标顶点，横向是x正轴，纵向是y正轴；\n\n## 矩形\n\n要绘制矩形，可以使用两种办法：\n\n（1）使用之前的`moveTo`和`lineTo`方法，一次性绘制4条直线，那自然就围城了一个矩形；\n\n（2）直接调用canvas封装的API：`rect(x, y, width, height)`来绘制矩形；\n\n这两种方法都可以在页面上绘制出一个矩形，但是使用方法（1）的时候必须要在绘制结束后加上`context.closePath()`，否则图形看上去就会有缺口；\n\n你可以把下面这两段直接拷贝到自己的代码中，就可以看到效果了：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\nlet context = canvas.getContext(\"2d\");\n\n// 方法（1）绘制矩形\ncontext.beginPath();\ncontext.moveTo(100, 100);\ncontext.lineTo(400, 100);\ncontext.lineTo(400, 400);\ncontext.lineTo(100, 400);\ncontext.closePath(); // 要想图形闭合，需要加上这句话\ncontext.strokeStyle = \"blue\";\ncontext.stroke();\n\n// 方法(2)绘制矩形\ncontext.beginPath();\ncontext.rect(100, 100, 300, 300);\ncontext.strokeStyle = \"red\";\ncontext.stroke();\n```\n\n最后，我们再说一下线条属性：\n\n- lineCap：定义上下文中线的端点样式：可以是：butt、round和square；\n- lineJoin：定义两条线相交产生的拐角，可以称为连接，可以是：miter、bevel和round；\n- lindWidth：定义线条宽度，默认是1.0；\n- strokeStyle：定义线和形状边框的颜色样式；\n\n## 弧线\n\n熟悉PS的同学也会知道，绘制圆弧常用的工具有预设的圆弧工具和钢笔工具（贝塞尔曲线）；那么在canvas中也是一样的：\n\n- 标准圆弧：`arc()`\n- 复杂圆弧：`arcTo()`\n- 2阶贝塞尔曲线：`quadraticCurveTo()`\n- 3阶贝塞尔曲线：`bezierCurveTo()`\n\n### `context.arc(x, y, radius, startAngle, endAngle, antiClockWise)`\n\n参数代表的含义分别为：圆心坐标，圆心半径，起始弧度，结束弧度以及是否逆时针；\n\n这里的弧度和中学课本里面讲的弧度是同一个概念，只不过坐标系的参考位置是不一样的；\n\n### `context.arcTo(x1, y1, x2, y2, radius)`\n\n参数代表的含义分别为：两个切点的坐标和圆弧半径。这个方法是依据切线来画弧线，即两条切线就能确定一条弧线；例子如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.moveTo(200, 200);\ncontext.arcTo(600, 200, 600, 400, 100);\n\ncontext.lineWidth = 6;\ncontext.strokeStyle = \"red\";\ncontext.stroke();\n\ncontext.beginPath();\ncontext.moveTo(200, 200);\ncontext.lineTo(600, 200);\ncontext.lineTo(600, 400);\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = \"#0088AA\";\ncontext.stroke();\n```\n\n## 圆形\n\n有了上面绘制圆弧的基础知识，我们就可以绘制圆形了，其实也非常简单。\n\n```javascript\nconst PI = Math.PI;\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.arc(200, 200, 50, 0, PI * 2); // 顺时针绘制\ncontext.arc(400, 400, 50, 0, PI * 2, true); // 逆时针绘制\n```\n\n记住计算机上圆形的弧度顺序：时钟3点对应的是0(PI * 2)，时钟6点对应的是PI / 2，时钟9点对应的是PI，时钟12点对应的是PI * 3 / 2；默认情况下绘图顺序是顺时针方向；\n\n## 曲线\n\n如果你用过PS的钢笔工具，那么一定也画过曲线，钢笔工具画出来的曲线就叫做贝塞尔曲线，这是发过数学家贝塞尔于1962年发现，并以他的名字命名了这种曲线。\n\n曲线由起始点、终止点和控制点组成，每条曲线都具备这三个点。控制点为曲线阶数 - 1，也就是说2阶贝塞尔曲线有2 - 1 = 1个控制点。\n\n### 2阶贝塞尔曲线\n\ncanvas中，绘制二阶贝塞尔曲线的API如下：\n\n```javascript\ncontext.quadraticCurveTo(cpx, cpy, x, y); // 2阶\n```\n\n一个控制点（cpx, cpy）和一个终止点（x, y）；\n\n### 3阶贝塞尔曲线\n\n绘制三阶贝塞尔曲线的API如下：\n\n```javascript\ncontext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); // 3阶\n```\n\n两个控制点（cp1x, cp1y）和（cp2x, cp2y）和终止点（x, y）\n","slug":"frontend/canvas/canvas-draw-shape","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vx00434f619vka7o1a","content":"<h1 id=\"Canvas绘图\"><a href=\"#Canvas绘图\" class=\"headerlink\" title=\"Canvas绘图\"></a>Canvas绘图</h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>前一章讲了如何创建绘图的几个基本要素，它们分别是：</p>\n<ul>\n<li>画布</li>\n<li>画笔</li>\n<li>颜色</li>\n<li>橡皮擦（这个现在还用不着）</li>\n</ul>\n<p>光有这些还不够，一幅画主要由线条，形状（圆形或者矩形），弧线组成，所以要学会用代码画图，那么得先知道如何在电脑上画出这些线条。我们直接拿之前的HTML 5页面来使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas-wrap&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">\t<span class=\"hljs-comment\">// 创建画布</span></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);</span><br><span class=\"language-javascript\">    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;</span><br><span class=\"language-javascript\">    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;</span><br><span class=\"language-javascript\">    <span class=\"hljs-comment\">// 创建画笔</span></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>好了，接下来，我们将开始学习如何画出线条、矩形、圆形和弧形；</p>\n<h2 id=\"线条\"><a href=\"#线条\" class=\"headerlink\" title=\"线条\"></a>线条</h2><p>线条比较简单，中学的时候我们都知道，两点就能确定一条直线，所以在计算机中也是一样，只要我给定两个点的坐标，那么他们之间的轨迹就是一条直线。所以直线的绘制方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<p>其中<code>moveTo(x, y)</code>代表了直线的绘制起点，<code>lineTo(x, y)</code>代表了直线的绘制终点；</p>\n<p>由于canvas是基于状态绘制的，所以每绘制一个图形，都要以<code>context.beginPath()</code>起头，如果要上色，可以使用<code>context.strokeStyle = &lt;color&gt;</code>给线条上色。</p>\n<p>这里的坐标用的同样是笛卡尔坐标系，但是跟我们中学课本上的不一样。在计算机中，屏幕的左上角是坐标顶点，横向是x正轴，纵向是y正轴；</p>\n<h2 id=\"矩形\"><a href=\"#矩形\" class=\"headerlink\" title=\"矩形\"></a>矩形</h2><p>要绘制矩形，可以使用两种办法：</p>\n<p>（1）使用之前的<code>moveTo</code>和<code>lineTo</code>方法，一次性绘制4条直线，那自然就围城了一个矩形；</p>\n<p>（2）直接调用canvas封装的API：<code>rect(x, y, width, height)</code>来绘制矩形；</p>\n<p>这两种方法都可以在页面上绘制出一个矩形，但是使用方法（1）的时候必须要在绘制结束后加上<code>context.closePath()</code>，否则图形看上去就会有缺口；</p>\n<p>你可以把下面这两段直接拷贝到自己的代码中，就可以看到效果了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br><span class=\"hljs-comment\">// 方法（1）绘制矩形</span><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">400</span>);<br>context.<span class=\"hljs-title function_\">closePath</span>(); <span class=\"hljs-comment\">// 要想图形闭合，需要加上这句话</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;blue&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br><br><span class=\"hljs-comment\">// 方法(2)绘制矩形</span><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">300</span>);<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<p>最后，我们再说一下线条属性：</p>\n<ul>\n<li>lineCap：定义上下文中线的端点样式：可以是：butt、round和square；</li>\n<li>lineJoin：定义两条线相交产生的拐角，可以称为连接，可以是：miter、bevel和round；</li>\n<li>lindWidth：定义线条宽度，默认是1.0；</li>\n<li>strokeStyle：定义线和形状边框的颜色样式；</li>\n</ul>\n<h2 id=\"弧线\"><a href=\"#弧线\" class=\"headerlink\" title=\"弧线\"></a>弧线</h2><p>熟悉PS的同学也会知道，绘制圆弧常用的工具有预设的圆弧工具和钢笔工具（贝塞尔曲线）；那么在canvas中也是一样的：</p>\n<ul>\n<li>标准圆弧：<code>arc()</code></li>\n<li>复杂圆弧：<code>arcTo()</code></li>\n<li>2阶贝塞尔曲线：<code>quadraticCurveTo()</code></li>\n<li>3阶贝塞尔曲线：<code>bezierCurveTo()</code></li>\n</ul>\n<h3 id=\"context-arc-x-y-radius-startAngle-endAngle-antiClockWise\"><a href=\"#context-arc-x-y-radius-startAngle-endAngle-antiClockWise\" class=\"headerlink\" title=\"context.arc(x, y, radius, startAngle, endAngle, antiClockWise)\"></a><code>context.arc(x, y, radius, startAngle, endAngle, antiClockWise)</code></h3><p>参数代表的含义分别为：圆心坐标，圆心半径，起始弧度，结束弧度以及是否逆时针；</p>\n<p>这里的弧度和中学课本里面讲的弧度是同一个概念，只不过坐标系的参考位置是不一样的；</p>\n<h3 id=\"context-arcTo-x1-y1-x2-y2-radius\"><a href=\"#context-arcTo-x1-y1-x2-y2-radius\" class=\"headerlink\" title=\"context.arcTo(x1, y1, x2, y2, radius)\"></a><code>context.arcTo(x1, y1, x2, y2, radius)</code></h3><p>参数代表的含义分别为：两个切点的坐标和圆弧半径。这个方法是依据切线来画弧线，即两条切线就能确定一条弧线；例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">arcTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">100</span>);<br><br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">6</span>;<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);<br><br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">1</span>;<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#0088AA&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"圆形\"><a href=\"#圆形\" class=\"headerlink\" title=\"圆形\"></a>圆形</h2><p>有了上面绘制圆弧的基础知识，我们就可以绘制圆形了，其实也非常简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PI</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>;<br><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable constant_\">PI</span> * <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 顺时针绘制</span><br>context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable constant_\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 逆时针绘制</span><br></code></pre></td></tr></table></figure>\n<p>记住计算机上圆形的弧度顺序：时钟3点对应的是0(PI <em> 2)，时钟6点对应的是PI / 2，时钟9点对应的是PI，时钟12点对应的是PI </em> 3 / 2；默认情况下绘图顺序是顺时针方向；</p>\n<h2 id=\"曲线\"><a href=\"#曲线\" class=\"headerlink\" title=\"曲线\"></a>曲线</h2><p>如果你用过PS的钢笔工具，那么一定也画过曲线，钢笔工具画出来的曲线就叫做贝塞尔曲线，这是发过数学家贝塞尔于1962年发现，并以他的名字命名了这种曲线。</p>\n<p>曲线由起始点、终止点和控制点组成，每条曲线都具备这三个点。控制点为曲线阶数 - 1，也就是说2阶贝塞尔曲线有2 - 1 = 1个控制点。</p>\n<h3 id=\"2阶贝塞尔曲线\"><a href=\"#2阶贝塞尔曲线\" class=\"headerlink\" title=\"2阶贝塞尔曲线\"></a>2阶贝塞尔曲线</h3><p>canvas中，绘制二阶贝塞尔曲线的API如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">context.<span class=\"hljs-title function_\">quadraticCurveTo</span>(cpx, cpy, x, y); <span class=\"hljs-comment\">// 2阶</span><br></code></pre></td></tr></table></figure>\n<p>一个控制点（cpx, cpy）和一个终止点（x, y）；</p>\n<h3 id=\"3阶贝塞尔曲线\"><a href=\"#3阶贝塞尔曲线\" class=\"headerlink\" title=\"3阶贝塞尔曲线\"></a>3阶贝塞尔曲线</h3><p>绘制三阶贝塞尔曲线的API如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">context.<span class=\"hljs-title function_\">bezierCurveTo</span>(cp1x, cp1y, cp2x, cp2y, x, y); <span class=\"hljs-comment\">// 3阶</span><br></code></pre></td></tr></table></figure>\n<p>两个控制点（cp1x, cp1y）和（cp2x, cp2y）和终止点（x, y）</p>\n","site":{"data":{}},"wordcount":3684,"excerpt":"","more":"<h1 id=\"Canvas绘图\"><a href=\"#Canvas绘图\" class=\"headerlink\" title=\"Canvas绘图\"></a>Canvas绘图</h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>前一章讲了如何创建绘图的几个基本要素，它们分别是：</p>\n<ul>\n<li>画布</li>\n<li>画笔</li>\n<li>颜色</li>\n<li>橡皮擦（这个现在还用不着）</li>\n</ul>\n<p>光有这些还不够，一幅画主要由线条，形状（圆形或者矩形），弧线组成，所以要学会用代码画图，那么得先知道如何在电脑上画出这些线条。我们直接拿之前的HTML 5页面来使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas-wrap&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">\t<span class=\"hljs-comment\">// 创建画布</span></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);</span><br><span class=\"language-javascript\">    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;</span><br><span class=\"language-javascript\">    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;</span><br><span class=\"language-javascript\">    <span class=\"hljs-comment\">// 创建画笔</span></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>好了，接下来，我们将开始学习如何画出线条、矩形、圆形和弧形；</p>\n<h2 id=\"线条\"><a href=\"#线条\" class=\"headerlink\" title=\"线条\"></a>线条</h2><p>线条比较简单，中学的时候我们都知道，两点就能确定一条直线，所以在计算机中也是一样，只要我给定两个点的坐标，那么他们之间的轨迹就是一条直线。所以直线的绘制方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<p>其中<code>moveTo(x, y)</code>代表了直线的绘制起点，<code>lineTo(x, y)</code>代表了直线的绘制终点；</p>\n<p>由于canvas是基于状态绘制的，所以每绘制一个图形，都要以<code>context.beginPath()</code>起头，如果要上色，可以使用<code>context.strokeStyle = &lt;color&gt;</code>给线条上色。</p>\n<p>这里的坐标用的同样是笛卡尔坐标系，但是跟我们中学课本上的不一样。在计算机中，屏幕的左上角是坐标顶点，横向是x正轴，纵向是y正轴；</p>\n<h2 id=\"矩形\"><a href=\"#矩形\" class=\"headerlink\" title=\"矩形\"></a>矩形</h2><p>要绘制矩形，可以使用两种办法：</p>\n<p>（1）使用之前的<code>moveTo</code>和<code>lineTo</code>方法，一次性绘制4条直线，那自然就围城了一个矩形；</p>\n<p>（2）直接调用canvas封装的API：<code>rect(x, y, width, height)</code>来绘制矩形；</p>\n<p>这两种方法都可以在页面上绘制出一个矩形，但是使用方法（1）的时候必须要在绘制结束后加上<code>context.closePath()</code>，否则图形看上去就会有缺口；</p>\n<p>你可以把下面这两段直接拷贝到自己的代码中，就可以看到效果了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br><span class=\"hljs-comment\">// 方法（1）绘制矩形</span><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">400</span>);<br>context.<span class=\"hljs-title function_\">closePath</span>(); <span class=\"hljs-comment\">// 要想图形闭合，需要加上这句话</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;blue&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br><br><span class=\"hljs-comment\">// 方法(2)绘制矩形</span><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">300</span>);<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<p>最后，我们再说一下线条属性：</p>\n<ul>\n<li>lineCap：定义上下文中线的端点样式：可以是：butt、round和square；</li>\n<li>lineJoin：定义两条线相交产生的拐角，可以称为连接，可以是：miter、bevel和round；</li>\n<li>lindWidth：定义线条宽度，默认是1.0；</li>\n<li>strokeStyle：定义线和形状边框的颜色样式；</li>\n</ul>\n<h2 id=\"弧线\"><a href=\"#弧线\" class=\"headerlink\" title=\"弧线\"></a>弧线</h2><p>熟悉PS的同学也会知道，绘制圆弧常用的工具有预设的圆弧工具和钢笔工具（贝塞尔曲线）；那么在canvas中也是一样的：</p>\n<ul>\n<li>标准圆弧：<code>arc()</code></li>\n<li>复杂圆弧：<code>arcTo()</code></li>\n<li>2阶贝塞尔曲线：<code>quadraticCurveTo()</code></li>\n<li>3阶贝塞尔曲线：<code>bezierCurveTo()</code></li>\n</ul>\n<h3 id=\"context-arc-x-y-radius-startAngle-endAngle-antiClockWise\"><a href=\"#context-arc-x-y-radius-startAngle-endAngle-antiClockWise\" class=\"headerlink\" title=\"context.arc(x, y, radius, startAngle, endAngle, antiClockWise)\"></a><code>context.arc(x, y, radius, startAngle, endAngle, antiClockWise)</code></h3><p>参数代表的含义分别为：圆心坐标，圆心半径，起始弧度，结束弧度以及是否逆时针；</p>\n<p>这里的弧度和中学课本里面讲的弧度是同一个概念，只不过坐标系的参考位置是不一样的；</p>\n<h3 id=\"context-arcTo-x1-y1-x2-y2-radius\"><a href=\"#context-arcTo-x1-y1-x2-y2-radius\" class=\"headerlink\" title=\"context.arcTo(x1, y1, x2, y2, radius)\"></a><code>context.arcTo(x1, y1, x2, y2, radius)</code></h3><p>参数代表的含义分别为：两个切点的坐标和圆弧半径。这个方法是依据切线来画弧线，即两条切线就能确定一条弧线；例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">arcTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">100</span>);<br><br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">6</span>;<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);<br><br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">1</span>;<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#0088AA&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"圆形\"><a href=\"#圆形\" class=\"headerlink\" title=\"圆形\"></a>圆形</h2><p>有了上面绘制圆弧的基础知识，我们就可以绘制圆形了，其实也非常简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PI</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>;<br><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable constant_\">PI</span> * <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 顺时针绘制</span><br>context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable constant_\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 逆时针绘制</span><br></code></pre></td></tr></table></figure>\n<p>记住计算机上圆形的弧度顺序：时钟3点对应的是0(PI <em> 2)，时钟6点对应的是PI / 2，时钟9点对应的是PI，时钟12点对应的是PI </em> 3 / 2；默认情况下绘图顺序是顺时针方向；</p>\n<h2 id=\"曲线\"><a href=\"#曲线\" class=\"headerlink\" title=\"曲线\"></a>曲线</h2><p>如果你用过PS的钢笔工具，那么一定也画过曲线，钢笔工具画出来的曲线就叫做贝塞尔曲线，这是发过数学家贝塞尔于1962年发现，并以他的名字命名了这种曲线。</p>\n<p>曲线由起始点、终止点和控制点组成，每条曲线都具备这三个点。控制点为曲线阶数 - 1，也就是说2阶贝塞尔曲线有2 - 1 = 1个控制点。</p>\n<h3 id=\"2阶贝塞尔曲线\"><a href=\"#2阶贝塞尔曲线\" class=\"headerlink\" title=\"2阶贝塞尔曲线\"></a>2阶贝塞尔曲线</h3><p>canvas中，绘制二阶贝塞尔曲线的API如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">context.<span class=\"hljs-title function_\">quadraticCurveTo</span>(cpx, cpy, x, y); <span class=\"hljs-comment\">// 2阶</span><br></code></pre></td></tr></table></figure>\n<p>一个控制点（cpx, cpy）和一个终止点（x, y）；</p>\n<h3 id=\"3阶贝塞尔曲线\"><a href=\"#3阶贝塞尔曲线\" class=\"headerlink\" title=\"3阶贝塞尔曲线\"></a>3阶贝塞尔曲线</h3><p>绘制三阶贝塞尔曲线的API如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">context.<span class=\"hljs-title function_\">bezierCurveTo</span>(cp1x, cp1y, cp2x, cp2y, x, y); <span class=\"hljs-comment\">// 3阶</span><br></code></pre></td></tr></table></figure>\n<p>两个控制点（cp1x, cp1y）和（cp2x, cp2y）和终止点（x, y）</p>\n"},{"title":"Canvas基础入门","date":"2022-02-18T02:59:03.000Z","updated":"2022-02-18T02:59:03.000Z","_content":"\n# Canvas快速上手\n\n## 准备工作\n\n你只需要准备：\n\n- Web Kit内核浏览器：Safari（Apple MacOS）、Google Chrome或者Mozilla Firefox；（由于Canvas的标准是Chrome和Mozilla联合制定的，所以推荐使用Chrome或者Firefox）\n- 你最拿手的编辑器：Sublime Text、Atom或者是Visual Studio Code；（这里我选择了VS Code）\n\n准备好上面这些之后，在你的电脑文件系统中找一个位置，然后创建一个HTML 5的页面，像下面这样：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n</body>\n</html>\n```\n\n准备好页面以后，我们在`<body></body>`标签中写一点东西，来验证一下`<canvas>`的魅力，像下面这样：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n\t<div id=\"canvas-wrap\">\n\t\t<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n\t</div>\n</body>\n</html>\n```\n\n可以发现，当你打开浏览器以后，你的页面上什么都看不到，这恰恰说明你的浏览器是支持Canvas的！你可以找一个老古董浏览器（例如：Internet Explorer）来打开看看，它就会显示“<u>抱歉你的浏览器不支持Canvas！</u>”\n\n## 计算机绘图基础\n\n现实生活中，要想绘图，你需要准备下面这些东西：\n\n- 画布（当然不一定是真的布，纸张也算是画布的一种）\n- 画笔（各种粗细不一，功能不同的笔）\n- 颜料（12色、16色或者24色的颜料板）\n- 橡皮、尺子以及其他辅助工具等等；\n\n那么将这些东西映射到计算机上呢？答案也是一样的，你同样需要准备上面的那几样东西，只不过我们把现实生活中的工具都转换成了JavaScript代码而已。\n\n### 画布\n\n我们再次看`<canvas></canvas>`标签，它有一个id属性，这个id所指向的DOM元素就是我们的画布了。\n\n```html\n<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n```\n\n我们可以给画布添加一些CSS样式，这样在浏览器中你就能看到画布的位置了：\n\n```css\n#canvas {\n    border: 1px solid #aaaaaa;\n    display: block;\n    margin: 50px auto;\n    width: 800;\n    height: 600;\n}\n```\n\n用JavaScript也可以设置画布的宽和高，像下面这样：\n\n```javascript\nwindow.onload = function() {\n    var canvas = document.getElementById(\"canvas\"); // 这样就可以取到画布对象了\n    // 设置画布的大小\n    canvas.width = 800;\n    canvas.height = 600;\n};\n```\n\n到此画布我们就创建好了，今后都会在画布上创建图形。\n\n### 画笔\n\n有了画布，自然就少不了画笔了，一般在其他教程中都会叫做上下文环境，我觉得这个词过于抽象，还是用画笔比较容易理解。\n\n```javascript\nwindow.onload = function () {\n    // 画布\n    var canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    // 画笔\n    var context = canvas.getContext(\"2d\");\n};\n```\n\n那么既然是画笔，自然就可以设置它的粗细，颜色了对吧，说得对，确实是可以设置：\n\n```javascript\nvar context = canvas.getContext(\"2d\");\ncontext.lineWidth = 5; //画笔的粗细\ncontext.strokeStyle = \"#acef4d\"; // 画笔的颜色\n```\n\n### 颜料\n\n说完画布和画笔，我们来说颜料；计算机中的颜色表示相信大家都知道了。你可以用`RGB`或者`HSLA`颜色表示法，也可以像学习CSS那样给图形上颜色；非常简单。\n\n上色的方法也非常简单，只需要再创建画笔之后使用`context.fillStyle`就可以了。上色的方式支持下面这些：\n\n- 颜色字符串，例如：red，blue和purple；\n- 使用十六进制字符串或者其简写形式填充：#FF0000或者#FF0;\n- 使用`rgb()`方法设置颜色；R红色、G绿色、B蓝色；\n- 使用`rgba()`方法设置颜色；A代表(Alpha)，代表透明度；（0 ~ 1）；\n- 使用`hsl()`方法设置颜色；H色相、S饱和度、L明度；\n- 使用`hsla()`方法设置颜色；A代表透明度(Alpha)；（0 ~ 1）；\n\n### 渐变效果\n\n渐变分为两种，熟悉PS的同学应该知道是什么；\n\n- 线性渐变：`context.createLinearGradient(xstart, ystart, xend, yend)`\n- 径向渐变：`context.createRadialGradient(x0, y0, r0, x1, y1, r1)`\n\n添加渐变的步骤有下面3个：\n\n（1）添加渐变线\n\n（2）为渐变线添加关建色；\n\n（3）应用渐变；\n\n转换成代码就是下面这样子：（以线性渐变为例）\n\n```javascript\n// 添加渐变线\nlet grd = context.createLinearGradient(xstart, ystart, xend, yend);\nlet grd2 = context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\n// 添加关建色\n/* stop代表到(xstart, ystart)的距离占整个渐变色长度的比例，为0~1的浮点数 */\ngrd.addColorStop(stop, color)\n\n// 应用渐变\ncontext.fillStyle = grd; // 填充渐变色\ncontext.strokeStyle = grd; // 线框渐变色\n```\n\n贴上一个例子方便理解：\n\n```javascript\n// Code should wrap in HTML script tag\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    let context = canvas.getContext(\"2d\");\n    \n    let grd = context.createRadialGradient(400, 300, 100, 400, 300, 200);\n    \n    grd.addColorStop(0, \"olive\");\n    grd.addColorStop(0.25, \"maroon\");\n    grd.addColorStop(0.5, \"aqua\");\n    grd.addColorStop(0.75, \"fuchsia\");\n    grd.addColorStop(0.25, \"teal\");\n    \n    context.fillStyle = grd;\n    \n    context.fillRect(100, 100, 600, 400);\n};\n```\n\n### 橡皮擦\n\ncanvas提供了一个API叫做`context.clearRect(x, y, w, h)`，这个API就是用来清除画布中的像素的，也就是现实作画中的橡皮擦。\n","source":"_posts/frontend/canvas/canvas-getting-started.md","raw":"---\ntitle: Canvas基础入门\ndate: 2022-02-18 10:59:03\nupdated: 2022-02-18 10:59:03\ntags: HTML\ncategories: 前端\n---\n\n# Canvas快速上手\n\n## 准备工作\n\n你只需要准备：\n\n- Web Kit内核浏览器：Safari（Apple MacOS）、Google Chrome或者Mozilla Firefox；（由于Canvas的标准是Chrome和Mozilla联合制定的，所以推荐使用Chrome或者Firefox）\n- 你最拿手的编辑器：Sublime Text、Atom或者是Visual Studio Code；（这里我选择了VS Code）\n\n准备好上面这些之后，在你的电脑文件系统中找一个位置，然后创建一个HTML 5的页面，像下面这样：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n</body>\n</html>\n```\n\n准备好页面以后，我们在`<body></body>`标签中写一点东西，来验证一下`<canvas>`的魅力，像下面这样：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n\t<div id=\"canvas-wrap\">\n\t\t<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n\t</div>\n</body>\n</html>\n```\n\n可以发现，当你打开浏览器以后，你的页面上什么都看不到，这恰恰说明你的浏览器是支持Canvas的！你可以找一个老古董浏览器（例如：Internet Explorer）来打开看看，它就会显示“<u>抱歉你的浏览器不支持Canvas！</u>”\n\n## 计算机绘图基础\n\n现实生活中，要想绘图，你需要准备下面这些东西：\n\n- 画布（当然不一定是真的布，纸张也算是画布的一种）\n- 画笔（各种粗细不一，功能不同的笔）\n- 颜料（12色、16色或者24色的颜料板）\n- 橡皮、尺子以及其他辅助工具等等；\n\n那么将这些东西映射到计算机上呢？答案也是一样的，你同样需要准备上面的那几样东西，只不过我们把现实生活中的工具都转换成了JavaScript代码而已。\n\n### 画布\n\n我们再次看`<canvas></canvas>`标签，它有一个id属性，这个id所指向的DOM元素就是我们的画布了。\n\n```html\n<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n```\n\n我们可以给画布添加一些CSS样式，这样在浏览器中你就能看到画布的位置了：\n\n```css\n#canvas {\n    border: 1px solid #aaaaaa;\n    display: block;\n    margin: 50px auto;\n    width: 800;\n    height: 600;\n}\n```\n\n用JavaScript也可以设置画布的宽和高，像下面这样：\n\n```javascript\nwindow.onload = function() {\n    var canvas = document.getElementById(\"canvas\"); // 这样就可以取到画布对象了\n    // 设置画布的大小\n    canvas.width = 800;\n    canvas.height = 600;\n};\n```\n\n到此画布我们就创建好了，今后都会在画布上创建图形。\n\n### 画笔\n\n有了画布，自然就少不了画笔了，一般在其他教程中都会叫做上下文环境，我觉得这个词过于抽象，还是用画笔比较容易理解。\n\n```javascript\nwindow.onload = function () {\n    // 画布\n    var canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    // 画笔\n    var context = canvas.getContext(\"2d\");\n};\n```\n\n那么既然是画笔，自然就可以设置它的粗细，颜色了对吧，说得对，确实是可以设置：\n\n```javascript\nvar context = canvas.getContext(\"2d\");\ncontext.lineWidth = 5; //画笔的粗细\ncontext.strokeStyle = \"#acef4d\"; // 画笔的颜色\n```\n\n### 颜料\n\n说完画布和画笔，我们来说颜料；计算机中的颜色表示相信大家都知道了。你可以用`RGB`或者`HSLA`颜色表示法，也可以像学习CSS那样给图形上颜色；非常简单。\n\n上色的方法也非常简单，只需要再创建画笔之后使用`context.fillStyle`就可以了。上色的方式支持下面这些：\n\n- 颜色字符串，例如：red，blue和purple；\n- 使用十六进制字符串或者其简写形式填充：#FF0000或者#FF0;\n- 使用`rgb()`方法设置颜色；R红色、G绿色、B蓝色；\n- 使用`rgba()`方法设置颜色；A代表(Alpha)，代表透明度；（0 ~ 1）；\n- 使用`hsl()`方法设置颜色；H色相、S饱和度、L明度；\n- 使用`hsla()`方法设置颜色；A代表透明度(Alpha)；（0 ~ 1）；\n\n### 渐变效果\n\n渐变分为两种，熟悉PS的同学应该知道是什么；\n\n- 线性渐变：`context.createLinearGradient(xstart, ystart, xend, yend)`\n- 径向渐变：`context.createRadialGradient(x0, y0, r0, x1, y1, r1)`\n\n添加渐变的步骤有下面3个：\n\n（1）添加渐变线\n\n（2）为渐变线添加关建色；\n\n（3）应用渐变；\n\n转换成代码就是下面这样子：（以线性渐变为例）\n\n```javascript\n// 添加渐变线\nlet grd = context.createLinearGradient(xstart, ystart, xend, yend);\nlet grd2 = context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\n// 添加关建色\n/* stop代表到(xstart, ystart)的距离占整个渐变色长度的比例，为0~1的浮点数 */\ngrd.addColorStop(stop, color)\n\n// 应用渐变\ncontext.fillStyle = grd; // 填充渐变色\ncontext.strokeStyle = grd; // 线框渐变色\n```\n\n贴上一个例子方便理解：\n\n```javascript\n// Code should wrap in HTML script tag\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    let context = canvas.getContext(\"2d\");\n    \n    let grd = context.createRadialGradient(400, 300, 100, 400, 300, 200);\n    \n    grd.addColorStop(0, \"olive\");\n    grd.addColorStop(0.25, \"maroon\");\n    grd.addColorStop(0.5, \"aqua\");\n    grd.addColorStop(0.75, \"fuchsia\");\n    grd.addColorStop(0.25, \"teal\");\n    \n    context.fillStyle = grd;\n    \n    context.fillRect(100, 100, 600, 400);\n};\n```\n\n### 橡皮擦\n\ncanvas提供了一个API叫做`context.clearRect(x, y, w, h)`，这个API就是用来清除画布中的像素的，也就是现实作画中的橡皮擦。\n","slug":"frontend/canvas/canvas-getting-started","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vy00474f61dniu1lq7","content":"<h1 id=\"Canvas快速上手\"><a href=\"#Canvas快速上手\" class=\"headerlink\" title=\"Canvas快速上手\"></a>Canvas快速上手</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>你只需要准备：</p>\n<ul>\n<li>Web Kit内核浏览器：Safari（Apple MacOS）、Google Chrome或者Mozilla Firefox；（由于Canvas的标准是Chrome和Mozilla联合制定的，所以推荐使用Chrome或者Firefox）</li>\n<li>你最拿手的编辑器：Sublime Text、Atom或者是Visual Studio Code；（这里我选择了VS Code）</li>\n</ul>\n<p>准备好上面这些之后，在你的电脑文件系统中找一个位置，然后创建一个HTML 5的页面，像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>准备好页面以后，我们在<code>&lt;body&gt;&lt;/body&gt;</code>标签中写一点东西，来验证一下<code>&lt;canvas&gt;</code>的魅力，像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas-wrap&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>可以发现，当你打开浏览器以后，你的页面上什么都看不到，这恰恰说明你的浏览器是支持Canvas的！你可以找一个老古董浏览器（例如：Internet Explorer）来打开看看，它就会显示“<u>抱歉你的浏览器不支持Canvas！</u>”</p>\n<h2 id=\"计算机绘图基础\"><a href=\"#计算机绘图基础\" class=\"headerlink\" title=\"计算机绘图基础\"></a>计算机绘图基础</h2><p>现实生活中，要想绘图，你需要准备下面这些东西：</p>\n<ul>\n<li>画布（当然不一定是真的布，纸张也算是画布的一种）</li>\n<li>画笔（各种粗细不一，功能不同的笔）</li>\n<li>颜料（12色、16色或者24色的颜料板）</li>\n<li>橡皮、尺子以及其他辅助工具等等；</li>\n</ul>\n<p>那么将这些东西映射到计算机上呢？答案也是一样的，你同样需要准备上面的那几样东西，只不过我们把现实生活中的工具都转换成了JavaScript代码而已。</p>\n<h3 id=\"画布\"><a href=\"#画布\" class=\"headerlink\" title=\"画布\"></a>画布</h3><p>我们再次看<code>&lt;canvas&gt;&lt;/canvas&gt;</code>标签，它有一个id属性，这个id所指向的DOM元素就是我们的画布了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>我们可以给画布添加一些CSS样式，这样在浏览器中你就能看到画布的位置了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#canvas</span> &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#aaaaaa</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">50px</span> auto;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">800</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">600</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>用JavaScript也可以设置画布的宽和高，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>); <span class=\"hljs-comment\">// 这样就可以取到画布对象了</span><br>    <span class=\"hljs-comment\">// 设置画布的大小</span><br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>到此画布我们就创建好了，今后都会在画布上创建图形。</p>\n<h3 id=\"画笔\"><a href=\"#画笔\" class=\"headerlink\" title=\"画笔\"></a>画笔</h3><p>有了画布，自然就少不了画笔了，一般在其他教程中都会叫做上下文环境，我觉得这个词过于抽象，还是用画笔比较容易理解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// 画布</span><br>    <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-comment\">// 画笔</span><br>    <span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>那么既然是画笔，自然就可以设置它的粗细，颜色了对吧，说得对，确实是可以设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">//画笔的粗细</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#acef4d&quot;</span>; <span class=\"hljs-comment\">// 画笔的颜色</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"颜料\"><a href=\"#颜料\" class=\"headerlink\" title=\"颜料\"></a>颜料</h3><p>说完画布和画笔，我们来说颜料；计算机中的颜色表示相信大家都知道了。你可以用<code>RGB</code>或者<code>HSLA</code>颜色表示法，也可以像学习CSS那样给图形上颜色；非常简单。</p>\n<p>上色的方法也非常简单，只需要再创建画笔之后使用<code>context.fillStyle</code>就可以了。上色的方式支持下面这些：</p>\n<ul>\n<li>颜色字符串，例如：red，blue和purple；</li>\n<li>使用十六进制字符串或者其简写形式填充：#FF0000或者#FF0;</li>\n<li>使用<code>rgb()</code>方法设置颜色；R红色、G绿色、B蓝色；</li>\n<li>使用<code>rgba()</code>方法设置颜色；A代表(Alpha)，代表透明度；（0 ~ 1）；</li>\n<li>使用<code>hsl()</code>方法设置颜色；H色相、S饱和度、L明度；</li>\n<li>使用<code>hsla()</code>方法设置颜色；A代表透明度(Alpha)；（0 ~ 1）；</li>\n</ul>\n<h3 id=\"渐变效果\"><a href=\"#渐变效果\" class=\"headerlink\" title=\"渐变效果\"></a>渐变效果</h3><p>渐变分为两种，熟悉PS的同学应该知道是什么；</p>\n<ul>\n<li>线性渐变：<code>context.createLinearGradient(xstart, ystart, xend, yend)</code></li>\n<li>径向渐变：<code>context.createRadialGradient(x0, y0, r0, x1, y1, r1)</code></li>\n</ul>\n<p>添加渐变的步骤有下面3个：</p>\n<p>（1）添加渐变线</p>\n<p>（2）为渐变线添加关建色；</p>\n<p>（3）应用渐变；</p>\n<p>转换成代码就是下面这样子：（以线性渐变为例）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 添加渐变线</span><br><span class=\"hljs-keyword\">let</span> grd = context.<span class=\"hljs-title function_\">createLinearGradient</span>(xstart, ystart, xend, yend);<br><span class=\"hljs-keyword\">let</span> grd2 = context.<span class=\"hljs-title function_\">createRadialGradient</span>(x0, y0, r0, x1, y1, r1);<br><br><span class=\"hljs-comment\">// 添加关建色</span><br><span class=\"hljs-comment\">/* stop代表到(xstart, ystart)的距离占整个渐变色长度的比例，为0~1的浮点数 */</span><br>grd.<span class=\"hljs-title function_\">addColorStop</span>(stop, color)<br><br><span class=\"hljs-comment\">// 应用渐变</span><br>context.<span class=\"hljs-property\">fillStyle</span> = grd; <span class=\"hljs-comment\">// 填充渐变色</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = grd; <span class=\"hljs-comment\">// 线框渐变色</span><br></code></pre></td></tr></table></figure>\n<p>贴上一个例子方便理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Code should wrap in HTML script tag</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    <span class=\"hljs-keyword\">let</span> grd = context.<span class=\"hljs-title function_\">createRadialGradient</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>);<br>    <br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;olive&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.25</span>, <span class=\"hljs-string\">&quot;maroon&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-string\">&quot;aqua&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.75</span>, <span class=\"hljs-string\">&quot;fuchsia&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.25</span>, <span class=\"hljs-string\">&quot;teal&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = grd;<br>    <br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"橡皮擦\"><a href=\"#橡皮擦\" class=\"headerlink\" title=\"橡皮擦\"></a>橡皮擦</h3><p>canvas提供了一个API叫做<code>context.clearRect(x, y, w, h)</code>，这个API就是用来清除画布中的像素的，也就是现实作画中的橡皮擦。</p>\n","site":{"data":{}},"wordcount":3497,"excerpt":"","more":"<h1 id=\"Canvas快速上手\"><a href=\"#Canvas快速上手\" class=\"headerlink\" title=\"Canvas快速上手\"></a>Canvas快速上手</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>你只需要准备：</p>\n<ul>\n<li>Web Kit内核浏览器：Safari（Apple MacOS）、Google Chrome或者Mozilla Firefox；（由于Canvas的标准是Chrome和Mozilla联合制定的，所以推荐使用Chrome或者Firefox）</li>\n<li>你最拿手的编辑器：Sublime Text、Atom或者是Visual Studio Code；（这里我选择了VS Code）</li>\n</ul>\n<p>准备好上面这些之后，在你的电脑文件系统中找一个位置，然后创建一个HTML 5的页面，像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>准备好页面以后，我们在<code>&lt;body&gt;&lt;/body&gt;</code>标签中写一点东西，来验证一下<code>&lt;canvas&gt;</code>的魅力，像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas-wrap&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>可以发现，当你打开浏览器以后，你的页面上什么都看不到，这恰恰说明你的浏览器是支持Canvas的！你可以找一个老古董浏览器（例如：Internet Explorer）来打开看看，它就会显示“<u>抱歉你的浏览器不支持Canvas！</u>”</p>\n<h2 id=\"计算机绘图基础\"><a href=\"#计算机绘图基础\" class=\"headerlink\" title=\"计算机绘图基础\"></a>计算机绘图基础</h2><p>现实生活中，要想绘图，你需要准备下面这些东西：</p>\n<ul>\n<li>画布（当然不一定是真的布，纸张也算是画布的一种）</li>\n<li>画笔（各种粗细不一，功能不同的笔）</li>\n<li>颜料（12色、16色或者24色的颜料板）</li>\n<li>橡皮、尺子以及其他辅助工具等等；</li>\n</ul>\n<p>那么将这些东西映射到计算机上呢？答案也是一样的，你同样需要准备上面的那几样东西，只不过我们把现实生活中的工具都转换成了JavaScript代码而已。</p>\n<h3 id=\"画布\"><a href=\"#画布\" class=\"headerlink\" title=\"画布\"></a>画布</h3><p>我们再次看<code>&lt;canvas&gt;&lt;/canvas&gt;</code>标签，它有一个id属性，这个id所指向的DOM元素就是我们的画布了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>我们可以给画布添加一些CSS样式，这样在浏览器中你就能看到画布的位置了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#canvas</span> &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#aaaaaa</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">50px</span> auto;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">800</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">600</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>用JavaScript也可以设置画布的宽和高，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>); <span class=\"hljs-comment\">// 这样就可以取到画布对象了</span><br>    <span class=\"hljs-comment\">// 设置画布的大小</span><br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>到此画布我们就创建好了，今后都会在画布上创建图形。</p>\n<h3 id=\"画笔\"><a href=\"#画笔\" class=\"headerlink\" title=\"画笔\"></a>画笔</h3><p>有了画布，自然就少不了画笔了，一般在其他教程中都会叫做上下文环境，我觉得这个词过于抽象，还是用画笔比较容易理解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// 画布</span><br>    <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-comment\">// 画笔</span><br>    <span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>那么既然是画笔，自然就可以设置它的粗细，颜色了对吧，说得对，确实是可以设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">//画笔的粗细</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#acef4d&quot;</span>; <span class=\"hljs-comment\">// 画笔的颜色</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"颜料\"><a href=\"#颜料\" class=\"headerlink\" title=\"颜料\"></a>颜料</h3><p>说完画布和画笔，我们来说颜料；计算机中的颜色表示相信大家都知道了。你可以用<code>RGB</code>或者<code>HSLA</code>颜色表示法，也可以像学习CSS那样给图形上颜色；非常简单。</p>\n<p>上色的方法也非常简单，只需要再创建画笔之后使用<code>context.fillStyle</code>就可以了。上色的方式支持下面这些：</p>\n<ul>\n<li>颜色字符串，例如：red，blue和purple；</li>\n<li>使用十六进制字符串或者其简写形式填充：#FF0000或者#FF0;</li>\n<li>使用<code>rgb()</code>方法设置颜色；R红色、G绿色、B蓝色；</li>\n<li>使用<code>rgba()</code>方法设置颜色；A代表(Alpha)，代表透明度；（0 ~ 1）；</li>\n<li>使用<code>hsl()</code>方法设置颜色；H色相、S饱和度、L明度；</li>\n<li>使用<code>hsla()</code>方法设置颜色；A代表透明度(Alpha)；（0 ~ 1）；</li>\n</ul>\n<h3 id=\"渐变效果\"><a href=\"#渐变效果\" class=\"headerlink\" title=\"渐变效果\"></a>渐变效果</h3><p>渐变分为两种，熟悉PS的同学应该知道是什么；</p>\n<ul>\n<li>线性渐变：<code>context.createLinearGradient(xstart, ystart, xend, yend)</code></li>\n<li>径向渐变：<code>context.createRadialGradient(x0, y0, r0, x1, y1, r1)</code></li>\n</ul>\n<p>添加渐变的步骤有下面3个：</p>\n<p>（1）添加渐变线</p>\n<p>（2）为渐变线添加关建色；</p>\n<p>（3）应用渐变；</p>\n<p>转换成代码就是下面这样子：（以线性渐变为例）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 添加渐变线</span><br><span class=\"hljs-keyword\">let</span> grd = context.<span class=\"hljs-title function_\">createLinearGradient</span>(xstart, ystart, xend, yend);<br><span class=\"hljs-keyword\">let</span> grd2 = context.<span class=\"hljs-title function_\">createRadialGradient</span>(x0, y0, r0, x1, y1, r1);<br><br><span class=\"hljs-comment\">// 添加关建色</span><br><span class=\"hljs-comment\">/* stop代表到(xstart, ystart)的距离占整个渐变色长度的比例，为0~1的浮点数 */</span><br>grd.<span class=\"hljs-title function_\">addColorStop</span>(stop, color)<br><br><span class=\"hljs-comment\">// 应用渐变</span><br>context.<span class=\"hljs-property\">fillStyle</span> = grd; <span class=\"hljs-comment\">// 填充渐变色</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = grd; <span class=\"hljs-comment\">// 线框渐变色</span><br></code></pre></td></tr></table></figure>\n<p>贴上一个例子方便理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Code should wrap in HTML script tag</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    <span class=\"hljs-keyword\">let</span> grd = context.<span class=\"hljs-title function_\">createRadialGradient</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>);<br>    <br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;olive&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.25</span>, <span class=\"hljs-string\">&quot;maroon&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-string\">&quot;aqua&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.75</span>, <span class=\"hljs-string\">&quot;fuchsia&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.25</span>, <span class=\"hljs-string\">&quot;teal&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = grd;<br>    <br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"橡皮擦\"><a href=\"#橡皮擦\" class=\"headerlink\" title=\"橡皮擦\"></a>橡皮擦</h3><p>canvas提供了一个API叫做<code>context.clearRect(x, y, w, h)</code>，这个API就是用来清除画布中的像素的，也就是现实作画中的橡皮擦。</p>\n"},{"title":"Canvas文本","date":"2022-02-18T03:00:01.000Z","updated":"2022-02-18T03:00:01.000Z","_content":"\n# Canvas文本\n\n## 文本API\n\n使用Canvas显示字体分下面三步：\n\n- 使用`font`设置字体；\n- 使用`fillStyle`设置字体颜色；\n- 使用`fillText()`方法显示字体；\n\n默认情况下`font`属性可以不指定，如果不指定字体，则默认使用10px无衬字体；贴上一个例子：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.font = \"50px serif\";\n    context.fillStyle = \"#00AAAA\";\n    context.fillText(\"Canvas -- Draw on the web\", 50, 300);\n};\n```\n\n## 文本渲染\n\n和图形一样，文本也提供了`fillText()`和`strokeText()`两种方法。具体看例子：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.beginPath();\n    context.font = \"50px Verdana\";\n    var gradient = context.createLinearGradient(0, 0, 800, 0);\n    gradient.addColorStop(\"0\", \"magenta\");\n    gradient.addColorStop(\"0.5\", \"blue\");\n    gradient.addColorStop(\"1.0\", \"red\");\n    \n    context.fillStyle = gradient;\n    context.strokeStyle = \"#00AAAA\";\n    context.strokeText(\"Text\", 50, 100);\n    context.fillText(\"Text\", 50, 100);\n    \n    context.fillText(\"Text\", 50, 300, 200);\n};\n```\n","source":"_posts/frontend/canvas/canvas-text.md","raw":"---\ntitle: Canvas文本\ndate: 2022-02-18 11:00:01\nupdated: 2022-02-18 11:00:01\ntags: HTML\ncategories: 前端\n---\n\n# Canvas文本\n\n## 文本API\n\n使用Canvas显示字体分下面三步：\n\n- 使用`font`设置字体；\n- 使用`fillStyle`设置字体颜色；\n- 使用`fillText()`方法显示字体；\n\n默认情况下`font`属性可以不指定，如果不指定字体，则默认使用10px无衬字体；贴上一个例子：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.font = \"50px serif\";\n    context.fillStyle = \"#00AAAA\";\n    context.fillText(\"Canvas -- Draw on the web\", 50, 300);\n};\n```\n\n## 文本渲染\n\n和图形一样，文本也提供了`fillText()`和`strokeText()`两种方法。具体看例子：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.beginPath();\n    context.font = \"50px Verdana\";\n    var gradient = context.createLinearGradient(0, 0, 800, 0);\n    gradient.addColorStop(\"0\", \"magenta\");\n    gradient.addColorStop(\"0.5\", \"blue\");\n    gradient.addColorStop(\"1.0\", \"red\");\n    \n    context.fillStyle = gradient;\n    context.strokeStyle = \"#00AAAA\";\n    context.strokeText(\"Text\", 50, 100);\n    context.fillText(\"Text\", 50, 100);\n    \n    context.fillText(\"Text\", 50, 300, 200);\n};\n```\n","slug":"frontend/canvas/canvas-text","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vy00494f61ghzx13y8","content":"<h1 id=\"Canvas文本\"><a href=\"#Canvas文本\" class=\"headerlink\" title=\"Canvas文本\"></a>Canvas文本</h1><h2 id=\"文本API\"><a href=\"#文本API\" class=\"headerlink\" title=\"文本API\"></a>文本API</h2><p>使用Canvas显示字体分下面三步：</p>\n<ul>\n<li>使用<code>font</code>设置字体；</li>\n<li>使用<code>fillStyle</code>设置字体颜色；</li>\n<li>使用<code>fillText()</code>方法显示字体；</li>\n</ul>\n<p>默认情况下<code>font</code>属性可以不指定，如果不指定字体，则默认使用10px无衬字体；贴上一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">&quot;50px serif&quot;</span>;<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Canvas -- Draw on the web&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">300</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"文本渲染\"><a href=\"#文本渲染\" class=\"headerlink\" title=\"文本渲染\"></a>文本渲染</h2><p>和图形一样，文本也提供了<code>fillText()</code>和<code>strokeText()</code>两种方法。具体看例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-title function_\">beginPath</span>();<br>    context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">&quot;50px Verdana&quot;</span>;<br>    <span class=\"hljs-keyword\">var</span> gradient = context.<span class=\"hljs-title function_\">createLinearGradient</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">800</span>, <span class=\"hljs-number\">0</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;0&quot;</span>, <span class=\"hljs-string\">&quot;magenta&quot;</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;0.5&quot;</span>, <span class=\"hljs-string\">&quot;blue&quot;</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;1.0&quot;</span>, <span class=\"hljs-string\">&quot;red&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = gradient;<br>    context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">strokeText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">100</span>);<br>    <br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1170,"excerpt":"","more":"<h1 id=\"Canvas文本\"><a href=\"#Canvas文本\" class=\"headerlink\" title=\"Canvas文本\"></a>Canvas文本</h1><h2 id=\"文本API\"><a href=\"#文本API\" class=\"headerlink\" title=\"文本API\"></a>文本API</h2><p>使用Canvas显示字体分下面三步：</p>\n<ul>\n<li>使用<code>font</code>设置字体；</li>\n<li>使用<code>fillStyle</code>设置字体颜色；</li>\n<li>使用<code>fillText()</code>方法显示字体；</li>\n</ul>\n<p>默认情况下<code>font</code>属性可以不指定，如果不指定字体，则默认使用10px无衬字体；贴上一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">&quot;50px serif&quot;</span>;<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Canvas -- Draw on the web&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">300</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"文本渲染\"><a href=\"#文本渲染\" class=\"headerlink\" title=\"文本渲染\"></a>文本渲染</h2><p>和图形一样，文本也提供了<code>fillText()</code>和<code>strokeText()</code>两种方法。具体看例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-title function_\">beginPath</span>();<br>    context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">&quot;50px Verdana&quot;</span>;<br>    <span class=\"hljs-keyword\">var</span> gradient = context.<span class=\"hljs-title function_\">createLinearGradient</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">800</span>, <span class=\"hljs-number\">0</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;0&quot;</span>, <span class=\"hljs-string\">&quot;magenta&quot;</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;0.5&quot;</span>, <span class=\"hljs-string\">&quot;blue&quot;</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;1.0&quot;</span>, <span class=\"hljs-string\">&quot;red&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = gradient;<br>    context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">strokeText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">100</span>);<br>    <br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"Canvas变换","date":"2022-02-18T02:59:34.000Z","updated":"2022-02-18T02:59:34.000Z","_content":"\n# Canvas变换\n\n## 图形变换\n\n图形变换无外乎是利用数学方法调整所绘形状的物理属性，实质上是坐标变形。所有的变换都依赖于后台的数学矩阵运算，所以只需要使用即可，无需理会底层原理。\n\n- 平移变换：`translate(x, y)`\n- 旋转变换：`rotate(deg)`\n- 缩放变换：`scale(sx, sy)`\n\n## 平移变换\n\n顾名思义，就是一般的图形位移。例如我想把位于(100, 100)的矩形平移至(200, 200)点，那么只需要再绘制矩形之前加上`context.translate(100, 100)`即可，例子如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.fillStyle = \"#00AAAA\";\ncontext.fillRect(100, 100, 200, 100);\n\ncontext.fillStyle = \"red\";\ncontext.translate(100, 100);\ncontext.fillRect(100, 100, 200, 100);\n```\n\n如果想平移到(300, 300)的位置，需要重置参考坐标系的位置，也就是重置到原点，再进行平移，有两种方法：\n\n- 绘制下一次平移图形的时候，手动将坐标系换回原点：即：`translate(-x, -y)`；\n- 平移前调用`context.save()`和`context.restore()`。\n\n实例如下：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.fillStyle = \"#00AAAA\";\n    context.fillRect(100, 100, 200, 100);\n    \n    context.save();\n    context.fillStyle = \"red\";\n    context.translate(100, 100);\n    context.fillRect(100, 100, 200, 100);\n    context.restore();\n    \n    context.save();\n    context.fillStyle = \"green\";\n    context.translate(200, 200);\n    context.fillRect(100, 100, 200, 100);\n    context.restore();\n};\n```\n\n## 旋转变换\n\n`rotate(deg)`是指图形以坐标系原点为圆心进行顺时针旋转，因此在使用`rotate()`之前可以配合`translate()`来平移坐标系，确定旋转的圆心。\n\n我们用一个例子来看看：\n\n```javascript\n// 画布\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n// 画笔\nvar context = canvas.getContext(\"2d\");\n\nfor (let i = 0; i <= 12; i++) {\n    context.save();\n    context.translate(70 + i * 50, 50 + i * 40);\n    context.fillStyle = \"#00AAAA\";\n    context.fillRect(0, 0, 20, 20);\n    context.restore();\n\n    context.save();\n    context.translate(70 + i * 50, 50 + i * 40);\n    context.rotate(i * 30 * PI / 180); // 这里是弧度，不是角度\n    context.fillStyle = \"red\";\n    context.fillRect(0, 0, 20, 20);\n    context.restore();\n}\n```\n\n## 缩放变换\n\n缩放变换最简单了，分别是在水平方向和垂直方向上对象的缩放倍数。但是缩放会导致坐标位置改变、线条加粗。所以在实际使用过程中能尽量不使用scale函数做缩放变换是最好的。\n\n```javascript\n// 画布\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n// 画笔\nvar context = canvas.getContext(\"2d\");\n\ncontext.strokeStyle = \"red\";\ncontext.lineWidth = 5;\nfor (let i = 1; i < 4; i++) {\n    context.save();\n    context.scale(i, i);\n    context.strokeRect(50, 50, 150, 100);\n    context.restore();\n}\n```\n\n## 万能的transform函数\n\n前面讲的三种变换函数，使用`transform()`函数就可以做到，\n","source":"_posts/frontend/canvas/canvas-tranverse.md","raw":"---\ntitle: Canvas变换\ndate: 2022-02-18 10:59:34\nupdated: 2022-02-18 10:59:34\ntags: HTML\ncategories: 前端\n---\n\n# Canvas变换\n\n## 图形变换\n\n图形变换无外乎是利用数学方法调整所绘形状的物理属性，实质上是坐标变形。所有的变换都依赖于后台的数学矩阵运算，所以只需要使用即可，无需理会底层原理。\n\n- 平移变换：`translate(x, y)`\n- 旋转变换：`rotate(deg)`\n- 缩放变换：`scale(sx, sy)`\n\n## 平移变换\n\n顾名思义，就是一般的图形位移。例如我想把位于(100, 100)的矩形平移至(200, 200)点，那么只需要再绘制矩形之前加上`context.translate(100, 100)`即可，例子如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.fillStyle = \"#00AAAA\";\ncontext.fillRect(100, 100, 200, 100);\n\ncontext.fillStyle = \"red\";\ncontext.translate(100, 100);\ncontext.fillRect(100, 100, 200, 100);\n```\n\n如果想平移到(300, 300)的位置，需要重置参考坐标系的位置，也就是重置到原点，再进行平移，有两种方法：\n\n- 绘制下一次平移图形的时候，手动将坐标系换回原点：即：`translate(-x, -y)`；\n- 平移前调用`context.save()`和`context.restore()`。\n\n实例如下：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.fillStyle = \"#00AAAA\";\n    context.fillRect(100, 100, 200, 100);\n    \n    context.save();\n    context.fillStyle = \"red\";\n    context.translate(100, 100);\n    context.fillRect(100, 100, 200, 100);\n    context.restore();\n    \n    context.save();\n    context.fillStyle = \"green\";\n    context.translate(200, 200);\n    context.fillRect(100, 100, 200, 100);\n    context.restore();\n};\n```\n\n## 旋转变换\n\n`rotate(deg)`是指图形以坐标系原点为圆心进行顺时针旋转，因此在使用`rotate()`之前可以配合`translate()`来平移坐标系，确定旋转的圆心。\n\n我们用一个例子来看看：\n\n```javascript\n// 画布\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n// 画笔\nvar context = canvas.getContext(\"2d\");\n\nfor (let i = 0; i <= 12; i++) {\n    context.save();\n    context.translate(70 + i * 50, 50 + i * 40);\n    context.fillStyle = \"#00AAAA\";\n    context.fillRect(0, 0, 20, 20);\n    context.restore();\n\n    context.save();\n    context.translate(70 + i * 50, 50 + i * 40);\n    context.rotate(i * 30 * PI / 180); // 这里是弧度，不是角度\n    context.fillStyle = \"red\";\n    context.fillRect(0, 0, 20, 20);\n    context.restore();\n}\n```\n\n## 缩放变换\n\n缩放变换最简单了，分别是在水平方向和垂直方向上对象的缩放倍数。但是缩放会导致坐标位置改变、线条加粗。所以在实际使用过程中能尽量不使用scale函数做缩放变换是最好的。\n\n```javascript\n// 画布\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n// 画笔\nvar context = canvas.getContext(\"2d\");\n\ncontext.strokeStyle = \"red\";\ncontext.lineWidth = 5;\nfor (let i = 1; i < 4; i++) {\n    context.save();\n    context.scale(i, i);\n    context.strokeRect(50, 50, 150, 100);\n    context.restore();\n}\n```\n\n## 万能的transform函数\n\n前面讲的三种变换函数，使用`transform()`函数就可以做到，\n","slug":"frontend/canvas/canvas-tranverse","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2j6t6vz004c4f61g9cg23wz","content":"<h1 id=\"Canvas变换\"><a href=\"#Canvas变换\" class=\"headerlink\" title=\"Canvas变换\"></a>Canvas变换</h1><h2 id=\"图形变换\"><a href=\"#图形变换\" class=\"headerlink\" title=\"图形变换\"></a>图形变换</h2><p>图形变换无外乎是利用数学方法调整所绘形状的物理属性，实质上是坐标变形。所有的变换都依赖于后台的数学矩阵运算，所以只需要使用即可，无需理会底层原理。</p>\n<ul>\n<li>平移变换：<code>translate(x, y)</code></li>\n<li>旋转变换：<code>rotate(deg)</code></li>\n<li>缩放变换：<code>scale(sx, sy)</code></li>\n</ul>\n<h2 id=\"平移变换\"><a href=\"#平移变换\" class=\"headerlink\" title=\"平移变换\"></a>平移变换</h2><p>顾名思义，就是一般的图形位移。例如我想把位于(100, 100)的矩形平移至(200, 200)点，那么只需要再绘制矩形之前加上<code>context.translate(100, 100)</code>即可，例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br><br>context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br></code></pre></td></tr></table></figure>\n<p>如果想平移到(300, 300)的位置，需要重置参考坐标系的位置，也就是重置到原点，再进行平移，有两种方法：</p>\n<ul>\n<li>绘制下一次平移图形的时候，手动将坐标系换回原点：即：<code>translate(-x, -y)</code>；</li>\n<li>平移前调用<code>context.save()</code>和<code>context.restore()</code>。</li>\n</ul>\n<p>实例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    <br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>    <br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;green&quot;</span>;<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"旋转变换\"><a href=\"#旋转变换\" class=\"headerlink\" title=\"旋转变换\"></a>旋转变换</h2><p><code>rotate(deg)</code>是指图形以坐标系原点为圆心进行顺时针旋转，因此在使用<code>rotate()</code>之前可以配合<code>translate()</code>来平移坐标系，确定旋转的圆心。</p>\n<p>我们用一个例子来看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 画布</span><br><span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><span class=\"hljs-comment\">// 画笔</span><br><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">12</span>; i++) &#123;<br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">70</span> + i * <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span> + i * <span class=\"hljs-number\">40</span>);<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br><br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">70</span> + i * <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span> + i * <span class=\"hljs-number\">40</span>);<br>    context.<span class=\"hljs-title function_\">rotate</span>(i * <span class=\"hljs-number\">30</span> * <span class=\"hljs-variable constant_\">PI</span> / <span class=\"hljs-number\">180</span>); <span class=\"hljs-comment\">// 这里是弧度，不是角度</span><br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"缩放变换\"><a href=\"#缩放变换\" class=\"headerlink\" title=\"缩放变换\"></a>缩放变换</h2><p>缩放变换最简单了，分别是在水平方向和垂直方向上对象的缩放倍数。但是缩放会导致坐标位置改变、线条加粗。所以在实际使用过程中能尽量不使用scale函数做缩放变换是最好的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 画布</span><br><span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><span class=\"hljs-comment\">// 画笔</span><br><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">scale</span>(i, i);<br>    context.<span class=\"hljs-title function_\">strokeRect</span>(<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"万能的transform函数\"><a href=\"#万能的transform函数\" class=\"headerlink\" title=\"万能的transform函数\"></a>万能的transform函数</h2><p>前面讲的三种变换函数，使用<code>transform()</code>函数就可以做到，</p>\n","site":{"data":{}},"wordcount":2307,"excerpt":"","more":"<h1 id=\"Canvas变换\"><a href=\"#Canvas变换\" class=\"headerlink\" title=\"Canvas变换\"></a>Canvas变换</h1><h2 id=\"图形变换\"><a href=\"#图形变换\" class=\"headerlink\" title=\"图形变换\"></a>图形变换</h2><p>图形变换无外乎是利用数学方法调整所绘形状的物理属性，实质上是坐标变形。所有的变换都依赖于后台的数学矩阵运算，所以只需要使用即可，无需理会底层原理。</p>\n<ul>\n<li>平移变换：<code>translate(x, y)</code></li>\n<li>旋转变换：<code>rotate(deg)</code></li>\n<li>缩放变换：<code>scale(sx, sy)</code></li>\n</ul>\n<h2 id=\"平移变换\"><a href=\"#平移变换\" class=\"headerlink\" title=\"平移变换\"></a>平移变换</h2><p>顾名思义，就是一般的图形位移。例如我想把位于(100, 100)的矩形平移至(200, 200)点，那么只需要再绘制矩形之前加上<code>context.translate(100, 100)</code>即可，例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br><br>context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br></code></pre></td></tr></table></figure>\n<p>如果想平移到(300, 300)的位置，需要重置参考坐标系的位置，也就是重置到原点，再进行平移，有两种方法：</p>\n<ul>\n<li>绘制下一次平移图形的时候，手动将坐标系换回原点：即：<code>translate(-x, -y)</code>；</li>\n<li>平移前调用<code>context.save()</code>和<code>context.restore()</code>。</li>\n</ul>\n<p>实例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    <br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>    <br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;green&quot;</span>;<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"旋转变换\"><a href=\"#旋转变换\" class=\"headerlink\" title=\"旋转变换\"></a>旋转变换</h2><p><code>rotate(deg)</code>是指图形以坐标系原点为圆心进行顺时针旋转，因此在使用<code>rotate()</code>之前可以配合<code>translate()</code>来平移坐标系，确定旋转的圆心。</p>\n<p>我们用一个例子来看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 画布</span><br><span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><span class=\"hljs-comment\">// 画笔</span><br><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">12</span>; i++) &#123;<br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">70</span> + i * <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span> + i * <span class=\"hljs-number\">40</span>);<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br><br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">70</span> + i * <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span> + i * <span class=\"hljs-number\">40</span>);<br>    context.<span class=\"hljs-title function_\">rotate</span>(i * <span class=\"hljs-number\">30</span> * <span class=\"hljs-variable constant_\">PI</span> / <span class=\"hljs-number\">180</span>); <span class=\"hljs-comment\">// 这里是弧度，不是角度</span><br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"缩放变换\"><a href=\"#缩放变换\" class=\"headerlink\" title=\"缩放变换\"></a>缩放变换</h2><p>缩放变换最简单了，分别是在水平方向和垂直方向上对象的缩放倍数。但是缩放会导致坐标位置改变、线条加粗。所以在实际使用过程中能尽量不使用scale函数做缩放变换是最好的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 画布</span><br><span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><span class=\"hljs-comment\">// 画笔</span><br><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">scale</span>(i, i);<br>    context.<span class=\"hljs-title function_\">strokeRect</span>(<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"万能的transform函数\"><a href=\"#万能的transform函数\" class=\"headerlink\" title=\"万能的transform函数\"></a>万能的transform函数</h2><p>前面讲的三种变换函数，使用<code>transform()</code>函数就可以做到，</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl2j6t6uw00024f610jrp5w9z","category_id":"cl2j6t6uy00044f61awvb6tup","_id":"cl2j6t6v3000e4f61abki3cc0"},{"post_id":"cl2j6t6v2000c4f618p6dezby","category_id":"cl2j6t6v200094f61g4xy1vs9","_id":"cl2j6t6v6000l4f619ek3eonx"},{"post_id":"cl2j6t6ux00034f618idzf8cu","category_id":"cl2j6t6v200094f61g4xy1vs9","_id":"cl2j6t6v8000q4f61h1p0078b"},{"post_id":"cl2j6t6v3000d4f617v0m8ryv","category_id":"cl2j6t6v200094f61g4xy1vs9","_id":"cl2j6t6v8000t4f612nux66t2"},{"post_id":"cl2j6t6v000064f611813aw86","category_id":"cl2j6t6v200094f61g4xy1vs9","_id":"cl2j6t6v9000x4f61aujo5pln"},{"post_id":"cl2j6t6v7000p4f610ojtfle5","category_id":"cl2j6t6v200094f61g4xy1vs9","_id":"cl2j6t6va00104f612k6g0jqg"},{"post_id":"cl2j6t6v100074f616emlh7zp","category_id":"cl2j6t6v200094f61g4xy1vs9","_id":"cl2j6t6vc00144f611wpq04fg"},{"post_id":"cl2j6t6v100084f614a7y9f4o","category_id":"cl2j6t6v200094f61g4xy1vs9","_id":"cl2j6t6vd00174f616isa651m"},{"post_id":"cl2j6t6v5000i4f6178dtd40q","category_id":"cl2j6t6va00114f6173ub5mmf","_id":"cl2j6t6ve001d4f61fveu0268"},{"post_id":"cl2j6t6v5000k4f615s6c2ib8","category_id":"cl2j6t6vd00184f61efvsd2u1","_id":"cl2j6t6vf001j4f619g1n8fea"},{"post_id":"cl2j6t6v8000s4f61e0og2n6v","category_id":"cl2j6t6ve001f4f6167bk49sl","_id":"cl2j6t6vh001r4f618uk508tv"},{"post_id":"cl2j6t6v9000w4f61gyuwahup","category_id":"cl2j6t6ve001f4f6167bk49sl","_id":"cl2j6t6vj001w4f614hxwaddw"},{"post_id":"cl2j6t6vi001u4f611e41hsee","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vk00224f6169ln9jmd"},{"post_id":"cl2j6t6v9000z4f610o9acixi","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vl00274f617pha83al"},{"post_id":"cl2j6t6vi001v4f61g22zak62","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vl002a4f612um76coa"},{"post_id":"cl2j6t6vj001z4f6112llf3zz","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vm002f4f612l30f7sw"},{"post_id":"cl2j6t6va00134f618rgl6pvn","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vn002i4f613lcq1no7"},{"post_id":"cl2j6t6vk00214f614q2f3d6f","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vo002n4f615lzmb4vw"},{"post_id":"cl2j6t6vl00264f612cck29jx","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vo002q4f61azyzhux9"},{"post_id":"cl2j6t6vc00164f619tzwae94","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vp002v4f614zn8hj3p"},{"post_id":"cl2j6t6vl00294f614elggkd4","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vq002y4f6142cxbuec"},{"post_id":"cl2j6t6vm002e4f61c7thfp7g","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vq00334f6115qs3ayc"},{"post_id":"cl2j6t6vd001a4f618msx38y6","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vr00364f61ac1s3iul"},{"post_id":"cl2j6t6vn002h4f61f0y5ggz3","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vs003b4f61csai7tug"},{"post_id":"cl2j6t6ve001c4f61dvsye45p","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vs003e4f614frxbaw3"},{"post_id":"cl2j6t6vf001g4f6123ko1hak","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vt003i4f61g6om982w"},{"post_id":"cl2j6t6vf001i4f61gqk7f5ek","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vu003l4f618yfgbaad"},{"post_id":"cl2j6t6vg001o4f615jk350ts","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vu003p4f6152o9bo7x"},{"post_id":"cl2j6t6vh001p4f618xyodr6v","category_id":"cl2j6t6vh001q4f616g58a65n","_id":"cl2j6t6vv003s4f61025ec86i"},{"post_id":"cl2j6t6vn002m4f61gw3ohi08","category_id":"cl2j6t6vu003m4f6186w9crx1","_id":"cl2j6t6vw003y4f61dapnfmwq"},{"post_id":"cl2j6t6vo002p4f61c8772xrn","category_id":"cl2j6t6vv003t4f612yv3625g","_id":"cl2j6t6vy00464f6100jx89ez"},{"post_id":"cl2j6t6vp002u4f6144ro3oxb","category_id":"cl2j6t6vv003t4f612yv3625g","_id":"cl2j6t6vz004a4f61gxwx4r7q"},{"post_id":"cl2j6t6vp002x4f6191fn02ao","category_id":"cl2j6t6vy00454f612xe8achz","_id":"cl2j6t6w0004g4f61b0m5556x"},{"post_id":"cl2j6t6vq00324f61fo4h38wi","category_id":"cl2j6t6vy00454f612xe8achz","_id":"cl2j6t6w0004k4f61gyci58ys"},{"post_id":"cl2j6t6vr00354f61871i82vb","category_id":"cl2j6t6vy00454f612xe8achz","_id":"cl2j6t6w1004o4f61hhl66ily"},{"post_id":"cl2j6t6vs003a4f6114060dmc","category_id":"cl2j6t6vy00454f612xe8achz","_id":"cl2j6t6w1004s4f61c1z46nmo"},{"post_id":"cl2j6t6vs003d4f61ex76h9du","category_id":"cl2j6t6vv003t4f612yv3625g","_id":"cl2j6t6w2004w4f61b5l27in4"},{"post_id":"cl2j6t6vt003h4f619iik93ns","category_id":"cl2j6t6vy00454f612xe8achz","_id":"cl2j6t6w300504f61crs1ba25"},{"post_id":"cl2j6t6vt003k4f61f2u1f3fy","category_id":"cl2j6t6vy00454f612xe8achz","_id":"cl2j6t6w300534f61hcv92zp3"},{"post_id":"cl2j6t6vu003o4f617gel2u7h","category_id":"cl2j6t6w2004z4f610scwcfcq","_id":"cl2j6t6w300574f616635gdii"},{"post_id":"cl2j6t6vv003r4f610nheeeed","category_id":"cl2j6t6w300544f61cg8tc3ot","_id":"cl2j6t6w5005d4f611wis79hv"},{"post_id":"cl2j6t6vv003v4f619y1a7ib5","category_id":"cl2j6t6w300544f61cg8tc3ot","_id":"cl2j6t6w5005g4f61642t5dk1"},{"post_id":"cl2j6t6vw003x4f61cbzi5cvg","category_id":"cl2j6t6w300544f61cg8tc3ot","_id":"cl2j6t6w6005k4f613060fvwb"},{"post_id":"cl2j6t6vx00414f61enbhaapb","category_id":"cl2j6t6w300544f61cg8tc3ot","_id":"cl2j6t6w6005o4f611eqn54wf"},{"post_id":"cl2j6t6vx00434f619vka7o1a","category_id":"cl2j6t6w300544f61cg8tc3ot","_id":"cl2j6t6w7005s4f616zav7ky9"},{"post_id":"cl2j6t6vy00474f61dniu1lq7","category_id":"cl2j6t6w300544f61cg8tc3ot","_id":"cl2j6t6w8005w4f619oiu14wa"},{"post_id":"cl2j6t6vy00494f61ghzx13y8","category_id":"cl2j6t6w300544f61cg8tc3ot","_id":"cl2j6t6w8005z4f61avy1andb"},{"post_id":"cl2j6t6vz004c4f61g9cg23wz","category_id":"cl2j6t6w300544f61cg8tc3ot","_id":"cl2j6t6w800624f610wjz3fkv"}],"PostTag":[{"post_id":"cl2j6t6uw00024f610jrp5w9z","tag_id":"cl2j6t6uz00054f61d18vabk5","_id":"cl2j6t6v2000b4f61b1t41vvx"},{"post_id":"cl2j6t6v2000c4f618p6dezby","tag_id":"cl2j6t6v2000a4f61falm847q","_id":"cl2j6t6v4000h4f61ev6b76vs"},{"post_id":"cl2j6t6ux00034f618idzf8cu","tag_id":"cl2j6t6v2000a4f61falm847q","_id":"cl2j6t6v5000j4f61fb1bf37o"},{"post_id":"cl2j6t6v3000d4f617v0m8ryv","tag_id":"cl2j6t6v2000a4f61falm847q","_id":"cl2j6t6v7000o4f617so37k79"},{"post_id":"cl2j6t6v000064f611813aw86","tag_id":"cl2j6t6v2000a4f61falm847q","_id":"cl2j6t6v8000r4f615adhf4xc"},{"post_id":"cl2j6t6v100074f616emlh7zp","tag_id":"cl2j6t6v2000a4f61falm847q","_id":"cl2j6t6v9000y4f6199ye64u1"},{"post_id":"cl2j6t6v100084f614a7y9f4o","tag_id":"cl2j6t6v2000a4f61falm847q","_id":"cl2j6t6vc00154f61fl321otm"},{"post_id":"cl2j6t6v5000i4f6178dtd40q","tag_id":"cl2j6t6va00124f61gku600vw","_id":"cl2j6t6ve001b4f614dzwc5cw"},{"post_id":"cl2j6t6v5000k4f615s6c2ib8","tag_id":"cl2j6t6va00124f61gku600vw","_id":"cl2j6t6vf001h4f61ciie0bu3"},{"post_id":"cl2j6t6v7000p4f610ojtfle5","tag_id":"cl2j6t6ve001e4f61452436z7","_id":"cl2j6t6vg001n4f613y7u0xhq"},{"post_id":"cl2j6t6v8000s4f61e0og2n6v","tag_id":"cl2j6t6vf001k4f61gg7gfvic","_id":"cl2j6t6vi001t4f61g3vh7mou"},{"post_id":"cl2j6t6v9000w4f61gyuwahup","tag_id":"cl2j6t6vh001s4f61fpub0mt2","_id":"cl2j6t6vj00204f61hffxc6ek"},{"post_id":"cl2j6t6vj001z4f6112llf3zz","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vk00254f61gemz7tdl"},{"post_id":"cl2j6t6v9000z4f610o9acixi","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vl00284f619u2e76q5"},{"post_id":"cl2j6t6vk00214f614q2f3d6f","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vm002d4f61ezok5sql"},{"post_id":"cl2j6t6vl00264f612cck29jx","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vm002g4f617rpkbczt"},{"post_id":"cl2j6t6va00134f618rgl6pvn","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vn002l4f610ymwa41u"},{"post_id":"cl2j6t6vl00294f614elggkd4","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vo002o4f611139cysk"},{"post_id":"cl2j6t6vm002e4f61c7thfp7g","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vp002t4f618oi95fx1"},{"post_id":"cl2j6t6vc00164f619tzwae94","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vp002w4f614bii53z7"},{"post_id":"cl2j6t6vn002h4f61f0y5ggz3","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vq00314f61ew4p01rd"},{"post_id":"cl2j6t6vd001a4f618msx38y6","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vr00344f610993aoq8"},{"post_id":"cl2j6t6ve001c4f61dvsye45p","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vr00394f6146amdfwp"},{"post_id":"cl2j6t6vf001g4f6123ko1hak","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vs003c4f61houebtpw"},{"post_id":"cl2j6t6vf001i4f61gqk7f5ek","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vt003j4f613hbufhex"},{"post_id":"cl2j6t6vg001o4f615jk350ts","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vv003q4f610h92gung"},{"post_id":"cl2j6t6vh001p4f618xyodr6v","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vw003w4f610qk47rhr"},{"post_id":"cl2j6t6vi001u4f611e41hsee","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vx00424f6118y72jc1"},{"post_id":"cl2j6t6vi001v4f61g22zak62","tag_id":"cl2j6t6vj001y4f616xrd4pb3","_id":"cl2j6t6vy00484f61c5xpc82n"},{"post_id":"cl2j6t6vn002m4f61gw3ohi08","tag_id":"cl2j6t6vy00444f61g4s19b8u","_id":"cl2j6t6w0004e4f61fws3gfrp"},{"post_id":"cl2j6t6vo002p4f61c8772xrn","tag_id":"cl2j6t6vz004b4f61h5vghdwc","_id":"cl2j6t6w0004i4f61cvbj276m"},{"post_id":"cl2j6t6vp002u4f6144ro3oxb","tag_id":"cl2j6t6vz004b4f61h5vghdwc","_id":"cl2j6t6w1004m4f61hnbwesjy"},{"post_id":"cl2j6t6vp002x4f6191fn02ao","tag_id":"cl2j6t6w0004l4f61hhad202e","_id":"cl2j6t6w1004q4f6136ht8cuz"},{"post_id":"cl2j6t6vq00324f61fo4h38wi","tag_id":"cl2j6t6w0004l4f61hhad202e","_id":"cl2j6t6w2004u4f61f4qh8kqw"},{"post_id":"cl2j6t6vr00354f61871i82vb","tag_id":"cl2j6t6w0004l4f61hhad202e","_id":"cl2j6t6w2004y4f619r42ewkw"},{"post_id":"cl2j6t6vs003a4f6114060dmc","tag_id":"cl2j6t6w0004l4f61hhad202e","_id":"cl2j6t6w300524f6159a0angd"},{"post_id":"cl2j6t6vs003d4f61ex76h9du","tag_id":"cl2j6t6vz004b4f61h5vghdwc","_id":"cl2j6t6w300564f61bpqs5qmm"},{"post_id":"cl2j6t6vt003h4f619iik93ns","tag_id":"cl2j6t6w0004l4f61hhad202e","_id":"cl2j6t6w4005a4f61ave667yv"},{"post_id":"cl2j6t6vt003k4f61f2u1f3fy","tag_id":"cl2j6t6w0004l4f61hhad202e","_id":"cl2j6t6w5005e4f611elg58h6"},{"post_id":"cl2j6t6vu003o4f617gel2u7h","tag_id":"cl2j6t6w5005b4f61ekhv8zst","_id":"cl2j6t6w5005i4f616j02867x"},{"post_id":"cl2j6t6vv003r4f610nheeeed","tag_id":"cl2j6t6w5005h4f610unqdvu3","_id":"cl2j6t6w6005m4f61g73idjc1"},{"post_id":"cl2j6t6vv003v4f619y1a7ib5","tag_id":"cl2j6t6w5005h4f610unqdvu3","_id":"cl2j6t6w7005q4f612ft1hdmw"},{"post_id":"cl2j6t6vw003x4f61cbzi5cvg","tag_id":"cl2j6t6w5005h4f610unqdvu3","_id":"cl2j6t6w7005u4f61colq2vch"},{"post_id":"cl2j6t6vx00414f61enbhaapb","tag_id":"cl2j6t6w7005t4f615bhx49qx","_id":"cl2j6t6w8005y4f6173kfao15"},{"post_id":"cl2j6t6vx00434f619vka7o1a","tag_id":"cl2j6t6w7005t4f615bhx49qx","_id":"cl2j6t6w800614f61hd6222sp"},{"post_id":"cl2j6t6vy00474f61dniu1lq7","tag_id":"cl2j6t6w7005t4f615bhx49qx","_id":"cl2j6t6w800644f61766s1txi"},{"post_id":"cl2j6t6vy00494f61ghzx13y8","tag_id":"cl2j6t6w7005t4f615bhx49qx","_id":"cl2j6t6w900664f617fhsbpkc"},{"post_id":"cl2j6t6vz004c4f61g9cg23wz","tag_id":"cl2j6t6w7005t4f615bhx49qx","_id":"cl2j6t6wa00674f61bmn31cxx"}],"Tag":[{"name":"Go语言","_id":"cl2j6t6uz00054f61d18vabk5"},{"name":"Java基础","_id":"cl2j6t6v2000a4f61falm847q"},{"name":"Java","_id":"cl2j6t6va00124f61gku600vw"},{"name":"JVM","_id":"cl2j6t6ve001e4f61452436z7"},{"name":"Kafka","_id":"cl2j6t6vf001k4f61gg7gfvic"},{"name":"Redis","_id":"cl2j6t6vh001s4f61fpub0mt2"},{"name":"ES6基础","_id":"cl2j6t6vj001y4f616xrd4pb3"},{"name":"MySQL","_id":"cl2j6t6vy00444f61g4s19b8u"},{"name":"Spring框架","_id":"cl2j6t6vz004b4f61h5vghdwc"},{"name":"Spring Cloud","_id":"cl2j6t6w0004l4f61hhad202e"},{"name":"分布式","_id":"cl2j6t6w5005b4f61ekhv8zst"},{"name":"CSS3","_id":"cl2j6t6w5005h4f610unqdvu3"},{"name":"HTML","_id":"cl2j6t6w7005t4f615bhx49qx"}]}}