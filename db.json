{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"source/img/humphrey.jpg","path":"img/humphrey.jpg","modified":1,"renderable":0},{"_id":"source/img/lengtu.jpeg","path":"img/lengtu.jpeg","modified":1,"renderable":0},{"_id":"source/img/rabbit.gif","path":"img/rabbit.gif","modified":1,"renderable":0},{"_id":"source/img/my-little-pony.jpeg","path":"img/my-little-pony.jpeg","modified":1,"renderable":0},{"_id":"source/img/sheep.jpg","path":"img/sheep.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1644993977235},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1644809129879},{"_id":"source/img/humphrey.jpg","hash":"3500d8fbd318b9a70479a55f82c1a47c77d98ba4","modified":1644854157583},{"_id":"source/about/index.md","hash":"c3f95f5feccf86bda8ec2aef56e2e99ae444ea76","modified":1644855596886},{"_id":"source/_posts/java-core/ch01.md","hash":"6938f113630b5eb3761b5aeb5c1b961f82abf119","modified":1645011779647},{"_id":"source/_posts/java-core/ch02.md","hash":"a3efe991d79d8a09dc0d0aecee90acbcacf46963","modified":1645021087593},{"_id":"source/_posts/java-core/ch04.md","hash":"f110a1f19ccf8da151458a1ef394347309221abe","modified":1645012527938},{"_id":"source/_posts/java-core/ch03.md","hash":"4ef0081656089829a5921448dcd3cfa5eb7f5f78","modified":1645011813264},{"_id":"source/img/my-little-pony.jpeg","hash":"92aefc0ccd6d69e72ed9abadfbf333ebb239390b","modified":1644765379872},{"_id":"source/img/lengtu.jpeg","hash":"a181605cf087e48b00cf633aca0d6eb3cde66ced","modified":1644766297059},{"_id":"source/img/sheep.jpg","hash":"2f10e5756bee0bdc1f3de82c4b7a98adf42a2203","modified":1644765816950},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644732960745},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1644732960713},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1644732960714},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":1644732960715},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1644732960714},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8a7f1534c228538e2ab56249d5a65829650170ed","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"4e3992cacd64c6888218b0346283258e8f82a27d","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1644732960716},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":1644732960716},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"f3ae4395e751c4a02d5895e07856b1e8edfdda08","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1644732960746},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"f7f3494ed001e8cdcdc3e8a1d2cd1195cff2ded5","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1644732960746},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1644732960725},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1644732960715},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1644732960725},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"e8e01c5db46b383748855452aecd70fcda99f598","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"df6941bd3b860180d01fd39ee859ed2d42f4d1f0","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1644732960737},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1644732960738},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1644732960743},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"08b455b848b21d57e0563b87071c4bae2b63bafe","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"fd5fcb6a61ad865197a778eeae889b80484227dd","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1644732960736},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"c2d8bfd04bf0734b387c049402b46a06a05fc582","modified":1644732960738},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"80098e8354069631bde8edcd1181a53091a92949","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"a2993f23701de9a83e3f428300e62c5c52b4ff4b","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":1644732960741},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"5e86487de0f16c30ca3e16460ab94b57620e31c5","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":1644732960745},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1644732960745},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":1644732960737},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":1644732960741},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1644732960745},{"_id":"source/img/rabbit.gif","hash":"5a605d911a2a266fa3040c6205b372515db64e3d","modified":1644766159511}],"Category":[{"name":"Java","_id":"ckzpn37ii00043h618uxm82do"}],"Data":[],"Page":[{"title":"about","date":"2022-02-13T06:22:43.000Z","layout":"about","_content":"> 一句话总结：最不像程序员的程序员。\n\n一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。\n\n平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-02-13 14:22:43\nlayout: about\n---\n> 一句话总结：最不像程序员的程序员。\n\n一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。\n\n平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。\n","updated":"2022-02-14T16:19:56.886Z","path":"about/index.html","comments":1,"_id":"ckzpn37ib00003h61bzs272w7","content":"<blockquote>\n<p>一句话总结：最不像程序员的程序员。</p>\n</blockquote>\n<p>一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。</p>\n<p>平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。</p>\n","site":{"data":{}},"wordcount":165,"excerpt":"","more":"<blockquote>\n<p>一句话总结：最不像程序员的程序员。</p>\n</blockquote>\n<p>一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。</p>\n<p>平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。</p>\n"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-02-16T06:46:17.234Z","updated":"2022-02-16T06:46:17.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzpn37id00013h61epedcwhu","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"wordcount":367,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Java编程原理——编程基础","date":"2022-02-13T05:58:16.000Z","_content":"\n# 1. Java基本数据类型\n##### 1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\n\n类型名 | 取值范围\n---|---\nbyte | -2^7 ~ 2^(7-1)\nshort | -2^15 ~ 2^(15-1)\nint | -2^31 ~ 2^(31-1)\nlong | -2^63 ~ 2^(63-1)\n\n##### 1.2 小数类型：有float和double，分别占用4和8个字节\n\n类型名 | 取值范围\n---|---\nfloat | 1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45\ndouble | 4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324\n\n# 2. Java特殊数据类型\n##### 2.1 数组类型\n数组类型在内存中有两块：一块是用于**存储数组本身**，另一块是用于**存储数组内容的位置。** 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。\n\n# 3. Java运算符\n##### 3.1 \"+\", \"-\", \"*\", \"/\", \"%\"\n运算符的使用需要注意：\n1. 整数相除不是四舍五入，而是直接舍去小数位；\n2. a++表示先使用原值a后再进行自增；a--同理；\n3. ++a表示先对原始值a进行自增再进行使用；--a同理；\n4. a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；\n\n# 4. Java逻辑运算\n1. 与运算符(&)：两个都为true才是true，有一个为false就是false;\n2. 或运算符(|)：只要有一个为true就是true，只有都为false才是false;\n3. 非运算符(!)：true的非运算就是false，反之同理;\n4. 异或运算符(^)：相同为false，不相同就是true;\n5. 短路与(&&)：作用跟&类似，boolean flag = a || b++ > 0, 当a为true忽略后面的运算；\n6. 短路或(||)：作用于|类似，boolean flag = a && b++ > 0，当a为true时，忽略后面的运算；\n\n# 5. Java条件语法\n- 选择结构：if/else相当于三元运算符--> operator ? a : b;\n- 多重if/else if/else if/else相当于switch--> switch-case语法：\n```\nif (cond1) {\n    // op1\n} else if (cond2) {\n    // op2\n} else if (cond3) {\n    // op3\n} else {\n    // op4\n}\n\nswitch(cond) {\n    case cond1:\n        // op1\n        break;\n    case cond2:\n        // op2\n        break;\n    case cond3:\n        // op3\n        break;\n}\n```\n\n系统层面下：if/eise使用的操作系统中的**跳转指令**实现的，而switch使用的是**跳转表（跳转表使用二分查找实现，效率较高）** 实现的。在switch分支少的情况下会使用跳转指令实现。\n\n# 6. Java循环语法\n##### 1. while循环\n\n```\nwhile (cond) {\n    loop body\n}\n```\n只要循环条件为true，就一直执行循环体内，否则就中止执行；\n##### 2. do-while循环\n\n```\ndo {\n    loop body\n} while (cond)\n```\n不管循环条件是什么，循环体至少会执行一次；\n##### 3. for循环\n\n```\nfor (init; cond; step) {\n    loop body\n}\n```\n- 1.执行初始化命令；\n- 2.检查循环条件是否为true，如果为false执行步骤6\n- 3.循环条件为true，执行循环体；\n- 4.执行步进操作；\n- 5.步进操作执行结束后，跳转至步骤2\n- 6.for循环后续的语句；\n\n##### 4. foreach语法\n\n```\nfor (DataType element : DataTypeArr) {\n    loop body\n}\n```\n每次迭代循环element时，指针会自动更新；\n\n##### 5. 循环控制\n- break：提前结束循环，不再执行循环体内的剩余代码；\n- continue:跳过循环体内剩余的代码，然后执行步进操作；\n\n# 7. Java函数\n函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。\n1. 函数参数支持可变长度参数，语法为在数据类型的后面加上(...)，在函数内可变长度参数可以看做是数组。**可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数**。\n2. return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。\n3. 返回值可以是数组或者是对象，根据具体需求来选择；\n4. 函数重名但是参数列表不同的现象称之为函数的重载；\n5. 函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；\n6. 函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。\n7. 函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。\n8. 总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。\n\n","source":"_posts/java-core/ch01.md","raw":"---\ntitle: Java编程原理——编程基础\ndate: 2022-02-13 13:58:16\ntags: Java基础\ncategories: Java\n---\n\n# 1. Java基本数据类型\n##### 1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\n\n类型名 | 取值范围\n---|---\nbyte | -2^7 ~ 2^(7-1)\nshort | -2^15 ~ 2^(15-1)\nint | -2^31 ~ 2^(31-1)\nlong | -2^63 ~ 2^(63-1)\n\n##### 1.2 小数类型：有float和double，分别占用4和8个字节\n\n类型名 | 取值范围\n---|---\nfloat | 1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45\ndouble | 4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324\n\n# 2. Java特殊数据类型\n##### 2.1 数组类型\n数组类型在内存中有两块：一块是用于**存储数组本身**，另一块是用于**存储数组内容的位置。** 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。\n\n# 3. Java运算符\n##### 3.1 \"+\", \"-\", \"*\", \"/\", \"%\"\n运算符的使用需要注意：\n1. 整数相除不是四舍五入，而是直接舍去小数位；\n2. a++表示先使用原值a后再进行自增；a--同理；\n3. ++a表示先对原始值a进行自增再进行使用；--a同理；\n4. a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；\n\n# 4. Java逻辑运算\n1. 与运算符(&)：两个都为true才是true，有一个为false就是false;\n2. 或运算符(|)：只要有一个为true就是true，只有都为false才是false;\n3. 非运算符(!)：true的非运算就是false，反之同理;\n4. 异或运算符(^)：相同为false，不相同就是true;\n5. 短路与(&&)：作用跟&类似，boolean flag = a || b++ > 0, 当a为true忽略后面的运算；\n6. 短路或(||)：作用于|类似，boolean flag = a && b++ > 0，当a为true时，忽略后面的运算；\n\n# 5. Java条件语法\n- 选择结构：if/else相当于三元运算符--> operator ? a : b;\n- 多重if/else if/else if/else相当于switch--> switch-case语法：\n```\nif (cond1) {\n    // op1\n} else if (cond2) {\n    // op2\n} else if (cond3) {\n    // op3\n} else {\n    // op4\n}\n\nswitch(cond) {\n    case cond1:\n        // op1\n        break;\n    case cond2:\n        // op2\n        break;\n    case cond3:\n        // op3\n        break;\n}\n```\n\n系统层面下：if/eise使用的操作系统中的**跳转指令**实现的，而switch使用的是**跳转表（跳转表使用二分查找实现，效率较高）** 实现的。在switch分支少的情况下会使用跳转指令实现。\n\n# 6. Java循环语法\n##### 1. while循环\n\n```\nwhile (cond) {\n    loop body\n}\n```\n只要循环条件为true，就一直执行循环体内，否则就中止执行；\n##### 2. do-while循环\n\n```\ndo {\n    loop body\n} while (cond)\n```\n不管循环条件是什么，循环体至少会执行一次；\n##### 3. for循环\n\n```\nfor (init; cond; step) {\n    loop body\n}\n```\n- 1.执行初始化命令；\n- 2.检查循环条件是否为true，如果为false执行步骤6\n- 3.循环条件为true，执行循环体；\n- 4.执行步进操作；\n- 5.步进操作执行结束后，跳转至步骤2\n- 6.for循环后续的语句；\n\n##### 4. foreach语法\n\n```\nfor (DataType element : DataTypeArr) {\n    loop body\n}\n```\n每次迭代循环element时，指针会自动更新；\n\n##### 5. 循环控制\n- break：提前结束循环，不再执行循环体内的剩余代码；\n- continue:跳过循环体内剩余的代码，然后执行步进操作；\n\n# 7. Java函数\n函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。\n1. 函数参数支持可变长度参数，语法为在数据类型的后面加上(...)，在函数内可变长度参数可以看做是数组。**可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数**。\n2. return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。\n3. 返回值可以是数组或者是对象，根据具体需求来选择；\n4. 函数重名但是参数列表不同的现象称之为函数的重载；\n5. 函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；\n6. 函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。\n7. 函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。\n8. 总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。\n\n","slug":"java-core/ch01","published":1,"updated":"2022-02-16T11:42:59.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzpn37if00023h613titdzlm","content":"<h1 id=\"1-Java基本数据类型\"><a href=\"#1-Java基本数据类型\" class=\"headerlink\" title=\"1. Java基本数据类型\"></a>1. Java基本数据类型</h1><h5 id=\"1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\"><a href=\"#1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\" class=\"headerlink\" title=\"1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\"></a>1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>-2^7 ~ 2^(7-1)</td>\n</tr>\n<tr>\n<td>short</td>\n<td>-2^15 ~ 2^(15-1)</td>\n</tr>\n<tr>\n<td>int</td>\n<td>-2^31 ~ 2^(31-1)</td>\n</tr>\n<tr>\n<td>long</td>\n<td>-2^63 ~ 2^(63-1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-2-小数类型：有float和double，分别占用4和8个字节\"><a href=\"#1-2-小数类型：有float和double，分别占用4和8个字节\" class=\"headerlink\" title=\"1.2 小数类型：有float和double，分别占用4和8个字节\"></a>1.2 小数类型：有float和double，分别占用4和8个字节</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45</td>\n</tr>\n<tr>\n<td>double</td>\n<td>4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"2-Java特殊数据类型\"><a href=\"#2-Java特殊数据类型\" class=\"headerlink\" title=\"2. Java特殊数据类型\"></a>2. Java特殊数据类型</h1><h5 id=\"2-1-数组类型\"><a href=\"#2-1-数组类型\" class=\"headerlink\" title=\"2.1 数组类型\"></a>2.1 数组类型</h5><p>数组类型在内存中有两块：一块是用于<strong>存储数组本身</strong>，另一块是用于<strong>存储数组内容的位置。</strong> 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。</p>\n<h1 id=\"3-Java运算符\"><a href=\"#3-Java运算符\" class=\"headerlink\" title=\"3. Java运算符\"></a>3. Java运算符</h1><h5 id=\"3-1-“-”-“-“-“-”-“-“-“-”\"><a href=\"#3-1-“-”-“-“-“-”-“-“-“-”\" class=\"headerlink\" title=\"3.1 “+”, “-“, “*”, “/“, “%”\"></a>3.1 “+”, “-“, “*”, “/“, “%”</h5><p>运算符的使用需要注意：</p>\n<ol>\n<li>整数相除不是四舍五入，而是直接舍去小数位；</li>\n<li>a++表示先使用原值a后再进行自增；a—同理；</li>\n<li>++a表示先对原始值a进行自增再进行使用；—a同理；</li>\n<li>a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；</li>\n</ol>\n<h1 id=\"4-Java逻辑运算\"><a href=\"#4-Java逻辑运算\" class=\"headerlink\" title=\"4. Java逻辑运算\"></a>4. Java逻辑运算</h1><ol>\n<li>与运算符(&amp;)：两个都为true才是true，有一个为false就是false;</li>\n<li>或运算符(|)：只要有一个为true就是true，只有都为false才是false;</li>\n<li>非运算符(!)：true的非运算就是false，反之同理;</li>\n<li>异或运算符(^)：相同为false，不相同就是true;</li>\n<li>短路与(&amp;&amp;)：作用跟&amp;类似，boolean flag = a || b++ &gt; 0, 当a为true忽略后面的运算；</li>\n<li>短路或(||)：作用于|类似，boolean flag = a &amp;&amp; b++ &gt; 0，当a为true时，忽略后面的运算；</li>\n</ol>\n<h1 id=\"5-Java条件语法\"><a href=\"#5-Java条件语法\" class=\"headerlink\" title=\"5. Java条件语法\"></a>5. Java条件语法</h1><ul>\n<li>选择结构：if/else相当于三元运算符—&gt; operator ? a : b;</li>\n<li>多重if/else if/else if/else相当于switch—&gt; switch-case语法：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-keyword\">if</span> (cond1) &#123;<br>    <span class=\"hljs-regexp\">//</span> op1<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond2) &#123;<br>    <span class=\"hljs-regexp\">//</span> op2<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond3) &#123;<br>    <span class=\"hljs-regexp\">//</span> op3<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-regexp\">//</span> op4<br>&#125;<br><br>switch(cond) &#123;<br>    case cond1:<br>        <span class=\"hljs-regexp\">//</span> op1<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond2:<br>        <span class=\"hljs-regexp\">//</span> op2<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond3:<br>        <span class=\"hljs-regexp\">//</span> op3<br>        <span class=\"hljs-keyword\">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>系统层面下：if/eise使用的操作系统中的<strong>跳转指令</strong>实现的，而switch使用的是<strong>跳转表（跳转表使用二分查找实现，效率较高）</strong> 实现的。在switch分支少的情况下会使用跳转指令实现。</p>\n<h1 id=\"6-Java循环语法\"><a href=\"#6-Java循环语法\" class=\"headerlink\" title=\"6. Java循环语法\"></a>6. Java循环语法</h1><h5 id=\"1-while循环\"><a href=\"#1-while循环\" class=\"headerlink\" title=\"1. while循环\"></a>1. while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">while</span> (cond) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>只要循环条件为true，就一直执行循环体内，否则就中止执行；</p>\n<h5 id=\"2-do-while循环\"><a href=\"#2-do-while循环\" class=\"headerlink\" title=\"2. do-while循环\"></a>2. do-while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125; <span class=\"hljs-keyword\">while</span> (cond)<br></code></pre></td></tr></table></figure>\n<p>不管循环条件是什么，循环体至少会执行一次；</p>\n<h5 id=\"3-for循环\"><a href=\"#3-for循环\" class=\"headerlink\" title=\"3. for循环\"></a>3. for循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (init; cond; step) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>1.执行初始化命令；</li>\n<li>2.检查循环条件是否为true，如果为false执行步骤6</li>\n<li>3.循环条件为true，执行循环体；</li>\n<li>4.执行步进操作；</li>\n<li>5.步进操作执行结束后，跳转至步骤2</li>\n<li>6.for循环后续的语句；</li>\n</ul>\n<h5 id=\"4-foreach语法\"><a href=\"#4-foreach语法\" class=\"headerlink\" title=\"4. foreach语法\"></a>4. foreach语法</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (DataType element : <span class=\"hljs-type\">DataTypeArr</span>) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每次迭代循环element时，指针会自动更新；</p>\n<h5 id=\"5-循环控制\"><a href=\"#5-循环控制\" class=\"headerlink\" title=\"5. 循环控制\"></a>5. 循环控制</h5><ul>\n<li>break：提前结束循环，不再执行循环体内的剩余代码；</li>\n<li>continue:跳过循环体内剩余的代码，然后执行步进操作；</li>\n</ul>\n<h1 id=\"7-Java函数\"><a href=\"#7-Java函数\" class=\"headerlink\" title=\"7. Java函数\"></a>7. Java函数</h1><p>函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。</p>\n<ol>\n<li>函数参数支持可变长度参数，语法为在数据类型的后面加上(…)，在函数内可变长度参数可以看做是数组。<strong>可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数</strong>。</li>\n<li>return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。</li>\n<li>返回值可以是数组或者是对象，根据具体需求来选择；</li>\n<li>函数重名但是参数列表不同的现象称之为函数的重载；</li>\n<li>函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；</li>\n<li>函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。</li>\n<li>函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。</li>\n<li>总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。</li>\n</ol>\n","site":{"data":{}},"wordcount":2120,"excerpt":"","more":"<h1 id=\"1-Java基本数据类型\"><a href=\"#1-Java基本数据类型\" class=\"headerlink\" title=\"1. Java基本数据类型\"></a>1. Java基本数据类型</h1><h5 id=\"1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\"><a href=\"#1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\" class=\"headerlink\" title=\"1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\"></a>1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>-2^7 ~ 2^(7-1)</td>\n</tr>\n<tr>\n<td>short</td>\n<td>-2^15 ~ 2^(15-1)</td>\n</tr>\n<tr>\n<td>int</td>\n<td>-2^31 ~ 2^(31-1)</td>\n</tr>\n<tr>\n<td>long</td>\n<td>-2^63 ~ 2^(63-1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-2-小数类型：有float和double，分别占用4和8个字节\"><a href=\"#1-2-小数类型：有float和double，分别占用4和8个字节\" class=\"headerlink\" title=\"1.2 小数类型：有float和double，分别占用4和8个字节\"></a>1.2 小数类型：有float和double，分别占用4和8个字节</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45</td>\n</tr>\n<tr>\n<td>double</td>\n<td>4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"2-Java特殊数据类型\"><a href=\"#2-Java特殊数据类型\" class=\"headerlink\" title=\"2. Java特殊数据类型\"></a>2. Java特殊数据类型</h1><h5 id=\"2-1-数组类型\"><a href=\"#2-1-数组类型\" class=\"headerlink\" title=\"2.1 数组类型\"></a>2.1 数组类型</h5><p>数组类型在内存中有两块：一块是用于<strong>存储数组本身</strong>，另一块是用于<strong>存储数组内容的位置。</strong> 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。</p>\n<h1 id=\"3-Java运算符\"><a href=\"#3-Java运算符\" class=\"headerlink\" title=\"3. Java运算符\"></a>3. Java运算符</h1><h5 id=\"3-1-“-”-“-“-“-”-“-“-“-”\"><a href=\"#3-1-“-”-“-“-“-”-“-“-“-”\" class=\"headerlink\" title=\"3.1 “+”, “-“, “*”, “/“, “%”\"></a>3.1 “+”, “-“, “*”, “/“, “%”</h5><p>运算符的使用需要注意：</p>\n<ol>\n<li>整数相除不是四舍五入，而是直接舍去小数位；</li>\n<li>a++表示先使用原值a后再进行自增；a—同理；</li>\n<li>++a表示先对原始值a进行自增再进行使用；—a同理；</li>\n<li>a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；</li>\n</ol>\n<h1 id=\"4-Java逻辑运算\"><a href=\"#4-Java逻辑运算\" class=\"headerlink\" title=\"4. Java逻辑运算\"></a>4. Java逻辑运算</h1><ol>\n<li>与运算符(&amp;)：两个都为true才是true，有一个为false就是false;</li>\n<li>或运算符(|)：只要有一个为true就是true，只有都为false才是false;</li>\n<li>非运算符(!)：true的非运算就是false，反之同理;</li>\n<li>异或运算符(^)：相同为false，不相同就是true;</li>\n<li>短路与(&amp;&amp;)：作用跟&amp;类似，boolean flag = a || b++ &gt; 0, 当a为true忽略后面的运算；</li>\n<li>短路或(||)：作用于|类似，boolean flag = a &amp;&amp; b++ &gt; 0，当a为true时，忽略后面的运算；</li>\n</ol>\n<h1 id=\"5-Java条件语法\"><a href=\"#5-Java条件语法\" class=\"headerlink\" title=\"5. Java条件语法\"></a>5. Java条件语法</h1><ul>\n<li>选择结构：if/else相当于三元运算符—&gt; operator ? a : b;</li>\n<li>多重if/else if/else if/else相当于switch—&gt; switch-case语法：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-keyword\">if</span> (cond1) &#123;<br>    <span class=\"hljs-regexp\">//</span> op1<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond2) &#123;<br>    <span class=\"hljs-regexp\">//</span> op2<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond3) &#123;<br>    <span class=\"hljs-regexp\">//</span> op3<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-regexp\">//</span> op4<br>&#125;<br><br>switch(cond) &#123;<br>    case cond1:<br>        <span class=\"hljs-regexp\">//</span> op1<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond2:<br>        <span class=\"hljs-regexp\">//</span> op2<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond3:<br>        <span class=\"hljs-regexp\">//</span> op3<br>        <span class=\"hljs-keyword\">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>系统层面下：if/eise使用的操作系统中的<strong>跳转指令</strong>实现的，而switch使用的是<strong>跳转表（跳转表使用二分查找实现，效率较高）</strong> 实现的。在switch分支少的情况下会使用跳转指令实现。</p>\n<h1 id=\"6-Java循环语法\"><a href=\"#6-Java循环语法\" class=\"headerlink\" title=\"6. Java循环语法\"></a>6. Java循环语法</h1><h5 id=\"1-while循环\"><a href=\"#1-while循环\" class=\"headerlink\" title=\"1. while循环\"></a>1. while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">while</span> (cond) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>只要循环条件为true，就一直执行循环体内，否则就中止执行；</p>\n<h5 id=\"2-do-while循环\"><a href=\"#2-do-while循环\" class=\"headerlink\" title=\"2. do-while循环\"></a>2. do-while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125; <span class=\"hljs-keyword\">while</span> (cond)<br></code></pre></td></tr></table></figure>\n<p>不管循环条件是什么，循环体至少会执行一次；</p>\n<h5 id=\"3-for循环\"><a href=\"#3-for循环\" class=\"headerlink\" title=\"3. for循环\"></a>3. for循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (init; cond; step) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>1.执行初始化命令；</li>\n<li>2.检查循环条件是否为true，如果为false执行步骤6</li>\n<li>3.循环条件为true，执行循环体；</li>\n<li>4.执行步进操作；</li>\n<li>5.步进操作执行结束后，跳转至步骤2</li>\n<li>6.for循环后续的语句；</li>\n</ul>\n<h5 id=\"4-foreach语法\"><a href=\"#4-foreach语法\" class=\"headerlink\" title=\"4. foreach语法\"></a>4. foreach语法</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (DataType element : <span class=\"hljs-type\">DataTypeArr</span>) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每次迭代循环element时，指针会自动更新；</p>\n<h5 id=\"5-循环控制\"><a href=\"#5-循环控制\" class=\"headerlink\" title=\"5. 循环控制\"></a>5. 循环控制</h5><ul>\n<li>break：提前结束循环，不再执行循环体内的剩余代码；</li>\n<li>continue:跳过循环体内剩余的代码，然后执行步进操作；</li>\n</ul>\n<h1 id=\"7-Java函数\"><a href=\"#7-Java函数\" class=\"headerlink\" title=\"7. Java函数\"></a>7. Java函数</h1><p>函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。</p>\n<ol>\n<li>函数参数支持可变长度参数，语法为在数据类型的后面加上(…)，在函数内可变长度参数可以看做是数组。<strong>可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数</strong>。</li>\n<li>return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。</li>\n<li>返回值可以是数组或者是对象，根据具体需求来选择；</li>\n<li>函数重名但是参数列表不同的现象称之为函数的重载；</li>\n<li>函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；</li>\n<li>函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。</li>\n<li>函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。</li>\n<li>总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。</li>\n</ol>\n"},{"title":"Java编程原理——计算机执行的二进制逻辑","date":"2022-02-16T06:51:30.000Z","updated":"2022-02-16T06:51:30.000Z","math":true,"mermaid":true,"_content":"# 1. 二进制--计算机表示数据的方式\n### 1.1 十进制表示数的方式\n1. 以123来说，使用十进制表示可以写为:<br/>\n\n$$\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0\n$$\n\n2. 按照类比规则推算，N进制数字abc有如下表示，其中k为位权：\n\n$$\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...\n$$\n\n### 1.2 二进制的数字表示\n二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:\n\n$$\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}\n$$\n十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：\n1. -1的8位二进制按概念应是10000001，实际上为11111111\n2. -127的8位二进制按概念应是11111111，实际上为10000001<br/>\n因此我们需要注意下列计算机表示二进制的机器码。\n- 原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;\n- 反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;\n- 补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;\n\n使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。\n\n### 1.3 十六进制--二进制的简化\n由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])\n\n二进制 | 十进制 | 十六进制 | 二进制 | 十进制 | 十六进制\n:---:|:---:|:---:|:---:|:---:|:---:\n1010 | 10 | A | 1011 | 11 | B\n1100 | 12 | C| 1101 | 13 | D\n1110 | 14 | E | 1111 | 15 | F\n\n##### 1.4 位运算\n1. 左移(<<)：左移一位表示乘以2（高位舍去，右侧补0）；\n2. 右移(>>)：右移一位表示除以2（低位舍去，高位按原先补充）；\n\n##### 1.5 查看浮点数的具体二进制形式\n\n```java\nInteger.toBinaryString(Float.floatToIntBits(value));\nLong.toBinaryString(Double.doubleToLongBits(value));\n```\n# 2. 字符集与编码\n##### 2.1 非Unicode编码\n1. **ASCII：**覆盖键盘上的绝大多数的字符，对美国等英语国家够用；\n2. **ISO 8859-1：** 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；\n3. **Windows-1252：**在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；\n4. **GB2312：**简体中文编码规范，使用两个字节表示汉字；\n5. **GBK：**GB2312的扩充，支持更多的汉字编码；\n6. **GB18030：**在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；\n7. **Big5：**针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；\n\n##### 2.2 Unicode编码\n为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：\n1. UTF-32：字符编号的整数二进制形式，4字节\n2. UTF-16：变长字节表示，编号在U+0000\\~U+FFFF使用两字节；编号在U+10000\\~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；\n3. UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；\n\n##### 2.3 编码转换\n1. 假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。\n```mermaid\ngraph LR;\n\t字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B\n```\n\n编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。\n\n2. 乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。\n3. 乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。\n4. 使用Java恢复乱码：\n\n```java\nString str = \"value to encdoe\";\nString newStr = new String(str.getBytes(\"Windows-1252\"), \"GB18030\");\nSystem.out.println(newStr);\n```","source":"_posts/java-core/ch02.md","raw":"---\ntitle: Java编程原理——计算机执行的二进制逻辑\ndate: 2022-02-16 14:51:30\nupdated: 2022-02-16 14:51:30\ntags: Java基础\ncategories: Java\nmath: true\nmermaid: true\n---\n# 1. 二进制--计算机表示数据的方式\n### 1.1 十进制表示数的方式\n1. 以123来说，使用十进制表示可以写为:<br/>\n\n$$\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0\n$$\n\n2. 按照类比规则推算，N进制数字abc有如下表示，其中k为位权：\n\n$$\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...\n$$\n\n### 1.2 二进制的数字表示\n二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:\n\n$$\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}\n$$\n十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：\n1. -1的8位二进制按概念应是10000001，实际上为11111111\n2. -127的8位二进制按概念应是11111111，实际上为10000001<br/>\n因此我们需要注意下列计算机表示二进制的机器码。\n- 原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;\n- 反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;\n- 补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;\n\n使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。\n\n### 1.3 十六进制--二进制的简化\n由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])\n\n二进制 | 十进制 | 十六进制 | 二进制 | 十进制 | 十六进制\n:---:|:---:|:---:|:---:|:---:|:---:\n1010 | 10 | A | 1011 | 11 | B\n1100 | 12 | C| 1101 | 13 | D\n1110 | 14 | E | 1111 | 15 | F\n\n##### 1.4 位运算\n1. 左移(<<)：左移一位表示乘以2（高位舍去，右侧补0）；\n2. 右移(>>)：右移一位表示除以2（低位舍去，高位按原先补充）；\n\n##### 1.5 查看浮点数的具体二进制形式\n\n```java\nInteger.toBinaryString(Float.floatToIntBits(value));\nLong.toBinaryString(Double.doubleToLongBits(value));\n```\n# 2. 字符集与编码\n##### 2.1 非Unicode编码\n1. **ASCII：**覆盖键盘上的绝大多数的字符，对美国等英语国家够用；\n2. **ISO 8859-1：** 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；\n3. **Windows-1252：**在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；\n4. **GB2312：**简体中文编码规范，使用两个字节表示汉字；\n5. **GBK：**GB2312的扩充，支持更多的汉字编码；\n6. **GB18030：**在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；\n7. **Big5：**针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；\n\n##### 2.2 Unicode编码\n为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：\n1. UTF-32：字符编号的整数二进制形式，4字节\n2. UTF-16：变长字节表示，编号在U+0000\\~U+FFFF使用两字节；编号在U+10000\\~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；\n3. UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；\n\n##### 2.3 编码转换\n1. 假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。\n```mermaid\ngraph LR;\n\t字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B\n```\n\n编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。\n\n2. 乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。\n3. 乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。\n4. 使用Java恢复乱码：\n\n```java\nString str = \"value to encdoe\";\nString newStr = new String(str.getBytes(\"Windows-1252\"), \"GB18030\");\nSystem.out.println(newStr);\n```","slug":"java-core/ch02","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckzpn37ih00033h61g3vl4u8s","content":"<h1 id=\"1-二进制—计算机表示数据的方式\"><a href=\"#1-二进制—计算机表示数据的方式\" class=\"headerlink\" title=\"1. 二进制—计算机表示数据的方式\"></a>1. 二进制—计算机表示数据的方式</h1><h3 id=\"1-1-十进制表示数的方式\"><a href=\"#1-1-十进制表示数的方式\" class=\"headerlink\" title=\"1.1 十进制表示数的方式\"></a>1.1 十进制表示数的方式</h3><ol>\n<li>以123来说，使用十进制表示可以写为:<br/></li>\n</ol>\n<script type=\"math/tex; mode=display\">\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0</script><ol>\n<li>按照类比规则推算，N进制数字abc有如下表示，其中k为位权：</li>\n</ol>\n<script type=\"math/tex; mode=display\">\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...</script><h3 id=\"1-2-二进制的数字表示\"><a href=\"#1-2-二进制的数字表示\" class=\"headerlink\" title=\"1.2 二进制的数字表示\"></a>1.2 二进制的数字表示</h3><p>二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:</p>\n<script type=\"math/tex; mode=display\">\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}</script><p>十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：</p>\n<ol>\n<li>-1的8位二进制按概念应是10000001，实际上为11111111</li>\n<li>-127的8位二进制按概念应是11111111，实际上为10000001<br/><br>因此我们需要注意下列计算机表示二进制的机器码。</li>\n</ol>\n<ul>\n<li>原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;</li>\n<li>反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;</li>\n<li>补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;</li>\n</ul>\n<p>使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。</p>\n<h3 id=\"1-3-十六进制—二进制的简化\"><a href=\"#1-3-十六进制—二进制的简化\" class=\"headerlink\" title=\"1.3 十六进制—二进制的简化\"></a>1.3 十六进制—二进制的简化</h3><p>由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1010</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">1011</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">B</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1100</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1101</td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1110</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">1111</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">F</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-4-位运算\"><a href=\"#1-4-位运算\" class=\"headerlink\" title=\"1.4 位运算\"></a>1.4 位运算</h5><ol>\n<li>左移(&lt;&lt;)：左移一位表示乘以2（高位舍去，右侧补0）；</li>\n<li>右移(&gt;&gt;)：右移一位表示除以2（低位舍去，高位按原先补充）；</li>\n</ol>\n<h5 id=\"1-5-查看浮点数的具体二进制形式\"><a href=\"#1-5-查看浮点数的具体二进制形式\" class=\"headerlink\" title=\"1.5 查看浮点数的具体二进制形式\"></a>1.5 查看浮点数的具体二进制形式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\">Integer.toBinaryString(Float.floatToIntBits(value));<br>Long.toBinaryString(Double.doubleToLongBits(value));<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-字符集与编码\"><a href=\"#2-字符集与编码\" class=\"headerlink\" title=\"2. 字符集与编码\"></a>2. 字符集与编码</h1><h5 id=\"2-1-非Unicode编码\"><a href=\"#2-1-非Unicode编码\" class=\"headerlink\" title=\"2.1 非Unicode编码\"></a>2.1 非Unicode编码</h5><ol>\n<li><strong>ASCII：</strong>覆盖键盘上的绝大多数的字符，对美国等英语国家够用；</li>\n<li><strong>ISO 8859-1：</strong> 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；</li>\n<li><strong>Windows-1252：</strong>在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；</li>\n<li><strong>GB2312：</strong>简体中文编码规范，使用两个字节表示汉字；</li>\n<li><strong>GBK：</strong>GB2312的扩充，支持更多的汉字编码；</li>\n<li><strong>GB18030：</strong>在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；</li>\n<li><strong>Big5：</strong>针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；</li>\n</ol>\n<h5 id=\"2-2-Unicode编码\"><a href=\"#2-2-Unicode编码\" class=\"headerlink\" title=\"2.2 Unicode编码\"></a>2.2 Unicode编码</h5><p>为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：</p>\n<ol>\n<li>UTF-32：字符编号的整数二进制形式，4字节</li>\n<li>UTF-16：变长字节表示，编号在U+0000~U+FFFF使用两字节；编号在U+10000~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；</li>\n<li>UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；</li>\n</ol>\n<h5 id=\"2-3-编码转换\"><a href=\"#2-3-编码转换\" class=\"headerlink\" title=\"2.3 编码转换\"></a>2.3 编码转换</h5><ol>\n<li>假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。<div class=\"code-wrapper\"><pre class=\"mermaid\">graph LR;\n 字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B</pre></div>\n\n</li>\n</ol>\n<p>编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。</p>\n<ol>\n<li>乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。</li>\n<li>乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。</li>\n<li>使用Java恢复乱码：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value to encdoe&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">newStr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(str.getBytes(<span class=\"hljs-string\">&quot;Windows-1252&quot;</span>), <span class=\"hljs-string\">&quot;GB18030&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":1956,"excerpt":"","more":"<h1 id=\"1-二进制—计算机表示数据的方式\"><a href=\"#1-二进制—计算机表示数据的方式\" class=\"headerlink\" title=\"1. 二进制—计算机表示数据的方式\"></a>1. 二进制—计算机表示数据的方式</h1><h3 id=\"1-1-十进制表示数的方式\"><a href=\"#1-1-十进制表示数的方式\" class=\"headerlink\" title=\"1.1 十进制表示数的方式\"></a>1.1 十进制表示数的方式</h3><ol>\n<li>以123来说，使用十进制表示可以写为:<br/></li>\n</ol>\n<script type=\"math/tex; mode=display\">\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0</script><ol>\n<li>按照类比规则推算，N进制数字abc有如下表示，其中k为位权：</li>\n</ol>\n<script type=\"math/tex; mode=display\">\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...</script><h3 id=\"1-2-二进制的数字表示\"><a href=\"#1-2-二进制的数字表示\" class=\"headerlink\" title=\"1.2 二进制的数字表示\"></a>1.2 二进制的数字表示</h3><p>二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:</p>\n<script type=\"math/tex; mode=display\">\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}</script><p>十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：</p>\n<ol>\n<li>-1的8位二进制按概念应是10000001，实际上为11111111</li>\n<li>-127的8位二进制按概念应是11111111，实际上为10000001<br/><br>因此我们需要注意下列计算机表示二进制的机器码。</li>\n</ol>\n<ul>\n<li>原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;</li>\n<li>反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;</li>\n<li>补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;</li>\n</ul>\n<p>使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。</p>\n<h3 id=\"1-3-十六进制—二进制的简化\"><a href=\"#1-3-十六进制—二进制的简化\" class=\"headerlink\" title=\"1.3 十六进制—二进制的简化\"></a>1.3 十六进制—二进制的简化</h3><p>由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1010</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">1011</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">B</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1100</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1101</td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1110</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">1111</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">F</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-4-位运算\"><a href=\"#1-4-位运算\" class=\"headerlink\" title=\"1.4 位运算\"></a>1.4 位运算</h5><ol>\n<li>左移(&lt;&lt;)：左移一位表示乘以2（高位舍去，右侧补0）；</li>\n<li>右移(&gt;&gt;)：右移一位表示除以2（低位舍去，高位按原先补充）；</li>\n</ol>\n<h5 id=\"1-5-查看浮点数的具体二进制形式\"><a href=\"#1-5-查看浮点数的具体二进制形式\" class=\"headerlink\" title=\"1.5 查看浮点数的具体二进制形式\"></a>1.5 查看浮点数的具体二进制形式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Integer.toBinaryString(Float.floatToIntBits(value));<br>Long.toBinaryString(Double.doubleToLongBits(value));<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-字符集与编码\"><a href=\"#2-字符集与编码\" class=\"headerlink\" title=\"2. 字符集与编码\"></a>2. 字符集与编码</h1><h5 id=\"2-1-非Unicode编码\"><a href=\"#2-1-非Unicode编码\" class=\"headerlink\" title=\"2.1 非Unicode编码\"></a>2.1 非Unicode编码</h5><ol>\n<li><strong>ASCII：</strong>覆盖键盘上的绝大多数的字符，对美国等英语国家够用；</li>\n<li><strong>ISO 8859-1：</strong> 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；</li>\n<li><strong>Windows-1252：</strong>在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；</li>\n<li><strong>GB2312：</strong>简体中文编码规范，使用两个字节表示汉字；</li>\n<li><strong>GBK：</strong>GB2312的扩充，支持更多的汉字编码；</li>\n<li><strong>GB18030：</strong>在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；</li>\n<li><strong>Big5：</strong>针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；</li>\n</ol>\n<h5 id=\"2-2-Unicode编码\"><a href=\"#2-2-Unicode编码\" class=\"headerlink\" title=\"2.2 Unicode编码\"></a>2.2 Unicode编码</h5><p>为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：</p>\n<ol>\n<li>UTF-32：字符编号的整数二进制形式，4字节</li>\n<li>UTF-16：变长字节表示，编号在U+0000~U+FFFF使用两字节；编号在U+10000~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；</li>\n<li>UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；</li>\n</ol>\n<h5 id=\"2-3-编码转换\"><a href=\"#2-3-编码转换\" class=\"headerlink\" title=\"2.3 编码转换\"></a>2.3 编码转换</h5><ol>\n<li>假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。<pre class=\"mermaid\">graph LR;\n 字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B</pre>\n\n</li>\n</ol>\n<p>编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。</p>\n<ol>\n<li>乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。</li>\n<li>乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。</li>\n<li>使用Java恢复乱码：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value to encdoe&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">newStr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(str.getBytes(<span class=\"hljs-string\">&quot;Windows-1252&quot;</span>), <span class=\"hljs-string\">&quot;GB18030&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure>"},{"title":"Java编程原理——泛型和容器","date":"2022-02-16T11:52:26.000Z","updated":"2022-02-16T11:52:26.000Z","_content":"\n# 1 泛型\n\n## 1.1 基本概念\n\n1. 泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；\n2. Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；\n3. 泛型可以指定上限为某个具体类，例如：\n\n```\npublic class NumberPair<U extends Number, V extends Number> extends Pair<U, V>{\n    public NumberPair(U first, V second) {\n        super(first, second);\n    }\n}\n```\n\n1. 除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；\n2. 总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。\n\n\n\n## 1.2 通配符解析\n\n1. 参数类型限定通配符写法。例如：public void addAll(DynamicArray<? extends E> c), **<? exntends E>也称为有限定通配符**；\n2. 与之相对应的就为无限定通配符，具体为：Dynamic<?>，更简洁的写法就为<T>\n3. 但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；\n4. 通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；\n5. 通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；\n6. 如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；\n7. 通配符形式和类型参数往往配合使用；\n\n\n\n## 1.3 超类型通配符\n\n1. 形式：<? super E>，用于表示E的某个父类类型；\n2. 使用场景：对于有限通配符形式<? extends E>在无法满足工作需要时，可以使用<? super E>代替；\n3. <? super E>用于灵活写入或比较，<?>或<? exntends E>用于灵活读取；\n\n\n\n## 1.4 局限性\n\n1. 基本类型不能用于实例化类型参数；\n2. 运行时类型信息不适用泛型；\n3. 类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；\n4. 不能通过类型参数创建对象；\n5. 泛型类类型参数不能用于创建静态变量和方法；\n6. 不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；\n7. 如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；\n8. 泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；\n\n\n\n# 2 列表和队列\n\n## 2.1 ArrayList\n\n1. ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；\n2. ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；\n3. 迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。\n\n```\n/* 错误写法 */\npublic void remove(ArrayList<Integer> list) {\n    for (Integer a : list) {\n        if (a < 100) {\n            list.remove(a); // 恐抛出ConcurrentModificationException\n        }\n    }\n}\n\n/* 正确写法 */\npublic void remove(ArrayList<Integer> list) {\n    Iterator<Integer> it = list.iterator();\n    while(it.hasNext()) {\n        if (it.next() < 100) {\n            it.remove();\n        }\n    }\n}\n```\n\n1. 使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。\n2. ArrayList的特点\n\n+ 随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；\n+ 除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；\n+ 添加数组元素的效率为O(N)；\n+ 插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；\n+ 需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；\n\n\n\n## 2.2 LinkedList\n\n1. LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；\n2. LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：\n\n```\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"a\");\nqueue.offer(\"b\");\nqueue.offer(\"c\");\nwhile(queue.peek() != null) {\n    System.out.println(queue.poll());\n}\n```\n\n1. LinkedList也可以当作栈使用，示例如下：\n\n```\nDeque<String> stack = new LinkedList<>();\nstack.push(\"a\");\nstack.push(\"b\");\nstack.push(\"c\");\nwhile(stack.peek() != null) {\n    System.out.println(stack.pop());\n}\n```\n\n1. LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；\n2. LinkedList的特点如下：\n\n+ 按需分配空间，不需要预先分配很多空间；\n+ 不可随机访问，按照索引位置访问效率较低；\n+ 无论列表是否有序，按内容查找都需要逐个查找；\n+ 在两端进行添加、删除操作效率很高；\n\n\n\n## 2.3 ArrayDeque\n\n1. ArrayDeque是基于数组实现的双端队列\n2. ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。\n3. 由于是双端队列因此具备下列特点：\n\n+ 在两端添加和删除的效率很高；\n+ 根据元素的内容查找和删除的效率很低；\n+ 与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。\n\n\n\n# 3 Map和Set\n\n## 3.1 HashMap\n\n1. 创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12\n2. 创建Map保存数据的几个步骤分别为：\n\n+ (1) 计算键的哈希值；\n+ (2) 根据哈希值得到保存位置（取模）；\n+ (3) 插到对应位置的链表表头或者更新已有值；\n+ (4) 根据扩展table大小，注意这里的table是Entry类型；\n\n1. 总结HashMap的实现原理\n\n+ HashMap内部有一个哈希表，每个元素指向一个单链表；\n+ 根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；\n+ 存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较\n+ HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；\n+ HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；\n\n\n\n## 3.2 HashSet\n\n1. Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；\n2. HashSet有下列应用场景\n\n+ 排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；\n+ 保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；\n+ 集合运算：方便进行数学中的交集以及并集的集合运算；\n\n1. HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；\n2. 总结HashSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效的添加、删除元素、判断元素是否存在；\n+ 没有顺序；\n\n\n\n## 3.3 TreeMap或TreeSet\n\n1. 与HashMap无序相对比，TreeMap是有序的。\n2. TreeMap内部使用的是[红黑树](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin)实现的；\n3. TreeMap的特点如下\n\n+ 按键有序：可以很方便地根据键的顺序进行查找\n+ 为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；\n+ 根据键值保存、查找、删除的效率比较高；\n\n1. 总结TreeSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效地添加、删除元素、判断元素是否存在；\n+ 有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；\n\n\n\n## 3.4 LinkedHashMap\n\n1. LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；\n2. LinkedHashMap是有序的，例子如下(插入顺序)：\n\n```\nMap<String, Integer> seqMap = new LinkedHashMap<>();\nseqMap.put(\"c\", 100);\nseqMap.put(\"d\", 200);\nseqMap.put(\"a\", 500);\nseqMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : seqMap.entrySet()) {\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is :\nc 100\nd 300\na 500\n*/\n```\n\n1. LinkedHashMap的访问顺序：\n\n```\nMap<String, Integer> accessMap = new LinkedHashMap<>(16, 0.75, true);\naccessMap.put(\"c\", 100);\naccessMap.put(\"d\", 200);\naccessMap.put(\"a\", 500);\naccessMap.get(\"c\");\naccessMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : accessMap.getEntrySet()){\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is : \na 500\nc 100\nd 300\n*/\n```\n\n1. LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：\n\n```\n// 实现代码\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private int maxEntries;\n    public LRUCache(int maxEntries) {\n        super(16, 0.75f, true);\n        this.maxEntries = maxEntries;\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Entry<K, V> eldest) {\n        return size() > maxEntries;\n    }\n}\n// 使用示例\nLRUCache<String, Object> cache = new LRUCache<>(3);\ncache.put(\"a\", \"abstract\");\ncache.put(\"b\", \"basic\");\ncache.put(\"c\", \"call\");\ncache.get(\"a\");\ncache.put(\"d\", \"call\");\nSystem.out.println(cache);\n\n// 输出结果\n{c=call, a=abstract, d=call}\n```\n\n\n\n## 3.5 EnumMap\n\n1. 键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；\n2. EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：\n\n```\npublic enum Size {\n    SMALL, MEDIUM, LARGE\n}\n\npublic class Clothes {\n    String id;\n    Size size;\n}\n\npublic static Map<Size, Integer> countBySize(List<Clothes> clothes) {\n    Map<Size, Integer> map = new EnumMap<>(Size.class);\n    for (Clothes c : clothes) {\n        Size size = c.getSize();\n        Integer count = map.get(size);\n        if (count != null) {\n            map.put(size, count + 1);\n        } else {\n            map.put(size, 1);\n        }\n    }\n    return map;\n}\n```\n\n1. EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。\n2. EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；\n3. 位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。\n4. 对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。\n\n\n\n# 4 堆与优先级队列\n\n## 4.1 完全二叉树\n\n1. 完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其**父节点**和**孩子节点**的编号。**例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 \\* i，右孩子节点编号为2 \\* i + 1;**\n2. 基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；\n\n\n\n## 4.2 PriorityQueue\n\n1. PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：\n\n```\nstatic class Task {\n    int priority; // 数值越大，优先级越高\n    String name; // 表示任务的名称\n    \n    private static Comparator<Task> taskComparator = new Comparator() {\n        @Override\n        public int compare(Task o1, Task o2) {\n            if (o1.getPriority() > o2.getPriority()) {\n                return -1;\n            } else if (o1.getPriority() < o2.getPriority()){\n                return 1;\n            }\n            return 0;\n        }\n    }\n}\n\nQueue<Task> tasks = new Priority<>(11, taskComparator);\ntasks.offer(new Task(20, \"写日记\"));\ntasks.offer(new Task(10, \"看电视\"));\ntasks.offer(new Task(100, \"写代码\"));\nTask task = tasks.poll();\nwhile (task != null) {\n    System.out.print(\"处理任务：\" + task.getName() + \", 优先级：\" + task.getPriority());\n    task = tasks.poll();\n}\n// 结果如下：\n处理任务：写代码，优先级：100\n处理任务：写日记，优先级：20\n处理任务：看电视，优先级：10\n```\n\n1. PriorityQueue有如下特点：\n\n+ 实现了优先级队列，最先出队的总是优先级最高的；\n+ 优先级相同时，内部元素不完全有序；\n+ 查询头部元素效率很高，入队、出队效率很高；\n+ 根据值查找和删除元素效率很低\n+ 具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；\n\n\n\n# 5 通用容器类\n\n1. Collections提供了很多针对容器接口的通用算法和功能；\n2. 容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；\n3. 容器类中运用了大量的适配器模式\n\n+ 空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）\n+ 单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）\n+ 其他适配方法，例如将Map转换为Set等。\n\n1. 基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；\n","source":"_posts/java-core/ch04.md","raw":"---\ntitle: Java编程原理——泛型和容器\ndate: 2022-02-16 19:52:26\nupdated: 2022-02-16 19:52:26\ntags: Java基础\ncategories: Java\n---\n\n# 1 泛型\n\n## 1.1 基本概念\n\n1. 泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；\n2. Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；\n3. 泛型可以指定上限为某个具体类，例如：\n\n```\npublic class NumberPair<U extends Number, V extends Number> extends Pair<U, V>{\n    public NumberPair(U first, V second) {\n        super(first, second);\n    }\n}\n```\n\n1. 除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；\n2. 总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。\n\n\n\n## 1.2 通配符解析\n\n1. 参数类型限定通配符写法。例如：public void addAll(DynamicArray<? extends E> c), **<? exntends E>也称为有限定通配符**；\n2. 与之相对应的就为无限定通配符，具体为：Dynamic<?>，更简洁的写法就为<T>\n3. 但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；\n4. 通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；\n5. 通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；\n6. 如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；\n7. 通配符形式和类型参数往往配合使用；\n\n\n\n## 1.3 超类型通配符\n\n1. 形式：<? super E>，用于表示E的某个父类类型；\n2. 使用场景：对于有限通配符形式<? extends E>在无法满足工作需要时，可以使用<? super E>代替；\n3. <? super E>用于灵活写入或比较，<?>或<? exntends E>用于灵活读取；\n\n\n\n## 1.4 局限性\n\n1. 基本类型不能用于实例化类型参数；\n2. 运行时类型信息不适用泛型；\n3. 类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；\n4. 不能通过类型参数创建对象；\n5. 泛型类类型参数不能用于创建静态变量和方法；\n6. 不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；\n7. 如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；\n8. 泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；\n\n\n\n# 2 列表和队列\n\n## 2.1 ArrayList\n\n1. ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；\n2. ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；\n3. 迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。\n\n```\n/* 错误写法 */\npublic void remove(ArrayList<Integer> list) {\n    for (Integer a : list) {\n        if (a < 100) {\n            list.remove(a); // 恐抛出ConcurrentModificationException\n        }\n    }\n}\n\n/* 正确写法 */\npublic void remove(ArrayList<Integer> list) {\n    Iterator<Integer> it = list.iterator();\n    while(it.hasNext()) {\n        if (it.next() < 100) {\n            it.remove();\n        }\n    }\n}\n```\n\n1. 使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。\n2. ArrayList的特点\n\n+ 随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；\n+ 除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；\n+ 添加数组元素的效率为O(N)；\n+ 插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；\n+ 需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；\n\n\n\n## 2.2 LinkedList\n\n1. LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；\n2. LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：\n\n```\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"a\");\nqueue.offer(\"b\");\nqueue.offer(\"c\");\nwhile(queue.peek() != null) {\n    System.out.println(queue.poll());\n}\n```\n\n1. LinkedList也可以当作栈使用，示例如下：\n\n```\nDeque<String> stack = new LinkedList<>();\nstack.push(\"a\");\nstack.push(\"b\");\nstack.push(\"c\");\nwhile(stack.peek() != null) {\n    System.out.println(stack.pop());\n}\n```\n\n1. LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；\n2. LinkedList的特点如下：\n\n+ 按需分配空间，不需要预先分配很多空间；\n+ 不可随机访问，按照索引位置访问效率较低；\n+ 无论列表是否有序，按内容查找都需要逐个查找；\n+ 在两端进行添加、删除操作效率很高；\n\n\n\n## 2.3 ArrayDeque\n\n1. ArrayDeque是基于数组实现的双端队列\n2. ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。\n3. 由于是双端队列因此具备下列特点：\n\n+ 在两端添加和删除的效率很高；\n+ 根据元素的内容查找和删除的效率很低；\n+ 与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。\n\n\n\n# 3 Map和Set\n\n## 3.1 HashMap\n\n1. 创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12\n2. 创建Map保存数据的几个步骤分别为：\n\n+ (1) 计算键的哈希值；\n+ (2) 根据哈希值得到保存位置（取模）；\n+ (3) 插到对应位置的链表表头或者更新已有值；\n+ (4) 根据扩展table大小，注意这里的table是Entry类型；\n\n1. 总结HashMap的实现原理\n\n+ HashMap内部有一个哈希表，每个元素指向一个单链表；\n+ 根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；\n+ 存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较\n+ HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；\n+ HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；\n\n\n\n## 3.2 HashSet\n\n1. Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；\n2. HashSet有下列应用场景\n\n+ 排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；\n+ 保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；\n+ 集合运算：方便进行数学中的交集以及并集的集合运算；\n\n1. HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；\n2. 总结HashSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效的添加、删除元素、判断元素是否存在；\n+ 没有顺序；\n\n\n\n## 3.3 TreeMap或TreeSet\n\n1. 与HashMap无序相对比，TreeMap是有序的。\n2. TreeMap内部使用的是[红黑树](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin)实现的；\n3. TreeMap的特点如下\n\n+ 按键有序：可以很方便地根据键的顺序进行查找\n+ 为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；\n+ 根据键值保存、查找、删除的效率比较高；\n\n1. 总结TreeSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效地添加、删除元素、判断元素是否存在；\n+ 有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；\n\n\n\n## 3.4 LinkedHashMap\n\n1. LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；\n2. LinkedHashMap是有序的，例子如下(插入顺序)：\n\n```\nMap<String, Integer> seqMap = new LinkedHashMap<>();\nseqMap.put(\"c\", 100);\nseqMap.put(\"d\", 200);\nseqMap.put(\"a\", 500);\nseqMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : seqMap.entrySet()) {\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is :\nc 100\nd 300\na 500\n*/\n```\n\n1. LinkedHashMap的访问顺序：\n\n```\nMap<String, Integer> accessMap = new LinkedHashMap<>(16, 0.75, true);\naccessMap.put(\"c\", 100);\naccessMap.put(\"d\", 200);\naccessMap.put(\"a\", 500);\naccessMap.get(\"c\");\naccessMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : accessMap.getEntrySet()){\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is : \na 500\nc 100\nd 300\n*/\n```\n\n1. LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：\n\n```\n// 实现代码\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private int maxEntries;\n    public LRUCache(int maxEntries) {\n        super(16, 0.75f, true);\n        this.maxEntries = maxEntries;\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Entry<K, V> eldest) {\n        return size() > maxEntries;\n    }\n}\n// 使用示例\nLRUCache<String, Object> cache = new LRUCache<>(3);\ncache.put(\"a\", \"abstract\");\ncache.put(\"b\", \"basic\");\ncache.put(\"c\", \"call\");\ncache.get(\"a\");\ncache.put(\"d\", \"call\");\nSystem.out.println(cache);\n\n// 输出结果\n{c=call, a=abstract, d=call}\n```\n\n\n\n## 3.5 EnumMap\n\n1. 键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；\n2. EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：\n\n```\npublic enum Size {\n    SMALL, MEDIUM, LARGE\n}\n\npublic class Clothes {\n    String id;\n    Size size;\n}\n\npublic static Map<Size, Integer> countBySize(List<Clothes> clothes) {\n    Map<Size, Integer> map = new EnumMap<>(Size.class);\n    for (Clothes c : clothes) {\n        Size size = c.getSize();\n        Integer count = map.get(size);\n        if (count != null) {\n            map.put(size, count + 1);\n        } else {\n            map.put(size, 1);\n        }\n    }\n    return map;\n}\n```\n\n1. EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。\n2. EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；\n3. 位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。\n4. 对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。\n\n\n\n# 4 堆与优先级队列\n\n## 4.1 完全二叉树\n\n1. 完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其**父节点**和**孩子节点**的编号。**例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 \\* i，右孩子节点编号为2 \\* i + 1;**\n2. 基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；\n\n\n\n## 4.2 PriorityQueue\n\n1. PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：\n\n```\nstatic class Task {\n    int priority; // 数值越大，优先级越高\n    String name; // 表示任务的名称\n    \n    private static Comparator<Task> taskComparator = new Comparator() {\n        @Override\n        public int compare(Task o1, Task o2) {\n            if (o1.getPriority() > o2.getPriority()) {\n                return -1;\n            } else if (o1.getPriority() < o2.getPriority()){\n                return 1;\n            }\n            return 0;\n        }\n    }\n}\n\nQueue<Task> tasks = new Priority<>(11, taskComparator);\ntasks.offer(new Task(20, \"写日记\"));\ntasks.offer(new Task(10, \"看电视\"));\ntasks.offer(new Task(100, \"写代码\"));\nTask task = tasks.poll();\nwhile (task != null) {\n    System.out.print(\"处理任务：\" + task.getName() + \", 优先级：\" + task.getPriority());\n    task = tasks.poll();\n}\n// 结果如下：\n处理任务：写代码，优先级：100\n处理任务：写日记，优先级：20\n处理任务：看电视，优先级：10\n```\n\n1. PriorityQueue有如下特点：\n\n+ 实现了优先级队列，最先出队的总是优先级最高的；\n+ 优先级相同时，内部元素不完全有序；\n+ 查询头部元素效率很高，入队、出队效率很高；\n+ 根据值查找和删除元素效率很低\n+ 具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；\n\n\n\n# 5 通用容器类\n\n1. Collections提供了很多针对容器接口的通用算法和功能；\n2. 容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；\n3. 容器类中运用了大量的适配器模式\n\n+ 空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）\n+ 单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）\n+ 其他适配方法，例如将Map转换为Set等。\n\n1. 基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；\n","slug":"java-core/ch04","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckzpn37ij00063h61dt2p9wqy","content":"<h1 id=\"1-泛型\"><a href=\"#1-泛型\" class=\"headerlink\" title=\"1 泛型\"></a>1 泛型</h1><h2 id=\"1-1-基本概念\"><a href=\"#1-1-基本概念\" class=\"headerlink\" title=\"1.1 基本概念\"></a>1.1 基本概念</h2><ol>\n<li>泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；</li>\n<li>Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；</li>\n<li>泛型可以指定上限为某个具体类，例如：</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NumberPair&lt;U</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Number</span>, <span class=\"hljs-title\">V</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Number&gt;</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Pair&lt;U</span>, <span class=\"hljs-title\">V&gt;</span></span>&#123;<br>    public <span class=\"hljs-type\">NumberPair</span>(<span class=\"hljs-type\">U</span> first, <span class=\"hljs-type\">V</span> second) &#123;<br>        <span class=\"hljs-keyword\">super</span>(first, second);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；</li>\n<li>总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。</li>\n</ol>\n<h2 id=\"1-2-通配符解析\"><a href=\"#1-2-通配符解析\" class=\"headerlink\" title=\"1.2 通配符解析\"></a>1.2 通配符解析</h2><ol>\n<li>参数类型限定通配符写法。例如：public void addAll(DynamicArray&lt;? extends E&gt; c), <strong>&lt;? exntends E&gt;也称为有限定通配符</strong>；</li>\n<li>与之相对应的就为无限定通配符，具体为：Dynamic&lt;?&gt;，更简洁的写法就为<T></li>\n<li>但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；</li>\n<li>通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；</li>\n<li>通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；</li>\n<li>如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；</li>\n<li>通配符形式和类型参数往往配合使用；</li>\n</ol>\n<h2 id=\"1-3-超类型通配符\"><a href=\"#1-3-超类型通配符\" class=\"headerlink\" title=\"1.3 超类型通配符\"></a>1.3 超类型通配符</h2><ol>\n<li>形式：&lt;? super E&gt;，用于表示E的某个父类类型；</li>\n<li>使用场景：对于有限通配符形式&lt;? extends E&gt;在无法满足工作需要时，可以使用&lt;? super E&gt;代替；</li>\n<li>&lt;? super E&gt;用于灵活写入或比较，&lt;?&gt;或&lt;? exntends E&gt;用于灵活读取；</li>\n</ol>\n<h2 id=\"1-4-局限性\"><a href=\"#1-4-局限性\" class=\"headerlink\" title=\"1.4 局限性\"></a>1.4 局限性</h2><ol>\n<li>基本类型不能用于实例化类型参数；</li>\n<li>运行时类型信息不适用泛型；</li>\n<li>类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；</li>\n<li>不能通过类型参数创建对象；</li>\n<li>泛型类类型参数不能用于创建静态变量和方法；</li>\n<li>不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；</li>\n<li>如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；</li>\n<li>泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；</li>\n</ol>\n<h1 id=\"2-列表和队列\"><a href=\"#2-列表和队列\" class=\"headerlink\" title=\"2 列表和队列\"></a>2 列表和队列</h1><h2 id=\"2-1-ArrayList\"><a href=\"#2-1-ArrayList\" class=\"headerlink\" title=\"2.1 ArrayList\"></a>2.1 ArrayList</h2><ol>\n<li>ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；</li>\n<li>ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；</li>\n<li>迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">/* 错误写法 */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span>(<span class=\"hljs-params\">ArrayList&lt;Integer&gt; list</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">for</span> (Integer a : list) &#123;<br>        <span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            list.<span class=\"hljs-keyword\">remove</span>(a); <span class=\"hljs-comment\">// 恐抛出ConcurrentModificationException</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 正确写法 */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span>(<span class=\"hljs-params\">ArrayList&lt;Integer&gt; list</span>)</span> &#123;<br>    Iterator&lt;Integer&gt; it = list.iterator();<br>    <span class=\"hljs-keyword\">while</span>(it.hasNext()) &#123;<br>        <span class=\"hljs-keyword\">if</span> (it.next() &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            it.<span class=\"hljs-keyword\">remove</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。</li>\n<li>ArrayList的特点</li>\n</ol>\n<ul>\n<li>随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；</li>\n<li>除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；</li>\n<li>添加数组元素的效率为O(N)；</li>\n<li>插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；</li>\n<li>需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；</li>\n</ul>\n<h2 id=\"2-2-LinkedList\"><a href=\"#2-2-LinkedList\" class=\"headerlink\" title=\"2.2 LinkedList\"></a>2.2 LinkedList</h2><ol>\n<li>LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；</li>\n<li>LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：</li>\n</ol>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\"><span class=\"hljs-built_in\">Queue</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; <span class=\"hljs-built_in\">queue</span> = <span class=\"hljs-literal\">new</span> LinkedList&lt;&gt;();<br><span class=\"hljs-built_in\">queue</span>.offer(<span class=\"hljs-string\">&quot;a&quot;</span>);<br><span class=\"hljs-built_in\">queue</span>.offer(<span class=\"hljs-string\">&quot;b&quot;</span>);<br><span class=\"hljs-built_in\">queue</span>.offer(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">queue</span>.peek() != <span class=\"hljs-built_in\">null</span>) &#123;<br>    System.out.println(<span class=\"hljs-built_in\">queue</span>.poll());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList也可以当作栈使用，示例如下：</li>\n</ol>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">Deque&lt;<span class=\"hljs-built_in\">String</span>&gt; <span class=\"hljs-built_in\">stack</span> = <span class=\"hljs-literal\">new</span> LinkedList&lt;&gt;();<br><span class=\"hljs-built_in\">stack</span>.push(<span class=\"hljs-string\">&quot;a&quot;</span>);<br><span class=\"hljs-built_in\">stack</span>.push(<span class=\"hljs-string\">&quot;b&quot;</span>);<br><span class=\"hljs-built_in\">stack</span>.push(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">stack</span>.peek() != <span class=\"hljs-built_in\">null</span>) &#123;<br>    System.out.println(<span class=\"hljs-built_in\">stack</span>.pop());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；</li>\n<li>LinkedList的特点如下：</li>\n</ol>\n<ul>\n<li>按需分配空间，不需要预先分配很多空间；</li>\n<li>不可随机访问，按照索引位置访问效率较低；</li>\n<li>无论列表是否有序，按内容查找都需要逐个查找；</li>\n<li>在两端进行添加、删除操作效率很高；</li>\n</ul>\n<h2 id=\"2-3-ArrayDeque\"><a href=\"#2-3-ArrayDeque\" class=\"headerlink\" title=\"2.3 ArrayDeque\"></a>2.3 ArrayDeque</h2><ol>\n<li>ArrayDeque是基于数组实现的双端队列</li>\n<li>ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。</li>\n<li>由于是双端队列因此具备下列特点：</li>\n</ol>\n<ul>\n<li>在两端添加和删除的效率很高；</li>\n<li>根据元素的内容查找和删除的效率很低；</li>\n<li>与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。</li>\n</ul>\n<h1 id=\"3-Map和Set\"><a href=\"#3-Map和Set\" class=\"headerlink\" title=\"3 Map和Set\"></a>3 Map和Set</h1><h2 id=\"3-1-HashMap\"><a href=\"#3-1-HashMap\" class=\"headerlink\" title=\"3.1 HashMap\"></a>3.1 HashMap</h2><ol>\n<li>创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12</li>\n<li>创建Map保存数据的几个步骤分别为：</li>\n</ol>\n<ul>\n<li>(1) 计算键的哈希值；</li>\n<li>(2) 根据哈希值得到保存位置（取模）；</li>\n<li>(3) 插到对应位置的链表表头或者更新已有值；</li>\n<li>(4) 根据扩展table大小，注意这里的table是Entry类型；</li>\n</ul>\n<ol>\n<li>总结HashMap的实现原理</li>\n</ol>\n<ul>\n<li>HashMap内部有一个哈希表，每个元素指向一个单链表；</li>\n<li>根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；</li>\n<li>存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较</li>\n<li>HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；</li>\n<li>HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ol>\n<li>Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；</li>\n<li>HashSet有下列应用场景</li>\n</ol>\n<ul>\n<li>排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；</li>\n<li>保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；</li>\n<li>集合运算：方便进行数学中的交集以及并集的集合运算；</li>\n</ul>\n<ol>\n<li>HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；</li>\n<li>总结HashSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效的添加、删除元素、判断元素是否存在；</li>\n<li>没有顺序；</li>\n</ul>\n<h2 id=\"3-3-TreeMap或TreeSet\"><a href=\"#3-3-TreeMap或TreeSet\" class=\"headerlink\" title=\"3.3 TreeMap或TreeSet\"></a>3.3 TreeMap或TreeSet</h2><ol>\n<li>与HashMap无序相对比，TreeMap是有序的。</li>\n<li>TreeMap内部使用的是<a href=\"https://baike.baidu.com/item/红黑树/2413209?fr=aladdin\">红黑树</a>实现的；</li>\n<li>TreeMap的特点如下</li>\n</ol>\n<ul>\n<li>按键有序：可以很方便地根据键的顺序进行查找</li>\n<li>为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；</li>\n<li>根据键值保存、查找、删除的效率比较高；</li>\n</ul>\n<ol>\n<li>总结TreeSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效地添加、删除元素、判断元素是否存在；</li>\n<li>有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；</li>\n</ul>\n<h2 id=\"3-4-LinkedHashMap\"><a href=\"#3-4-LinkedHashMap\" class=\"headerlink\" title=\"3.4 LinkedHashMap\"></a>3.4 LinkedHashMap</h2><ol>\n<li>LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；</li>\n<li>LinkedHashMap是有序的，例子如下(插入顺序)：</li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">Map&lt;String, Integer&gt; seqMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;();<br>seqMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">Entry</span>&lt;String, Integer&gt; <span class=\"hljs-keyword\">entry</span> : <span class=\"hljs-type\">seqMap.entrySet</span>()) &#123;<br>    System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-keyword\">entry</span>.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + <span class=\"hljs-keyword\">entry</span>.getValue());<br>&#125;<br>/*<br>Result <span class=\"hljs-keyword\">is</span> :<br><span class=\"hljs-type\">c</span> <span class=\"hljs-number\">100</span><br>d <span class=\"hljs-number\">300</span><br>a <span class=\"hljs-number\">500</span><br>*/<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap的访问顺序：</li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">Map&lt;String, Integer&gt; accessMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75</span>, <span class=\"hljs-literal\">true</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>accessMap.get(<span class=\"hljs-string\">&quot;c&quot;</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">Entry</span>&lt;String, Integer&gt; <span class=\"hljs-keyword\">entry</span> : <span class=\"hljs-type\">accessMap.getEntrySet</span>())&#123;<br>    System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-keyword\">entry</span>.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + <span class=\"hljs-keyword\">entry</span>.getValue());<br>&#125;<br>/*<br>Result <span class=\"hljs-keyword\">is</span> : <br><span class=\"hljs-type\">a</span> <span class=\"hljs-number\">500</span><br>c <span class=\"hljs-number\">100</span><br>d <span class=\"hljs-number\">300</span><br>*/<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-comment\">// 实现代码</span><br>public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LRUCache&lt;K</span>, <span class=\"hljs-title\">V&gt;</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">LinkedHashMap&lt;K</span>, <span class=\"hljs-title\">V&gt;</span> </span>&#123;<br>    <span class=\"hljs-keyword\">private</span> int maxEntries;<br>    public <span class=\"hljs-type\">LRUCache</span>(int maxEntries) &#123;<br>        <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75</span>f, <span class=\"hljs-literal\">true</span>);<br>        <span class=\"hljs-keyword\">this</span>.maxEntries = maxEntries;<br>    &#125;<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">protected</span> boolean removeEldestEntry(<span class=\"hljs-type\">Entry</span>&lt;<span class=\"hljs-type\">K</span>, <span class=\"hljs-type\">V</span>&gt; eldest) &#123;<br>        <span class=\"hljs-keyword\">return</span> size() &gt; maxEntries;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 使用示例</span><br><span class=\"hljs-type\">LRUCache</span>&lt;<span class=\"hljs-type\">String</span>, <span class=\"hljs-type\">Object</span>&gt; cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">LRUCache</span>&lt;&gt;(<span class=\"hljs-number\">3</span>);<br>cache.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>cache.get(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br><span class=\"hljs-type\">System</span>.out.println(cache);<br><br><span class=\"hljs-comment\">// 输出结果</span><br>&#123;c=call, a=<span class=\"hljs-keyword\">abstract</span>, d=call&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-5-EnumMap\"><a href=\"#3-5-EnumMap\" class=\"headerlink\" title=\"3.5 EnumMap\"></a>3.5 EnumMap</h2><ol>\n<li>键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；</li>\n<li>EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：</li>\n</ol>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Size</span> &#123;<br>    SMALL, MEDIUM, LARGE<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clothes</span> &#123;<br>    <span class=\"hljs-type\">String</span> id;<br>    Size size;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">static</span> Map&lt;Size, Integer&gt; <span class=\"hljs-title\">countBySize</span><span class=\"hljs-params\">(List&lt;Clothes&gt; clothes)</span> </span>&#123;<br>    Map&lt;Size, Integer&gt; map = <span class=\"hljs-keyword\">new</span> EnumMap&lt;&gt;(Size.<span class=\"hljs-keyword\">class</span>);<br>    <span class=\"hljs-keyword\">for</span> (Clothes c : clothes) &#123;<br>        Size size = c.<span class=\"hljs-built_in\">getSize</span>();<br>        Integer count = map.<span class=\"hljs-built_in\">get</span>(size);<br>        <span class=\"hljs-keyword\">if</span> (count != null) &#123;<br>            map.<span class=\"hljs-built_in\">put</span>(size, count + <span class=\"hljs-number\">1</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            map.<span class=\"hljs-built_in\">put</span>(size, <span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。</li>\n<li>EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；</li>\n<li>位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。</li>\n<li>对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。</li>\n</ol>\n<h1 id=\"4-堆与优先级队列\"><a href=\"#4-堆与优先级队列\" class=\"headerlink\" title=\"4 堆与优先级队列\"></a>4 堆与优先级队列</h1><h2 id=\"4-1-完全二叉树\"><a href=\"#4-1-完全二叉树\" class=\"headerlink\" title=\"4.1 完全二叉树\"></a>4.1 完全二叉树</h2><ol>\n<li>完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其<strong>父节点</strong>和<strong>孩子节点</strong>的编号。<strong>例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 * i，右孩子节点编号为2 * i + 1;</strong></li>\n<li>基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；</li>\n</ol>\n<h2 id=\"4-2-PriorityQueue\"><a href=\"#4-2-PriorityQueue\" class=\"headerlink\" title=\"4.2 PriorityQueue\"></a>4.2 PriorityQueue</h2><ol>\n<li>PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：</li>\n</ol>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">Task</span> &#123;<br>    <span class=\"hljs-keyword\">int</span> priority; <span class=\"hljs-comment\">// 数值越大，优先级越高</span><br>    String name; <span class=\"hljs-comment\">// 表示任务的名称</span><br>    <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Comparator&lt;<span class=\"hljs-keyword\">Task</span>&gt; taskComparator = <span class=\"hljs-keyword\">new</span> Comparator() &#123;<br>        @Override<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> compare(<span class=\"hljs-keyword\">Task</span> o1, <span class=\"hljs-keyword\">Task</span> o2) &#123;<br>            <span class=\"hljs-keyword\">if</span> (o1.getPriority() &gt; o2.getPriority()) &#123;<br>                <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (o1.getPriority() &lt; o2.getPriority())&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Queue&lt;<span class=\"hljs-keyword\">Task</span>&gt; tasks = <span class=\"hljs-keyword\">new</span> Priority&lt;&gt;(<span class=\"hljs-number\">11</span>, taskComparator);<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Task</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">&quot;写日记&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Task</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&quot;看电视&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Task</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">&quot;写代码&quot;</span>));<br><span class=\"hljs-keyword\">Task</span> <span class=\"hljs-keyword\">task</span> = tasks.poll();<br><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">task</span> != <span class=\"hljs-keyword\">null</span>) &#123;<br>    System.out.<span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">&quot;处理任务：&quot;</span> + <span class=\"hljs-keyword\">task</span>.getName() + <span class=\"hljs-string\">&quot;, 优先级：&quot;</span> + <span class=\"hljs-keyword\">task</span>.getPriority());<br>    <span class=\"hljs-keyword\">task</span> = tasks.poll();<br>&#125;<br><span class=\"hljs-comment\">// 结果如下：</span><br>处理任务：写代码，优先级：<span class=\"hljs-number\">100</span><br>处理任务：写日记，优先级：<span class=\"hljs-number\">20</span><br>处理任务：看电视，优先级：<span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>PriorityQueue有如下特点：</li>\n</ol>\n<ul>\n<li>实现了优先级队列，最先出队的总是优先级最高的；</li>\n<li>优先级相同时，内部元素不完全有序；</li>\n<li>查询头部元素效率很高，入队、出队效率很高；</li>\n<li>根据值查找和删除元素效率很低</li>\n<li>具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；</li>\n</ul>\n<h1 id=\"5-通用容器类\"><a href=\"#5-通用容器类\" class=\"headerlink\" title=\"5 通用容器类\"></a>5 通用容器类</h1><ol>\n<li>Collections提供了很多针对容器接口的通用算法和功能；</li>\n<li>容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；</li>\n<li>容器类中运用了大量的适配器模式</li>\n</ol>\n<ul>\n<li>空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）</li>\n<li>单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）</li>\n<li>其他适配方法，例如将Map转换为Set等。</li>\n</ul>\n<ol>\n<li>基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；</li>\n</ol>\n","site":{"data":{}},"wordcount":7864,"excerpt":"","more":"<h1 id=\"1-泛型\"><a href=\"#1-泛型\" class=\"headerlink\" title=\"1 泛型\"></a>1 泛型</h1><h2 id=\"1-1-基本概念\"><a href=\"#1-1-基本概念\" class=\"headerlink\" title=\"1.1 基本概念\"></a>1.1 基本概念</h2><ol>\n<li>泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；</li>\n<li>Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；</li>\n<li>泛型可以指定上限为某个具体类，例如：</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NumberPair&lt;U</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Number</span>, <span class=\"hljs-title\">V</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Number&gt;</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Pair&lt;U</span>, <span class=\"hljs-title\">V&gt;</span></span>&#123;<br>    public <span class=\"hljs-type\">NumberPair</span>(<span class=\"hljs-type\">U</span> first, <span class=\"hljs-type\">V</span> second) &#123;<br>        <span class=\"hljs-keyword\">super</span>(first, second);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；</li>\n<li>总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。</li>\n</ol>\n<h2 id=\"1-2-通配符解析\"><a href=\"#1-2-通配符解析\" class=\"headerlink\" title=\"1.2 通配符解析\"></a>1.2 通配符解析</h2><ol>\n<li>参数类型限定通配符写法。例如：public void addAll(DynamicArray&lt;? extends E&gt; c), <strong>&lt;? exntends E&gt;也称为有限定通配符</strong>；</li>\n<li>与之相对应的就为无限定通配符，具体为：Dynamic&lt;?&gt;，更简洁的写法就为<T></li>\n<li>但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；</li>\n<li>通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；</li>\n<li>通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；</li>\n<li>如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；</li>\n<li>通配符形式和类型参数往往配合使用；</li>\n</ol>\n<h2 id=\"1-3-超类型通配符\"><a href=\"#1-3-超类型通配符\" class=\"headerlink\" title=\"1.3 超类型通配符\"></a>1.3 超类型通配符</h2><ol>\n<li>形式：&lt;? super E&gt;，用于表示E的某个父类类型；</li>\n<li>使用场景：对于有限通配符形式&lt;? extends E&gt;在无法满足工作需要时，可以使用&lt;? super E&gt;代替；</li>\n<li>&lt;? super E&gt;用于灵活写入或比较，&lt;?&gt;或&lt;? exntends E&gt;用于灵活读取；</li>\n</ol>\n<h2 id=\"1-4-局限性\"><a href=\"#1-4-局限性\" class=\"headerlink\" title=\"1.4 局限性\"></a>1.4 局限性</h2><ol>\n<li>基本类型不能用于实例化类型参数；</li>\n<li>运行时类型信息不适用泛型；</li>\n<li>类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；</li>\n<li>不能通过类型参数创建对象；</li>\n<li>泛型类类型参数不能用于创建静态变量和方法；</li>\n<li>不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；</li>\n<li>如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；</li>\n<li>泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；</li>\n</ol>\n<h1 id=\"2-列表和队列\"><a href=\"#2-列表和队列\" class=\"headerlink\" title=\"2 列表和队列\"></a>2 列表和队列</h1><h2 id=\"2-1-ArrayList\"><a href=\"#2-1-ArrayList\" class=\"headerlink\" title=\"2.1 ArrayList\"></a>2.1 ArrayList</h2><ol>\n<li>ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；</li>\n<li>ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；</li>\n<li>迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-comment\">/* 错误写法 */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span>(<span class=\"hljs-params\">ArrayList&lt;Integer&gt; list</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">for</span> (Integer a : list) &#123;<br>        <span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            list.<span class=\"hljs-keyword\">remove</span>(a); <span class=\"hljs-comment\">// 恐抛出ConcurrentModificationException</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 正确写法 */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span>(<span class=\"hljs-params\">ArrayList&lt;Integer&gt; list</span>)</span> &#123;<br>    Iterator&lt;Integer&gt; it = list.iterator();<br>    <span class=\"hljs-keyword\">while</span>(it.hasNext()) &#123;<br>        <span class=\"hljs-keyword\">if</span> (it.next() &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            it.<span class=\"hljs-keyword\">remove</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。</li>\n<li>ArrayList的特点</li>\n</ol>\n<ul>\n<li>随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；</li>\n<li>除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；</li>\n<li>添加数组元素的效率为O(N)；</li>\n<li>插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；</li>\n<li>需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；</li>\n</ul>\n<h2 id=\"2-2-LinkedList\"><a href=\"#2-2-LinkedList\" class=\"headerlink\" title=\"2.2 LinkedList\"></a>2.2 LinkedList</h2><ol>\n<li>LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；</li>\n<li>LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：</li>\n</ol>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\"><span class=\"hljs-built_in\">Queue</span>&lt;<span class=\"hljs-built_in\">String</span>&gt; <span class=\"hljs-built_in\">queue</span> = <span class=\"hljs-literal\">new</span> LinkedList&lt;&gt;();<br><span class=\"hljs-built_in\">queue</span>.offer(<span class=\"hljs-string\">&quot;a&quot;</span>);<br><span class=\"hljs-built_in\">queue</span>.offer(<span class=\"hljs-string\">&quot;b&quot;</span>);<br><span class=\"hljs-built_in\">queue</span>.offer(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">queue</span>.peek() != <span class=\"hljs-built_in\">null</span>) &#123;<br>    System.out.println(<span class=\"hljs-built_in\">queue</span>.poll());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList也可以当作栈使用，示例如下：</li>\n</ol>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">Deque&lt;<span class=\"hljs-built_in\">String</span>&gt; <span class=\"hljs-built_in\">stack</span> = <span class=\"hljs-literal\">new</span> LinkedList&lt;&gt;();<br><span class=\"hljs-built_in\">stack</span>.push(<span class=\"hljs-string\">&quot;a&quot;</span>);<br><span class=\"hljs-built_in\">stack</span>.push(<span class=\"hljs-string\">&quot;b&quot;</span>);<br><span class=\"hljs-built_in\">stack</span>.push(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">stack</span>.peek() != <span class=\"hljs-built_in\">null</span>) &#123;<br>    System.out.println(<span class=\"hljs-built_in\">stack</span>.pop());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；</li>\n<li>LinkedList的特点如下：</li>\n</ol>\n<ul>\n<li>按需分配空间，不需要预先分配很多空间；</li>\n<li>不可随机访问，按照索引位置访问效率较低；</li>\n<li>无论列表是否有序，按内容查找都需要逐个查找；</li>\n<li>在两端进行添加、删除操作效率很高；</li>\n</ul>\n<h2 id=\"2-3-ArrayDeque\"><a href=\"#2-3-ArrayDeque\" class=\"headerlink\" title=\"2.3 ArrayDeque\"></a>2.3 ArrayDeque</h2><ol>\n<li>ArrayDeque是基于数组实现的双端队列</li>\n<li>ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。</li>\n<li>由于是双端队列因此具备下列特点：</li>\n</ol>\n<ul>\n<li>在两端添加和删除的效率很高；</li>\n<li>根据元素的内容查找和删除的效率很低；</li>\n<li>与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。</li>\n</ul>\n<h1 id=\"3-Map和Set\"><a href=\"#3-Map和Set\" class=\"headerlink\" title=\"3 Map和Set\"></a>3 Map和Set</h1><h2 id=\"3-1-HashMap\"><a href=\"#3-1-HashMap\" class=\"headerlink\" title=\"3.1 HashMap\"></a>3.1 HashMap</h2><ol>\n<li>创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12</li>\n<li>创建Map保存数据的几个步骤分别为：</li>\n</ol>\n<ul>\n<li>(1) 计算键的哈希值；</li>\n<li>(2) 根据哈希值得到保存位置（取模）；</li>\n<li>(3) 插到对应位置的链表表头或者更新已有值；</li>\n<li>(4) 根据扩展table大小，注意这里的table是Entry类型；</li>\n</ul>\n<ol>\n<li>总结HashMap的实现原理</li>\n</ol>\n<ul>\n<li>HashMap内部有一个哈希表，每个元素指向一个单链表；</li>\n<li>根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；</li>\n<li>存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较</li>\n<li>HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；</li>\n<li>HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ol>\n<li>Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；</li>\n<li>HashSet有下列应用场景</li>\n</ol>\n<ul>\n<li>排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；</li>\n<li>保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；</li>\n<li>集合运算：方便进行数学中的交集以及并集的集合运算；</li>\n</ul>\n<ol>\n<li>HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；</li>\n<li>总结HashSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效的添加、删除元素、判断元素是否存在；</li>\n<li>没有顺序；</li>\n</ul>\n<h2 id=\"3-3-TreeMap或TreeSet\"><a href=\"#3-3-TreeMap或TreeSet\" class=\"headerlink\" title=\"3.3 TreeMap或TreeSet\"></a>3.3 TreeMap或TreeSet</h2><ol>\n<li>与HashMap无序相对比，TreeMap是有序的。</li>\n<li>TreeMap内部使用的是<a href=\"https://baike.baidu.com/item/红黑树/2413209?fr=aladdin\">红黑树</a>实现的；</li>\n<li>TreeMap的特点如下</li>\n</ol>\n<ul>\n<li>按键有序：可以很方便地根据键的顺序进行查找</li>\n<li>为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；</li>\n<li>根据键值保存、查找、删除的效率比较高；</li>\n</ul>\n<ol>\n<li>总结TreeSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效地添加、删除元素、判断元素是否存在；</li>\n<li>有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；</li>\n</ul>\n<h2 id=\"3-4-LinkedHashMap\"><a href=\"#3-4-LinkedHashMap\" class=\"headerlink\" title=\"3.4 LinkedHashMap\"></a>3.4 LinkedHashMap</h2><ol>\n<li>LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；</li>\n<li>LinkedHashMap是有序的，例子如下(插入顺序)：</li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">Map&lt;String, Integer&gt; seqMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;();<br>seqMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">Entry</span>&lt;String, Integer&gt; <span class=\"hljs-keyword\">entry</span> : <span class=\"hljs-type\">seqMap.entrySet</span>()) &#123;<br>    System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-keyword\">entry</span>.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + <span class=\"hljs-keyword\">entry</span>.getValue());<br>&#125;<br>/*<br>Result <span class=\"hljs-keyword\">is</span> :<br><span class=\"hljs-type\">c</span> <span class=\"hljs-number\">100</span><br>d <span class=\"hljs-number\">300</span><br>a <span class=\"hljs-number\">500</span><br>*/<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap的访问顺序：</li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">Map&lt;String, Integer&gt; accessMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75</span>, <span class=\"hljs-literal\">true</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>accessMap.get(<span class=\"hljs-string\">&quot;c&quot;</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">Entry</span>&lt;String, Integer&gt; <span class=\"hljs-keyword\">entry</span> : <span class=\"hljs-type\">accessMap.getEntrySet</span>())&#123;<br>    System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-keyword\">entry</span>.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + <span class=\"hljs-keyword\">entry</span>.getValue());<br>&#125;<br>/*<br>Result <span class=\"hljs-keyword\">is</span> : <br><span class=\"hljs-type\">a</span> <span class=\"hljs-number\">500</span><br>c <span class=\"hljs-number\">100</span><br>d <span class=\"hljs-number\">300</span><br>*/<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-comment\">// 实现代码</span><br>public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LRUCache&lt;K</span>, <span class=\"hljs-title\">V&gt;</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">LinkedHashMap&lt;K</span>, <span class=\"hljs-title\">V&gt;</span> </span>&#123;<br>    <span class=\"hljs-keyword\">private</span> int maxEntries;<br>    public <span class=\"hljs-type\">LRUCache</span>(int maxEntries) &#123;<br>        <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75</span>f, <span class=\"hljs-literal\">true</span>);<br>        <span class=\"hljs-keyword\">this</span>.maxEntries = maxEntries;<br>    &#125;<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">protected</span> boolean removeEldestEntry(<span class=\"hljs-type\">Entry</span>&lt;<span class=\"hljs-type\">K</span>, <span class=\"hljs-type\">V</span>&gt; eldest) &#123;<br>        <span class=\"hljs-keyword\">return</span> size() &gt; maxEntries;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 使用示例</span><br><span class=\"hljs-type\">LRUCache</span>&lt;<span class=\"hljs-type\">String</span>, <span class=\"hljs-type\">Object</span>&gt; cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">LRUCache</span>&lt;&gt;(<span class=\"hljs-number\">3</span>);<br>cache.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>cache.get(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br><span class=\"hljs-type\">System</span>.out.println(cache);<br><br><span class=\"hljs-comment\">// 输出结果</span><br>&#123;c=call, a=<span class=\"hljs-keyword\">abstract</span>, d=call&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-5-EnumMap\"><a href=\"#3-5-EnumMap\" class=\"headerlink\" title=\"3.5 EnumMap\"></a>3.5 EnumMap</h2><ol>\n<li>键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；</li>\n<li>EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：</li>\n</ol>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Size</span> &#123;<br>    SMALL, MEDIUM, LARGE<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clothes</span> &#123;<br>    <span class=\"hljs-type\">String</span> id;<br>    Size size;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">static</span> Map&lt;Size, Integer&gt; <span class=\"hljs-title\">countBySize</span><span class=\"hljs-params\">(List&lt;Clothes&gt; clothes)</span> </span>&#123;<br>    Map&lt;Size, Integer&gt; map = <span class=\"hljs-keyword\">new</span> EnumMap&lt;&gt;(Size.<span class=\"hljs-keyword\">class</span>);<br>    <span class=\"hljs-keyword\">for</span> (Clothes c : clothes) &#123;<br>        Size size = c.<span class=\"hljs-built_in\">getSize</span>();<br>        Integer count = map.<span class=\"hljs-built_in\">get</span>(size);<br>        <span class=\"hljs-keyword\">if</span> (count != null) &#123;<br>            map.<span class=\"hljs-built_in\">put</span>(size, count + <span class=\"hljs-number\">1</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            map.<span class=\"hljs-built_in\">put</span>(size, <span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。</li>\n<li>EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；</li>\n<li>位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。</li>\n<li>对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。</li>\n</ol>\n<h1 id=\"4-堆与优先级队列\"><a href=\"#4-堆与优先级队列\" class=\"headerlink\" title=\"4 堆与优先级队列\"></a>4 堆与优先级队列</h1><h2 id=\"4-1-完全二叉树\"><a href=\"#4-1-完全二叉树\" class=\"headerlink\" title=\"4.1 完全二叉树\"></a>4.1 完全二叉树</h2><ol>\n<li>完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其<strong>父节点</strong>和<strong>孩子节点</strong>的编号。<strong>例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 * i，右孩子节点编号为2 * i + 1;</strong></li>\n<li>基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；</li>\n</ol>\n<h2 id=\"4-2-PriorityQueue\"><a href=\"#4-2-PriorityQueue\" class=\"headerlink\" title=\"4.2 PriorityQueue\"></a>4.2 PriorityQueue</h2><ol>\n<li>PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：</li>\n</ol>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">Task</span> &#123;<br>    <span class=\"hljs-keyword\">int</span> priority; <span class=\"hljs-comment\">// 数值越大，优先级越高</span><br>    String name; <span class=\"hljs-comment\">// 表示任务的名称</span><br>    <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Comparator&lt;<span class=\"hljs-keyword\">Task</span>&gt; taskComparator = <span class=\"hljs-keyword\">new</span> Comparator() &#123;<br>        @Override<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> compare(<span class=\"hljs-keyword\">Task</span> o1, <span class=\"hljs-keyword\">Task</span> o2) &#123;<br>            <span class=\"hljs-keyword\">if</span> (o1.getPriority() &gt; o2.getPriority()) &#123;<br>                <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (o1.getPriority() &lt; o2.getPriority())&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Queue&lt;<span class=\"hljs-keyword\">Task</span>&gt; tasks = <span class=\"hljs-keyword\">new</span> Priority&lt;&gt;(<span class=\"hljs-number\">11</span>, taskComparator);<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Task</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">&quot;写日记&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Task</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&quot;看电视&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Task</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">&quot;写代码&quot;</span>));<br><span class=\"hljs-keyword\">Task</span> <span class=\"hljs-keyword\">task</span> = tasks.poll();<br><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">task</span> != <span class=\"hljs-keyword\">null</span>) &#123;<br>    System.out.<span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">&quot;处理任务：&quot;</span> + <span class=\"hljs-keyword\">task</span>.getName() + <span class=\"hljs-string\">&quot;, 优先级：&quot;</span> + <span class=\"hljs-keyword\">task</span>.getPriority());<br>    <span class=\"hljs-keyword\">task</span> = tasks.poll();<br>&#125;<br><span class=\"hljs-comment\">// 结果如下：</span><br>处理任务：写代码，优先级：<span class=\"hljs-number\">100</span><br>处理任务：写日记，优先级：<span class=\"hljs-number\">20</span><br>处理任务：看电视，优先级：<span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>PriorityQueue有如下特点：</li>\n</ol>\n<ul>\n<li>实现了优先级队列，最先出队的总是优先级最高的；</li>\n<li>优先级相同时，内部元素不完全有序；</li>\n<li>查询头部元素效率很高，入队、出队效率很高；</li>\n<li>根据值查找和删除元素效率很低</li>\n<li>具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；</li>\n</ul>\n<h1 id=\"5-通用容器类\"><a href=\"#5-通用容器类\" class=\"headerlink\" title=\"5 通用容器类\"></a>5 通用容器类</h1><ol>\n<li>Collections提供了很多针对容器接口的通用算法和功能；</li>\n<li>容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；</li>\n<li>容器类中运用了大量的适配器模式</li>\n</ol>\n<ul>\n<li>空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）</li>\n<li>单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）</li>\n<li>其他适配方法，例如将Map转换为Set等。</li>\n</ul>\n<ol>\n<li>基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；</li>\n</ol>\n"},{"title":"Java编程原理——面向对象基础","date":"2022-02-16T07:17:46.000Z","updated":"2022-02-16T07:17:46.000Z","_content":"\n# 1. 类的定义与理解\n## 1.1 容器的视角\n1. 函数是代码的容器，而类是函数的容器；\n2. 既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；\n3. 通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；\n\n## 1.2 数据类型的视角\n1. 类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；\n2. 一个表示数据类型的类可以由以下4部分构成\n- 以**类变量**体现出的类型本身具有的属性；\n- 以**类方法**体现出的类型本身具有的操作；\n- 以**实例变量**体现出的类型实例具有的属性；\n- 以**实例方法**体现出的类型实例具有的操作；\n\n```java\npublic class Point {\n    private int x; // 实例变量\n    private int y; // 实例变量\n    /* 实例方法 */\n    public double distance(){\n        return Math.sqrt(x * x + y * y);\n    }\n}\n```\n3. 通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；\n4. 一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；\n5. 静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；\n6. 构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；\n7. 一旦自定义构造函数，编译器将不再生成默认构造函数；\n\n## 1.3 私有构造函数\n使用私有构造函数存在于以下几个场景：\n1. 不能创建类的实例，类只能被静态访问；\n2. 能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；\n3. 只是用来被其他多个构造方法调用，用于减少重复代码；\n\n## 1.4 总结\n通过**类实现自定义数据类型**，封装该类型的数据所具有的属性和操作，**隐藏实现细节**，从而在更高层次（**类和对象层次**，而非基本数据类型和函数层次）上**考虑和操作数据**，是计算机程序解决复杂问题的一种重要的思维方式。\n\n## 1.5 将现实问题转化为面向对象的层次\n&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。\n\n# 2. 类的继承\n## 2.1 基本概念\n1. 使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；\n2. 不同子类的对象注重于实现自己的行为。\n\n## 2.2 有关继承的更多的细节\n1. 构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；\n2. 静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定\n3. 实例变量、静态变量、静态方法和private方法都是静态绑定的。\n4. 重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；\n\n## 2.3 类型转换与protected关键字\n1. 向上转型：子类型的对象赋值给父类型的引用变量；\n2. 向下转型：父类型的对象赋值给子类型的引用变量；\n3. protected关键字广泛用于模板方法模式中；\n4. 可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；\n5. 继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；\n\n# 3. 类加载的过程\n## 3.1 总览\n(1) 一个Java类所包含下列信息：\n- 静态变量\n- 类初始化代码\n- 静态方法\n- 实例变量\n- 实例初始化代码\n- 父类信息引用\n\n(2)类初始化代码包括\n- 定义静态变量时的赋值语句\n- 实例初始化代码块\n- 构造函数\n\n(3)类加载的过程\n- 分配内存以及保存类的信息\n- 给类变量赋默认值\n- 加载父类\n- 设置父子关系\n- 执行类初始化代码（先执行父类，再执行子类）\n\n## 3.2 对象创建的过程\n1. 每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；\n2. 寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；\n3. 动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；\n\n## 3.3 继承的破坏性——破坏封装\n1. 继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。\n2. 父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；\n3. 对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。\n\n## 3.4 继承的破坏性——没有反映\"is-a\"关系\n&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。\n\n## 3.5 最佳实践\n1. 避免使用继承——使用final关键字关闭继承；\n- 给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；\n2. 优先使用组合模式代替继承；\n- 组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；\n3. 使用接口；\n\n# 4. 接口\n## 4.1 本质\n1. 接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；\n2. 接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；\n3. 接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；\n\n## 4.2 Java 8和Java 9新增的接口函数：\n1. 新增静态方法，便于直接将函数定义在接口中；\n2. 默认方法，使用**default**关键字表示，有具体实现，引入默认方法主要是**函数式的数据处理请求**，为了给接口增加新功能；\n\n## 4.3 总结\n针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。\n\n# 5. 抽象类\n1. 相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。\n2. 抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)\n\n# 6. 内部类\n## 6.1 定义\n顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。\n\n## 6.2 内部类分类\n- 静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；\n1. Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；\n2. LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；\n3. Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；\n- 成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；\n1. Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。\n- 方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。\n\n```java\npublic class Outer {\n    public void test() {\n        final String[] str = new String[]{\"hello\"};\n        /* 方法内部类实例 */\n        class Inner {\n            public void innerMethod() {\n                str[0] = \"hello world\";\n            }\n        }\n        Inner inner = new Inner();\n        inner.innerMethod();\n        System.out.println(str[0]);\n    }\n}\n```\n- 匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。\n\n```java\npublic class Outer {\n    public void test(final int x, final int y) {\n        /* 匿名内部类示例 */\n        Point p = new Point(2, 3) {\n            @Override\n            public double distance() {\n                return distance(new Point(x, y));\n            }\n        };\n        System.out.println(p.distance());\n    }\n}\n```\nJava API使用中参见Arrays.sort函数。\n## 6.3 总结\n将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。\n\n# 7. 枚举\n## 7.1 使用枚举的好处\n1. 枚举使得语法更简洁；\n2. 枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；\n3. 枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；\n\n# 8. 异常\n## 8.1 基本概念\n1. throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；\n2. 异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。\n3. try-with-resource语法：\n\n```java\npublic static void useResource() throws Exception {\n    try(AutoClosable r = new FileInputStream(\"hello\")) { // 创建资源\n        // 使用资源\n    }\n}\n```\n4. 未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。\n\n## 8.2 异常的使用\n1. 真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；\n2. 异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；\n\n## 8.3 异常的处理逻辑\n1. 自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；\n2. 自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；\n3. 总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；\n\n## 8.4 总结\n通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。\n\n# 9. 基本类型的包装类以及String类型\n## 9.1 共性\n1. 均重写了Object类中的(equals，hashCode以及toString)方法；\n- equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；\n- hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；\n2. Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；\n3. 包装类和String\n4. 常用常量：包装类中包含一些常用的常量，例如布尔的**TRUE/FALSE**，整形中的**MIN_VALUE**和**MAX_VALUE**以及浮点中的**POSITIVE_INFINITY（正无穷）** 以及 **NEGATIVE_INFINITY（负无穷）**；\n5. 包装类中带有一个Number类型，可以返回任意基本数据类型；\n6. 不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；\n使用Immutable是因为可以使得程序更为简单和安全，在**多线程环境下不用担心数据会被篡改**；\n7. 包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；\n\n# 10. 单说String\n## 10.1 String类的一些特性\n1. String内部使用的是UTF-16BE模式编码；\n2. 同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。\n\n## 10.2 字符串常量\n1. 如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；\n2. 如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；\n\n## 10.3 StringBuilder与StringBuffer\n1. StringBuffer类是线程安全的，而StringBuilder是线程不安全的；\n2. append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。\n3. String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；\n\n# 11 Arrays类\n## 11.1 基本\n1. sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；\n2. Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；\n3. 总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。\n\n## 11.2 查找\n1. Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：\n```java\n// 针对基本类型\npublic static int binarySearch(int[] a, int key);\npublic static int binarySearch(int[] a, int fromIndex, int toIndex, int key);\n\n// 针对对象数组\npublic int static int binarySearch(Object[] a, Object key);\n\n// 自定义比较器\npublic static <T> int binarySearch(T[] a, T key, Comparator<? super T> c);\n```\n2. 需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；\n```java\n// 索引列表为数组下标：0, 1, 2, 3, 4\n// 插入点列表为：0, 1, 2, 3, 4\nint[] arr = {3, 5, 7, 13, 21};\nSystem.out.println(Arrays.binarySearch(arr, 3); // 0\nSystem.out.println(Arrays.binarySearch(arr, 5); // 1\nSystem.out.println(Arrays.binarySearch(arr, 7); // 2\nSystem.out.println(Arrays.binarySearch(arr, 13); // 3\nSystem.out.println(Arrays.binarySearch(arr, 21); // 4\nSystem.out.println(Arrays.binarySearch(arr, 22); // -6 (由21的插入点为5加1得到，再取负数)\nSystem.out.println(Arrays.binarySearch(arr, 2); // -1 (插在3的前面数插入点为0，再加1取负数得到)\n```\n\n3. 理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；\n\n4. 排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。\n\n# 12 时间处理\n## 12.1 基本概念：\n- 时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;\n- 时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；\n- 年历：例如中国的公历和年历、日本的农历等等；\n\n## 12.2 Java8之前的API支持\n- Date：时刻，绝对时间，与年月日无关；\n- Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；\n- TimeZone：表示时区\n- Locale：表示国家（或者地区）和语言；\n\n## 12.3 Java8之前的API局限性\n- Date中的过时方法有悖常识，因此容易被误用；\n- Calendar类操作繁琐，设计臃肿；\n- DateFormat不是线程安全的，在多线程环境中会存在问题；\n\n# 13 随机\n1. 种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；\n2. 指定种子是为了实现可重复的随机；\n","source":"_posts/java-core/ch03.md","raw":"---\ntitle: Java编程原理——面向对象基础\ndate: 2022-02-16 15:17:46\nupdated: 2022-02-16 15:17:46\ntags: Java基础\ncategories: Java\n---\n\n# 1. 类的定义与理解\n## 1.1 容器的视角\n1. 函数是代码的容器，而类是函数的容器；\n2. 既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；\n3. 通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；\n\n## 1.2 数据类型的视角\n1. 类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；\n2. 一个表示数据类型的类可以由以下4部分构成\n- 以**类变量**体现出的类型本身具有的属性；\n- 以**类方法**体现出的类型本身具有的操作；\n- 以**实例变量**体现出的类型实例具有的属性；\n- 以**实例方法**体现出的类型实例具有的操作；\n\n```java\npublic class Point {\n    private int x; // 实例变量\n    private int y; // 实例变量\n    /* 实例方法 */\n    public double distance(){\n        return Math.sqrt(x * x + y * y);\n    }\n}\n```\n3. 通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；\n4. 一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；\n5. 静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；\n6. 构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；\n7. 一旦自定义构造函数，编译器将不再生成默认构造函数；\n\n## 1.3 私有构造函数\n使用私有构造函数存在于以下几个场景：\n1. 不能创建类的实例，类只能被静态访问；\n2. 能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；\n3. 只是用来被其他多个构造方法调用，用于减少重复代码；\n\n## 1.4 总结\n通过**类实现自定义数据类型**，封装该类型的数据所具有的属性和操作，**隐藏实现细节**，从而在更高层次（**类和对象层次**，而非基本数据类型和函数层次）上**考虑和操作数据**，是计算机程序解决复杂问题的一种重要的思维方式。\n\n## 1.5 将现实问题转化为面向对象的层次\n&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。\n\n# 2. 类的继承\n## 2.1 基本概念\n1. 使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；\n2. 不同子类的对象注重于实现自己的行为。\n\n## 2.2 有关继承的更多的细节\n1. 构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；\n2. 静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定\n3. 实例变量、静态变量、静态方法和private方法都是静态绑定的。\n4. 重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；\n\n## 2.3 类型转换与protected关键字\n1. 向上转型：子类型的对象赋值给父类型的引用变量；\n2. 向下转型：父类型的对象赋值给子类型的引用变量；\n3. protected关键字广泛用于模板方法模式中；\n4. 可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；\n5. 继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；\n\n# 3. 类加载的过程\n## 3.1 总览\n(1) 一个Java类所包含下列信息：\n- 静态变量\n- 类初始化代码\n- 静态方法\n- 实例变量\n- 实例初始化代码\n- 父类信息引用\n\n(2)类初始化代码包括\n- 定义静态变量时的赋值语句\n- 实例初始化代码块\n- 构造函数\n\n(3)类加载的过程\n- 分配内存以及保存类的信息\n- 给类变量赋默认值\n- 加载父类\n- 设置父子关系\n- 执行类初始化代码（先执行父类，再执行子类）\n\n## 3.2 对象创建的过程\n1. 每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；\n2. 寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；\n3. 动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；\n\n## 3.3 继承的破坏性——破坏封装\n1. 继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。\n2. 父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；\n3. 对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。\n\n## 3.4 继承的破坏性——没有反映\"is-a\"关系\n&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。\n\n## 3.5 最佳实践\n1. 避免使用继承——使用final关键字关闭继承；\n- 给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；\n2. 优先使用组合模式代替继承；\n- 组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；\n3. 使用接口；\n\n# 4. 接口\n## 4.1 本质\n1. 接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；\n2. 接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；\n3. 接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；\n\n## 4.2 Java 8和Java 9新增的接口函数：\n1. 新增静态方法，便于直接将函数定义在接口中；\n2. 默认方法，使用**default**关键字表示，有具体实现，引入默认方法主要是**函数式的数据处理请求**，为了给接口增加新功能；\n\n## 4.3 总结\n针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。\n\n# 5. 抽象类\n1. 相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。\n2. 抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)\n\n# 6. 内部类\n## 6.1 定义\n顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。\n\n## 6.2 内部类分类\n- 静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；\n1. Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；\n2. LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；\n3. Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；\n- 成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；\n1. Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。\n- 方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。\n\n```java\npublic class Outer {\n    public void test() {\n        final String[] str = new String[]{\"hello\"};\n        /* 方法内部类实例 */\n        class Inner {\n            public void innerMethod() {\n                str[0] = \"hello world\";\n            }\n        }\n        Inner inner = new Inner();\n        inner.innerMethod();\n        System.out.println(str[0]);\n    }\n}\n```\n- 匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。\n\n```java\npublic class Outer {\n    public void test(final int x, final int y) {\n        /* 匿名内部类示例 */\n        Point p = new Point(2, 3) {\n            @Override\n            public double distance() {\n                return distance(new Point(x, y));\n            }\n        };\n        System.out.println(p.distance());\n    }\n}\n```\nJava API使用中参见Arrays.sort函数。\n## 6.3 总结\n将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。\n\n# 7. 枚举\n## 7.1 使用枚举的好处\n1. 枚举使得语法更简洁；\n2. 枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；\n3. 枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；\n\n# 8. 异常\n## 8.1 基本概念\n1. throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；\n2. 异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。\n3. try-with-resource语法：\n\n```java\npublic static void useResource() throws Exception {\n    try(AutoClosable r = new FileInputStream(\"hello\")) { // 创建资源\n        // 使用资源\n    }\n}\n```\n4. 未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。\n\n## 8.2 异常的使用\n1. 真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；\n2. 异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；\n\n## 8.3 异常的处理逻辑\n1. 自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；\n2. 自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；\n3. 总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；\n\n## 8.4 总结\n通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。\n\n# 9. 基本类型的包装类以及String类型\n## 9.1 共性\n1. 均重写了Object类中的(equals，hashCode以及toString)方法；\n- equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；\n- hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；\n2. Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；\n3. 包装类和String\n4. 常用常量：包装类中包含一些常用的常量，例如布尔的**TRUE/FALSE**，整形中的**MIN_VALUE**和**MAX_VALUE**以及浮点中的**POSITIVE_INFINITY（正无穷）** 以及 **NEGATIVE_INFINITY（负无穷）**；\n5. 包装类中带有一个Number类型，可以返回任意基本数据类型；\n6. 不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；\n使用Immutable是因为可以使得程序更为简单和安全，在**多线程环境下不用担心数据会被篡改**；\n7. 包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；\n\n# 10. 单说String\n## 10.1 String类的一些特性\n1. String内部使用的是UTF-16BE模式编码；\n2. 同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。\n\n## 10.2 字符串常量\n1. 如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；\n2. 如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；\n\n## 10.3 StringBuilder与StringBuffer\n1. StringBuffer类是线程安全的，而StringBuilder是线程不安全的；\n2. append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。\n3. String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；\n\n# 11 Arrays类\n## 11.1 基本\n1. sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；\n2. Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；\n3. 总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。\n\n## 11.2 查找\n1. Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：\n```java\n// 针对基本类型\npublic static int binarySearch(int[] a, int key);\npublic static int binarySearch(int[] a, int fromIndex, int toIndex, int key);\n\n// 针对对象数组\npublic int static int binarySearch(Object[] a, Object key);\n\n// 自定义比较器\npublic static <T> int binarySearch(T[] a, T key, Comparator<? super T> c);\n```\n2. 需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；\n```java\n// 索引列表为数组下标：0, 1, 2, 3, 4\n// 插入点列表为：0, 1, 2, 3, 4\nint[] arr = {3, 5, 7, 13, 21};\nSystem.out.println(Arrays.binarySearch(arr, 3); // 0\nSystem.out.println(Arrays.binarySearch(arr, 5); // 1\nSystem.out.println(Arrays.binarySearch(arr, 7); // 2\nSystem.out.println(Arrays.binarySearch(arr, 13); // 3\nSystem.out.println(Arrays.binarySearch(arr, 21); // 4\nSystem.out.println(Arrays.binarySearch(arr, 22); // -6 (由21的插入点为5加1得到，再取负数)\nSystem.out.println(Arrays.binarySearch(arr, 2); // -1 (插在3的前面数插入点为0，再加1取负数得到)\n```\n\n3. 理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；\n\n4. 排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。\n\n# 12 时间处理\n## 12.1 基本概念：\n- 时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;\n- 时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；\n- 年历：例如中国的公历和年历、日本的农历等等；\n\n## 12.2 Java8之前的API支持\n- Date：时刻，绝对时间，与年月日无关；\n- Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；\n- TimeZone：表示时区\n- Locale：表示国家（或者地区）和语言；\n\n## 12.3 Java8之前的API局限性\n- Date中的过时方法有悖常识，因此容易被误用；\n- Calendar类操作繁琐，设计臃肿；\n- DateFormat不是线程安全的，在多线程环境中会存在问题；\n\n# 13 随机\n1. 种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；\n2. 指定种子是为了实现可重复的随机；\n","slug":"java-core/ch03","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckzpn37io000h3h61fs7pearr","content":"<h1 id=\"1-类的定义与理解\"><a href=\"#1-类的定义与理解\" class=\"headerlink\" title=\"1. 类的定义与理解\"></a>1. 类的定义与理解</h1><h2 id=\"1-1-容器的视角\"><a href=\"#1-1-容器的视角\" class=\"headerlink\" title=\"1.1 容器的视角\"></a>1.1 容器的视角</h2><ol>\n<li>函数是代码的容器，而类是函数的容器；</li>\n<li>既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；</li>\n<li>通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；</li>\n</ol>\n<h2 id=\"1-2-数据类型的视角\"><a href=\"#1-2-数据类型的视角\" class=\"headerlink\" title=\"1.2 数据类型的视角\"></a>1.2 数据类型的视角</h2><ol>\n<li>类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；</li>\n<li>一个表示数据类型的类可以由以下4部分构成</li>\n</ol>\n<ul>\n<li>以<strong>类变量</strong>体现出的类型本身具有的属性；</li>\n<li>以<strong>类方法</strong>体现出的类型本身具有的操作；</li>\n<li>以<strong>实例变量</strong>体现出的类型实例具有的属性；</li>\n<li>以<strong>实例方法</strong>体现出的类型实例具有的操作；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> y; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-comment\">/* 实例方法 */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> Math.sqrt(x * x + y * y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；</li>\n<li>一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；</li>\n<li>静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；</li>\n<li>构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；</li>\n<li>一旦自定义构造函数，编译器将不再生成默认构造函数；</li>\n</ol>\n<h2 id=\"1-3-私有构造函数\"><a href=\"#1-3-私有构造函数\" class=\"headerlink\" title=\"1.3 私有构造函数\"></a>1.3 私有构造函数</h2><p>使用私有构造函数存在于以下几个场景：</p>\n<ol>\n<li>不能创建类的实例，类只能被静态访问；</li>\n<li>能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；</li>\n<li>只是用来被其他多个构造方法调用，用于减少重复代码；</li>\n</ol>\n<h2 id=\"1-4-总结\"><a href=\"#1-4-总结\" class=\"headerlink\" title=\"1.4 总结\"></a>1.4 总结</h2><p>通过<strong>类实现自定义数据类型</strong>，封装该类型的数据所具有的属性和操作，<strong>隐藏实现细节</strong>，从而在更高层次（<strong>类和对象层次</strong>，而非基本数据类型和函数层次）上<strong>考虑和操作数据</strong>，是计算机程序解决复杂问题的一种重要的思维方式。</p>\n<h2 id=\"1-5-将现实问题转化为面向对象的层次\"><a href=\"#1-5-将现实问题转化为面向对象的层次\" class=\"headerlink\" title=\"1.5 将现实问题转化为面向对象的层次\"></a>1.5 将现实问题转化为面向对象的层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。</p>\n<h1 id=\"2-类的继承\"><a href=\"#2-类的继承\" class=\"headerlink\" title=\"2. 类的继承\"></a>2. 类的继承</h1><h2 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h2><ol>\n<li>使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；</li>\n<li>不同子类的对象注重于实现自己的行为。</li>\n</ol>\n<h2 id=\"2-2-有关继承的更多的细节\"><a href=\"#2-2-有关继承的更多的细节\" class=\"headerlink\" title=\"2.2 有关继承的更多的细节\"></a>2.2 有关继承的更多的细节</h2><ol>\n<li>构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；</li>\n<li>静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定</li>\n<li>实例变量、静态变量、静态方法和private方法都是静态绑定的。</li>\n<li>重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；</li>\n</ol>\n<h2 id=\"2-3-类型转换与protected关键字\"><a href=\"#2-3-类型转换与protected关键字\" class=\"headerlink\" title=\"2.3 类型转换与protected关键字\"></a>2.3 类型转换与protected关键字</h2><ol>\n<li>向上转型：子类型的对象赋值给父类型的引用变量；</li>\n<li>向下转型：父类型的对象赋值给子类型的引用变量；</li>\n<li>protected关键字广泛用于模板方法模式中；</li>\n<li>可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；</li>\n<li>继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；</li>\n</ol>\n<h1 id=\"3-类加载的过程\"><a href=\"#3-类加载的过程\" class=\"headerlink\" title=\"3. 类加载的过程\"></a>3. 类加载的过程</h1><h2 id=\"3-1-总览\"><a href=\"#3-1-总览\" class=\"headerlink\" title=\"3.1 总览\"></a>3.1 总览</h2><p>(1) 一个Java类所包含下列信息：</p>\n<ul>\n<li>静态变量</li>\n<li>类初始化代码</li>\n<li>静态方法</li>\n<li>实例变量</li>\n<li>实例初始化代码</li>\n<li>父类信息引用</li>\n</ul>\n<p>(2)类初始化代码包括</p>\n<ul>\n<li>定义静态变量时的赋值语句</li>\n<li>实例初始化代码块</li>\n<li>构造函数</li>\n</ul>\n<p>(3)类加载的过程</p>\n<ul>\n<li>分配内存以及保存类的信息</li>\n<li>给类变量赋默认值</li>\n<li>加载父类</li>\n<li>设置父子关系</li>\n<li>执行类初始化代码（先执行父类，再执行子类）</li>\n</ul>\n<h2 id=\"3-2-对象创建的过程\"><a href=\"#3-2-对象创建的过程\" class=\"headerlink\" title=\"3.2 对象创建的过程\"></a>3.2 对象创建的过程</h2><ol>\n<li>每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；</li>\n<li>寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；</li>\n<li>动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；</li>\n</ol>\n<h2 id=\"3-3-继承的破坏性——破坏封装\"><a href=\"#3-3-继承的破坏性——破坏封装\" class=\"headerlink\" title=\"3.3 继承的破坏性——破坏封装\"></a>3.3 继承的破坏性——破坏封装</h2><ol>\n<li>继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。</li>\n<li>父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；</li>\n<li>对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</li>\n</ol>\n<h2 id=\"3-4-继承的破坏性——没有反映”is-a”关系\"><a href=\"#3-4-继承的破坏性——没有反映”is-a”关系\" class=\"headerlink\" title=\"3.4 继承的破坏性——没有反映”is-a”关系\"></a>3.4 继承的破坏性——没有反映”is-a”关系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。</p>\n<h2 id=\"3-5-最佳实践\"><a href=\"#3-5-最佳实践\" class=\"headerlink\" title=\"3.5 最佳实践\"></a>3.5 最佳实践</h2><ol>\n<li>避免使用继承——使用final关键字关闭继承；</li>\n</ol>\n<ul>\n<li>给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；</li>\n</ul>\n<ol>\n<li>优先使用组合模式代替继承；</li>\n</ol>\n<ul>\n<li>组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；</li>\n</ul>\n<ol>\n<li>使用接口；</li>\n</ol>\n<h1 id=\"4-接口\"><a href=\"#4-接口\" class=\"headerlink\" title=\"4. 接口\"></a>4. 接口</h1><h2 id=\"4-1-本质\"><a href=\"#4-1-本质\" class=\"headerlink\" title=\"4.1 本质\"></a>4.1 本质</h2><ol>\n<li>接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；</li>\n<li>接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；</li>\n<li>接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；</li>\n</ol>\n<h2 id=\"4-2-Java-8和Java-9新增的接口函数：\"><a href=\"#4-2-Java-8和Java-9新增的接口函数：\" class=\"headerlink\" title=\"4.2 Java 8和Java 9新增的接口函数：\"></a>4.2 Java 8和Java 9新增的接口函数：</h2><ol>\n<li>新增静态方法，便于直接将函数定义在接口中；</li>\n<li>默认方法，使用<strong>default</strong>关键字表示，有具体实现，引入默认方法主要是<strong>函数式的数据处理请求</strong>，为了给接口增加新功能；</li>\n</ol>\n<h2 id=\"4-3-总结\"><a href=\"#4-3-总结\" class=\"headerlink\" title=\"4.3 总结\"></a>4.3 总结</h2><p>针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。</p>\n<h1 id=\"5-抽象类\"><a href=\"#5-抽象类\" class=\"headerlink\" title=\"5. 抽象类\"></a>5. 抽象类</h1><ol>\n<li>相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。</li>\n<li>抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)</li>\n</ol>\n<h1 id=\"6-内部类\"><a href=\"#6-内部类\" class=\"headerlink\" title=\"6. 内部类\"></a>6. 内部类</h1><h2 id=\"6-1-定义\"><a href=\"#6-1-定义\" class=\"headerlink\" title=\"6.1 定义\"></a>6.1 定义</h2><p>顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。</p>\n<h2 id=\"6-2-内部类分类\"><a href=\"#6-2-内部类分类\" class=\"headerlink\" title=\"6.2 内部类分类\"></a>6.2 内部类分类</h2><ul>\n<li>静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；</li>\n</ul>\n<ol>\n<li>Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；</li>\n<li>LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；</li>\n<li>Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；</li>\n</ol>\n<ul>\n<li>成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；</li>\n</ul>\n<ol>\n<li>Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。</li>\n</ol>\n<ul>\n<li>方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> String[] str = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello&quot;</span>&#125;;<br>        <span class=\"hljs-comment\">/* 方法内部类实例 */</span><br>        <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Inner</span> &#123;<br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">innerMethod</span><span class=\"hljs-params\">()</span> &#123;<br>                str[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">Inner</span> <span class=\"hljs-variable\">inner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Inner</span>();<br>        inner.innerMethod();<br>        System.out.println(str[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> x, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> y)</span> &#123;<br>        <span class=\"hljs-comment\">/* 匿名内部类示例 */</span><br>        <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> distance(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(x, y));<br>            &#125;<br>        &#125;;<br>        System.out.println(p.distance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Java API使用中参见Arrays.sort函数。</p>\n<h2 id=\"6-3-总结\"><a href=\"#6-3-总结\" class=\"headerlink\" title=\"6.3 总结\"></a>6.3 总结</h2><p>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。</p>\n<h1 id=\"7-枚举\"><a href=\"#7-枚举\" class=\"headerlink\" title=\"7. 枚举\"></a>7. 枚举</h1><h2 id=\"7-1-使用枚举的好处\"><a href=\"#7-1-使用枚举的好处\" class=\"headerlink\" title=\"7.1 使用枚举的好处\"></a>7.1 使用枚举的好处</h2><ol>\n<li>枚举使得语法更简洁；</li>\n<li>枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；</li>\n<li>枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；</li>\n</ol>\n<h1 id=\"8-异常\"><a href=\"#8-异常\" class=\"headerlink\" title=\"8. 异常\"></a>8. 异常</h1><h2 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h2><ol>\n<li>throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；</li>\n<li>异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。</li>\n<li>try-with-resource语法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useResource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>    <span class=\"hljs-keyword\">try</span>(<span class=\"hljs-type\">AutoClosable</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>)) &#123; <span class=\"hljs-comment\">// 创建资源</span><br>        <span class=\"hljs-comment\">// 使用资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。</li>\n</ol>\n<h2 id=\"8-2-异常的使用\"><a href=\"#8-2-异常的使用\" class=\"headerlink\" title=\"8.2 异常的使用\"></a>8.2 异常的使用</h2><ol>\n<li>真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；</li>\n<li>异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；</li>\n</ol>\n<h2 id=\"8-3-异常的处理逻辑\"><a href=\"#8-3-异常的处理逻辑\" class=\"headerlink\" title=\"8.3 异常的处理逻辑\"></a>8.3 异常的处理逻辑</h2><ol>\n<li>自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；</li>\n<li>自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；</li>\n<li>总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；</li>\n</ol>\n<h2 id=\"8-4-总结\"><a href=\"#8-4-总结\" class=\"headerlink\" title=\"8.4 总结\"></a>8.4 总结</h2><p>通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。</p>\n<h1 id=\"9-基本类型的包装类以及String类型\"><a href=\"#9-基本类型的包装类以及String类型\" class=\"headerlink\" title=\"9. 基本类型的包装类以及String类型\"></a>9. 基本类型的包装类以及String类型</h1><h2 id=\"9-1-共性\"><a href=\"#9-1-共性\" class=\"headerlink\" title=\"9.1 共性\"></a>9.1 共性</h2><ol>\n<li>均重写了Object类中的(equals，hashCode以及toString)方法；</li>\n</ol>\n<ul>\n<li>equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；</li>\n<li>hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；</li>\n</ul>\n<ol>\n<li>Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；</li>\n<li>包装类和String</li>\n<li>常用常量：包装类中包含一些常用的常量，例如布尔的<strong>TRUE/FALSE</strong>，整形中的<strong>MIN_VALUE</strong>和<strong>MAX_VALUE</strong>以及浮点中的<strong>POSITIVE_INFINITY（正无穷）</strong> 以及 <strong>NEGATIVE_INFINITY（负无穷）</strong>；</li>\n<li>包装类中带有一个Number类型，可以返回任意基本数据类型；</li>\n<li>不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；<br>使用Immutable是因为可以使得程序更为简单和安全，在<strong>多线程环境下不用担心数据会被篡改</strong>；</li>\n<li>包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；</li>\n</ol>\n<h1 id=\"10-单说String\"><a href=\"#10-单说String\" class=\"headerlink\" title=\"10. 单说String\"></a>10. 单说String</h1><h2 id=\"10-1-String类的一些特性\"><a href=\"#10-1-String类的一些特性\" class=\"headerlink\" title=\"10.1 String类的一些特性\"></a>10.1 String类的一些特性</h2><ol>\n<li>String内部使用的是UTF-16BE模式编码；</li>\n<li>同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。</li>\n</ol>\n<h2 id=\"10-2-字符串常量\"><a href=\"#10-2-字符串常量\" class=\"headerlink\" title=\"10.2 字符串常量\"></a>10.2 字符串常量</h2><ol>\n<li>如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；</li>\n<li>如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；</li>\n</ol>\n<h2 id=\"10-3-StringBuilder与StringBuffer\"><a href=\"#10-3-StringBuilder与StringBuffer\" class=\"headerlink\" title=\"10.3 StringBuilder与StringBuffer\"></a>10.3 StringBuilder与StringBuffer</h2><ol>\n<li>StringBuffer类是线程安全的，而StringBuilder是线程不安全的；</li>\n<li>append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。</li>\n<li>String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；</li>\n</ol>\n<h1 id=\"11-Arrays类\"><a href=\"#11-Arrays类\" class=\"headerlink\" title=\"11 Arrays类\"></a>11 Arrays类</h1><h2 id=\"11-1-基本\"><a href=\"#11-1-基本\" class=\"headerlink\" title=\"11.1 基本\"></a>11.1 基本</h2><ol>\n<li>sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；</li>\n<li>Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；</li>\n<li>总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。</li>\n</ol>\n<h2 id=\"11-2-查找\"><a href=\"#11-2-查找\" class=\"headerlink\" title=\"11.2 查找\"></a>11.2 查找</h2><ol>\n<li>Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 针对基本类型</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> key)</span>;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> fromIndex, <span class=\"hljs-type\">int</span> toIndex, <span class=\"hljs-type\">int</span> key)</span>;<br><br><span class=\"hljs-comment\">// 针对对象数组</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(Object[] a, Object key)</span>;<br><br><span class=\"hljs-comment\">// 自定义比较器</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(T[] a, T key, Comparator&lt;? <span class=\"hljs-built_in\">super</span> T&gt; c)</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 索引列表为数组下标：0, 1, 2, 3, 4</span><br><span class=\"hljs-comment\">// 插入点列表为：0, 1, 2, 3, 4</span><br><span class=\"hljs-type\">int</span>[] arr = &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">21</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 0</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 1</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 2</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">13</span>); <span class=\"hljs-comment\">// 3</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">21</span>); <span class=\"hljs-comment\">// 4</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">22</span>); <span class=\"hljs-comment\">// -6 (由21的插入点为5加1得到，再取负数)</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// -1 (插在3的前面数插入点为0，再加1取负数得到)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；</p>\n</li>\n<li><p>排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。</p>\n</li>\n</ol>\n<h1 id=\"12-时间处理\"><a href=\"#12-时间处理\" class=\"headerlink\" title=\"12 时间处理\"></a>12 时间处理</h1><h2 id=\"12-1-基本概念：\"><a href=\"#12-1-基本概念：\" class=\"headerlink\" title=\"12.1 基本概念：\"></a>12.1 基本概念：</h2><ul>\n<li>时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;</li>\n<li>时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；</li>\n<li>年历：例如中国的公历和年历、日本的农历等等；</li>\n</ul>\n<h2 id=\"12-2-Java8之前的API支持\"><a href=\"#12-2-Java8之前的API支持\" class=\"headerlink\" title=\"12.2 Java8之前的API支持\"></a>12.2 Java8之前的API支持</h2><ul>\n<li>Date：时刻，绝对时间，与年月日无关；</li>\n<li>Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；</li>\n<li>TimeZone：表示时区</li>\n<li>Locale：表示国家（或者地区）和语言；</li>\n</ul>\n<h2 id=\"12-3-Java8之前的API局限性\"><a href=\"#12-3-Java8之前的API局限性\" class=\"headerlink\" title=\"12.3 Java8之前的API局限性\"></a>12.3 Java8之前的API局限性</h2><ul>\n<li>Date中的过时方法有悖常识，因此容易被误用；</li>\n<li>Calendar类操作繁琐，设计臃肿；</li>\n<li>DateFormat不是线程安全的，在多线程环境中会存在问题；</li>\n</ul>\n<h1 id=\"13-随机\"><a href=\"#13-随机\" class=\"headerlink\" title=\"13 随机\"></a>13 随机</h1><ol>\n<li>种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；</li>\n<li>指定种子是为了实现可重复的随机；</li>\n</ol>\n","site":{"data":{}},"wordcount":7748,"excerpt":"","more":"<h1 id=\"1-类的定义与理解\"><a href=\"#1-类的定义与理解\" class=\"headerlink\" title=\"1. 类的定义与理解\"></a>1. 类的定义与理解</h1><h2 id=\"1-1-容器的视角\"><a href=\"#1-1-容器的视角\" class=\"headerlink\" title=\"1.1 容器的视角\"></a>1.1 容器的视角</h2><ol>\n<li>函数是代码的容器，而类是函数的容器；</li>\n<li>既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；</li>\n<li>通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；</li>\n</ol>\n<h2 id=\"1-2-数据类型的视角\"><a href=\"#1-2-数据类型的视角\" class=\"headerlink\" title=\"1.2 数据类型的视角\"></a>1.2 数据类型的视角</h2><ol>\n<li>类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；</li>\n<li>一个表示数据类型的类可以由以下4部分构成</li>\n</ol>\n<ul>\n<li>以<strong>类变量</strong>体现出的类型本身具有的属性；</li>\n<li>以<strong>类方法</strong>体现出的类型本身具有的操作；</li>\n<li>以<strong>实例变量</strong>体现出的类型实例具有的属性；</li>\n<li>以<strong>实例方法</strong>体现出的类型实例具有的操作；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> y; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-comment\">/* 实例方法 */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> Math.sqrt(x * x + y * y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；</li>\n<li>一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；</li>\n<li>静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；</li>\n<li>构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；</li>\n<li>一旦自定义构造函数，编译器将不再生成默认构造函数；</li>\n</ol>\n<h2 id=\"1-3-私有构造函数\"><a href=\"#1-3-私有构造函数\" class=\"headerlink\" title=\"1.3 私有构造函数\"></a>1.3 私有构造函数</h2><p>使用私有构造函数存在于以下几个场景：</p>\n<ol>\n<li>不能创建类的实例，类只能被静态访问；</li>\n<li>能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；</li>\n<li>只是用来被其他多个构造方法调用，用于减少重复代码；</li>\n</ol>\n<h2 id=\"1-4-总结\"><a href=\"#1-4-总结\" class=\"headerlink\" title=\"1.4 总结\"></a>1.4 总结</h2><p>通过<strong>类实现自定义数据类型</strong>，封装该类型的数据所具有的属性和操作，<strong>隐藏实现细节</strong>，从而在更高层次（<strong>类和对象层次</strong>，而非基本数据类型和函数层次）上<strong>考虑和操作数据</strong>，是计算机程序解决复杂问题的一种重要的思维方式。</p>\n<h2 id=\"1-5-将现实问题转化为面向对象的层次\"><a href=\"#1-5-将现实问题转化为面向对象的层次\" class=\"headerlink\" title=\"1.5 将现实问题转化为面向对象的层次\"></a>1.5 将现实问题转化为面向对象的层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。</p>\n<h1 id=\"2-类的继承\"><a href=\"#2-类的继承\" class=\"headerlink\" title=\"2. 类的继承\"></a>2. 类的继承</h1><h2 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h2><ol>\n<li>使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；</li>\n<li>不同子类的对象注重于实现自己的行为。</li>\n</ol>\n<h2 id=\"2-2-有关继承的更多的细节\"><a href=\"#2-2-有关继承的更多的细节\" class=\"headerlink\" title=\"2.2 有关继承的更多的细节\"></a>2.2 有关继承的更多的细节</h2><ol>\n<li>构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；</li>\n<li>静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定</li>\n<li>实例变量、静态变量、静态方法和private方法都是静态绑定的。</li>\n<li>重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；</li>\n</ol>\n<h2 id=\"2-3-类型转换与protected关键字\"><a href=\"#2-3-类型转换与protected关键字\" class=\"headerlink\" title=\"2.3 类型转换与protected关键字\"></a>2.3 类型转换与protected关键字</h2><ol>\n<li>向上转型：子类型的对象赋值给父类型的引用变量；</li>\n<li>向下转型：父类型的对象赋值给子类型的引用变量；</li>\n<li>protected关键字广泛用于模板方法模式中；</li>\n<li>可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；</li>\n<li>继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；</li>\n</ol>\n<h1 id=\"3-类加载的过程\"><a href=\"#3-类加载的过程\" class=\"headerlink\" title=\"3. 类加载的过程\"></a>3. 类加载的过程</h1><h2 id=\"3-1-总览\"><a href=\"#3-1-总览\" class=\"headerlink\" title=\"3.1 总览\"></a>3.1 总览</h2><p>(1) 一个Java类所包含下列信息：</p>\n<ul>\n<li>静态变量</li>\n<li>类初始化代码</li>\n<li>静态方法</li>\n<li>实例变量</li>\n<li>实例初始化代码</li>\n<li>父类信息引用</li>\n</ul>\n<p>(2)类初始化代码包括</p>\n<ul>\n<li>定义静态变量时的赋值语句</li>\n<li>实例初始化代码块</li>\n<li>构造函数</li>\n</ul>\n<p>(3)类加载的过程</p>\n<ul>\n<li>分配内存以及保存类的信息</li>\n<li>给类变量赋默认值</li>\n<li>加载父类</li>\n<li>设置父子关系</li>\n<li>执行类初始化代码（先执行父类，再执行子类）</li>\n</ul>\n<h2 id=\"3-2-对象创建的过程\"><a href=\"#3-2-对象创建的过程\" class=\"headerlink\" title=\"3.2 对象创建的过程\"></a>3.2 对象创建的过程</h2><ol>\n<li>每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；</li>\n<li>寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；</li>\n<li>动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；</li>\n</ol>\n<h2 id=\"3-3-继承的破坏性——破坏封装\"><a href=\"#3-3-继承的破坏性——破坏封装\" class=\"headerlink\" title=\"3.3 继承的破坏性——破坏封装\"></a>3.3 继承的破坏性——破坏封装</h2><ol>\n<li>继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。</li>\n<li>父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；</li>\n<li>对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</li>\n</ol>\n<h2 id=\"3-4-继承的破坏性——没有反映”is-a”关系\"><a href=\"#3-4-继承的破坏性——没有反映”is-a”关系\" class=\"headerlink\" title=\"3.4 继承的破坏性——没有反映”is-a”关系\"></a>3.4 继承的破坏性——没有反映”is-a”关系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。</p>\n<h2 id=\"3-5-最佳实践\"><a href=\"#3-5-最佳实践\" class=\"headerlink\" title=\"3.5 最佳实践\"></a>3.5 最佳实践</h2><ol>\n<li>避免使用继承——使用final关键字关闭继承；</li>\n</ol>\n<ul>\n<li>给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；</li>\n</ul>\n<ol>\n<li>优先使用组合模式代替继承；</li>\n</ol>\n<ul>\n<li>组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；</li>\n</ul>\n<ol>\n<li>使用接口；</li>\n</ol>\n<h1 id=\"4-接口\"><a href=\"#4-接口\" class=\"headerlink\" title=\"4. 接口\"></a>4. 接口</h1><h2 id=\"4-1-本质\"><a href=\"#4-1-本质\" class=\"headerlink\" title=\"4.1 本质\"></a>4.1 本质</h2><ol>\n<li>接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；</li>\n<li>接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；</li>\n<li>接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；</li>\n</ol>\n<h2 id=\"4-2-Java-8和Java-9新增的接口函数：\"><a href=\"#4-2-Java-8和Java-9新增的接口函数：\" class=\"headerlink\" title=\"4.2 Java 8和Java 9新增的接口函数：\"></a>4.2 Java 8和Java 9新增的接口函数：</h2><ol>\n<li>新增静态方法，便于直接将函数定义在接口中；</li>\n<li>默认方法，使用<strong>default</strong>关键字表示，有具体实现，引入默认方法主要是<strong>函数式的数据处理请求</strong>，为了给接口增加新功能；</li>\n</ol>\n<h2 id=\"4-3-总结\"><a href=\"#4-3-总结\" class=\"headerlink\" title=\"4.3 总结\"></a>4.3 总结</h2><p>针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。</p>\n<h1 id=\"5-抽象类\"><a href=\"#5-抽象类\" class=\"headerlink\" title=\"5. 抽象类\"></a>5. 抽象类</h1><ol>\n<li>相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。</li>\n<li>抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)</li>\n</ol>\n<h1 id=\"6-内部类\"><a href=\"#6-内部类\" class=\"headerlink\" title=\"6. 内部类\"></a>6. 内部类</h1><h2 id=\"6-1-定义\"><a href=\"#6-1-定义\" class=\"headerlink\" title=\"6.1 定义\"></a>6.1 定义</h2><p>顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。</p>\n<h2 id=\"6-2-内部类分类\"><a href=\"#6-2-内部类分类\" class=\"headerlink\" title=\"6.2 内部类分类\"></a>6.2 内部类分类</h2><ul>\n<li>静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；</li>\n</ul>\n<ol>\n<li>Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；</li>\n<li>LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；</li>\n<li>Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；</li>\n</ol>\n<ul>\n<li>成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；</li>\n</ul>\n<ol>\n<li>Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。</li>\n</ol>\n<ul>\n<li>方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> String[] str = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello&quot;</span>&#125;;<br>        <span class=\"hljs-comment\">/* 方法内部类实例 */</span><br>        <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Inner</span> &#123;<br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">innerMethod</span><span class=\"hljs-params\">()</span> &#123;<br>                str[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">Inner</span> <span class=\"hljs-variable\">inner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Inner</span>();<br>        inner.innerMethod();<br>        System.out.println(str[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> x, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> y)</span> &#123;<br>        <span class=\"hljs-comment\">/* 匿名内部类示例 */</span><br>        <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> distance(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(x, y));<br>            &#125;<br>        &#125;;<br>        System.out.println(p.distance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Java API使用中参见Arrays.sort函数。</p>\n<h2 id=\"6-3-总结\"><a href=\"#6-3-总结\" class=\"headerlink\" title=\"6.3 总结\"></a>6.3 总结</h2><p>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。</p>\n<h1 id=\"7-枚举\"><a href=\"#7-枚举\" class=\"headerlink\" title=\"7. 枚举\"></a>7. 枚举</h1><h2 id=\"7-1-使用枚举的好处\"><a href=\"#7-1-使用枚举的好处\" class=\"headerlink\" title=\"7.1 使用枚举的好处\"></a>7.1 使用枚举的好处</h2><ol>\n<li>枚举使得语法更简洁；</li>\n<li>枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；</li>\n<li>枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；</li>\n</ol>\n<h1 id=\"8-异常\"><a href=\"#8-异常\" class=\"headerlink\" title=\"8. 异常\"></a>8. 异常</h1><h2 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h2><ol>\n<li>throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；</li>\n<li>异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。</li>\n<li>try-with-resource语法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useResource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>    <span class=\"hljs-keyword\">try</span>(<span class=\"hljs-type\">AutoClosable</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>)) &#123; <span class=\"hljs-comment\">// 创建资源</span><br>        <span class=\"hljs-comment\">// 使用资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。</li>\n</ol>\n<h2 id=\"8-2-异常的使用\"><a href=\"#8-2-异常的使用\" class=\"headerlink\" title=\"8.2 异常的使用\"></a>8.2 异常的使用</h2><ol>\n<li>真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；</li>\n<li>异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；</li>\n</ol>\n<h2 id=\"8-3-异常的处理逻辑\"><a href=\"#8-3-异常的处理逻辑\" class=\"headerlink\" title=\"8.3 异常的处理逻辑\"></a>8.3 异常的处理逻辑</h2><ol>\n<li>自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；</li>\n<li>自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；</li>\n<li>总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；</li>\n</ol>\n<h2 id=\"8-4-总结\"><a href=\"#8-4-总结\" class=\"headerlink\" title=\"8.4 总结\"></a>8.4 总结</h2><p>通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。</p>\n<h1 id=\"9-基本类型的包装类以及String类型\"><a href=\"#9-基本类型的包装类以及String类型\" class=\"headerlink\" title=\"9. 基本类型的包装类以及String类型\"></a>9. 基本类型的包装类以及String类型</h1><h2 id=\"9-1-共性\"><a href=\"#9-1-共性\" class=\"headerlink\" title=\"9.1 共性\"></a>9.1 共性</h2><ol>\n<li>均重写了Object类中的(equals，hashCode以及toString)方法；</li>\n</ol>\n<ul>\n<li>equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；</li>\n<li>hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；</li>\n</ul>\n<ol>\n<li>Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；</li>\n<li>包装类和String</li>\n<li>常用常量：包装类中包含一些常用的常量，例如布尔的<strong>TRUE/FALSE</strong>，整形中的<strong>MIN_VALUE</strong>和<strong>MAX_VALUE</strong>以及浮点中的<strong>POSITIVE_INFINITY（正无穷）</strong> 以及 <strong>NEGATIVE_INFINITY（负无穷）</strong>；</li>\n<li>包装类中带有一个Number类型，可以返回任意基本数据类型；</li>\n<li>不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；<br>使用Immutable是因为可以使得程序更为简单和安全，在<strong>多线程环境下不用担心数据会被篡改</strong>；</li>\n<li>包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；</li>\n</ol>\n<h1 id=\"10-单说String\"><a href=\"#10-单说String\" class=\"headerlink\" title=\"10. 单说String\"></a>10. 单说String</h1><h2 id=\"10-1-String类的一些特性\"><a href=\"#10-1-String类的一些特性\" class=\"headerlink\" title=\"10.1 String类的一些特性\"></a>10.1 String类的一些特性</h2><ol>\n<li>String内部使用的是UTF-16BE模式编码；</li>\n<li>同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。</li>\n</ol>\n<h2 id=\"10-2-字符串常量\"><a href=\"#10-2-字符串常量\" class=\"headerlink\" title=\"10.2 字符串常量\"></a>10.2 字符串常量</h2><ol>\n<li>如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；</li>\n<li>如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；</li>\n</ol>\n<h2 id=\"10-3-StringBuilder与StringBuffer\"><a href=\"#10-3-StringBuilder与StringBuffer\" class=\"headerlink\" title=\"10.3 StringBuilder与StringBuffer\"></a>10.3 StringBuilder与StringBuffer</h2><ol>\n<li>StringBuffer类是线程安全的，而StringBuilder是线程不安全的；</li>\n<li>append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。</li>\n<li>String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；</li>\n</ol>\n<h1 id=\"11-Arrays类\"><a href=\"#11-Arrays类\" class=\"headerlink\" title=\"11 Arrays类\"></a>11 Arrays类</h1><h2 id=\"11-1-基本\"><a href=\"#11-1-基本\" class=\"headerlink\" title=\"11.1 基本\"></a>11.1 基本</h2><ol>\n<li>sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；</li>\n<li>Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；</li>\n<li>总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。</li>\n</ol>\n<h2 id=\"11-2-查找\"><a href=\"#11-2-查找\" class=\"headerlink\" title=\"11.2 查找\"></a>11.2 查找</h2><ol>\n<li>Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 针对基本类型</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> key)</span>;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> fromIndex, <span class=\"hljs-type\">int</span> toIndex, <span class=\"hljs-type\">int</span> key)</span>;<br><br><span class=\"hljs-comment\">// 针对对象数组</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(Object[] a, Object key)</span>;<br><br><span class=\"hljs-comment\">// 自定义比较器</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(T[] a, T key, Comparator&lt;? <span class=\"hljs-built_in\">super</span> T&gt; c)</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 索引列表为数组下标：0, 1, 2, 3, 4</span><br><span class=\"hljs-comment\">// 插入点列表为：0, 1, 2, 3, 4</span><br><span class=\"hljs-type\">int</span>[] arr = &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">21</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 0</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 1</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 2</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">13</span>); <span class=\"hljs-comment\">// 3</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">21</span>); <span class=\"hljs-comment\">// 4</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">22</span>); <span class=\"hljs-comment\">// -6 (由21的插入点为5加1得到，再取负数)</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// -1 (插在3的前面数插入点为0，再加1取负数得到)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；</p>\n</li>\n<li><p>排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。</p>\n</li>\n</ol>\n<h1 id=\"12-时间处理\"><a href=\"#12-时间处理\" class=\"headerlink\" title=\"12 时间处理\"></a>12 时间处理</h1><h2 id=\"12-1-基本概念：\"><a href=\"#12-1-基本概念：\" class=\"headerlink\" title=\"12.1 基本概念：\"></a>12.1 基本概念：</h2><ul>\n<li>时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;</li>\n<li>时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；</li>\n<li>年历：例如中国的公历和年历、日本的农历等等；</li>\n</ul>\n<h2 id=\"12-2-Java8之前的API支持\"><a href=\"#12-2-Java8之前的API支持\" class=\"headerlink\" title=\"12.2 Java8之前的API支持\"></a>12.2 Java8之前的API支持</h2><ul>\n<li>Date：时刻，绝对时间，与年月日无关；</li>\n<li>Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；</li>\n<li>TimeZone：表示时区</li>\n<li>Locale：表示国家（或者地区）和语言；</li>\n</ul>\n<h2 id=\"12-3-Java8之前的API局限性\"><a href=\"#12-3-Java8之前的API局限性\" class=\"headerlink\" title=\"12.3 Java8之前的API局限性\"></a>12.3 Java8之前的API局限性</h2><ul>\n<li>Date中的过时方法有悖常识，因此容易被误用；</li>\n<li>Calendar类操作繁琐，设计臃肿；</li>\n<li>DateFormat不是线程安全的，在多线程环境中会存在问题；</li>\n</ul>\n<h1 id=\"13-随机\"><a href=\"#13-随机\" class=\"headerlink\" title=\"13 随机\"></a>13 随机</h1><ol>\n<li>种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；</li>\n<li>指定种子是为了实现可重复的随机；</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckzpn37if00023h613titdzlm","category_id":"ckzpn37ii00043h618uxm82do","_id":"ckzpn37im000b3h61cfwld4gf"},{"post_id":"ckzpn37ih00033h61g3vl4u8s","category_id":"ckzpn37ii00043h618uxm82do","_id":"ckzpn37im000e3h614rt46fr7"},{"post_id":"ckzpn37ij00063h61dt2p9wqy","category_id":"ckzpn37ii00043h618uxm82do","_id":"ckzpn37in000g3h613yll1r7m"},{"post_id":"ckzpn37io000h3h61fs7pearr","category_id":"ckzpn37ii00043h618uxm82do","_id":"ckzpn37ip000j3h61fp8gc4gi"}],"PostTag":[{"post_id":"ckzpn37if00023h613titdzlm","tag_id":"ckzpn37ij00053h61gv0o7drc","_id":"ckzpn37il00093h61dlx1hesq"},{"post_id":"ckzpn37ih00033h61g3vl4u8s","tag_id":"ckzpn37ij00053h61gv0o7drc","_id":"ckzpn37im000d3h613ks86hhd"},{"post_id":"ckzpn37ij00063h61dt2p9wqy","tag_id":"ckzpn37ij00053h61gv0o7drc","_id":"ckzpn37in000f3h615ueu9a6b"},{"post_id":"ckzpn37io000h3h61fs7pearr","tag_id":"ckzpn37ij00053h61gv0o7drc","_id":"ckzpn37ip000i3h6181og12xi"}],"Tag":[{"name":"Java基础","_id":"ckzpn37ij00053h61gv0o7drc"}]}}