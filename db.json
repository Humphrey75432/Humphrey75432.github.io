{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"source/img/humphrey.jpg","path":"img/humphrey.jpg","modified":1,"renderable":0},{"_id":"source/img/lengtu.jpeg","path":"img/lengtu.jpeg","modified":1,"renderable":0},{"_id":"source/img/my-little-pony.jpeg","path":"img/my-little-pony.jpeg","modified":1,"renderable":0},{"_id":"source/img/rabbit.gif","path":"img/rabbit.gif","modified":1,"renderable":0},{"_id":"source/img/sheep.jpg","path":"img/sheep.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1644993977235},{"_id":"source/about/index.md","hash":"c3f95f5feccf86bda8ec2aef56e2e99ae444ea76","modified":1644855596886},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1644809129879},{"_id":"source/img/humphrey.jpg","hash":"3500d8fbd318b9a70479a55f82c1a47c77d98ba4","modified":1644854157583},{"_id":"source/_posts/java-core/ch01.md","hash":"6938f113630b5eb3761b5aeb5c1b961f82abf119","modified":1645011779647},{"_id":"source/_posts/java-core/ch02.md","hash":"a3efe991d79d8a09dc0d0aecee90acbcacf46963","modified":1645021087593},{"_id":"source/_posts/java-core/ch03.md","hash":"4ef0081656089829a5921448dcd3cfa5eb7f5f78","modified":1645011813264},{"_id":"source/_posts/java-core/ch04.md","hash":"b41b57ce179ce93c1208da5fc7f695180f246e8a","modified":1645021284390},{"_id":"source/_posts/java-core/ch06.md","hash":"6bf02776377b0c5bf5077ec037901f95e3846e97","modified":1645023910108},{"_id":"source/_posts/java-core/ch05.md","hash":"1d68cfb889d646957b4845a629c0094ae22c4be5","modified":1645022013507},{"_id":"source/_posts/springcloud/springcloud-getting-started.md","hash":"954ca805e9c26e34a5bc81331ba7060e2d5dc363","modified":1645260618026},{"_id":"source/_posts/springcloud/springcloud-service-consumer.md","hash":"d9c59c789b56ac6fd35e566fa6225c248f15e7c9","modified":1645276860562},{"_id":"source/_posts/javascript/es6-array-expand.md","hash":"e4421c94bf2e2bd40bc1a12b85bda8e44abddbf8","modified":1645108088170},{"_id":"source/_posts/javascript/es6-async-operate.md","hash":"428b842827974926a7d3edcf6fe4a574e354afae","modified":1645108019047},{"_id":"source/_posts/javascript/es6-class.md","hash":"c82466c2235aa61cee274cdeb67c2ec4e7c67c57","modified":1645108005921},{"_id":"source/_posts/javascript/es6-function-expand.md","hash":"d1894b75a02d0ddf6c2b1d66e061508d816d11a6","modified":1645108049942},{"_id":"source/_posts/javascript/es6-generator-function.md","hash":"42cdea87fbf40ba5b4178c981359ae048a20c672","modified":1645107866161},{"_id":"source/_posts/javascript/es6-getting-started.md","hash":"4eae531b63cd191e902280978a60322706a3576c","modified":1645108063038},{"_id":"source/_posts/javascript/es6-iterator.md","hash":"ca738e194961da6ff0149e07e02105e6e7b6211b","modified":1645108029845},{"_id":"source/_posts/javascript/es6-let-const.md","hash":"2f61d30ddefbb9e550bc3a5f291e52d05ccbf2be","modified":1645108057625},{"_id":"source/_posts/javascript/es6-num-expand.md","hash":"db9f5a67e34b34de8079285751f1ab54040ae08e","modified":1645108083761},{"_id":"source/_posts/javascript/es6-object-expand.md","hash":"9cc3d01f680d5979f6a0c154b0ef3d90c7df2cf7","modified":1645108092853},{"_id":"source/_posts/javascript/es6-program-style.md","hash":"a3d978210dc461dd8de68be46f10b587b18d56c4","modified":1645107949584},{"_id":"source/_posts/javascript/es6-promise.md","hash":"16ec571eb4d47b3d65c4b41c0c004b393aa22720","modified":1645107862383},{"_id":"source/_posts/javascript/es6-proxy-and-reflect.md","hash":"16d19b5498396c29f02e99ce4795572dccb25a6e","modified":1645082655646},{"_id":"source/_posts/javascript/es6-regexp.md","hash":"9ec0313ea3d730f72d737fd0edf8e4ea4e21fa96","modified":1645108078812},{"_id":"source/_posts/javascript/es6-set-and-map.md","hash":"441a8211572cbf54bb1f5b6f1af171230ddefe80","modified":1645082677119},{"_id":"source/_posts/javascript/es6-string.md","hash":"559b335ffbd7a23361163157918517b7619fe11e","modified":1645108073569},{"_id":"source/_posts/javascript/es6-symbol.md","hash":"2f2290975fda5898460f6eed4e53a94dc8d05c64","modified":1645108044228},{"_id":"source/_posts/javascript/es6-var-expand.md","hash":"59a996617f29b8c8a77b68d6464651708c153aed","modified":1645108067403},{"_id":"source/_posts/frontend/canvas/canvas-around-principle.md","hash":"bd7674cb9b6325c0add6e104f2f262b546ceeee7","modified":1645187875773},{"_id":"source/_posts/frontend/canvas/canvas-draw-shape.md","hash":"7bb8a2bc87b21ab00fc0f8f387acde003d357918","modified":1645187897657},{"_id":"source/_posts/frontend/canvas/canvas-getting-started.md","hash":"20ffbcef12f7343633311b07a6f198b46123b3b0","modified":1645187879791},{"_id":"source/_posts/frontend/canvas/canvas-text.md","hash":"a98b33e9871d56b8c143a0b236c8cfbffa850b7a","modified":1645187752829},{"_id":"source/_posts/frontend/canvas/canvas-tranverse.md","hash":"fe2b3285b649bd0b5a7b4164cd7fcccf6860263d","modified":1645187764846},{"_id":"source/_posts/frontend/css3/css3-ch01.md","hash":"f5c2f64c716234ab4e2cac9681c18e0817713189","modified":1645188750290},{"_id":"source/_posts/frontend/css3/css3-ch02.md","hash":"f8d531f97c21c505d4ca2a23dc2916942d7650fa","modified":1645188846789},{"_id":"source/_posts/frontend/css3/css3-ch03.md","hash":"2d7f5c52b374a4048eb9e9e16f4a14abc69e8967","modified":1645188893695},{"_id":"source/img/my-little-pony.jpeg","hash":"92aefc0ccd6d69e72ed9abadfbf333ebb239390b","modified":1644765379872},{"_id":"source/img/lengtu.jpeg","hash":"a181605cf087e48b00cf633aca0d6eb3cde66ced","modified":1644766297059},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644732960745},{"_id":"source/img/sheep.jpg","hash":"2f10e5756bee0bdc1f3de82c4b7a98adf42a2203","modified":1644765816950},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1644732960714},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1644732960713},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1644732960714},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":1644732960715},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"4e3992cacd64c6888218b0346283258e8f82a27d","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8a7f1534c228538e2ab56249d5a65829650170ed","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":1644732960747},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":1644732960748},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1644732960716},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":1644732960716},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"f3ae4395e751c4a02d5895e07856b1e8edfdda08","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1644732960733},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1644732960746},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"f7f3494ed001e8cdcdc3e8a1d2cd1195cff2ded5","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1644732960725},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1644732960731},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1644732960734},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1644732960715},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1644732960724},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1644732960732},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1644732960725},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1644732960730},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1644732960746},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1644732960718},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1644732960719},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1644732960721},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":1644732960722},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1644732960717},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"df6941bd3b860180d01fd39ee859ed2d42f4d1f0","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":1644732960726},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"e8e01c5db46b383748855452aecd70fcda99f598","modified":1644732960723},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1644732960720},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1644732960728},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"fd5fcb6a61ad865197a778eeae889b80484227dd","modified":1644732960727},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":1644732960729},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1644732960737},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1644732960738},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1644732960743},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"08b455b848b21d57e0563b87071c4bae2b63bafe","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1644732960735},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1644732960736},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"c2d8bfd04bf0734b387c049402b46a06a05fc582","modified":1644732960738},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"80098e8354069631bde8edcd1181a53091a92949","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"a2993f23701de9a83e3f428300e62c5c52b4ff4b","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":1644732960741},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":1644732960742},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":1644732960745},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1644732960745},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"5e86487de0f16c30ca3e16460ab94b57620e31c5","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":1644732960737},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1644732960739},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1644732960740},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":1644732960741},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":1644732960744},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1644732960745},{"_id":"source/img/rabbit.gif","hash":"5a605d911a2a266fa3040c6205b372515db64e3d","modified":1644766159511}],"Category":[{"name":"Java","_id":"ckztvdl2i00042y61adq4f9oz"},{"name":"微服务架构学习","_id":"ckztvdl2t000o2y61howq7sdi"},{"name":"JavaScript","_id":"ckztvdl2y00122y61hgms3lr7"},{"name":"前端","_id":"ckztvdl3f002j2y61cb4ufind"}],"Data":[],"Page":[{"title":"about","date":"2022-02-13T06:22:43.000Z","layout":"about","_content":"> 一句话总结：最不像程序员的程序员。\n\n一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。\n\n平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-02-13 14:22:43\nlayout: about\n---\n> 一句话总结：最不像程序员的程序员。\n\n一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。\n\n平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。\n","updated":"2022-02-14T16:19:56.886Z","path":"about/index.html","comments":1,"_id":"ckztvdl2b00002y617ohhgdfe","content":"<blockquote>\n<p>一句话总结：最不像程序员的程序员。</p>\n</blockquote>\n<p>一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。</p>\n<p>平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。</p>\n","site":{"data":{}},"wordcount":165,"excerpt":"","more":"<blockquote>\n<p>一句话总结：最不像程序员的程序员。</p>\n</blockquote>\n<p>一枚95后的Java程序员民工，算不上非常喜欢钻研技术，但也深知技术是个吃功底沉淀的岗位，需要在行业中不断积累和沉淀才能有所成就。</p>\n<p>平常会去学习新技术，写写博客，由于早期的技术文章都放在云笔记上，因此建立这个网站的目的一是为了将自己之前所学的东西综合起来，另一方面希望通过博客来增加自己的技术沉淀。</p>\n"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-02-16T06:46:17.234Z","updated":"2022-02-16T06:46:17.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2d00012y613tgc834f","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"wordcount":367,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Java编程原理——编程基础","date":"2022-02-13T05:58:16.000Z","_content":"\n# 1. Java基本数据类型\n##### 1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\n\n类型名 | 取值范围\n---|---\nbyte | -2^7 ~ 2^(7-1)\nshort | -2^15 ~ 2^(15-1)\nint | -2^31 ~ 2^(31-1)\nlong | -2^63 ~ 2^(63-1)\n\n##### 1.2 小数类型：有float和double，分别占用4和8个字节\n\n类型名 | 取值范围\n---|---\nfloat | 1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45\ndouble | 4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324\n\n# 2. Java特殊数据类型\n##### 2.1 数组类型\n数组类型在内存中有两块：一块是用于**存储数组本身**，另一块是用于**存储数组内容的位置。** 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。\n\n# 3. Java运算符\n##### 3.1 \"+\", \"-\", \"*\", \"/\", \"%\"\n运算符的使用需要注意：\n1. 整数相除不是四舍五入，而是直接舍去小数位；\n2. a++表示先使用原值a后再进行自增；a--同理；\n3. ++a表示先对原始值a进行自增再进行使用；--a同理；\n4. a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；\n\n# 4. Java逻辑运算\n1. 与运算符(&)：两个都为true才是true，有一个为false就是false;\n2. 或运算符(|)：只要有一个为true就是true，只有都为false才是false;\n3. 非运算符(!)：true的非运算就是false，反之同理;\n4. 异或运算符(^)：相同为false，不相同就是true;\n5. 短路与(&&)：作用跟&类似，boolean flag = a || b++ > 0, 当a为true忽略后面的运算；\n6. 短路或(||)：作用于|类似，boolean flag = a && b++ > 0，当a为true时，忽略后面的运算；\n\n# 5. Java条件语法\n- 选择结构：if/else相当于三元运算符--> operator ? a : b;\n- 多重if/else if/else if/else相当于switch--> switch-case语法：\n```\nif (cond1) {\n    // op1\n} else if (cond2) {\n    // op2\n} else if (cond3) {\n    // op3\n} else {\n    // op4\n}\n\nswitch(cond) {\n    case cond1:\n        // op1\n        break;\n    case cond2:\n        // op2\n        break;\n    case cond3:\n        // op3\n        break;\n}\n```\n\n系统层面下：if/eise使用的操作系统中的**跳转指令**实现的，而switch使用的是**跳转表（跳转表使用二分查找实现，效率较高）** 实现的。在switch分支少的情况下会使用跳转指令实现。\n\n# 6. Java循环语法\n##### 1. while循环\n\n```\nwhile (cond) {\n    loop body\n}\n```\n只要循环条件为true，就一直执行循环体内，否则就中止执行；\n##### 2. do-while循环\n\n```\ndo {\n    loop body\n} while (cond)\n```\n不管循环条件是什么，循环体至少会执行一次；\n##### 3. for循环\n\n```\nfor (init; cond; step) {\n    loop body\n}\n```\n- 1.执行初始化命令；\n- 2.检查循环条件是否为true，如果为false执行步骤6\n- 3.循环条件为true，执行循环体；\n- 4.执行步进操作；\n- 5.步进操作执行结束后，跳转至步骤2\n- 6.for循环后续的语句；\n\n##### 4. foreach语法\n\n```\nfor (DataType element : DataTypeArr) {\n    loop body\n}\n```\n每次迭代循环element时，指针会自动更新；\n\n##### 5. 循环控制\n- break：提前结束循环，不再执行循环体内的剩余代码；\n- continue:跳过循环体内剩余的代码，然后执行步进操作；\n\n# 7. Java函数\n函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。\n1. 函数参数支持可变长度参数，语法为在数据类型的后面加上(...)，在函数内可变长度参数可以看做是数组。**可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数**。\n2. return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。\n3. 返回值可以是数组或者是对象，根据具体需求来选择；\n4. 函数重名但是参数列表不同的现象称之为函数的重载；\n5. 函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；\n6. 函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。\n7. 函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。\n8. 总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。\n\n","source":"_posts/java-core/ch01.md","raw":"---\ntitle: Java编程原理——编程基础\ndate: 2022-02-13 13:58:16\ntags: Java基础\ncategories: Java\n---\n\n# 1. Java基本数据类型\n##### 1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\n\n类型名 | 取值范围\n---|---\nbyte | -2^7 ~ 2^(7-1)\nshort | -2^15 ~ 2^(15-1)\nint | -2^31 ~ 2^(31-1)\nlong | -2^63 ~ 2^(63-1)\n\n##### 1.2 小数类型：有float和double，分别占用4和8个字节\n\n类型名 | 取值范围\n---|---\nfloat | 1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45\ndouble | 4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324\n\n# 2. Java特殊数据类型\n##### 2.1 数组类型\n数组类型在内存中有两块：一块是用于**存储数组本身**，另一块是用于**存储数组内容的位置。** 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。\n\n# 3. Java运算符\n##### 3.1 \"+\", \"-\", \"*\", \"/\", \"%\"\n运算符的使用需要注意：\n1. 整数相除不是四舍五入，而是直接舍去小数位；\n2. a++表示先使用原值a后再进行自增；a--同理；\n3. ++a表示先对原始值a进行自增再进行使用；--a同理；\n4. a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；\n\n# 4. Java逻辑运算\n1. 与运算符(&)：两个都为true才是true，有一个为false就是false;\n2. 或运算符(|)：只要有一个为true就是true，只有都为false才是false;\n3. 非运算符(!)：true的非运算就是false，反之同理;\n4. 异或运算符(^)：相同为false，不相同就是true;\n5. 短路与(&&)：作用跟&类似，boolean flag = a || b++ > 0, 当a为true忽略后面的运算；\n6. 短路或(||)：作用于|类似，boolean flag = a && b++ > 0，当a为true时，忽略后面的运算；\n\n# 5. Java条件语法\n- 选择结构：if/else相当于三元运算符--> operator ? a : b;\n- 多重if/else if/else if/else相当于switch--> switch-case语法：\n```\nif (cond1) {\n    // op1\n} else if (cond2) {\n    // op2\n} else if (cond3) {\n    // op3\n} else {\n    // op4\n}\n\nswitch(cond) {\n    case cond1:\n        // op1\n        break;\n    case cond2:\n        // op2\n        break;\n    case cond3:\n        // op3\n        break;\n}\n```\n\n系统层面下：if/eise使用的操作系统中的**跳转指令**实现的，而switch使用的是**跳转表（跳转表使用二分查找实现，效率较高）** 实现的。在switch分支少的情况下会使用跳转指令实现。\n\n# 6. Java循环语法\n##### 1. while循环\n\n```\nwhile (cond) {\n    loop body\n}\n```\n只要循环条件为true，就一直执行循环体内，否则就中止执行；\n##### 2. do-while循环\n\n```\ndo {\n    loop body\n} while (cond)\n```\n不管循环条件是什么，循环体至少会执行一次；\n##### 3. for循环\n\n```\nfor (init; cond; step) {\n    loop body\n}\n```\n- 1.执行初始化命令；\n- 2.检查循环条件是否为true，如果为false执行步骤6\n- 3.循环条件为true，执行循环体；\n- 4.执行步进操作；\n- 5.步进操作执行结束后，跳转至步骤2\n- 6.for循环后续的语句；\n\n##### 4. foreach语法\n\n```\nfor (DataType element : DataTypeArr) {\n    loop body\n}\n```\n每次迭代循环element时，指针会自动更新；\n\n##### 5. 循环控制\n- break：提前结束循环，不再执行循环体内的剩余代码；\n- continue:跳过循环体内剩余的代码，然后执行步进操作；\n\n# 7. Java函数\n函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。\n1. 函数参数支持可变长度参数，语法为在数据类型的后面加上(...)，在函数内可变长度参数可以看做是数组。**可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数**。\n2. return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。\n3. 返回值可以是数组或者是对象，根据具体需求来选择；\n4. 函数重名但是参数列表不同的现象称之为函数的重载；\n5. 函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；\n6. 函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。\n7. 函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。\n8. 总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。\n\n","slug":"java-core/ch01","published":1,"updated":"2022-02-16T11:42:59.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2g00022y61cwa4cx2v","content":"<h1 id=\"1-Java基本数据类型\"><a href=\"#1-Java基本数据类型\" class=\"headerlink\" title=\"1. Java基本数据类型\"></a>1. Java基本数据类型</h1><h5 id=\"1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\"><a href=\"#1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\" class=\"headerlink\" title=\"1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\"></a>1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>-2^7 ~ 2^(7-1)</td>\n</tr>\n<tr>\n<td>short</td>\n<td>-2^15 ~ 2^(15-1)</td>\n</tr>\n<tr>\n<td>int</td>\n<td>-2^31 ~ 2^(31-1)</td>\n</tr>\n<tr>\n<td>long</td>\n<td>-2^63 ~ 2^(63-1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-2-小数类型：有float和double，分别占用4和8个字节\"><a href=\"#1-2-小数类型：有float和double，分别占用4和8个字节\" class=\"headerlink\" title=\"1.2 小数类型：有float和double，分别占用4和8个字节\"></a>1.2 小数类型：有float和double，分别占用4和8个字节</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45</td>\n</tr>\n<tr>\n<td>double</td>\n<td>4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"2-Java特殊数据类型\"><a href=\"#2-Java特殊数据类型\" class=\"headerlink\" title=\"2. Java特殊数据类型\"></a>2. Java特殊数据类型</h1><h5 id=\"2-1-数组类型\"><a href=\"#2-1-数组类型\" class=\"headerlink\" title=\"2.1 数组类型\"></a>2.1 数组类型</h5><p>数组类型在内存中有两块：一块是用于<strong>存储数组本身</strong>，另一块是用于<strong>存储数组内容的位置。</strong> 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。</p>\n<h1 id=\"3-Java运算符\"><a href=\"#3-Java运算符\" class=\"headerlink\" title=\"3. Java运算符\"></a>3. Java运算符</h1><h5 id=\"3-1-“-”-“-“-“-”-“-“-“-”\"><a href=\"#3-1-“-”-“-“-“-”-“-“-“-”\" class=\"headerlink\" title=\"3.1 “+”, “-“, “*”, “/“, “%”\"></a>3.1 “+”, “-“, “*”, “/“, “%”</h5><p>运算符的使用需要注意：</p>\n<ol>\n<li>整数相除不是四舍五入，而是直接舍去小数位；</li>\n<li>a++表示先使用原值a后再进行自增；a—同理；</li>\n<li>++a表示先对原始值a进行自增再进行使用；—a同理；</li>\n<li>a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；</li>\n</ol>\n<h1 id=\"4-Java逻辑运算\"><a href=\"#4-Java逻辑运算\" class=\"headerlink\" title=\"4. Java逻辑运算\"></a>4. Java逻辑运算</h1><ol>\n<li>与运算符(&amp;)：两个都为true才是true，有一个为false就是false;</li>\n<li>或运算符(|)：只要有一个为true就是true，只有都为false才是false;</li>\n<li>非运算符(!)：true的非运算就是false，反之同理;</li>\n<li>异或运算符(^)：相同为false，不相同就是true;</li>\n<li>短路与(&amp;&amp;)：作用跟&amp;类似，boolean flag = a || b++ &gt; 0, 当a为true忽略后面的运算；</li>\n<li>短路或(||)：作用于|类似，boolean flag = a &amp;&amp; b++ &gt; 0，当a为true时，忽略后面的运算；</li>\n</ol>\n<h1 id=\"5-Java条件语法\"><a href=\"#5-Java条件语法\" class=\"headerlink\" title=\"5. Java条件语法\"></a>5. Java条件语法</h1><ul>\n<li>选择结构：if/else相当于三元运算符—&gt; operator ? a : b;</li>\n<li>多重if/else if/else if/else相当于switch—&gt; switch-case语法：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-keyword\">if</span> (cond1) &#123;<br>    <span class=\"hljs-regexp\">//</span> op1<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond2) &#123;<br>    <span class=\"hljs-regexp\">//</span> op2<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond3) &#123;<br>    <span class=\"hljs-regexp\">//</span> op3<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-regexp\">//</span> op4<br>&#125;<br><br>switch(cond) &#123;<br>    case cond1:<br>        <span class=\"hljs-regexp\">//</span> op1<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond2:<br>        <span class=\"hljs-regexp\">//</span> op2<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond3:<br>        <span class=\"hljs-regexp\">//</span> op3<br>        <span class=\"hljs-keyword\">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>系统层面下：if/eise使用的操作系统中的<strong>跳转指令</strong>实现的，而switch使用的是<strong>跳转表（跳转表使用二分查找实现，效率较高）</strong> 实现的。在switch分支少的情况下会使用跳转指令实现。</p>\n<h1 id=\"6-Java循环语法\"><a href=\"#6-Java循环语法\" class=\"headerlink\" title=\"6. Java循环语法\"></a>6. Java循环语法</h1><h5 id=\"1-while循环\"><a href=\"#1-while循环\" class=\"headerlink\" title=\"1. while循环\"></a>1. while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">while</span> (cond) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>只要循环条件为true，就一直执行循环体内，否则就中止执行；</p>\n<h5 id=\"2-do-while循环\"><a href=\"#2-do-while循环\" class=\"headerlink\" title=\"2. do-while循环\"></a>2. do-while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125; <span class=\"hljs-keyword\">while</span> (cond)<br></code></pre></td></tr></table></figure>\n<p>不管循环条件是什么，循环体至少会执行一次；</p>\n<h5 id=\"3-for循环\"><a href=\"#3-for循环\" class=\"headerlink\" title=\"3. for循环\"></a>3. for循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (init; cond; step) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>1.执行初始化命令；</li>\n<li>2.检查循环条件是否为true，如果为false执行步骤6</li>\n<li>3.循环条件为true，执行循环体；</li>\n<li>4.执行步进操作；</li>\n<li>5.步进操作执行结束后，跳转至步骤2</li>\n<li>6.for循环后续的语句；</li>\n</ul>\n<h5 id=\"4-foreach语法\"><a href=\"#4-foreach语法\" class=\"headerlink\" title=\"4. foreach语法\"></a>4. foreach语法</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (DataType element : <span class=\"hljs-type\">DataTypeArr</span>) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每次迭代循环element时，指针会自动更新；</p>\n<h5 id=\"5-循环控制\"><a href=\"#5-循环控制\" class=\"headerlink\" title=\"5. 循环控制\"></a>5. 循环控制</h5><ul>\n<li>break：提前结束循环，不再执行循环体内的剩余代码；</li>\n<li>continue:跳过循环体内剩余的代码，然后执行步进操作；</li>\n</ul>\n<h1 id=\"7-Java函数\"><a href=\"#7-Java函数\" class=\"headerlink\" title=\"7. Java函数\"></a>7. Java函数</h1><p>函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。</p>\n<ol>\n<li>函数参数支持可变长度参数，语法为在数据类型的后面加上(…)，在函数内可变长度参数可以看做是数组。<strong>可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数</strong>。</li>\n<li>return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。</li>\n<li>返回值可以是数组或者是对象，根据具体需求来选择；</li>\n<li>函数重名但是参数列表不同的现象称之为函数的重载；</li>\n<li>函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；</li>\n<li>函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。</li>\n<li>函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。</li>\n<li>总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。</li>\n</ol>\n","site":{"data":{}},"wordcount":2120,"excerpt":"","more":"<h1 id=\"1-Java基本数据类型\"><a href=\"#1-Java基本数据类型\" class=\"headerlink\" title=\"1. Java基本数据类型\"></a>1. Java基本数据类型</h1><h5 id=\"1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\"><a href=\"#1-1-整数类型：包括byte-short-int和long；分别占用1-2-4和8个字节。取值范围如下：\" class=\"headerlink\" title=\"1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：\"></a>1.1 整数类型：包括byte, short, int和long；分别占用1, 2, 4和8个字节。取值范围如下：</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>-2^7 ~ 2^(7-1)</td>\n</tr>\n<tr>\n<td>short</td>\n<td>-2^15 ~ 2^(15-1)</td>\n</tr>\n<tr>\n<td>int</td>\n<td>-2^31 ~ 2^(31-1)</td>\n</tr>\n<tr>\n<td>long</td>\n<td>-2^63 ~ 2^(63-1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-2-小数类型：有float和double，分别占用4和8个字节\"><a href=\"#1-2-小数类型：有float和double，分别占用4和8个字节\" class=\"headerlink\" title=\"1.2 小数类型：有float和double，分别占用4和8个字节\"></a>1.2 小数类型：有float和double，分别占用4和8个字节</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型名</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>1.4E-45 ~ 3.4E+38<br>-3.4E+38~-1.4E-45</td>\n</tr>\n<tr>\n<td>double</td>\n<td>4.9E-324 ~ 1.7E+308<br>-1.7E+308~-4.9E-324</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"2-Java特殊数据类型\"><a href=\"#2-Java特殊数据类型\" class=\"headerlink\" title=\"2. Java特殊数据类型\"></a>2. Java特殊数据类型</h1><h5 id=\"2-1-数组类型\"><a href=\"#2-1-数组类型\" class=\"headerlink\" title=\"2.1 数组类型\"></a>2.1 数组类型</h5><p>数组类型在内存中有两块：一块是用于<strong>存储数组本身</strong>，另一块是用于<strong>存储数组内容的位置。</strong> 因此给数组变量赋值和给数组中的元素赋值是完全不同的两个概念。</p>\n<h1 id=\"3-Java运算符\"><a href=\"#3-Java运算符\" class=\"headerlink\" title=\"3. Java运算符\"></a>3. Java运算符</h1><h5 id=\"3-1-“-”-“-“-“-”-“-“-“-”\"><a href=\"#3-1-“-”-“-“-“-”-“-“-“-”\" class=\"headerlink\" title=\"3.1 “+”, “-“, “*”, “/“, “%”\"></a>3.1 “+”, “-“, “*”, “/“, “%”</h5><p>运算符的使用需要注意：</p>\n<ol>\n<li>整数相除不是四舍五入，而是直接舍去小数位；</li>\n<li>a++表示先使用原值a后再进行自增；a—同理；</li>\n<li>++a表示先对原始值a进行自增再进行使用；—a同理；</li>\n<li>a += b相当于 a = a + b; a -= b同理，同样对乘除取模运算一样；</li>\n</ol>\n<h1 id=\"4-Java逻辑运算\"><a href=\"#4-Java逻辑运算\" class=\"headerlink\" title=\"4. Java逻辑运算\"></a>4. Java逻辑运算</h1><ol>\n<li>与运算符(&amp;)：两个都为true才是true，有一个为false就是false;</li>\n<li>或运算符(|)：只要有一个为true就是true，只有都为false才是false;</li>\n<li>非运算符(!)：true的非运算就是false，反之同理;</li>\n<li>异或运算符(^)：相同为false，不相同就是true;</li>\n<li>短路与(&amp;&amp;)：作用跟&amp;类似，boolean flag = a || b++ &gt; 0, 当a为true忽略后面的运算；</li>\n<li>短路或(||)：作用于|类似，boolean flag = a &amp;&amp; b++ &gt; 0，当a为true时，忽略后面的运算；</li>\n</ol>\n<h1 id=\"5-Java条件语法\"><a href=\"#5-Java条件语法\" class=\"headerlink\" title=\"5. Java条件语法\"></a>5. Java条件语法</h1><ul>\n<li>选择结构：if/else相当于三元运算符—&gt; operator ? a : b;</li>\n<li>多重if/else if/else if/else相当于switch—&gt; switch-case语法：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-keyword\">if</span> (cond1) &#123;<br>    <span class=\"hljs-regexp\">//</span> op1<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond2) &#123;<br>    <span class=\"hljs-regexp\">//</span> op2<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (cond3) &#123;<br>    <span class=\"hljs-regexp\">//</span> op3<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-regexp\">//</span> op4<br>&#125;<br><br>switch(cond) &#123;<br>    case cond1:<br>        <span class=\"hljs-regexp\">//</span> op1<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond2:<br>        <span class=\"hljs-regexp\">//</span> op2<br>        <span class=\"hljs-keyword\">break</span>;<br>    case cond3:<br>        <span class=\"hljs-regexp\">//</span> op3<br>        <span class=\"hljs-keyword\">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>系统层面下：if/eise使用的操作系统中的<strong>跳转指令</strong>实现的，而switch使用的是<strong>跳转表（跳转表使用二分查找实现，效率较高）</strong> 实现的。在switch分支少的情况下会使用跳转指令实现。</p>\n<h1 id=\"6-Java循环语法\"><a href=\"#6-Java循环语法\" class=\"headerlink\" title=\"6. Java循环语法\"></a>6. Java循环语法</h1><h5 id=\"1-while循环\"><a href=\"#1-while循环\" class=\"headerlink\" title=\"1. while循环\"></a>1. while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">while</span> (cond) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>只要循环条件为true，就一直执行循环体内，否则就中止执行；</p>\n<h5 id=\"2-do-while循环\"><a href=\"#2-do-while循环\" class=\"headerlink\" title=\"2. do-while循环\"></a>2. do-while循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125; <span class=\"hljs-keyword\">while</span> (cond)<br></code></pre></td></tr></table></figure>\n<p>不管循环条件是什么，循环体至少会执行一次；</p>\n<h5 id=\"3-for循环\"><a href=\"#3-for循环\" class=\"headerlink\" title=\"3. for循环\"></a>3. for循环</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (init; cond; step) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>1.执行初始化命令；</li>\n<li>2.检查循环条件是否为true，如果为false执行步骤6</li>\n<li>3.循环条件为true，执行循环体；</li>\n<li>4.执行步进操作；</li>\n<li>5.步进操作执行结束后，跳转至步骤2</li>\n<li>6.for循环后续的语句；</li>\n</ul>\n<h5 id=\"4-foreach语法\"><a href=\"#4-foreach语法\" class=\"headerlink\" title=\"4. foreach语法\"></a>4. foreach语法</h5><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\"><span class=\"hljs-keyword\">for</span> (DataType element : <span class=\"hljs-type\">DataTypeArr</span>) &#123;<br>    <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-keyword\">body</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每次迭代循环element时，指针会自动更新；</p>\n<h5 id=\"5-循环控制\"><a href=\"#5-循环控制\" class=\"headerlink\" title=\"5. 循环控制\"></a>5. 循环控制</h5><ul>\n<li>break：提前结束循环，不再执行循环体内的剩余代码；</li>\n<li>continue:跳过循环体内剩余的代码，然后执行步进操作；</li>\n</ul>\n<h1 id=\"7-Java函数\"><a href=\"#7-Java函数\" class=\"headerlink\" title=\"7. Java函数\"></a>7. Java函数</h1><p>函数是一种操作，一种处理模块，也是用来减少重复代码和分解复杂操作的重要手段。</p>\n<ol>\n<li>函数参数支持可变长度参数，语法为在数据类型的后面加上(…)，在函数内可变长度参数可以看做是数组。<strong>可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度参数</strong>。</li>\n<li>return用于显示执行函数返回，即便函数返回值是void也可以使用return关键字。</li>\n<li>返回值可以是数组或者是对象，根据具体需求来选择；</li>\n<li>函数重名但是参数列表不同的现象称之为函数的重载；</li>\n<li>函数自己调用自己的行为称之为函数的递归；递归函数实现简单，但是十分占用资源开销比较大，并且不易调试；</li>\n<li>函数中的参数以及函数中定义的变量都是在栈中分配内存，当栈的内存不够使用后就会出现StackOverflowError错误。</li>\n<li>函数中使用到的数组，数组的地址是在栈中分配内存，数组中的元素是在堆中分配内存。当栈中数组元素没有指向堆中的内存，JVM将会收回分配在堆中的内存。</li>\n<li>总结：函数主要是通过内存中的栈来进行内存分配的，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单地认为是通过一个专门的返回值存储器存储的。</li>\n</ol>\n"},{"title":"Java编程原理——计算机执行的二进制逻辑","date":"2022-02-16T06:51:30.000Z","updated":"2022-02-16T06:51:30.000Z","math":true,"mermaid":true,"_content":"# 1. 二进制--计算机表示数据的方式\n### 1.1 十进制表示数的方式\n1. 以123来说，使用十进制表示可以写为:<br/>\n\n$$\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0\n$$\n\n2. 按照类比规则推算，N进制数字abc有如下表示，其中k为位权：\n\n$$\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...\n$$\n\n### 1.2 二进制的数字表示\n二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:\n\n$$\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}\n$$\n十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：\n1. -1的8位二进制按概念应是10000001，实际上为11111111\n2. -127的8位二进制按概念应是11111111，实际上为10000001<br/>\n因此我们需要注意下列计算机表示二进制的机器码。\n- 原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;\n- 反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;\n- 补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;\n\n使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。\n\n### 1.3 十六进制--二进制的简化\n由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])\n\n二进制 | 十进制 | 十六进制 | 二进制 | 十进制 | 十六进制\n:---:|:---:|:---:|:---:|:---:|:---:\n1010 | 10 | A | 1011 | 11 | B\n1100 | 12 | C| 1101 | 13 | D\n1110 | 14 | E | 1111 | 15 | F\n\n##### 1.4 位运算\n1. 左移(<<)：左移一位表示乘以2（高位舍去，右侧补0）；\n2. 右移(>>)：右移一位表示除以2（低位舍去，高位按原先补充）；\n\n##### 1.5 查看浮点数的具体二进制形式\n\n```java\nInteger.toBinaryString(Float.floatToIntBits(value));\nLong.toBinaryString(Double.doubleToLongBits(value));\n```\n# 2. 字符集与编码\n##### 2.1 非Unicode编码\n1. **ASCII：**覆盖键盘上的绝大多数的字符，对美国等英语国家够用；\n2. **ISO 8859-1：** 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；\n3. **Windows-1252：**在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；\n4. **GB2312：**简体中文编码规范，使用两个字节表示汉字；\n5. **GBK：**GB2312的扩充，支持更多的汉字编码；\n6. **GB18030：**在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；\n7. **Big5：**针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；\n\n##### 2.2 Unicode编码\n为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：\n1. UTF-32：字符编号的整数二进制形式，4字节\n2. UTF-16：变长字节表示，编号在U+0000\\~U+FFFF使用两字节；编号在U+10000\\~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；\n3. UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；\n\n##### 2.3 编码转换\n1. 假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。\n```mermaid\ngraph LR;\n\t字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B\n```\n\n编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。\n\n2. 乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。\n3. 乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。\n4. 使用Java恢复乱码：\n\n```java\nString str = \"value to encdoe\";\nString newStr = new String(str.getBytes(\"Windows-1252\"), \"GB18030\");\nSystem.out.println(newStr);\n```","source":"_posts/java-core/ch02.md","raw":"---\ntitle: Java编程原理——计算机执行的二进制逻辑\ndate: 2022-02-16 14:51:30\nupdated: 2022-02-16 14:51:30\ntags: Java基础\ncategories: Java\nmath: true\nmermaid: true\n---\n# 1. 二进制--计算机表示数据的方式\n### 1.1 十进制表示数的方式\n1. 以123来说，使用十进制表示可以写为:<br/>\n\n$$\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0\n$$\n\n2. 按照类比规则推算，N进制数字abc有如下表示，其中k为位权：\n\n$$\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...\n$$\n\n### 1.2 二进制的数字表示\n二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:\n\n$$\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}\n$$\n十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：\n1. -1的8位二进制按概念应是10000001，实际上为11111111\n2. -127的8位二进制按概念应是11111111，实际上为10000001<br/>\n因此我们需要注意下列计算机表示二进制的机器码。\n- 原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;\n- 反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;\n- 补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;\n\n使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。\n\n### 1.3 十六进制--二进制的简化\n由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])\n\n二进制 | 十进制 | 十六进制 | 二进制 | 十进制 | 十六进制\n:---:|:---:|:---:|:---:|:---:|:---:\n1010 | 10 | A | 1011 | 11 | B\n1100 | 12 | C| 1101 | 13 | D\n1110 | 14 | E | 1111 | 15 | F\n\n##### 1.4 位运算\n1. 左移(<<)：左移一位表示乘以2（高位舍去，右侧补0）；\n2. 右移(>>)：右移一位表示除以2（低位舍去，高位按原先补充）；\n\n##### 1.5 查看浮点数的具体二进制形式\n\n```java\nInteger.toBinaryString(Float.floatToIntBits(value));\nLong.toBinaryString(Double.doubleToLongBits(value));\n```\n# 2. 字符集与编码\n##### 2.1 非Unicode编码\n1. **ASCII：**覆盖键盘上的绝大多数的字符，对美国等英语国家够用；\n2. **ISO 8859-1：** 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；\n3. **Windows-1252：**在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；\n4. **GB2312：**简体中文编码规范，使用两个字节表示汉字；\n5. **GBK：**GB2312的扩充，支持更多的汉字编码；\n6. **GB18030：**在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；\n7. **Big5：**针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；\n\n##### 2.2 Unicode编码\n为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：\n1. UTF-32：字符编号的整数二进制形式，4字节\n2. UTF-16：变长字节表示，编号在U+0000\\~U+FFFF使用两字节；编号在U+10000\\~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；\n3. UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；\n\n##### 2.3 编码转换\n1. 假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。\n```mermaid\ngraph LR;\n\t字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B\n```\n\n编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。\n\n2. 乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。\n3. 乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。\n4. 使用Java恢复乱码：\n\n```java\nString str = \"value to encdoe\";\nString newStr = new String(str.getBytes(\"Windows-1252\"), \"GB18030\");\nSystem.out.println(newStr);\n```","slug":"java-core/ch02","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2h00032y61b2y182ui","content":"<h1 id=\"1-二进制—计算机表示数据的方式\"><a href=\"#1-二进制—计算机表示数据的方式\" class=\"headerlink\" title=\"1. 二进制—计算机表示数据的方式\"></a>1. 二进制—计算机表示数据的方式</h1><h3 id=\"1-1-十进制表示数的方式\"><a href=\"#1-1-十进制表示数的方式\" class=\"headerlink\" title=\"1.1 十进制表示数的方式\"></a>1.1 十进制表示数的方式</h3><ol>\n<li>以123来说，使用十进制表示可以写为:<br/></li>\n</ol>\n<script type=\"math/tex; mode=display\">\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0</script><ol>\n<li>按照类比规则推算，N进制数字abc有如下表示，其中k为位权：</li>\n</ol>\n<script type=\"math/tex; mode=display\">\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...</script><h3 id=\"1-2-二进制的数字表示\"><a href=\"#1-2-二进制的数字表示\" class=\"headerlink\" title=\"1.2 二进制的数字表示\"></a>1.2 二进制的数字表示</h3><p>二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:</p>\n<script type=\"math/tex; mode=display\">\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}</script><p>十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：</p>\n<ol>\n<li>-1的8位二进制按概念应是10000001，实际上为11111111</li>\n<li>-127的8位二进制按概念应是11111111，实际上为10000001<br/><br>因此我们需要注意下列计算机表示二进制的机器码。</li>\n</ol>\n<ul>\n<li>原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;</li>\n<li>反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;</li>\n<li>补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;</li>\n</ul>\n<p>使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。</p>\n<h3 id=\"1-3-十六进制—二进制的简化\"><a href=\"#1-3-十六进制—二进制的简化\" class=\"headerlink\" title=\"1.3 十六进制—二进制的简化\"></a>1.3 十六进制—二进制的简化</h3><p>由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1010</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">1011</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">B</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1100</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1101</td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1110</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">1111</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">F</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-4-位运算\"><a href=\"#1-4-位运算\" class=\"headerlink\" title=\"1.4 位运算\"></a>1.4 位运算</h5><ol>\n<li>左移(&lt;&lt;)：左移一位表示乘以2（高位舍去，右侧补0）；</li>\n<li>右移(&gt;&gt;)：右移一位表示除以2（低位舍去，高位按原先补充）；</li>\n</ol>\n<h5 id=\"1-5-查看浮点数的具体二进制形式\"><a href=\"#1-5-查看浮点数的具体二进制形式\" class=\"headerlink\" title=\"1.5 查看浮点数的具体二进制形式\"></a>1.5 查看浮点数的具体二进制形式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\">Integer.toBinaryString(Float.floatToIntBits(value));<br>Long.toBinaryString(Double.doubleToLongBits(value));<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-字符集与编码\"><a href=\"#2-字符集与编码\" class=\"headerlink\" title=\"2. 字符集与编码\"></a>2. 字符集与编码</h1><h5 id=\"2-1-非Unicode编码\"><a href=\"#2-1-非Unicode编码\" class=\"headerlink\" title=\"2.1 非Unicode编码\"></a>2.1 非Unicode编码</h5><ol>\n<li><strong>ASCII：</strong>覆盖键盘上的绝大多数的字符，对美国等英语国家够用；</li>\n<li><strong>ISO 8859-1：</strong> 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；</li>\n<li><strong>Windows-1252：</strong>在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；</li>\n<li><strong>GB2312：</strong>简体中文编码规范，使用两个字节表示汉字；</li>\n<li><strong>GBK：</strong>GB2312的扩充，支持更多的汉字编码；</li>\n<li><strong>GB18030：</strong>在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；</li>\n<li><strong>Big5：</strong>针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；</li>\n</ol>\n<h5 id=\"2-2-Unicode编码\"><a href=\"#2-2-Unicode编码\" class=\"headerlink\" title=\"2.2 Unicode编码\"></a>2.2 Unicode编码</h5><p>为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：</p>\n<ol>\n<li>UTF-32：字符编号的整数二进制形式，4字节</li>\n<li>UTF-16：变长字节表示，编号在U+0000~U+FFFF使用两字节；编号在U+10000~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；</li>\n<li>UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；</li>\n</ol>\n<h5 id=\"2-3-编码转换\"><a href=\"#2-3-编码转换\" class=\"headerlink\" title=\"2.3 编码转换\"></a>2.3 编码转换</h5><ol>\n<li>假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。<div class=\"code-wrapper\"><pre class=\"mermaid\">graph LR;\n 字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B</pre></div>\n\n</li>\n</ol>\n<p>编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。</p>\n<ol>\n<li>乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。</li>\n<li>乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。</li>\n<li>使用Java恢复乱码：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value to encdoe&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">newStr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(str.getBytes(<span class=\"hljs-string\">&quot;Windows-1252&quot;</span>), <span class=\"hljs-string\">&quot;GB18030&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":1956,"excerpt":"","more":"<h1 id=\"1-二进制—计算机表示数据的方式\"><a href=\"#1-二进制—计算机表示数据的方式\" class=\"headerlink\" title=\"1. 二进制—计算机表示数据的方式\"></a>1. 二进制—计算机表示数据的方式</h1><h3 id=\"1-1-十进制表示数的方式\"><a href=\"#1-1-十进制表示数的方式\" class=\"headerlink\" title=\"1.1 十进制表示数的方式\"></a>1.1 十进制表示数的方式</h3><ol>\n<li>以123来说，使用十进制表示可以写为:<br/></li>\n</ol>\n<script type=\"math/tex; mode=display\">\n123 = 1 \\times 10 ^2 + 2 \\times 10 ^1 + 3 \\times 10 ^ 0</script><ol>\n<li>按照类比规则推算，N进制数字abc有如下表示，其中k为位权：</li>\n</ol>\n<script type=\"math/tex; mode=display\">\nabc_{(N)} = a \\times k^m + b \\times k^{m-1} + c \\times k^{m-2} + ...</script><h3 id=\"1-2-二进制的数字表示\"><a href=\"#1-2-二进制的数字表示\" class=\"headerlink\" title=\"1.2 二进制的数字表示\"></a>1.2 二进制的数字表示</h3><p>二进制的位权为2，基本数字只有0和1，整好符合计算机的高低电平。因此十进制数4可以表示为:</p>\n<script type=\"math/tex; mode=display\">\n4_{(10)} = 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0 = 100_{(2)}</script><p>十进制的负数只需要在数字前面加上负号就表示负数了，而二进制的负数与十进制类似，在最高添加一个符号为，1表示负数，0表示整数，每种类型的数据都是最左边的一位。但负数实际上不是简单的给最高位设置符号。例如：</p>\n<ol>\n<li>-1的8位二进制按概念应是10000001，实际上为11111111</li>\n<li>-127的8位二进制按概念应是11111111，实际上为10000001<br/><br>因此我们需要注意下列计算机表示二进制的机器码。</li>\n</ol>\n<ul>\n<li>原码：符合我们==日常逻辑的编码==为原码：例如1的8位原码为<u>00000001</u>;</li>\n<li>反码：在==原码的基础上按位取反==为反码：例如<u>00000001</u>的反码为<u>11111110</u>;</li>\n<li>补码：在==反码的基础上再加1==就为补码：例如<u>00000001</u>的补码为<u>11111111</u>;</li>\n</ul>\n<p>使用补码表示是因为计算机只会计算加法，通过补码的表示计算机能够通过加法做减法运算。</p>\n<h3 id=\"1-3-十六进制—二进制的简化\"><a href=\"#1-3-十六进制—二进制的简化\" class=\"headerlink\" title=\"1.3 十六进制—二进制的简化\"></a>1.3 十六进制—二进制的简化</h3><p>由于二进制书写不方便，加上越大的数，二进制越长，因此使用16进制来替代二进制。十六进制的数字分别为(0~9、A[10]、B[11]、C[12]、D[13]、E[14]和F[15])</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">十六进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1010</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">1011</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">B</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1100</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">1101</td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1110</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">1111</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">F</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"1-4-位运算\"><a href=\"#1-4-位运算\" class=\"headerlink\" title=\"1.4 位运算\"></a>1.4 位运算</h5><ol>\n<li>左移(&lt;&lt;)：左移一位表示乘以2（高位舍去，右侧补0）；</li>\n<li>右移(&gt;&gt;)：右移一位表示除以2（低位舍去，高位按原先补充）；</li>\n</ol>\n<h5 id=\"1-5-查看浮点数的具体二进制形式\"><a href=\"#1-5-查看浮点数的具体二进制形式\" class=\"headerlink\" title=\"1.5 查看浮点数的具体二进制形式\"></a>1.5 查看浮点数的具体二进制形式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Integer.toBinaryString(Float.floatToIntBits(value));<br>Long.toBinaryString(Double.doubleToLongBits(value));<br></code></pre></td></tr></table></figure>\n<h1 id=\"2-字符集与编码\"><a href=\"#2-字符集与编码\" class=\"headerlink\" title=\"2. 字符集与编码\"></a>2. 字符集与编码</h1><h5 id=\"2-1-非Unicode编码\"><a href=\"#2-1-非Unicode编码\" class=\"headerlink\" title=\"2.1 非Unicode编码\"></a>2.1 非Unicode编码</h5><ol>\n<li><strong>ASCII：</strong>覆盖键盘上的绝大多数的字符，对美国等英语国家够用；</li>\n<li><strong>ISO 8859-1：</strong> 在ASCII码的基础上对支持的字符集进行了扩展，新增了西欧字符；</li>\n<li><strong>Windows-1252：</strong>在ISO 8859-1的基础上新增了欧元以及其他的符号，用途广泛；</li>\n<li><strong>GB2312：</strong>简体中文编码规范，使用两个字节表示汉字；</li>\n<li><strong>GBK：</strong>GB2312的扩充，支持更多的汉字编码；</li>\n<li><strong>GB18030：</strong>在GBK的基础上扩充更多汉字编码以及中日韩统一字符，使用2~4个字节表示字符；</li>\n<li><strong>Big5：</strong>针对繁体中文编码，用于中国香港、中国澳门和中国台湾地区；</li>\n</ol>\n<h5 id=\"2-2-Unicode编码\"><a href=\"#2-2-Unicode编码\" class=\"headerlink\" title=\"2.2 Unicode编码\"></a>2.2 Unicode编码</h5><p>为全世界的字符进行统一编码，它没有规定编码如何对应二进制表示。常用的字符二进制编码方案有如下几种：</p>\n<ol>\n<li>UTF-32：字符编号的整数二进制形式，4字节</li>\n<li>UTF-16：变长字节表示，编号在U+0000~U+FFFF使用两字节；编号在U+10000~U+10FFFF使用四字节。使用U+D800~U+DBFF的就是4字节，否则为2字节；</li>\n<li>UTF-8：依旧使用变长字节表示，每个字符使用的字节个数与Unicode编号的大小有关；</li>\n</ol>\n<h5 id=\"2-3-编码转换\"><a href=\"#2-3-编码转换\" class=\"headerlink\" title=\"2.3 编码转换\"></a>2.3 编码转换</h5><ol>\n<li>假设字符需要从编码A转换为编码B，那么首先需要知道字符所对应的编码A的格式，通过编码A的Unicode字符映射表找到其Unicode编号，然后通过Unicode编号再查找编码B的映射表。<pre class=\"mermaid\">graph LR;\n 字符s的编码A --> 字符s对应Unicode的序号 --> 字符s的编码B</pre>\n\n</li>\n</ol>\n<p>编码转换实际上只是改变了字符的二进制内容，但并没有改变字符看上去的样子。</p>\n<ol>\n<li>乱码的原因：要么是字符在不同的语言环境对应不同编码导致，要么是字符在错误的编码下又再次进行了转码导致无法恢复。</li>\n<li>乱码的解决：第一种情况比较简单，只需要换成对应的编码即可重新查看，第二种情况就是对错误的编码进行逆向操作，从而达到恢复原先编码的问题。</li>\n<li>使用Java恢复乱码：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;value to encdoe&quot;</span>;<br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">newStr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(str.getBytes(<span class=\"hljs-string\">&quot;Windows-1252&quot;</span>), <span class=\"hljs-string\">&quot;GB18030&quot;</span>);<br>System.out.println(newStr);<br></code></pre></td></tr></table></figure>"},{"title":"Java编程原理——面向对象基础","date":"2022-02-16T07:17:46.000Z","updated":"2022-02-16T07:17:46.000Z","_content":"\n# 1. 类的定义与理解\n## 1.1 容器的视角\n1. 函数是代码的容器，而类是函数的容器；\n2. 既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；\n3. 通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；\n\n## 1.2 数据类型的视角\n1. 类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；\n2. 一个表示数据类型的类可以由以下4部分构成\n- 以**类变量**体现出的类型本身具有的属性；\n- 以**类方法**体现出的类型本身具有的操作；\n- 以**实例变量**体现出的类型实例具有的属性；\n- 以**实例方法**体现出的类型实例具有的操作；\n\n```java\npublic class Point {\n    private int x; // 实例变量\n    private int y; // 实例变量\n    /* 实例方法 */\n    public double distance(){\n        return Math.sqrt(x * x + y * y);\n    }\n}\n```\n3. 通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；\n4. 一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；\n5. 静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；\n6. 构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；\n7. 一旦自定义构造函数，编译器将不再生成默认构造函数；\n\n## 1.3 私有构造函数\n使用私有构造函数存在于以下几个场景：\n1. 不能创建类的实例，类只能被静态访问；\n2. 能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；\n3. 只是用来被其他多个构造方法调用，用于减少重复代码；\n\n## 1.4 总结\n通过**类实现自定义数据类型**，封装该类型的数据所具有的属性和操作，**隐藏实现细节**，从而在更高层次（**类和对象层次**，而非基本数据类型和函数层次）上**考虑和操作数据**，是计算机程序解决复杂问题的一种重要的思维方式。\n\n## 1.5 将现实问题转化为面向对象的层次\n&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。\n\n# 2. 类的继承\n## 2.1 基本概念\n1. 使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；\n2. 不同子类的对象注重于实现自己的行为。\n\n## 2.2 有关继承的更多的细节\n1. 构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；\n2. 静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定\n3. 实例变量、静态变量、静态方法和private方法都是静态绑定的。\n4. 重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；\n\n## 2.3 类型转换与protected关键字\n1. 向上转型：子类型的对象赋值给父类型的引用变量；\n2. 向下转型：父类型的对象赋值给子类型的引用变量；\n3. protected关键字广泛用于模板方法模式中；\n4. 可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；\n5. 继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；\n\n# 3. 类加载的过程\n## 3.1 总览\n(1) 一个Java类所包含下列信息：\n- 静态变量\n- 类初始化代码\n- 静态方法\n- 实例变量\n- 实例初始化代码\n- 父类信息引用\n\n(2)类初始化代码包括\n- 定义静态变量时的赋值语句\n- 实例初始化代码块\n- 构造函数\n\n(3)类加载的过程\n- 分配内存以及保存类的信息\n- 给类变量赋默认值\n- 加载父类\n- 设置父子关系\n- 执行类初始化代码（先执行父类，再执行子类）\n\n## 3.2 对象创建的过程\n1. 每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；\n2. 寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；\n3. 动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；\n\n## 3.3 继承的破坏性——破坏封装\n1. 继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。\n2. 父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；\n3. 对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。\n\n## 3.4 继承的破坏性——没有反映\"is-a\"关系\n&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。\n\n## 3.5 最佳实践\n1. 避免使用继承——使用final关键字关闭继承；\n- 给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；\n2. 优先使用组合模式代替继承；\n- 组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；\n3. 使用接口；\n\n# 4. 接口\n## 4.1 本质\n1. 接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；\n2. 接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；\n3. 接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；\n\n## 4.2 Java 8和Java 9新增的接口函数：\n1. 新增静态方法，便于直接将函数定义在接口中；\n2. 默认方法，使用**default**关键字表示，有具体实现，引入默认方法主要是**函数式的数据处理请求**，为了给接口增加新功能；\n\n## 4.3 总结\n针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。\n\n# 5. 抽象类\n1. 相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。\n2. 抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)\n\n# 6. 内部类\n## 6.1 定义\n顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。\n\n## 6.2 内部类分类\n- 静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；\n1. Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；\n2. LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；\n3. Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；\n- 成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；\n1. Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。\n- 方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。\n\n```java\npublic class Outer {\n    public void test() {\n        final String[] str = new String[]{\"hello\"};\n        /* 方法内部类实例 */\n        class Inner {\n            public void innerMethod() {\n                str[0] = \"hello world\";\n            }\n        }\n        Inner inner = new Inner();\n        inner.innerMethod();\n        System.out.println(str[0]);\n    }\n}\n```\n- 匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。\n\n```java\npublic class Outer {\n    public void test(final int x, final int y) {\n        /* 匿名内部类示例 */\n        Point p = new Point(2, 3) {\n            @Override\n            public double distance() {\n                return distance(new Point(x, y));\n            }\n        };\n        System.out.println(p.distance());\n    }\n}\n```\nJava API使用中参见Arrays.sort函数。\n## 6.3 总结\n将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。\n\n# 7. 枚举\n## 7.1 使用枚举的好处\n1. 枚举使得语法更简洁；\n2. 枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；\n3. 枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；\n\n# 8. 异常\n## 8.1 基本概念\n1. throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；\n2. 异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。\n3. try-with-resource语法：\n\n```java\npublic static void useResource() throws Exception {\n    try(AutoClosable r = new FileInputStream(\"hello\")) { // 创建资源\n        // 使用资源\n    }\n}\n```\n4. 未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。\n\n## 8.2 异常的使用\n1. 真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；\n2. 异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；\n\n## 8.3 异常的处理逻辑\n1. 自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；\n2. 自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；\n3. 总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；\n\n## 8.4 总结\n通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。\n\n# 9. 基本类型的包装类以及String类型\n## 9.1 共性\n1. 均重写了Object类中的(equals，hashCode以及toString)方法；\n- equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；\n- hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；\n2. Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；\n3. 包装类和String\n4. 常用常量：包装类中包含一些常用的常量，例如布尔的**TRUE/FALSE**，整形中的**MIN_VALUE**和**MAX_VALUE**以及浮点中的**POSITIVE_INFINITY（正无穷）** 以及 **NEGATIVE_INFINITY（负无穷）**；\n5. 包装类中带有一个Number类型，可以返回任意基本数据类型；\n6. 不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；\n使用Immutable是因为可以使得程序更为简单和安全，在**多线程环境下不用担心数据会被篡改**；\n7. 包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；\n\n# 10. 单说String\n## 10.1 String类的一些特性\n1. String内部使用的是UTF-16BE模式编码；\n2. 同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。\n\n## 10.2 字符串常量\n1. 如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；\n2. 如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；\n\n## 10.3 StringBuilder与StringBuffer\n1. StringBuffer类是线程安全的，而StringBuilder是线程不安全的；\n2. append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。\n3. String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；\n\n# 11 Arrays类\n## 11.1 基本\n1. sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；\n2. Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；\n3. 总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。\n\n## 11.2 查找\n1. Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：\n```java\n// 针对基本类型\npublic static int binarySearch(int[] a, int key);\npublic static int binarySearch(int[] a, int fromIndex, int toIndex, int key);\n\n// 针对对象数组\npublic int static int binarySearch(Object[] a, Object key);\n\n// 自定义比较器\npublic static <T> int binarySearch(T[] a, T key, Comparator<? super T> c);\n```\n2. 需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；\n```java\n// 索引列表为数组下标：0, 1, 2, 3, 4\n// 插入点列表为：0, 1, 2, 3, 4\nint[] arr = {3, 5, 7, 13, 21};\nSystem.out.println(Arrays.binarySearch(arr, 3); // 0\nSystem.out.println(Arrays.binarySearch(arr, 5); // 1\nSystem.out.println(Arrays.binarySearch(arr, 7); // 2\nSystem.out.println(Arrays.binarySearch(arr, 13); // 3\nSystem.out.println(Arrays.binarySearch(arr, 21); // 4\nSystem.out.println(Arrays.binarySearch(arr, 22); // -6 (由21的插入点为5加1得到，再取负数)\nSystem.out.println(Arrays.binarySearch(arr, 2); // -1 (插在3的前面数插入点为0，再加1取负数得到)\n```\n\n3. 理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；\n\n4. 排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。\n\n# 12 时间处理\n## 12.1 基本概念：\n- 时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;\n- 时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；\n- 年历：例如中国的公历和年历、日本的农历等等；\n\n## 12.2 Java8之前的API支持\n- Date：时刻，绝对时间，与年月日无关；\n- Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；\n- TimeZone：表示时区\n- Locale：表示国家（或者地区）和语言；\n\n## 12.3 Java8之前的API局限性\n- Date中的过时方法有悖常识，因此容易被误用；\n- Calendar类操作繁琐，设计臃肿；\n- DateFormat不是线程安全的，在多线程环境中会存在问题；\n\n# 13 随机\n1. 种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；\n2. 指定种子是为了实现可重复的随机；\n","source":"_posts/java-core/ch03.md","raw":"---\ntitle: Java编程原理——面向对象基础\ndate: 2022-02-16 15:17:46\nupdated: 2022-02-16 15:17:46\ntags: Java基础\ncategories: Java\n---\n\n# 1. 类的定义与理解\n## 1.1 容器的视角\n1. 函数是代码的容器，而类是函数的容器；\n2. 既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；\n3. 通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；\n\n## 1.2 数据类型的视角\n1. 类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；\n2. 一个表示数据类型的类可以由以下4部分构成\n- 以**类变量**体现出的类型本身具有的属性；\n- 以**类方法**体现出的类型本身具有的操作；\n- 以**实例变量**体现出的类型实例具有的属性；\n- 以**实例方法**体现出的类型实例具有的操作；\n\n```java\npublic class Point {\n    private int x; // 实例变量\n    private int y; // 实例变量\n    /* 实例方法 */\n    public double distance(){\n        return Math.sqrt(x * x + y * y);\n    }\n}\n```\n3. 通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；\n4. 一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；\n5. 静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；\n6. 构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；\n7. 一旦自定义构造函数，编译器将不再生成默认构造函数；\n\n## 1.3 私有构造函数\n使用私有构造函数存在于以下几个场景：\n1. 不能创建类的实例，类只能被静态访问；\n2. 能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；\n3. 只是用来被其他多个构造方法调用，用于减少重复代码；\n\n## 1.4 总结\n通过**类实现自定义数据类型**，封装该类型的数据所具有的属性和操作，**隐藏实现细节**，从而在更高层次（**类和对象层次**，而非基本数据类型和函数层次）上**考虑和操作数据**，是计算机程序解决复杂问题的一种重要的思维方式。\n\n## 1.5 将现实问题转化为面向对象的层次\n&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。\n\n# 2. 类的继承\n## 2.1 基本概念\n1. 使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；\n2. 不同子类的对象注重于实现自己的行为。\n\n## 2.2 有关继承的更多的细节\n1. 构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；\n2. 静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定\n3. 实例变量、静态变量、静态方法和private方法都是静态绑定的。\n4. 重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；\n\n## 2.3 类型转换与protected关键字\n1. 向上转型：子类型的对象赋值给父类型的引用变量；\n2. 向下转型：父类型的对象赋值给子类型的引用变量；\n3. protected关键字广泛用于模板方法模式中；\n4. 可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；\n5. 继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；\n\n# 3. 类加载的过程\n## 3.1 总览\n(1) 一个Java类所包含下列信息：\n- 静态变量\n- 类初始化代码\n- 静态方法\n- 实例变量\n- 实例初始化代码\n- 父类信息引用\n\n(2)类初始化代码包括\n- 定义静态变量时的赋值语句\n- 实例初始化代码块\n- 构造函数\n\n(3)类加载的过程\n- 分配内存以及保存类的信息\n- 给类变量赋默认值\n- 加载父类\n- 设置父子关系\n- 执行类初始化代码（先执行父类，再执行子类）\n\n## 3.2 对象创建的过程\n1. 每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；\n2. 寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；\n3. 动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；\n\n## 3.3 继承的破坏性——破坏封装\n1. 继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。\n2. 父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；\n3. 对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。\n\n## 3.4 继承的破坏性——没有反映\"is-a\"关系\n&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。\n\n## 3.5 最佳实践\n1. 避免使用继承——使用final关键字关闭继承；\n- 给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；\n2. 优先使用组合模式代替继承；\n- 组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；\n3. 使用接口；\n\n# 4. 接口\n## 4.1 本质\n1. 接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；\n2. 接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；\n3. 接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；\n\n## 4.2 Java 8和Java 9新增的接口函数：\n1. 新增静态方法，便于直接将函数定义在接口中；\n2. 默认方法，使用**default**关键字表示，有具体实现，引入默认方法主要是**函数式的数据处理请求**，为了给接口增加新功能；\n\n## 4.3 总结\n针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。\n\n# 5. 抽象类\n1. 相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。\n2. 抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)\n\n# 6. 内部类\n## 6.1 定义\n顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。\n\n## 6.2 内部类分类\n- 静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；\n1. Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；\n2. LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；\n3. Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；\n- 成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；\n1. Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。\n- 方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。\n\n```java\npublic class Outer {\n    public void test() {\n        final String[] str = new String[]{\"hello\"};\n        /* 方法内部类实例 */\n        class Inner {\n            public void innerMethod() {\n                str[0] = \"hello world\";\n            }\n        }\n        Inner inner = new Inner();\n        inner.innerMethod();\n        System.out.println(str[0]);\n    }\n}\n```\n- 匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。\n\n```java\npublic class Outer {\n    public void test(final int x, final int y) {\n        /* 匿名内部类示例 */\n        Point p = new Point(2, 3) {\n            @Override\n            public double distance() {\n                return distance(new Point(x, y));\n            }\n        };\n        System.out.println(p.distance());\n    }\n}\n```\nJava API使用中参见Arrays.sort函数。\n## 6.3 总结\n将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。\n\n# 7. 枚举\n## 7.1 使用枚举的好处\n1. 枚举使得语法更简洁；\n2. 枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；\n3. 枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；\n\n# 8. 异常\n## 8.1 基本概念\n1. throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；\n2. 异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。\n3. try-with-resource语法：\n\n```java\npublic static void useResource() throws Exception {\n    try(AutoClosable r = new FileInputStream(\"hello\")) { // 创建资源\n        // 使用资源\n    }\n}\n```\n4. 未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。\n\n## 8.2 异常的使用\n1. 真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；\n2. 异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；\n\n## 8.3 异常的处理逻辑\n1. 自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；\n2. 自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；\n3. 总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；\n\n## 8.4 总结\n通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。\n\n# 9. 基本类型的包装类以及String类型\n## 9.1 共性\n1. 均重写了Object类中的(equals，hashCode以及toString)方法；\n- equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；\n- hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；\n2. Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；\n3. 包装类和String\n4. 常用常量：包装类中包含一些常用的常量，例如布尔的**TRUE/FALSE**，整形中的**MIN_VALUE**和**MAX_VALUE**以及浮点中的**POSITIVE_INFINITY（正无穷）** 以及 **NEGATIVE_INFINITY（负无穷）**；\n5. 包装类中带有一个Number类型，可以返回任意基本数据类型；\n6. 不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；\n使用Immutable是因为可以使得程序更为简单和安全，在**多线程环境下不用担心数据会被篡改**；\n7. 包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；\n\n# 10. 单说String\n## 10.1 String类的一些特性\n1. String内部使用的是UTF-16BE模式编码；\n2. 同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。\n\n## 10.2 字符串常量\n1. 如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；\n2. 如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；\n\n## 10.3 StringBuilder与StringBuffer\n1. StringBuffer类是线程安全的，而StringBuilder是线程不安全的；\n2. append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。\n3. String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；\n\n# 11 Arrays类\n## 11.1 基本\n1. sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；\n2. Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；\n3. 总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。\n\n## 11.2 查找\n1. Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：\n```java\n// 针对基本类型\npublic static int binarySearch(int[] a, int key);\npublic static int binarySearch(int[] a, int fromIndex, int toIndex, int key);\n\n// 针对对象数组\npublic int static int binarySearch(Object[] a, Object key);\n\n// 自定义比较器\npublic static <T> int binarySearch(T[] a, T key, Comparator<? super T> c);\n```\n2. 需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；\n```java\n// 索引列表为数组下标：0, 1, 2, 3, 4\n// 插入点列表为：0, 1, 2, 3, 4\nint[] arr = {3, 5, 7, 13, 21};\nSystem.out.println(Arrays.binarySearch(arr, 3); // 0\nSystem.out.println(Arrays.binarySearch(arr, 5); // 1\nSystem.out.println(Arrays.binarySearch(arr, 7); // 2\nSystem.out.println(Arrays.binarySearch(arr, 13); // 3\nSystem.out.println(Arrays.binarySearch(arr, 21); // 4\nSystem.out.println(Arrays.binarySearch(arr, 22); // -6 (由21的插入点为5加1得到，再取负数)\nSystem.out.println(Arrays.binarySearch(arr, 2); // -1 (插在3的前面数插入点为0，再加1取负数得到)\n```\n\n3. 理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；\n\n4. 排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。\n\n# 12 时间处理\n## 12.1 基本概念：\n- 时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;\n- 时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；\n- 年历：例如中国的公历和年历、日本的农历等等；\n\n## 12.2 Java8之前的API支持\n- Date：时刻，绝对时间，与年月日无关；\n- Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；\n- TimeZone：表示时区\n- Locale：表示国家（或者地区）和语言；\n\n## 12.3 Java8之前的API局限性\n- Date中的过时方法有悖常识，因此容易被误用；\n- Calendar类操作繁琐，设计臃肿；\n- DateFormat不是线程安全的，在多线程环境中会存在问题；\n\n# 13 随机\n1. 种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；\n2. 指定种子是为了实现可重复的随机；\n","slug":"java-core/ch03","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2k00062y613y7k6c9w","content":"<h1 id=\"1-类的定义与理解\"><a href=\"#1-类的定义与理解\" class=\"headerlink\" title=\"1. 类的定义与理解\"></a>1. 类的定义与理解</h1><h2 id=\"1-1-容器的视角\"><a href=\"#1-1-容器的视角\" class=\"headerlink\" title=\"1.1 容器的视角\"></a>1.1 容器的视角</h2><ol>\n<li>函数是代码的容器，而类是函数的容器；</li>\n<li>既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；</li>\n<li>通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；</li>\n</ol>\n<h2 id=\"1-2-数据类型的视角\"><a href=\"#1-2-数据类型的视角\" class=\"headerlink\" title=\"1.2 数据类型的视角\"></a>1.2 数据类型的视角</h2><ol>\n<li>类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；</li>\n<li>一个表示数据类型的类可以由以下4部分构成</li>\n</ol>\n<ul>\n<li>以<strong>类变量</strong>体现出的类型本身具有的属性；</li>\n<li>以<strong>类方法</strong>体现出的类型本身具有的操作；</li>\n<li>以<strong>实例变量</strong>体现出的类型实例具有的属性；</li>\n<li>以<strong>实例方法</strong>体现出的类型实例具有的操作；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> y; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-comment\">/* 实例方法 */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> Math.sqrt(x * x + y * y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；</li>\n<li>一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；</li>\n<li>静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；</li>\n<li>构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；</li>\n<li>一旦自定义构造函数，编译器将不再生成默认构造函数；</li>\n</ol>\n<h2 id=\"1-3-私有构造函数\"><a href=\"#1-3-私有构造函数\" class=\"headerlink\" title=\"1.3 私有构造函数\"></a>1.3 私有构造函数</h2><p>使用私有构造函数存在于以下几个场景：</p>\n<ol>\n<li>不能创建类的实例，类只能被静态访问；</li>\n<li>能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；</li>\n<li>只是用来被其他多个构造方法调用，用于减少重复代码；</li>\n</ol>\n<h2 id=\"1-4-总结\"><a href=\"#1-4-总结\" class=\"headerlink\" title=\"1.4 总结\"></a>1.4 总结</h2><p>通过<strong>类实现自定义数据类型</strong>，封装该类型的数据所具有的属性和操作，<strong>隐藏实现细节</strong>，从而在更高层次（<strong>类和对象层次</strong>，而非基本数据类型和函数层次）上<strong>考虑和操作数据</strong>，是计算机程序解决复杂问题的一种重要的思维方式。</p>\n<h2 id=\"1-5-将现实问题转化为面向对象的层次\"><a href=\"#1-5-将现实问题转化为面向对象的层次\" class=\"headerlink\" title=\"1.5 将现实问题转化为面向对象的层次\"></a>1.5 将现实问题转化为面向对象的层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。</p>\n<h1 id=\"2-类的继承\"><a href=\"#2-类的继承\" class=\"headerlink\" title=\"2. 类的继承\"></a>2. 类的继承</h1><h2 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h2><ol>\n<li>使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；</li>\n<li>不同子类的对象注重于实现自己的行为。</li>\n</ol>\n<h2 id=\"2-2-有关继承的更多的细节\"><a href=\"#2-2-有关继承的更多的细节\" class=\"headerlink\" title=\"2.2 有关继承的更多的细节\"></a>2.2 有关继承的更多的细节</h2><ol>\n<li>构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；</li>\n<li>静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定</li>\n<li>实例变量、静态变量、静态方法和private方法都是静态绑定的。</li>\n<li>重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；</li>\n</ol>\n<h2 id=\"2-3-类型转换与protected关键字\"><a href=\"#2-3-类型转换与protected关键字\" class=\"headerlink\" title=\"2.3 类型转换与protected关键字\"></a>2.3 类型转换与protected关键字</h2><ol>\n<li>向上转型：子类型的对象赋值给父类型的引用变量；</li>\n<li>向下转型：父类型的对象赋值给子类型的引用变量；</li>\n<li>protected关键字广泛用于模板方法模式中；</li>\n<li>可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；</li>\n<li>继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；</li>\n</ol>\n<h1 id=\"3-类加载的过程\"><a href=\"#3-类加载的过程\" class=\"headerlink\" title=\"3. 类加载的过程\"></a>3. 类加载的过程</h1><h2 id=\"3-1-总览\"><a href=\"#3-1-总览\" class=\"headerlink\" title=\"3.1 总览\"></a>3.1 总览</h2><p>(1) 一个Java类所包含下列信息：</p>\n<ul>\n<li>静态变量</li>\n<li>类初始化代码</li>\n<li>静态方法</li>\n<li>实例变量</li>\n<li>实例初始化代码</li>\n<li>父类信息引用</li>\n</ul>\n<p>(2)类初始化代码包括</p>\n<ul>\n<li>定义静态变量时的赋值语句</li>\n<li>实例初始化代码块</li>\n<li>构造函数</li>\n</ul>\n<p>(3)类加载的过程</p>\n<ul>\n<li>分配内存以及保存类的信息</li>\n<li>给类变量赋默认值</li>\n<li>加载父类</li>\n<li>设置父子关系</li>\n<li>执行类初始化代码（先执行父类，再执行子类）</li>\n</ul>\n<h2 id=\"3-2-对象创建的过程\"><a href=\"#3-2-对象创建的过程\" class=\"headerlink\" title=\"3.2 对象创建的过程\"></a>3.2 对象创建的过程</h2><ol>\n<li>每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；</li>\n<li>寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；</li>\n<li>动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；</li>\n</ol>\n<h2 id=\"3-3-继承的破坏性——破坏封装\"><a href=\"#3-3-继承的破坏性——破坏封装\" class=\"headerlink\" title=\"3.3 继承的破坏性——破坏封装\"></a>3.3 继承的破坏性——破坏封装</h2><ol>\n<li>继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。</li>\n<li>父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；</li>\n<li>对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</li>\n</ol>\n<h2 id=\"3-4-继承的破坏性——没有反映”is-a”关系\"><a href=\"#3-4-继承的破坏性——没有反映”is-a”关系\" class=\"headerlink\" title=\"3.4 继承的破坏性——没有反映”is-a”关系\"></a>3.4 继承的破坏性——没有反映”is-a”关系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。</p>\n<h2 id=\"3-5-最佳实践\"><a href=\"#3-5-最佳实践\" class=\"headerlink\" title=\"3.5 最佳实践\"></a>3.5 最佳实践</h2><ol>\n<li>避免使用继承——使用final关键字关闭继承；</li>\n</ol>\n<ul>\n<li>给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；</li>\n</ul>\n<ol>\n<li>优先使用组合模式代替继承；</li>\n</ol>\n<ul>\n<li>组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；</li>\n</ul>\n<ol>\n<li>使用接口；</li>\n</ol>\n<h1 id=\"4-接口\"><a href=\"#4-接口\" class=\"headerlink\" title=\"4. 接口\"></a>4. 接口</h1><h2 id=\"4-1-本质\"><a href=\"#4-1-本质\" class=\"headerlink\" title=\"4.1 本质\"></a>4.1 本质</h2><ol>\n<li>接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；</li>\n<li>接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；</li>\n<li>接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；</li>\n</ol>\n<h2 id=\"4-2-Java-8和Java-9新增的接口函数：\"><a href=\"#4-2-Java-8和Java-9新增的接口函数：\" class=\"headerlink\" title=\"4.2 Java 8和Java 9新增的接口函数：\"></a>4.2 Java 8和Java 9新增的接口函数：</h2><ol>\n<li>新增静态方法，便于直接将函数定义在接口中；</li>\n<li>默认方法，使用<strong>default</strong>关键字表示，有具体实现，引入默认方法主要是<strong>函数式的数据处理请求</strong>，为了给接口增加新功能；</li>\n</ol>\n<h2 id=\"4-3-总结\"><a href=\"#4-3-总结\" class=\"headerlink\" title=\"4.3 总结\"></a>4.3 总结</h2><p>针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。</p>\n<h1 id=\"5-抽象类\"><a href=\"#5-抽象类\" class=\"headerlink\" title=\"5. 抽象类\"></a>5. 抽象类</h1><ol>\n<li>相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。</li>\n<li>抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)</li>\n</ol>\n<h1 id=\"6-内部类\"><a href=\"#6-内部类\" class=\"headerlink\" title=\"6. 内部类\"></a>6. 内部类</h1><h2 id=\"6-1-定义\"><a href=\"#6-1-定义\" class=\"headerlink\" title=\"6.1 定义\"></a>6.1 定义</h2><p>顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。</p>\n<h2 id=\"6-2-内部类分类\"><a href=\"#6-2-内部类分类\" class=\"headerlink\" title=\"6.2 内部类分类\"></a>6.2 内部类分类</h2><ul>\n<li>静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；</li>\n</ul>\n<ol>\n<li>Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；</li>\n<li>LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；</li>\n<li>Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；</li>\n</ol>\n<ul>\n<li>成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；</li>\n</ul>\n<ol>\n<li>Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。</li>\n</ol>\n<ul>\n<li>方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> String[] str = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello&quot;</span>&#125;;<br>        <span class=\"hljs-comment\">/* 方法内部类实例 */</span><br>        <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Inner</span> &#123;<br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">innerMethod</span><span class=\"hljs-params\">()</span> &#123;<br>                str[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">Inner</span> <span class=\"hljs-variable\">inner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Inner</span>();<br>        inner.innerMethod();<br>        System.out.println(str[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> x, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> y)</span> &#123;<br>        <span class=\"hljs-comment\">/* 匿名内部类示例 */</span><br>        <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> distance(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(x, y));<br>            &#125;<br>        &#125;;<br>        System.out.println(p.distance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Java API使用中参见Arrays.sort函数。</p>\n<h2 id=\"6-3-总结\"><a href=\"#6-3-总结\" class=\"headerlink\" title=\"6.3 总结\"></a>6.3 总结</h2><p>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。</p>\n<h1 id=\"7-枚举\"><a href=\"#7-枚举\" class=\"headerlink\" title=\"7. 枚举\"></a>7. 枚举</h1><h2 id=\"7-1-使用枚举的好处\"><a href=\"#7-1-使用枚举的好处\" class=\"headerlink\" title=\"7.1 使用枚举的好处\"></a>7.1 使用枚举的好处</h2><ol>\n<li>枚举使得语法更简洁；</li>\n<li>枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；</li>\n<li>枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；</li>\n</ol>\n<h1 id=\"8-异常\"><a href=\"#8-异常\" class=\"headerlink\" title=\"8. 异常\"></a>8. 异常</h1><h2 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h2><ol>\n<li>throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；</li>\n<li>异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。</li>\n<li>try-with-resource语法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useResource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>    <span class=\"hljs-keyword\">try</span>(<span class=\"hljs-type\">AutoClosable</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>)) &#123; <span class=\"hljs-comment\">// 创建资源</span><br>        <span class=\"hljs-comment\">// 使用资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。</li>\n</ol>\n<h2 id=\"8-2-异常的使用\"><a href=\"#8-2-异常的使用\" class=\"headerlink\" title=\"8.2 异常的使用\"></a>8.2 异常的使用</h2><ol>\n<li>真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；</li>\n<li>异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；</li>\n</ol>\n<h2 id=\"8-3-异常的处理逻辑\"><a href=\"#8-3-异常的处理逻辑\" class=\"headerlink\" title=\"8.3 异常的处理逻辑\"></a>8.3 异常的处理逻辑</h2><ol>\n<li>自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；</li>\n<li>自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；</li>\n<li>总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；</li>\n</ol>\n<h2 id=\"8-4-总结\"><a href=\"#8-4-总结\" class=\"headerlink\" title=\"8.4 总结\"></a>8.4 总结</h2><p>通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。</p>\n<h1 id=\"9-基本类型的包装类以及String类型\"><a href=\"#9-基本类型的包装类以及String类型\" class=\"headerlink\" title=\"9. 基本类型的包装类以及String类型\"></a>9. 基本类型的包装类以及String类型</h1><h2 id=\"9-1-共性\"><a href=\"#9-1-共性\" class=\"headerlink\" title=\"9.1 共性\"></a>9.1 共性</h2><ol>\n<li>均重写了Object类中的(equals，hashCode以及toString)方法；</li>\n</ol>\n<ul>\n<li>equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；</li>\n<li>hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；</li>\n</ul>\n<ol>\n<li>Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；</li>\n<li>包装类和String</li>\n<li>常用常量：包装类中包含一些常用的常量，例如布尔的<strong>TRUE/FALSE</strong>，整形中的<strong>MIN_VALUE</strong>和<strong>MAX_VALUE</strong>以及浮点中的<strong>POSITIVE_INFINITY（正无穷）</strong> 以及 <strong>NEGATIVE_INFINITY（负无穷）</strong>；</li>\n<li>包装类中带有一个Number类型，可以返回任意基本数据类型；</li>\n<li>不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；<br>使用Immutable是因为可以使得程序更为简单和安全，在<strong>多线程环境下不用担心数据会被篡改</strong>；</li>\n<li>包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；</li>\n</ol>\n<h1 id=\"10-单说String\"><a href=\"#10-单说String\" class=\"headerlink\" title=\"10. 单说String\"></a>10. 单说String</h1><h2 id=\"10-1-String类的一些特性\"><a href=\"#10-1-String类的一些特性\" class=\"headerlink\" title=\"10.1 String类的一些特性\"></a>10.1 String类的一些特性</h2><ol>\n<li>String内部使用的是UTF-16BE模式编码；</li>\n<li>同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。</li>\n</ol>\n<h2 id=\"10-2-字符串常量\"><a href=\"#10-2-字符串常量\" class=\"headerlink\" title=\"10.2 字符串常量\"></a>10.2 字符串常量</h2><ol>\n<li>如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；</li>\n<li>如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；</li>\n</ol>\n<h2 id=\"10-3-StringBuilder与StringBuffer\"><a href=\"#10-3-StringBuilder与StringBuffer\" class=\"headerlink\" title=\"10.3 StringBuilder与StringBuffer\"></a>10.3 StringBuilder与StringBuffer</h2><ol>\n<li>StringBuffer类是线程安全的，而StringBuilder是线程不安全的；</li>\n<li>append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。</li>\n<li>String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；</li>\n</ol>\n<h1 id=\"11-Arrays类\"><a href=\"#11-Arrays类\" class=\"headerlink\" title=\"11 Arrays类\"></a>11 Arrays类</h1><h2 id=\"11-1-基本\"><a href=\"#11-1-基本\" class=\"headerlink\" title=\"11.1 基本\"></a>11.1 基本</h2><ol>\n<li>sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；</li>\n<li>Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；</li>\n<li>总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。</li>\n</ol>\n<h2 id=\"11-2-查找\"><a href=\"#11-2-查找\" class=\"headerlink\" title=\"11.2 查找\"></a>11.2 查找</h2><ol>\n<li>Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 针对基本类型</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> key)</span>;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> fromIndex, <span class=\"hljs-type\">int</span> toIndex, <span class=\"hljs-type\">int</span> key)</span>;<br><br><span class=\"hljs-comment\">// 针对对象数组</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(Object[] a, Object key)</span>;<br><br><span class=\"hljs-comment\">// 自定义比较器</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(T[] a, T key, Comparator&lt;? <span class=\"hljs-built_in\">super</span> T&gt; c)</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 索引列表为数组下标：0, 1, 2, 3, 4</span><br><span class=\"hljs-comment\">// 插入点列表为：0, 1, 2, 3, 4</span><br><span class=\"hljs-type\">int</span>[] arr = &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">21</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 0</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 1</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 2</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">13</span>); <span class=\"hljs-comment\">// 3</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">21</span>); <span class=\"hljs-comment\">// 4</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">22</span>); <span class=\"hljs-comment\">// -6 (由21的插入点为5加1得到，再取负数)</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// -1 (插在3的前面数插入点为0，再加1取负数得到)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；</p>\n</li>\n<li><p>排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。</p>\n</li>\n</ol>\n<h1 id=\"12-时间处理\"><a href=\"#12-时间处理\" class=\"headerlink\" title=\"12 时间处理\"></a>12 时间处理</h1><h2 id=\"12-1-基本概念：\"><a href=\"#12-1-基本概念：\" class=\"headerlink\" title=\"12.1 基本概念：\"></a>12.1 基本概念：</h2><ul>\n<li>时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;</li>\n<li>时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；</li>\n<li>年历：例如中国的公历和年历、日本的农历等等；</li>\n</ul>\n<h2 id=\"12-2-Java8之前的API支持\"><a href=\"#12-2-Java8之前的API支持\" class=\"headerlink\" title=\"12.2 Java8之前的API支持\"></a>12.2 Java8之前的API支持</h2><ul>\n<li>Date：时刻，绝对时间，与年月日无关；</li>\n<li>Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；</li>\n<li>TimeZone：表示时区</li>\n<li>Locale：表示国家（或者地区）和语言；</li>\n</ul>\n<h2 id=\"12-3-Java8之前的API局限性\"><a href=\"#12-3-Java8之前的API局限性\" class=\"headerlink\" title=\"12.3 Java8之前的API局限性\"></a>12.3 Java8之前的API局限性</h2><ul>\n<li>Date中的过时方法有悖常识，因此容易被误用；</li>\n<li>Calendar类操作繁琐，设计臃肿；</li>\n<li>DateFormat不是线程安全的，在多线程环境中会存在问题；</li>\n</ul>\n<h1 id=\"13-随机\"><a href=\"#13-随机\" class=\"headerlink\" title=\"13 随机\"></a>13 随机</h1><ol>\n<li>种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；</li>\n<li>指定种子是为了实现可重复的随机；</li>\n</ol>\n","site":{"data":{}},"wordcount":7748,"excerpt":"","more":"<h1 id=\"1-类的定义与理解\"><a href=\"#1-类的定义与理解\" class=\"headerlink\" title=\"1. 类的定义与理解\"></a>1. 类的定义与理解</h1><h2 id=\"1-1-容器的视角\"><a href=\"#1-1-容器的视角\" class=\"headerlink\" title=\"1.1 容器的视角\"></a>1.1 容器的视角</h2><ol>\n<li>函数是代码的容器，而类是函数的容器；</li>\n<li>既然类是函数的容器，应当既可以对外暴露相应的行为和操作，也可以屏蔽相应的动作和行为防止误用；</li>\n<li>通过private关键字封装和隐藏函数的内部细节，避免被误操作，是计算机程序中的基本思维方式；</li>\n</ol>\n<h2 id=\"1-2-数据类型的视角\"><a href=\"#1-2-数据类型的视角\" class=\"headerlink\" title=\"1.2 数据类型的视角\"></a>1.2 数据类型的视角</h2><ol>\n<li>类也可以看作为自定义数据类型，一个数据类型包含其基本定义以及操作；</li>\n<li>一个表示数据类型的类可以由以下4部分构成</li>\n</ol>\n<ul>\n<li>以<strong>类变量</strong>体现出的类型本身具有的属性；</li>\n<li>以<strong>类方法</strong>体现出的类型本身具有的操作；</li>\n<li>以<strong>实例变量</strong>体现出的类型实例具有的属性；</li>\n<li>以<strong>实例方法</strong>体现出的类型实例具有的操作；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> y; <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-comment\">/* 实例方法 */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> Math.sqrt(x * x + y * y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过对象来访问和操作函数内部的数据是一种基本的面向对象思维；</li>\n<li>一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作；</li>\n<li>静态初始化代码块在类加载的时候执行，该步骤实在任何对象创建之前，且只执行一次；</li>\n<li>构造函数与类名相同，并且不带有返回值，构造函数隐式返回的就是实例本身；</li>\n<li>一旦自定义构造函数，编译器将不再生成默认构造函数；</li>\n</ol>\n<h2 id=\"1-3-私有构造函数\"><a href=\"#1-3-私有构造函数\" class=\"headerlink\" title=\"1.3 私有构造函数\"></a>1.3 私有构造函数</h2><p>使用私有构造函数存在于以下几个场景：</p>\n<ol>\n<li>不能创建类的实例，类只能被静态访问；</li>\n<li>能创建类的实例，但是只能够通过类的静态方法调用（也是单例模式常用的情景）；</li>\n<li>只是用来被其他多个构造方法调用，用于减少重复代码；</li>\n</ol>\n<h2 id=\"1-4-总结\"><a href=\"#1-4-总结\" class=\"headerlink\" title=\"1.4 总结\"></a>1.4 总结</h2><p>通过<strong>类实现自定义数据类型</strong>，封装该类型的数据所具有的属性和操作，<strong>隐藏实现细节</strong>，从而在更高层次（<strong>类和对象层次</strong>，而非基本数据类型和函数层次）上<strong>考虑和操作数据</strong>，是计算机程序解决复杂问题的一种重要的思维方式。</p>\n<h2 id=\"1-5-将现实问题转化为面向对象的层次\"><a href=\"#1-5-将现实问题转化为面向对象的层次\" class=\"headerlink\" title=\"1.5 将现实问题转化为面向对象的层次\"></a>1.5 将现实问题转化为面向对象的层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;设想现实问题的概念以及其所包含的属性、行为，再理清概念之间的关系，然后再定义类、属性、方法以及类与类之间的关系。概念属性和行为可能非常多，但是定义的类只需要包括与现实生活相关的问题即可。<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;分解现实问题中涉及的概念以及概念之间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念之间的关系，是计算机程序的一种基本思维方式。</p>\n<h1 id=\"2-类的继承\"><a href=\"#2-类的继承\" class=\"headerlink\" title=\"2. 类的继承\"></a>2. 类的继承</h1><h2 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h2><ol>\n<li>使用继承可以复用代码，公共属性和行为可以放至父类中，而子类只需要关注自身特有的行为即可；</li>\n<li>不同子类的对象注重于实现自己的行为。</li>\n</ol>\n<h2 id=\"2-2-有关继承的更多的细节\"><a href=\"#2-2-有关继承的更多的细节\" class=\"headerlink\" title=\"2.2 有关继承的更多的细节\"></a>2.2 有关继承的更多的细节</h2><ol>\n<li>构造函数：由于子类继承父类需要重写父类的构造函数，如果父类构造函数调用可被子类重写的方法，则可能导致混淆，应当只调用private方法；</li>\n<li>静态绑定是在程序编译期间决定的，而动态绑定需要等到程序运行时才决定</li>\n<li>实例变量、静态变量、静态方法和private方法都是静态绑定的。</li>\n<li>重载是指方法名称相同但是参数签名不同，重写是指子类重写父类相同参数签名的方法；函数的重写是动态绑定的；</li>\n</ol>\n<h2 id=\"2-3-类型转换与protected关键字\"><a href=\"#2-3-类型转换与protected关键字\" class=\"headerlink\" title=\"2.3 类型转换与protected关键字\"></a>2.3 类型转换与protected关键字</h2><ol>\n<li>向上转型：子类型的对象赋值给父类型的引用变量；</li>\n<li>向下转型：父类型的对象赋值给子类型的引用变量；</li>\n<li>protected关键字广泛用于模板方法模式中；</li>\n<li>可见性重写：子类重写父类方法时不降低父类方法的可见性，这样的规定是由于子类和父类属于“is-a”关系，子类必须支持父类所有对外的行为，降低可见性将导致子类对外的行为减少；</li>\n<li>继承所带来负面影响就在于有时候我们不希望子类去复写父类的一些方法，因此可以通过final关键字实现；</li>\n</ol>\n<h1 id=\"3-类加载的过程\"><a href=\"#3-类加载的过程\" class=\"headerlink\" title=\"3. 类加载的过程\"></a>3. 类加载的过程</h1><h2 id=\"3-1-总览\"><a href=\"#3-1-总览\" class=\"headerlink\" title=\"3.1 总览\"></a>3.1 总览</h2><p>(1) 一个Java类所包含下列信息：</p>\n<ul>\n<li>静态变量</li>\n<li>类初始化代码</li>\n<li>静态方法</li>\n<li>实例变量</li>\n<li>实例初始化代码</li>\n<li>父类信息引用</li>\n</ul>\n<p>(2)类初始化代码包括</p>\n<ul>\n<li>定义静态变量时的赋值语句</li>\n<li>实例初始化代码块</li>\n<li>构造函数</li>\n</ul>\n<p>(3)类加载的过程</p>\n<ul>\n<li>分配内存以及保存类的信息</li>\n<li>给类变量赋默认值</li>\n<li>加载父类</li>\n<li>设置父子关系</li>\n<li>执行类初始化代码（先执行父类，再执行子类）</li>\n</ul>\n<h2 id=\"3-2-对象创建的过程\"><a href=\"#3-2-对象创建的过程\" class=\"headerlink\" title=\"3.2 对象创建的过程\"></a>3.2 对象创建的过程</h2><ol>\n<li>每个对象除了保存着类的实例变量外，还保存着实际类信息的引用；</li>\n<li>寻找要执行的实例方法时，是从对象的实际类型信息开始找，找不到再去父类信息中寻找；</li>\n<li>动态绑定实际就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类；</li>\n</ol>\n<h2 id=\"3-3-继承的破坏性——破坏封装\"><a href=\"#3-3-继承的破坏性——破坏封装\" class=\"headerlink\" title=\"3.3 继承的破坏性——破坏封装\"></a>3.3 继承的破坏性——破坏封装</h2><ol>\n<li>继承使用不当会造成破坏。首先，当父类和子类存在实现细节上的依赖则可能出现破坏封装的行为，如果子类不知道基类实现方法的实现细节，则子类无法正确地进行扩展。</li>\n<li>父类不能随意增加公开方法，因为给父类增加方法就是给子类增加方法，而子类可能必须要重写该方法才能确保方法的正确性；</li>\n<li>对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏，而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由。</li>\n</ol>\n<h2 id=\"3-4-继承的破坏性——没有反映”is-a”关系\"><a href=\"#3-4-继承的破坏性——没有反映”is-a”关系\" class=\"headerlink\" title=\"3.4 继承的破坏性——没有反映”is-a”关系\"></a>3.4 继承的破坏性——没有反映”is-a”关系</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;按照继承的语义来说，父类拥有的行为，子类也应该有。然而在生活中的例子总有特殊。例如鸟都是会飞的，但是企鹅也属于鸟，但是不会飞。因此父类约束子类的行为在日常中并不能完全保证。</p>\n<h2 id=\"3-5-最佳实践\"><a href=\"#3-5-最佳实践\" class=\"headerlink\" title=\"3.5 最佳实践\"></a>3.5 最佳实践</h2><ol>\n<li>避免使用继承——使用final关键字关闭继承；</li>\n</ol>\n<ul>\n<li>给父类方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由；</li>\n</ul>\n<ol>\n<li>优先使用组合模式代替继承；</li>\n</ol>\n<ul>\n<li>组合替代继承，使得父类的行为不在对外暴露，子类也可以实现自己的逻辑，互不影响；</li>\n</ul>\n<ol>\n<li>使用接口；</li>\n</ol>\n<h1 id=\"4-接口\"><a href=\"#4-接口\" class=\"headerlink\" title=\"4. 接口\"></a>4. 接口</h1><h2 id=\"4-1-本质\"><a href=\"#4-1-本质\" class=\"headerlink\" title=\"4.1 本质\"></a>4.1 本质</h2><ol>\n<li>接口是声明能力的一种方式，其只是一个对对象而言需要遵守的规定。从而衍生出一种新的计算机思维：面向接口编程；</li>\n<li>接口更重要的意义在于降低了代码间的耦合，挺高了代码的灵活性；</li>\n<li>接口可以多继承，也可以继承是实现并行，但是关键字==extends==要放在==implements==前面；</li>\n</ol>\n<h2 id=\"4-2-Java-8和Java-9新增的接口函数：\"><a href=\"#4-2-Java-8和Java-9新增的接口函数：\" class=\"headerlink\" title=\"4.2 Java 8和Java 9新增的接口函数：\"></a>4.2 Java 8和Java 9新增的接口函数：</h2><ol>\n<li>新增静态方法，便于直接将函数定义在接口中；</li>\n<li>默认方法，使用<strong>default</strong>关键字表示，有具体实现，引入默认方法主要是<strong>函数式的数据处理请求</strong>，为了给接口增加新功能；</li>\n</ol>\n<h2 id=\"4-3-总结\"><a href=\"#4-3-总结\" class=\"headerlink\" title=\"4.3 总结\"></a>4.3 总结</h2><p>针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具。</p>\n<h1 id=\"5-抽象类\"><a href=\"#5-抽象类\" class=\"headerlink\" title=\"5. 抽象类\"></a>5. 抽象类</h1><ol>\n<li>相对于具体类而言，抽象类具有抽象的方法，可以用于表达抽象的概念。</li>\n<li>抽象类和接口是配合而非替代关系，两者经常一起使用。接口声明能力，抽象类提供默认实现，实现全部或者部分方法，一个接口经常有一个对应的抽象类。（参见Collection接口对应的AbstractCollection)</li>\n</ol>\n<h1 id=\"6-内部类\"><a href=\"#6-内部类\" class=\"headerlink\" title=\"6. 内部类\"></a>6. 内部类</h1><h2 id=\"6-1-定义\"><a href=\"#6-1-定义\" class=\"headerlink\" title=\"6.1 定义\"></a>6.1 定义</h2><p>顾名思义为定义外部类内部的类称之为内部类，通过内部类可以实现对外部的完全隐藏，可以得到更好的封装性。代码实现上也会更加简洁。内部类也可以很方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏。相关代码写在一起，写法也会更加简洁。</p>\n<h2 id=\"6-2-内部类分类\"><a href=\"#6-2-内部类分类\" class=\"headerlink\" title=\"6.2 内部类分类\"></a>6.2 内部类分类</h2><ul>\n<li>静态内部类：带有static关键字的内部类，如果静态内部类与外部类关系密切，且不依赖于外部实例，则可以考虑定义静态内部类；</li>\n</ul>\n<ol>\n<li>Java API中Integer类内部的IntegerCache类，用于支持整数的自动装箱；</li>\n<li>LinkedList类内部有一个私有静态内部类Node，用于表示链中的每个节点；</li>\n<li>Character类内部有public的UnicodeBlock，用于表示一个UnicodeBlock；</li>\n</ol>\n<ul>\n<li>成员内部类：无任何修饰符的内部类，成员内部类对象总是与一个外部对象相连；如果内部类和外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回该接口，外部类方法可能使用内部类实现该接口。这个内部类就可以设置为private，对外完全隐藏；</li>\n</ul>\n<ol>\n<li>Java API中的LinkedList类中，listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表进行遍历，listIterator和descendingIterator内部分别使用成员内部类ListItr和DescendingIterator。</li>\n</ol>\n<ul>\n<li>方法内部类：定义在方法体中的类，方法内部类可以直接访问外部类的变量以及方法（取决于是静态的还是实例的）。实际上方法内部类操作的并不是外部的变量，而是它自己的实例变量。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">final</span> String[] str = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello&quot;</span>&#125;;<br>        <span class=\"hljs-comment\">/* 方法内部类实例 */</span><br>        <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Inner</span> &#123;<br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">innerMethod</span><span class=\"hljs-params\">()</span> &#123;<br>                str[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">Inner</span> <span class=\"hljs-variable\">inner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Inner</span>();<br>        inner.innerMethod();<br>        System.out.println(str[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>匿名内部类：没有具体类名关联，使用new关键字临时创建的类成为匿名内部类；匿名内部类只能被使用一次，用来创建一个对象，没有构造函数，但是可以根据参数列表调用对应父类构造方法，也可以定义实例变量和方法，可以初始化代码块。匿名内部类能做的，方法内部类都可以实现，只不过是用匿名内部类在实现上显得更加简洁一些。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> x, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> y)</span> &#123;<br>        <span class=\"hljs-comment\">/* 匿名内部类示例 */</span><br>        <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span> &#123;<br>                <span class=\"hljs-keyword\">return</span> distance(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(x, y));<br>            &#125;<br>        &#125;;<br>        System.out.println(p.distance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Java API使用中参见Arrays.sort函数。</p>\n<h2 id=\"6-3-总结\"><a href=\"#6-3-总结\" class=\"headerlink\" title=\"6.3 总结\"></a>6.3 总结</h2><p>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行写作，是计算机程序中的一种常见实践。匿名内部类是实现回调接口的一种简便方式。</p>\n<h1 id=\"7-枚举\"><a href=\"#7-枚举\" class=\"headerlink\" title=\"7. 枚举\"></a>7. 枚举</h1><h2 id=\"7-1-使用枚举的好处\"><a href=\"#7-1-使用枚举的好处\" class=\"headerlink\" title=\"7.1 使用枚举的好处\"></a>7.1 使用枚举的好处</h2><ol>\n<li>枚举使得语法更简洁；</li>\n<li>枚举更安全，一个枚举类型的变量，值要么为null，要么为具体枚举值；</li>\n<li>枚举自带便利方法（例如values以及valueOf和toString方法），易于使用；</li>\n</ol>\n<h1 id=\"8-异常\"><a href=\"#8-异常\" class=\"headerlink\" title=\"8. 异常\"></a>8. 异常</h1><h2 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h2><ol>\n<li>throw关键字表示异常退出，因此出现异常的地方，后续代码都不会执行；</li>\n<li>异常处理机制会从当前函数开始查找谁能“捕获”该异常，当前函数无法捕获则查看上一层，直至主函数。如果主函数也没有则启用默认机制。即输出至控制台。</li>\n<li>try-with-resource语法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">useResource</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>    <span class=\"hljs-keyword\">try</span>(<span class=\"hljs-type\">AutoClosable</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>)) &#123; <span class=\"hljs-comment\">// 创建资源</span><br>        <span class=\"hljs-comment\">// 使用资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>未受检异常表示编程的逻辑错误，编程过程中应当检查以避免这种错误。无论是受检异常还是未受检异常，无论是出现在throws关键字声明中，都应该在合适的地方以适当的方式进行处理。</li>\n</ol>\n<h2 id=\"8-2-异常的使用\"><a href=\"#8-2-异常的使用\" class=\"headerlink\" title=\"8.2 异常的使用\"></a>8.2 异常的使用</h2><ol>\n<li>真正出现异常的时候，应当抛出异常，而不是返回一个特殊值；</li>\n<li>异常处理分报告恢复，报告时需说明异常出现的原因以及正确输入的范例或者格式；</li>\n</ol>\n<h2 id=\"8-3-异常的处理逻辑\"><a href=\"#8-3-异常的处理逻辑\" class=\"headerlink\" title=\"8.3 异常的处理逻辑\"></a>8.3 异常的处理逻辑</h2><ol>\n<li>自己能处理的异常由自己处理，如果可通过程序自动解决的就不需要向上报告了，直接自动解决；</li>\n<li>自己不能完全解决的，就向上报告，如果自己有额外的信息提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常；</li>\n<li>总有一层代码需要为异常负责，可能是知道处理异常的代码，也可能是面向用户的代码，也可能是主程序。如果异常不能自动解决，对于用户而言需要提供对用户有用以及有帮助的信息；对于运维人员应该输出详细的异常链和异常栈日志；</li>\n</ol>\n<h2 id=\"8-4-总结\"><a href=\"#8-4-总结\" class=\"headerlink\" title=\"8.4 总结\"></a>8.4 总结</h2><p>通过异常机制可以将程序正常逻辑和异常逻辑进行分离，异常情况可以集中处理，也可以自动传递。不需要每层方法都进行处理，异常也不能被自动忽略。从而处理异常的代码可以大大减少，代码的可读性、可靠性以及可维护性也会增加。</p>\n<h1 id=\"9-基本类型的包装类以及String类型\"><a href=\"#9-基本类型的包装类以及String类型\" class=\"headerlink\" title=\"9. 基本类型的包装类以及String类型\"></a>9. 基本类型的包装类以及String类型</h1><h2 id=\"9-1-共性\"><a href=\"#9-1-共性\" class=\"headerlink\" title=\"9.1 共性\"></a>9.1 共性</h2><ol>\n<li>均重写了Object类中的(equals，hashCode以及toString)方法；</li>\n</ol>\n<ul>\n<li>equals：表示两个数值在逻辑上的相等，而非地址上的相等，因此需要重写；</li>\n<li>hashCode：返回对象的哈希值，hashCode反映的是其在内存中的地址相同，一般equals和hashCode都需要一起重写；</li>\n</ul>\n<ol>\n<li>Comparable接口，用于比较大小，在小于、等于和大于的时分别返回-1，0和1；</li>\n<li>包装类和String</li>\n<li>常用常量：包装类中包含一些常用的常量，例如布尔的<strong>TRUE/FALSE</strong>，整形中的<strong>MIN_VALUE</strong>和<strong>MAX_VALUE</strong>以及浮点中的<strong>POSITIVE_INFINITY（正无穷）</strong> 以及 <strong>NEGATIVE_INFINITY（负无穷）</strong>；</li>\n<li>包装类中带有一个Number类型，可以返回任意基本数据类型；</li>\n<li>不可变性：包装类和String声明都是final的，无法被继承；并且内部基本类型都是私有final的，并且无setter方法；<br>使用Immutable是因为可以使得程序更为简单和安全，在<strong>多线程环境下不用担心数据会被篡改</strong>；</li>\n<li>包装类中存在一个Cache的静态内部类，用于缓存共享常量以节约内存空间，借用了享元模式；</li>\n</ol>\n<h1 id=\"10-单说String\"><a href=\"#10-单说String\" class=\"headerlink\" title=\"10. 单说String\"></a>10. 单说String</h1><h2 id=\"10-1-String类的一些特性\"><a href=\"#10-1-String类的一些特性\" class=\"headerlink\" title=\"10.1 String类的一些特性\"></a>10.1 String类的一些特性</h2><ol>\n<li>String内部使用的是UTF-16BE模式编码；</li>\n<li>同其他包装类一样，String类使用的也是不可变对象，对象一旦创建将不可再更改；定义不可变类，程序更加简洁，安全以及容易理解。但如果频繁更改字符串则会导致性能底下。</li>\n</ol>\n<h2 id=\"10-2-字符串常量\"><a href=\"#10-2-字符串常量\" class=\"headerlink\" title=\"10.2 字符串常量\"></a>10.2 字符串常量</h2><ol>\n<li>如果通过字符串常量赋值，则两个String对象的内存地址都是指向同一块的；</li>\n<li>如果是通过new的方式创建出来的字符串对象在内存中实际上两个不同的对象，因此所在的内存地址是不相同的；</li>\n</ol>\n<h2 id=\"10-3-StringBuilder与StringBuffer\"><a href=\"#10-3-StringBuilder与StringBuffer\" class=\"headerlink\" title=\"10.3 StringBuilder与StringBuffer\"></a>10.3 StringBuilder与StringBuffer</h2><ol>\n<li>StringBuffer类是线程安全的，而StringBuilder是线程不安全的；</li>\n<li>append方法使用了一种类似于指数分配长度的策略。在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中。</li>\n<li>String支持+，+=运算。由Java编译器提供支持，其会将该运算符转换成append操作；</li>\n</ol>\n<h1 id=\"11-Arrays类\"><a href=\"#11-Arrays类\" class=\"headerlink\" title=\"11 Arrays类\"></a>11 Arrays类</h1><h2 id=\"11-1-基本\"><a href=\"#11-1-基本\" class=\"headerlink\" title=\"11.1 基本\"></a>11.1 基本</h2><ol>\n<li>sort排序：可以使用sort排序，默认返回从小到大排序，基本类型可以直接使用，对象类型需要实现Comparator接口，可以使用Java8的lambda表达式简化语法；</li>\n<li>Comparator接口可以接收Collections接口中的reverse或者reverseOrder方法；</li>\n<li>总结：传递比较器Comparator给sort方法，体现了程序设计中的一种重要方式。将不变以及变化进行分离，排序的基本步骤和算法是保持不变的。将不变的算法作为主体，而将变化的部分设计成参数，允许调用者动态绑定。也是一种常见的设计模式。</li>\n</ol>\n<h2 id=\"11-2-查找\"><a href=\"#11-2-查找\" class=\"headerlink\" title=\"11.2 查找\"></a>11.2 查找</h2><ol>\n<li>Arrays方法支持很多种查找方法，包括二分查找，使用方法如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 针对基本类型</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> key)</span>;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a, <span class=\"hljs-type\">int</span> fromIndex, <span class=\"hljs-type\">int</span> toIndex, <span class=\"hljs-type\">int</span> key)</span>;<br><br><span class=\"hljs-comment\">// 针对对象数组</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(Object[] a, Object key)</span>;<br><br><span class=\"hljs-comment\">// 自定义比较器</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">binarySearch</span><span class=\"hljs-params\">(T[] a, T key, Comparator&lt;? <span class=\"hljs-built_in\">super</span> T&gt; c)</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>需要说明的是二分查找若能找到相应的数值，返回的是其所在的索引，数值为正数；否则返回插入点的数值+1并且为负数；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 索引列表为数组下标：0, 1, 2, 3, 4</span><br><span class=\"hljs-comment\">// 插入点列表为：0, 1, 2, 3, 4</span><br><span class=\"hljs-type\">int</span>[] arr = &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">21</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 0</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 1</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 2</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">13</span>); <span class=\"hljs-comment\">// 3</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">21</span>); <span class=\"hljs-comment\">// 4</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">22</span>); <span class=\"hljs-comment\">// -6 (由21的插入点为5加1得到，再取负数)</span><br>System.out.println(Arrays.binarySearch(arr, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// -1 (插在3的前面数插入点为0，再加1取负数得到)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>理解多维数组：多维数组本质上还是一个一维数组，只是每个数组元素都可以再放一个数组，这样就构成了所谓的“多维数组”；其中对于多维数组会包括一个deepXXX的方法；</p>\n</li>\n<li><p>排序算法：对于基本数据类型，Java采用的是“双枢轴快速排序”算法；而对于对象类型，使用的是TimSort（Java 7引进），而TimSort实际上是对归并排序做了一系列优化。</p>\n</li>\n</ol>\n<h1 id=\"12-时间处理\"><a href=\"#12-时间处理\" class=\"headerlink\" title=\"12 时间处理\"></a>12 时间处理</h1><h2 id=\"12-1-基本概念：\"><a href=\"#12-1-基本概念：\" class=\"headerlink\" title=\"12.1 基本概念：\"></a>12.1 基本概念：</h2><ul>\n<li>时区：GMT为格林尼治标准时间，全球共分为24时区，中国在东八区，因此也成为GMT+8;</li>\n<li>时刻和纪元时：按照计算机规定：1970年1月1日的0时0分0秒称之为纪元时；</li>\n<li>年历：例如中国的公历和年历、日本的农历等等；</li>\n</ul>\n<h2 id=\"12-2-Java8之前的API支持\"><a href=\"#12-2-Java8之前的API支持\" class=\"headerlink\" title=\"12.2 Java8之前的API支持\"></a>12.2 Java8之前的API支持</h2><ul>\n<li>Date：时刻，绝对时间，与年月日无关；</li>\n<li>Calenda：年历，为抽象类；表示公历的子类为Gregorian-Calendar；</li>\n<li>TimeZone：表示时区</li>\n<li>Locale：表示国家（或者地区）和语言；</li>\n</ul>\n<h2 id=\"12-3-Java8之前的API局限性\"><a href=\"#12-3-Java8之前的API局限性\" class=\"headerlink\" title=\"12.3 Java8之前的API局限性\"></a>12.3 Java8之前的API局限性</h2><ul>\n<li>Date中的过时方法有悖常识，因此容易被误用；</li>\n<li>Calendar类操作繁琐，设计臃肿；</li>\n<li>DateFormat不是线程安全的，在多线程环境中会存在问题；</li>\n</ul>\n<h1 id=\"13-随机\"><a href=\"#13-随机\" class=\"headerlink\" title=\"13 随机\"></a>13 随机</h1><ol>\n<li>种子决定了随机序列的产生，种子相同，产生的随机数序列就是相同的；</li>\n<li>指定种子是为了实现可重复的随机；</li>\n</ol>\n"},{"title":"Java编程原理——泛型和容器","date":"2022-02-16T11:52:26.000Z","updated":"2022-02-16T11:52:26.000Z","_content":"\n# 1 泛型\n\n## 1.1 基本概念\n\n1. 泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；\n2. Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；\n3. 泛型可以指定上限为某个具体类，例如：\n\n```java\npublic class NumberPair<U extends Number, V extends Number> extends Pair<U, V>{\n    public NumberPair(U first, V second) {\n        super(first, second);\n    }\n}\n```\n\n1. 除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；\n2. 总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。\n\n\n\n## 1.2 通配符解析\n\n1. 参数类型限定通配符写法。例如：public void addAll(DynamicArray<? extends E> c), **<? exntends E>也称为有限定通配符**；\n2. 与之相对应的就为无限定通配符，具体为：Dynamic<?>，更简洁的写法就为<T>\n3. 但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；\n4. 通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；\n5. 通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；\n6. 如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；\n7. 通配符形式和类型参数往往配合使用；\n\n\n\n## 1.3 超类型通配符\n\n1. 形式：<? super E>，用于表示E的某个父类类型；\n2. 使用场景：对于有限通配符形式<? extends E>在无法满足工作需要时，可以使用<? super E>代替；\n3. <? super E>用于灵活写入或比较，<?>或<? exntends E>用于灵活读取；\n\n\n\n## 1.4 局限性\n\n1. 基本类型不能用于实例化类型参数；\n2. 运行时类型信息不适用泛型；\n3. 类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；\n4. 不能通过类型参数创建对象；\n5. 泛型类类型参数不能用于创建静态变量和方法；\n6. 不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；\n7. 如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；\n8. 泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；\n\n\n\n# 2 列表和队列\n\n## 2.1 ArrayList\n\n1. ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；\n2. ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；\n3. 迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。\n\n```java\n/* 错误写法 */\npublic void remove(ArrayList<Integer> list) {\n    for (Integer a : list) {\n        if (a < 100) {\n            list.remove(a); // 恐抛出ConcurrentModificationException\n        }\n    }\n}\n\n/* 正确写法 */\npublic void remove(ArrayList<Integer> list) {\n    Iterator<Integer> it = list.iterator();\n    while(it.hasNext()) {\n        if (it.next() < 100) {\n            it.remove();\n        }\n    }\n}\n```\n\n1. 使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。\n2. ArrayList的特点\n\n+ 随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；\n+ 除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；\n+ 添加数组元素的效率为O(N)；\n+ 插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；\n+ 需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；\n\n\n\n## 2.2 LinkedList\n\n1. LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；\n2. LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"a\");\nqueue.offer(\"b\");\nqueue.offer(\"c\");\nwhile(queue.peek() != null) {\n    System.out.println(queue.poll());\n}\n```\n\n1. LinkedList也可以当作栈使用，示例如下：\n\n```java\nDeque<String> stack = new LinkedList<>();\nstack.push(\"a\");\nstack.push(\"b\");\nstack.push(\"c\");\nwhile(stack.peek() != null) {\n    System.out.println(stack.pop());\n}\n```\n\n1. LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；\n2. LinkedList的特点如下：\n\n+ 按需分配空间，不需要预先分配很多空间；\n+ 不可随机访问，按照索引位置访问效率较低；\n+ 无论列表是否有序，按内容查找都需要逐个查找；\n+ 在两端进行添加、删除操作效率很高；\n\n\n\n## 2.3 ArrayDeque\n\n1. ArrayDeque是基于数组实现的双端队列\n2. ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。\n3. 由于是双端队列因此具备下列特点：\n\n+ 在两端添加和删除的效率很高；\n+ 根据元素的内容查找和删除的效率很低；\n+ 与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。\n\n\n\n# 3 Map和Set\n\n## 3.1 HashMap\n\n1. 创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12\n2. 创建Map保存数据的几个步骤分别为：\n\n+ (1) 计算键的哈希值；\n+ (2) 根据哈希值得到保存位置（取模）；\n+ (3) 插到对应位置的链表表头或者更新已有值；\n+ (4) 根据扩展table大小，注意这里的table是Entry类型；\n\n1. 总结HashMap的实现原理\n\n+ HashMap内部有一个哈希表，每个元素指向一个单链表；\n+ 根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；\n+ 存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较\n+ HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；\n+ HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；\n\n\n\n## 3.2 HashSet\n\n1. Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；\n2. HashSet有下列应用场景\n\n+ 排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；\n+ 保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；\n+ 集合运算：方便进行数学中的交集以及并集的集合运算；\n\n1. HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；\n2. 总结HashSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效的添加、删除元素、判断元素是否存在；\n+ 没有顺序；\n\n\n\n## 3.3 TreeMap或TreeSet\n\n1. 与HashMap无序相对比，TreeMap是有序的。\n2. TreeMap内部使用的是[红黑树](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin)实现的；\n3. TreeMap的特点如下\n\n+ 按键有序：可以很方便地根据键的顺序进行查找\n+ 为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；\n+ 根据键值保存、查找、删除的效率比较高；\n\n1. 总结TreeSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效地添加、删除元素、判断元素是否存在；\n+ 有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；\n\n\n\n## 3.4 LinkedHashMap\n\n1. LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；\n2. LinkedHashMap是有序的，例子如下(插入顺序)：\n\n```java\nMap<String, Integer> seqMap = new LinkedHashMap<>();\nseqMap.put(\"c\", 100);\nseqMap.put(\"d\", 200);\nseqMap.put(\"a\", 500);\nseqMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : seqMap.entrySet()) {\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is :\nc 100\nd 300\na 500\n*/\n```\n\n1. LinkedHashMap的访问顺序：\n\n```java\nMap<String, Integer> accessMap = new LinkedHashMap<>(16, 0.75, true);\naccessMap.put(\"c\", 100);\naccessMap.put(\"d\", 200);\naccessMap.put(\"a\", 500);\naccessMap.get(\"c\");\naccessMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : accessMap.getEntrySet()){\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is : \na 500\nc 100\nd 300\n*/\n```\n\n1. LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：\n\n```java\n// 实现代码\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private int maxEntries;\n    public LRUCache(int maxEntries) {\n        super(16, 0.75f, true);\n        this.maxEntries = maxEntries;\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Entry<K, V> eldest) {\n        return size() > maxEntries;\n    }\n}\n// 使用示例\nLRUCache<String, Object> cache = new LRUCache<>(3);\ncache.put(\"a\", \"abstract\");\ncache.put(\"b\", \"basic\");\ncache.put(\"c\", \"call\");\ncache.get(\"a\");\ncache.put(\"d\", \"call\");\nSystem.out.println(cache);\n\n// 输出结果\n{c=call, a=abstract, d=call}\n```\n\n\n\n## 3.5 EnumMap\n\n1. 键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；\n2. EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：\n\n```java\npublic enum Size {\n    SMALL, MEDIUM, LARGE\n}\n\npublic class Clothes {\n    String id;\n    Size size;\n}\n\npublic static Map<Size, Integer> countBySize(List<Clothes> clothes) {\n    Map<Size, Integer> map = new EnumMap<>(Size.class);\n    for (Clothes c : clothes) {\n        Size size = c.getSize();\n        Integer count = map.get(size);\n        if (count != null) {\n            map.put(size, count + 1);\n        } else {\n            map.put(size, 1);\n        }\n    }\n    return map;\n}\n```\n\n1. EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。\n2. EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；\n3. 位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。\n4. 对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。\n\n\n\n# 4 堆与优先级队列\n\n## 4.1 完全二叉树\n\n1. 完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其**父节点**和**孩子节点**的编号。**例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 \\* i，右孩子节点编号为2 \\* i + 1;**\n2. 基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；\n\n\n\n## 4.2 PriorityQueue\n\n1. PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：\n\n```java\nstatic class Task {\n    int priority; // 数值越大，优先级越高\n    String name; // 表示任务的名称\n    \n    private static Comparator<Task> taskComparator = new Comparator() {\n        @Override\n        public int compare(Task o1, Task o2) {\n            if (o1.getPriority() > o2.getPriority()) {\n                return -1;\n            } else if (o1.getPriority() < o2.getPriority()){\n                return 1;\n            }\n            return 0;\n        }\n    }\n}\n\nQueue<Task> tasks = new Priority<>(11, taskComparator);\ntasks.offer(new Task(20, \"写日记\"));\ntasks.offer(new Task(10, \"看电视\"));\ntasks.offer(new Task(100, \"写代码\"));\nTask task = tasks.poll();\nwhile (task != null) {\n    System.out.print(\"处理任务：\" + task.getName() + \", 优先级：\" + task.getPriority());\n    task = tasks.poll();\n}\n// 结果如下：\n处理任务：写代码，优先级：100\n处理任务：写日记，优先级：20\n处理任务：看电视，优先级：10\n```\n\n1. PriorityQueue有如下特点：\n\n+ 实现了优先级队列，最先出队的总是优先级最高的；\n+ 优先级相同时，内部元素不完全有序；\n+ 查询头部元素效率很高，入队、出队效率很高；\n+ 根据值查找和删除元素效率很低\n+ 具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；\n\n\n\n# 5 通用容器类\n\n1. Collections提供了很多针对容器接口的通用算法和功能；\n2. 容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；\n3. 容器类中运用了大量的适配器模式\n\n+ 空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）\n+ 单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）\n+ 其他适配方法，例如将Map转换为Set等。\n\n1. 基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；\n","source":"_posts/java-core/ch04.md","raw":"---\ntitle: Java编程原理——泛型和容器\ndate: 2022-02-16 19:52:26\nupdated: 2022-02-16 19:52:26\ntags: Java基础\ncategories: Java\n---\n\n# 1 泛型\n\n## 1.1 基本概念\n\n1. 泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；\n2. Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；\n3. 泛型可以指定上限为某个具体类，例如：\n\n```java\npublic class NumberPair<U extends Number, V extends Number> extends Pair<U, V>{\n    public NumberPair(U first, V second) {\n        super(first, second);\n    }\n}\n```\n\n1. 除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；\n2. 总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。\n\n\n\n## 1.2 通配符解析\n\n1. 参数类型限定通配符写法。例如：public void addAll(DynamicArray<? extends E> c), **<? exntends E>也称为有限定通配符**；\n2. 与之相对应的就为无限定通配符，具体为：Dynamic<?>，更简洁的写法就为<T>\n3. 但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；\n4. 通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；\n5. 通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；\n6. 如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；\n7. 通配符形式和类型参数往往配合使用；\n\n\n\n## 1.3 超类型通配符\n\n1. 形式：<? super E>，用于表示E的某个父类类型；\n2. 使用场景：对于有限通配符形式<? extends E>在无法满足工作需要时，可以使用<? super E>代替；\n3. <? super E>用于灵活写入或比较，<?>或<? exntends E>用于灵活读取；\n\n\n\n## 1.4 局限性\n\n1. 基本类型不能用于实例化类型参数；\n2. 运行时类型信息不适用泛型；\n3. 类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；\n4. 不能通过类型参数创建对象；\n5. 泛型类类型参数不能用于创建静态变量和方法；\n6. 不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；\n7. 如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；\n8. 泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；\n\n\n\n# 2 列表和队列\n\n## 2.1 ArrayList\n\n1. ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；\n2. ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；\n3. 迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。\n\n```java\n/* 错误写法 */\npublic void remove(ArrayList<Integer> list) {\n    for (Integer a : list) {\n        if (a < 100) {\n            list.remove(a); // 恐抛出ConcurrentModificationException\n        }\n    }\n}\n\n/* 正确写法 */\npublic void remove(ArrayList<Integer> list) {\n    Iterator<Integer> it = list.iterator();\n    while(it.hasNext()) {\n        if (it.next() < 100) {\n            it.remove();\n        }\n    }\n}\n```\n\n1. 使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。\n2. ArrayList的特点\n\n+ 随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；\n+ 除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；\n+ 添加数组元素的效率为O(N)；\n+ 插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；\n+ 需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；\n\n\n\n## 2.2 LinkedList\n\n1. LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；\n2. LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"a\");\nqueue.offer(\"b\");\nqueue.offer(\"c\");\nwhile(queue.peek() != null) {\n    System.out.println(queue.poll());\n}\n```\n\n1. LinkedList也可以当作栈使用，示例如下：\n\n```java\nDeque<String> stack = new LinkedList<>();\nstack.push(\"a\");\nstack.push(\"b\");\nstack.push(\"c\");\nwhile(stack.peek() != null) {\n    System.out.println(stack.pop());\n}\n```\n\n1. LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；\n2. LinkedList的特点如下：\n\n+ 按需分配空间，不需要预先分配很多空间；\n+ 不可随机访问，按照索引位置访问效率较低；\n+ 无论列表是否有序，按内容查找都需要逐个查找；\n+ 在两端进行添加、删除操作效率很高；\n\n\n\n## 2.3 ArrayDeque\n\n1. ArrayDeque是基于数组实现的双端队列\n2. ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。\n3. 由于是双端队列因此具备下列特点：\n\n+ 在两端添加和删除的效率很高；\n+ 根据元素的内容查找和删除的效率很低；\n+ 与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。\n\n\n\n# 3 Map和Set\n\n## 3.1 HashMap\n\n1. 创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12\n2. 创建Map保存数据的几个步骤分别为：\n\n+ (1) 计算键的哈希值；\n+ (2) 根据哈希值得到保存位置（取模）；\n+ (3) 插到对应位置的链表表头或者更新已有值；\n+ (4) 根据扩展table大小，注意这里的table是Entry类型；\n\n1. 总结HashMap的实现原理\n\n+ HashMap内部有一个哈希表，每个元素指向一个单链表；\n+ 根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；\n+ 存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较\n+ HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；\n+ HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；\n\n\n\n## 3.2 HashSet\n\n1. Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；\n2. HashSet有下列应用场景\n\n+ 排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；\n+ 保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；\n+ 集合运算：方便进行数学中的交集以及并集的集合运算；\n\n1. HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；\n2. 总结HashSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效的添加、删除元素、判断元素是否存在；\n+ 没有顺序；\n\n\n\n## 3.3 TreeMap或TreeSet\n\n1. 与HashMap无序相对比，TreeMap是有序的。\n2. TreeMap内部使用的是[红黑树](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin)实现的；\n3. TreeMap的特点如下\n\n+ 按键有序：可以很方便地根据键的顺序进行查找\n+ 为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；\n+ 根据键值保存、查找、删除的效率比较高；\n\n1. 总结TreeSet的特点有如下几个：\n\n+ 没有重复元素；\n+ 可以高效地添加、删除元素、判断元素是否存在；\n+ 有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；\n\n\n\n## 3.4 LinkedHashMap\n\n1. LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；\n2. LinkedHashMap是有序的，例子如下(插入顺序)：\n\n```java\nMap<String, Integer> seqMap = new LinkedHashMap<>();\nseqMap.put(\"c\", 100);\nseqMap.put(\"d\", 200);\nseqMap.put(\"a\", 500);\nseqMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : seqMap.entrySet()) {\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is :\nc 100\nd 300\na 500\n*/\n```\n\n1. LinkedHashMap的访问顺序：\n\n```java\nMap<String, Integer> accessMap = new LinkedHashMap<>(16, 0.75, true);\naccessMap.put(\"c\", 100);\naccessMap.put(\"d\", 200);\naccessMap.put(\"a\", 500);\naccessMap.get(\"c\");\naccessMap.put(\"d\", 300);\nfor (Entry<String, Integer> entry : accessMap.getEntrySet()){\n    System.out.println(entry.getKey() + \" \" + entry.getValue());\n}\n/*\nResult is : \na 500\nc 100\nd 300\n*/\n```\n\n1. LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：\n\n```java\n// 实现代码\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private int maxEntries;\n    public LRUCache(int maxEntries) {\n        super(16, 0.75f, true);\n        this.maxEntries = maxEntries;\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Entry<K, V> eldest) {\n        return size() > maxEntries;\n    }\n}\n// 使用示例\nLRUCache<String, Object> cache = new LRUCache<>(3);\ncache.put(\"a\", \"abstract\");\ncache.put(\"b\", \"basic\");\ncache.put(\"c\", \"call\");\ncache.get(\"a\");\ncache.put(\"d\", \"call\");\nSystem.out.println(cache);\n\n// 输出结果\n{c=call, a=abstract, d=call}\n```\n\n\n\n## 3.5 EnumMap\n\n1. 键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；\n2. EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：\n\n```java\npublic enum Size {\n    SMALL, MEDIUM, LARGE\n}\n\npublic class Clothes {\n    String id;\n    Size size;\n}\n\npublic static Map<Size, Integer> countBySize(List<Clothes> clothes) {\n    Map<Size, Integer> map = new EnumMap<>(Size.class);\n    for (Clothes c : clothes) {\n        Size size = c.getSize();\n        Integer count = map.get(size);\n        if (count != null) {\n            map.put(size, count + 1);\n        } else {\n            map.put(size, 1);\n        }\n    }\n    return map;\n}\n```\n\n1. EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。\n2. EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；\n3. 位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。\n4. 对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。\n\n\n\n# 4 堆与优先级队列\n\n## 4.1 完全二叉树\n\n1. 完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其**父节点**和**孩子节点**的编号。**例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 \\* i，右孩子节点编号为2 \\* i + 1;**\n2. 基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；\n\n\n\n## 4.2 PriorityQueue\n\n1. PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：\n\n```java\nstatic class Task {\n    int priority; // 数值越大，优先级越高\n    String name; // 表示任务的名称\n    \n    private static Comparator<Task> taskComparator = new Comparator() {\n        @Override\n        public int compare(Task o1, Task o2) {\n            if (o1.getPriority() > o2.getPriority()) {\n                return -1;\n            } else if (o1.getPriority() < o2.getPriority()){\n                return 1;\n            }\n            return 0;\n        }\n    }\n}\n\nQueue<Task> tasks = new Priority<>(11, taskComparator);\ntasks.offer(new Task(20, \"写日记\"));\ntasks.offer(new Task(10, \"看电视\"));\ntasks.offer(new Task(100, \"写代码\"));\nTask task = tasks.poll();\nwhile (task != null) {\n    System.out.print(\"处理任务：\" + task.getName() + \", 优先级：\" + task.getPriority());\n    task = tasks.poll();\n}\n// 结果如下：\n处理任务：写代码，优先级：100\n处理任务：写日记，优先级：20\n处理任务：看电视，优先级：10\n```\n\n1. PriorityQueue有如下特点：\n\n+ 实现了优先级队列，最先出队的总是优先级最高的；\n+ 优先级相同时，内部元素不完全有序；\n+ 查询头部元素效率很高，入队、出队效率很高；\n+ 根据值查找和删除元素效率很低\n+ 具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；\n\n\n\n# 5 通用容器类\n\n1. Collections提供了很多针对容器接口的通用算法和功能；\n2. 容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；\n3. 容器类中运用了大量的适配器模式\n\n+ 空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）\n+ 单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）\n+ 其他适配方法，例如将Map转换为Set等。\n\n1. 基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；\n","slug":"java-core/ch04","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2l00072y61g72ce4k4","content":"<h1 id=\"1-泛型\"><a href=\"#1-泛型\" class=\"headerlink\" title=\"1 泛型\"></a>1 泛型</h1><h2 id=\"1-1-基本概念\"><a href=\"#1-1-基本概念\" class=\"headerlink\" title=\"1.1 基本概念\"></a>1.1 基本概念</h2><ol>\n<li>泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；</li>\n<li>Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；</li>\n<li>泛型可以指定上限为某个具体类，例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NumberPair</span>&lt;U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>, V <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Pair</span>&lt;U, V&gt;&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">NumberPair</span><span class=\"hljs-params\">(U first, V second)</span> &#123;<br>        <span class=\"hljs-built_in\">super</span>(first, second);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；</li>\n<li>总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。</li>\n</ol>\n<h2 id=\"1-2-通配符解析\"><a href=\"#1-2-通配符解析\" class=\"headerlink\" title=\"1.2 通配符解析\"></a>1.2 通配符解析</h2><ol>\n<li>参数类型限定通配符写法。例如：public void addAll(DynamicArray&lt;? extends E&gt; c), <strong>&lt;? exntends E&gt;也称为有限定通配符</strong>；</li>\n<li>与之相对应的就为无限定通配符，具体为：Dynamic&lt;?&gt;，更简洁的写法就为<T></li>\n<li>但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；</li>\n<li>通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；</li>\n<li>通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；</li>\n<li>如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；</li>\n<li>通配符形式和类型参数往往配合使用；</li>\n</ol>\n<h2 id=\"1-3-超类型通配符\"><a href=\"#1-3-超类型通配符\" class=\"headerlink\" title=\"1.3 超类型通配符\"></a>1.3 超类型通配符</h2><ol>\n<li>形式：&lt;? super E&gt;，用于表示E的某个父类类型；</li>\n<li>使用场景：对于有限通配符形式&lt;? extends E&gt;在无法满足工作需要时，可以使用&lt;? super E&gt;代替；</li>\n<li>&lt;? super E&gt;用于灵活写入或比较，&lt;?&gt;或&lt;? exntends E&gt;用于灵活读取；</li>\n</ol>\n<h2 id=\"1-4-局限性\"><a href=\"#1-4-局限性\" class=\"headerlink\" title=\"1.4 局限性\"></a>1.4 局限性</h2><ol>\n<li>基本类型不能用于实例化类型参数；</li>\n<li>运行时类型信息不适用泛型；</li>\n<li>类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；</li>\n<li>不能通过类型参数创建对象；</li>\n<li>泛型类类型参数不能用于创建静态变量和方法；</li>\n<li>不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；</li>\n<li>如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；</li>\n<li>泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；</li>\n</ol>\n<h1 id=\"2-列表和队列\"><a href=\"#2-列表和队列\" class=\"headerlink\" title=\"2 列表和队列\"></a>2 列表和队列</h1><h2 id=\"2-1-ArrayList\"><a href=\"#2-1-ArrayList\" class=\"headerlink\" title=\"2.1 ArrayList\"></a>2.1 ArrayList</h2><ol>\n<li>ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；</li>\n<li>ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；</li>\n<li>迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/* 错误写法 */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>    <span class=\"hljs-keyword\">for</span> (Integer a : list) &#123;<br>        <span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            list.remove(a); <span class=\"hljs-comment\">// 恐抛出ConcurrentModificationException</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 正确写法 */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>    Iterator&lt;Integer&gt; it = list.iterator();<br>    <span class=\"hljs-keyword\">while</span>(it.hasNext()) &#123;<br>        <span class=\"hljs-keyword\">if</span> (it.next() &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。</li>\n<li>ArrayList的特点</li>\n</ol>\n<ul>\n<li>随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；</li>\n<li>除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；</li>\n<li>添加数组元素的效率为O(N)；</li>\n<li>插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；</li>\n<li>需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；</li>\n</ul>\n<h2 id=\"2-2-LinkedList\"><a href=\"#2-2-LinkedList\" class=\"headerlink\" title=\"2.2 LinkedList\"></a>2.2 LinkedList</h2><ol>\n<li>LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；</li>\n<li>LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Queue&lt;String&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>queue.offer(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>queue.offer(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>queue.offer(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(queue.peek() != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList也可以当作栈使用，示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Deque&lt;String&gt; stack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>stack.push(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>stack.push(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>stack.push(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(stack.peek() != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.println(stack.pop());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；</li>\n<li>LinkedList的特点如下：</li>\n</ol>\n<ul>\n<li>按需分配空间，不需要预先分配很多空间；</li>\n<li>不可随机访问，按照索引位置访问效率较低；</li>\n<li>无论列表是否有序，按内容查找都需要逐个查找；</li>\n<li>在两端进行添加、删除操作效率很高；</li>\n</ul>\n<h2 id=\"2-3-ArrayDeque\"><a href=\"#2-3-ArrayDeque\" class=\"headerlink\" title=\"2.3 ArrayDeque\"></a>2.3 ArrayDeque</h2><ol>\n<li>ArrayDeque是基于数组实现的双端队列</li>\n<li>ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。</li>\n<li>由于是双端队列因此具备下列特点：</li>\n</ol>\n<ul>\n<li>在两端添加和删除的效率很高；</li>\n<li>根据元素的内容查找和删除的效率很低；</li>\n<li>与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。</li>\n</ul>\n<h1 id=\"3-Map和Set\"><a href=\"#3-Map和Set\" class=\"headerlink\" title=\"3 Map和Set\"></a>3 Map和Set</h1><h2 id=\"3-1-HashMap\"><a href=\"#3-1-HashMap\" class=\"headerlink\" title=\"3.1 HashMap\"></a>3.1 HashMap</h2><ol>\n<li>创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12</li>\n<li>创建Map保存数据的几个步骤分别为：</li>\n</ol>\n<ul>\n<li>(1) 计算键的哈希值；</li>\n<li>(2) 根据哈希值得到保存位置（取模）；</li>\n<li>(3) 插到对应位置的链表表头或者更新已有值；</li>\n<li>(4) 根据扩展table大小，注意这里的table是Entry类型；</li>\n</ul>\n<ol>\n<li>总结HashMap的实现原理</li>\n</ol>\n<ul>\n<li>HashMap内部有一个哈希表，每个元素指向一个单链表；</li>\n<li>根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；</li>\n<li>存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较</li>\n<li>HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；</li>\n<li>HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ol>\n<li>Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；</li>\n<li>HashSet有下列应用场景</li>\n</ol>\n<ul>\n<li>排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；</li>\n<li>保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；</li>\n<li>集合运算：方便进行数学中的交集以及并集的集合运算；</li>\n</ul>\n<ol>\n<li>HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；</li>\n<li>总结HashSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效的添加、删除元素、判断元素是否存在；</li>\n<li>没有顺序；</li>\n</ul>\n<h2 id=\"3-3-TreeMap或TreeSet\"><a href=\"#3-3-TreeMap或TreeSet\" class=\"headerlink\" title=\"3.3 TreeMap或TreeSet\"></a>3.3 TreeMap或TreeSet</h2><ol>\n<li>与HashMap无序相对比，TreeMap是有序的。</li>\n<li>TreeMap内部使用的是<a href=\"https://baike.baidu.com/item/红黑树/2413209?fr=aladdin\">红黑树</a>实现的；</li>\n<li>TreeMap的特点如下</li>\n</ol>\n<ul>\n<li>按键有序：可以很方便地根据键的顺序进行查找</li>\n<li>为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；</li>\n<li>根据键值保存、查找、删除的效率比较高；</li>\n</ul>\n<ol>\n<li>总结TreeSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效地添加、删除元素、判断元素是否存在；</li>\n<li>有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；</li>\n</ul>\n<h2 id=\"3-4-LinkedHashMap\"><a href=\"#3-4-LinkedHashMap\" class=\"headerlink\" title=\"3.4 LinkedHashMap\"></a>3.4 LinkedHashMap</h2><ol>\n<li>LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；</li>\n<li>LinkedHashMap是有序的，例子如下(插入顺序)：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Integer&gt; seqMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;();<br>seqMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (Entry&lt;String, Integer&gt; entry : seqMap.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + entry.getValue());<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Result is :</span><br><span class=\"hljs-comment\">c 100</span><br><span class=\"hljs-comment\">d 300</span><br><span class=\"hljs-comment\">a 500</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap的访问顺序：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Integer&gt; accessMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75</span>, <span class=\"hljs-literal\">true</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>accessMap.get(<span class=\"hljs-string\">&quot;c&quot;</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (Entry&lt;String, Integer&gt; entry : accessMap.getEntrySet())&#123;<br>    System.out.println(entry.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + entry.getValue());<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Result is : </span><br><span class=\"hljs-comment\">a 500</span><br><span class=\"hljs-comment\">c 100</span><br><span class=\"hljs-comment\">d 300</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 实现代码</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> maxEntries;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">LRUCache</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> maxEntries)</span> &#123;<br>        <span class=\"hljs-built_in\">super</span>(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75f</span>, <span class=\"hljs-literal\">true</span>);<br>        <span class=\"hljs-built_in\">this</span>.maxEntries = maxEntries;<br>    &#125;<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">removeEldestEntry</span><span class=\"hljs-params\">(Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> size() &gt; maxEntries;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 使用示例</span><br>LRUCache&lt;String, Object&gt; cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LRUCache</span>&lt;&gt;(<span class=\"hljs-number\">3</span>);<br>cache.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>cache.get(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>System.out.println(cache);<br><br><span class=\"hljs-comment\">// 输出结果</span><br>&#123;c=call, a=<span class=\"hljs-keyword\">abstract</span>, d=call&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-5-EnumMap\"><a href=\"#3-5-EnumMap\" class=\"headerlink\" title=\"3.5 EnumMap\"></a>3.5 EnumMap</h2><ol>\n<li>键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；</li>\n<li>EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Size</span> &#123;<br>    SMALL, MEDIUM, LARGE<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clothes</span> &#123;<br>    String id;<br>    Size size;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Map&lt;Size, Integer&gt; <span class=\"hljs-title function_\">countBySize</span><span class=\"hljs-params\">(List&lt;Clothes&gt; clothes)</span> &#123;<br>    Map&lt;Size, Integer&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumMap</span>&lt;&gt;(Size.class);<br>    <span class=\"hljs-keyword\">for</span> (Clothes c : clothes) &#123;<br>        <span class=\"hljs-type\">Size</span> <span class=\"hljs-variable\">size</span> <span class=\"hljs-operator\">=</span> c.getSize();<br>        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> map.get(size);<br>        <span class=\"hljs-keyword\">if</span> (count != <span class=\"hljs-literal\">null</span>) &#123;<br>            map.put(size, count + <span class=\"hljs-number\">1</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            map.put(size, <span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。</li>\n<li>EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；</li>\n<li>位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。</li>\n<li>对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。</li>\n</ol>\n<h1 id=\"4-堆与优先级队列\"><a href=\"#4-堆与优先级队列\" class=\"headerlink\" title=\"4 堆与优先级队列\"></a>4 堆与优先级队列</h1><h2 id=\"4-1-完全二叉树\"><a href=\"#4-1-完全二叉树\" class=\"headerlink\" title=\"4.1 完全二叉树\"></a>4.1 完全二叉树</h2><ol>\n<li>完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其<strong>父节点</strong>和<strong>孩子节点</strong>的编号。<strong>例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 * i，右孩子节点编号为2 * i + 1;</strong></li>\n<li>基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；</li>\n</ol>\n<h2 id=\"4-2-PriorityQueue\"><a href=\"#4-2-PriorityQueue\" class=\"headerlink\" title=\"4.2 PriorityQueue\"></a>4.2 PriorityQueue</h2><ol>\n<li>PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Task</span> &#123;<br>    <span class=\"hljs-type\">int</span> priority; <span class=\"hljs-comment\">// 数值越大，优先级越高</span><br>    String name; <span class=\"hljs-comment\">// 表示任务的名称</span><br>    <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Comparator&lt;Task&gt; taskComparator = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Comparator</span>() &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">compare</span><span class=\"hljs-params\">(Task o1, Task o2)</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> (o1.getPriority() &gt; o2.getPriority()) &#123;<br>                <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (o1.getPriority() &lt; o2.getPriority())&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Queue&lt;Task&gt; tasks = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Priority</span>&lt;&gt;(<span class=\"hljs-number\">11</span>, taskComparator);<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">&quot;写日记&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&quot;看电视&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">&quot;写代码&quot;</span>));<br><span class=\"hljs-type\">Task</span> <span class=\"hljs-variable\">task</span> <span class=\"hljs-operator\">=</span> tasks.poll();<br><span class=\"hljs-keyword\">while</span> (task != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.print(<span class=\"hljs-string\">&quot;处理任务：&quot;</span> + task.getName() + <span class=\"hljs-string\">&quot;, 优先级：&quot;</span> + task.getPriority());<br>    task = tasks.poll();<br>&#125;<br><span class=\"hljs-comment\">// 结果如下：</span><br>处理任务：写代码，优先级：<span class=\"hljs-number\">100</span><br>处理任务：写日记，优先级：<span class=\"hljs-number\">20</span><br>处理任务：看电视，优先级：<span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>PriorityQueue有如下特点：</li>\n</ol>\n<ul>\n<li>实现了优先级队列，最先出队的总是优先级最高的；</li>\n<li>优先级相同时，内部元素不完全有序；</li>\n<li>查询头部元素效率很高，入队、出队效率很高；</li>\n<li>根据值查找和删除元素效率很低</li>\n<li>具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；</li>\n</ul>\n<h1 id=\"5-通用容器类\"><a href=\"#5-通用容器类\" class=\"headerlink\" title=\"5 通用容器类\"></a>5 通用容器类</h1><ol>\n<li>Collections提供了很多针对容器接口的通用算法和功能；</li>\n<li>容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；</li>\n<li>容器类中运用了大量的适配器模式</li>\n</ol>\n<ul>\n<li>空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）</li>\n<li>单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）</li>\n<li>其他适配方法，例如将Map转换为Set等。</li>\n</ul>\n<ol>\n<li>基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；</li>\n</ol>\n","site":{"data":{}},"wordcount":7864,"excerpt":"","more":"<h1 id=\"1-泛型\"><a href=\"#1-泛型\" class=\"headerlink\" title=\"1 泛型\"></a>1 泛型</h1><h2 id=\"1-1-基本概念\"><a href=\"#1-1-基本概念\" class=\"headerlink\" title=\"1.1 基本概念\"></a>1.1 基本概念</h2><ol>\n<li>泛型实际上就是将类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；</li>\n<li>Java的泛型实际上通过Java编译器对泛型字符做类型擦除实现的；</li>\n<li>泛型可以指定上限为某个具体类，例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NumberPair</span>&lt;U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>, V <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Number</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Pair</span>&lt;U, V&gt;&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">NumberPair</span><span class=\"hljs-params\">(U first, V second)</span> &#123;<br>        <span class=\"hljs-built_in\">super</span>(first, second);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>除此之外，也可以指定上界为某个接口，例如Java中的max方法需要实现Comparable接口；</li>\n<li>总结：泛型是计算机中一种非常重要的思维方式，它将数据结构和算法与数据类型进行分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性。</li>\n</ol>\n<h2 id=\"1-2-通配符解析\"><a href=\"#1-2-通配符解析\" class=\"headerlink\" title=\"1.2 通配符解析\"></a>1.2 通配符解析</h2><ol>\n<li>参数类型限定通配符写法。例如：public void addAll(DynamicArray&lt;? extends E&gt; c), <strong>&lt;? exntends E&gt;也称为有限定通配符</strong>；</li>\n<li>与之相对应的就为无限定通配符，具体为：Dynamic&lt;?&gt;，更简洁的写法就为<T></li>\n<li>但是通配符存在一个重要限制：只能读，不能写，由于类型安全无知，因此Java编译器一般是不允许写入，所以干脆禁止；</li>\n<li>通配符的形式都可以使用类型参数的形式来替代，通配符能做的，用类型参数都可以做；</li>\n<li>通配符的形式可以减少类型参数，形式上往往更为简单，可读性也更好；因此能使用通配符就使用通配符；</li>\n<li>如果类型参数之间有依赖关系，或者返回依赖类型参数，或者需要写操作，则只能使用类型参数；</li>\n<li>通配符形式和类型参数往往配合使用；</li>\n</ol>\n<h2 id=\"1-3-超类型通配符\"><a href=\"#1-3-超类型通配符\" class=\"headerlink\" title=\"1.3 超类型通配符\"></a>1.3 超类型通配符</h2><ol>\n<li>形式：&lt;? super E&gt;，用于表示E的某个父类类型；</li>\n<li>使用场景：对于有限通配符形式&lt;? extends E&gt;在无法满足工作需要时，可以使用&lt;? super E&gt;代替；</li>\n<li>&lt;? super E&gt;用于灵活写入或比较，&lt;?&gt;或&lt;? exntends E&gt;用于灵活读取；</li>\n</ol>\n<h2 id=\"1-4-局限性\"><a href=\"#1-4-局限性\" class=\"headerlink\" title=\"1.4 局限性\"></a>1.4 局限性</h2><ol>\n<li>基本类型不能用于实例化类型参数；</li>\n<li>运行时类型信息不适用泛型；</li>\n<li>类型擦除可能引起一些冲突，因此泛型中不能使用基本类型，要使用基本类型对应的包装类型；</li>\n<li>不能通过类型参数创建对象；</li>\n<li>泛型类类型参数不能用于创建静态变量和方法；</li>\n<li>不能创建泛型数组，因为一旦创建泛型数组既不会产生编译错误，也不会产生运行异常，但确是非常危险的；</li>\n<li>如果要存放泛型对象，可以使用原始类型的数组，或者是用泛型容器；</li>\n<li>泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射；</li>\n</ol>\n<h1 id=\"2-列表和队列\"><a href=\"#2-列表和队列\" class=\"headerlink\" title=\"2 列表和队列\"></a>2 列表和队列</h1><h2 id=\"2-1-ArrayList\"><a href=\"#2-1-ArrayList\" class=\"headerlink\" title=\"2.1 ArrayList\"></a>2.1 ArrayList</h2><ol>\n<li>ArrayList为动态数组，其内部使用了一个Object类型的数组，默认容量为10，可以通过构造函数更改其初始容量；</li>\n<li>ArrayList实现了Iterable接口，Iterable表示可迭代，凡是实现了Iterable接口的容器类均可以使用foreach语法，Java编译器会将其转换成调用Iterable接口中的Iterator方法；</li>\n<li>迭代陷阱：由于迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化。否则索引位置就失效了，因此会出现ConcurrentModificationException异常。如果需要删除容器中间的元素，需使用iterator的remove方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/* 错误写法 */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>    <span class=\"hljs-keyword\">for</span> (Integer a : list) &#123;<br>        <span class=\"hljs-keyword\">if</span> (a &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            list.remove(a); <span class=\"hljs-comment\">// 恐抛出ConcurrentModificationException</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* 正确写法 */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>    Iterator&lt;Integer&gt; it = list.iterator();<br>    <span class=\"hljs-keyword\">while</span>(it.hasNext()) &#123;<br>        <span class=\"hljs-keyword\">if</span> (it.next() &lt; <span class=\"hljs-number\">100</span>) &#123;<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用迭代器的好处：迭代器表示的是一种关注点分离的思想，将数据和实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。从封装思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单一致性的接口。</li>\n<li>ArrayList的特点</li>\n</ol>\n<ul>\n<li>随机访问：按照索引位置访问效率非常高，时间复杂度为O(1)；</li>\n<li>除非数组已排序，否则按照内容查找元素效率比较低，具体为O(N)，也就是说性能与长度成正比；</li>\n<li>添加数组元素的效率为O(N)；</li>\n<li>插入和删除的效率较低，如果是在数组首部插入或者删除元素，需要对整个数组中的元素进行移动，具体为O(N)；</li>\n<li>需要说明的是ArrayList不是线程安全的，在不需要线程安全的场景下推荐使用ArrayList；</li>\n</ul>\n<h2 id=\"2-2-LinkedList\"><a href=\"#2-2-LinkedList\" class=\"headerlink\" title=\"2.2 LinkedList\"></a>2.2 LinkedList</h2><ol>\n<li>LinkedList是使用数据结构中的单链表来实现的，因此插入和删除的性能很高，但是随机访问的效率就很低；</li>\n<li>LinkedList除了实现Collection接口，还实现了Queue接口，因此对于队列可以这样使用：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Queue&lt;String&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>queue.offer(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>queue.offer(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>queue.offer(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(queue.peek() != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList也可以当作栈使用，示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Deque&lt;String&gt; stack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();<br>stack.push(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>stack.push(<span class=\"hljs-string\">&quot;b&quot;</span>);<br>stack.push(<span class=\"hljs-string\">&quot;c&quot;</span>);<br><span class=\"hljs-keyword\">while</span>(stack.peek() != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.println(stack.pop());<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedList的用法和ArrayList类似，与ArrayList不同的是，LinkedList既可以用作队列也可以用作栈；</li>\n<li>LinkedList的特点如下：</li>\n</ol>\n<ul>\n<li>按需分配空间，不需要预先分配很多空间；</li>\n<li>不可随机访问，按照索引位置访问效率较低；</li>\n<li>无论列表是否有序，按内容查找都需要逐个查找；</li>\n<li>在两端进行添加、删除操作效率很高；</li>\n</ul>\n<h2 id=\"2-3-ArrayDeque\"><a href=\"#2-3-ArrayDeque\" class=\"headerlink\" title=\"2.3 ArrayDeque\"></a>2.3 ArrayDeque</h2><ol>\n<li>ArrayDeque是基于数组实现的双端队列</li>\n<li>ArrayDeque内部使用了一种叫做“循环数组”的结构，通过head和tail指针实现数据的插入和删除。循环数组的长度是2的幂次方。以及使用高效的位运算实现高效。</li>\n<li>由于是双端队列因此具备下列特点：</li>\n</ol>\n<ul>\n<li>在两端添加和删除的效率很高；</li>\n<li>根据元素的内容查找和删除的效率很低；</li>\n<li>与ArrayList和LinkedList不同的是，没有索引位置的概念，不能根据索引位置进行操作。</li>\n</ul>\n<h1 id=\"3-Map和Set\"><a href=\"#3-Map和Set\" class=\"headerlink\" title=\"3 Map和Set\"></a>3 Map和Set</h1><h2 id=\"3-1-HashMap\"><a href=\"#3-1-HashMap\" class=\"headerlink\" title=\"3.1 HashMap\"></a>3.1 HashMap</h2><ol>\n<li>创建的HashMap默认容量为16，默认因子为0.75，因此阈值为16 * 0.75 = 12</li>\n<li>创建Map保存数据的几个步骤分别为：</li>\n</ol>\n<ul>\n<li>(1) 计算键的哈希值；</li>\n<li>(2) 根据哈希值得到保存位置（取模）；</li>\n<li>(3) 插到对应位置的链表表头或者更新已有值；</li>\n<li>(4) 根据扩展table大小，注意这里的table是Entry类型；</li>\n</ul>\n<ol>\n<li>总结HashMap的实现原理</li>\n</ol>\n<ul>\n<li>HashMap内部有一个哈希表，每个元素指向一个单链表；</li>\n<li>根据键值对操作实际上就是用键计算hash值，取模得到数组中的索引位置；然后操作哈希表中指向的单链表；</li>\n<li>存取时依据键的hash值，只在对应的链表中操作，不会访问其他链表。对应链表操作时也是先计算hash值，当哈希值相同时再使用equals方法比较</li>\n<li>HashMap是无顺序的，所有的键值对都是随机排列的，如果希望Map中的数据有序排列，可以使用LinkedHashMap；</li>\n<li>HashMap不是线程安全的，因此在不需要高并发的场景下推荐使用HashMap，如果是在高并发场景，可以使用Java8中新增的ConcurrentHashMap对象；</li>\n</ul>\n<h2 id=\"3-2-HashSet\"><a href=\"#3-2-HashSet\" class=\"headerlink\" title=\"3.2 HashSet\"></a>3.2 HashSet</h2><ol>\n<li>Set表示没有重复元素并且无序的容器接口，与数学中的集合概念吻合；</li>\n<li>HashSet有下列应用场景</li>\n</ol>\n<ul>\n<li>排重：如果对排重后的元素无顺序要求，可以使用HashSet进行排重；</li>\n<li>保存特殊值：例如维护IP地址的黑名单和白名单，可以使用HashSet；</li>\n<li>集合运算：方便进行数学中的交集以及并集的集合运算；</li>\n</ul>\n<ol>\n<li>HashSet内部使用的是HashMap实现，内部都包含一个HashMap的实例变量；</li>\n<li>总结HashSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效的添加、删除元素、判断元素是否存在；</li>\n<li>没有顺序；</li>\n</ul>\n<h2 id=\"3-3-TreeMap或TreeSet\"><a href=\"#3-3-TreeMap或TreeSet\" class=\"headerlink\" title=\"3.3 TreeMap或TreeSet\"></a>3.3 TreeMap或TreeSet</h2><ol>\n<li>与HashMap无序相对比，TreeMap是有序的。</li>\n<li>TreeMap内部使用的是<a href=\"https://baike.baidu.com/item/红黑树/2413209?fr=aladdin\">红黑树</a>实现的；</li>\n<li>TreeMap的特点如下</li>\n</ol>\n<ul>\n<li>按键有序：可以很方便地根据键的顺序进行查找</li>\n<li>为了使得按键有序，TreeMap要求键实现Comparable接口或者通过构造方法提供一个Comparator对象；</li>\n<li>根据键值保存、查找、删除的效率比较高；</li>\n</ul>\n<ol>\n<li>总结TreeSet的特点有如下几个：</li>\n</ol>\n<ul>\n<li>没有重复元素；</li>\n<li>可以高效地添加、删除元素、判断元素是否存在；</li>\n<li>有顺序，可以根据自己实现Comparator方法达到正序或者逆序排列；</li>\n</ul>\n<h2 id=\"3-4-LinkedHashMap\"><a href=\"#3-4-LinkedHashMap\" class=\"headerlink\" title=\"3.4 LinkedHashMap\"></a>3.4 LinkedHashMap</h2><ol>\n<li>LinkedHashMap存在两种顺序，一种是插入顺序（先插入的元素在前面），一种是访问顺序（最近访问的元素会移动到末尾，最开始的是没被访问的）；</li>\n<li>LinkedHashMap是有序的，例子如下(插入顺序)：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Integer&gt; seqMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;();<br>seqMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>seqMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (Entry&lt;String, Integer&gt; entry : seqMap.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + entry.getValue());<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Result is :</span><br><span class=\"hljs-comment\">c 100</span><br><span class=\"hljs-comment\">d 300</span><br><span class=\"hljs-comment\">a 500</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap的访问顺序：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Integer&gt; accessMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75</span>, <span class=\"hljs-literal\">true</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">100</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">200</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">500</span>);<br>accessMap.get(<span class=\"hljs-string\">&quot;c&quot;</span>);<br>accessMap.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">300</span>);<br><span class=\"hljs-keyword\">for</span> (Entry&lt;String, Integer&gt; entry : accessMap.getEntrySet())&#123;<br>    System.out.println(entry.getKey() + <span class=\"hljs-string\">&quot; &quot;</span> + entry.getValue());<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Result is : </span><br><span class=\"hljs-comment\">a 500</span><br><span class=\"hljs-comment\">c 100</span><br><span class=\"hljs-comment\">d 300</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>LinkedHashMap可以应用于缓存，例如LRU缓存，下面贴出一个LRU缓存的简单实现：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 实现代码</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> maxEntries;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">LRUCache</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> maxEntries)</span> &#123;<br>        <span class=\"hljs-built_in\">super</span>(<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">0.75f</span>, <span class=\"hljs-literal\">true</span>);<br>        <span class=\"hljs-built_in\">this</span>.maxEntries = maxEntries;<br>    &#125;<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">removeEldestEntry</span><span class=\"hljs-params\">(Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> size() &gt; maxEntries;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 使用示例</span><br>LRUCache&lt;String, Object&gt; cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LRUCache</span>&lt;&gt;(<span class=\"hljs-number\">3</span>);<br>cache.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>cache.get(<span class=\"hljs-string\">&quot;a&quot;</span>);<br>cache.put(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>System.out.println(cache);<br><br><span class=\"hljs-comment\">// 输出结果</span><br>&#123;c=call, a=<span class=\"hljs-keyword\">abstract</span>, d=call&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-5-EnumMap\"><a href=\"#3-5-EnumMap\" class=\"headerlink\" title=\"3.5 EnumMap\"></a>3.5 EnumMap</h2><ol>\n<li>键类型为枚举类型，除了可以使用基本的HashMap，也可以使用EnumMap；</li>\n<li>EnumMap的好处在于，Map的所有键都是预先定义的，其次是枚举能保证一定的顺序性。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Size</span> &#123;<br>    SMALL, MEDIUM, LARGE<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Clothes</span> &#123;<br>    String id;<br>    Size size;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Map&lt;Size, Integer&gt; <span class=\"hljs-title function_\">countBySize</span><span class=\"hljs-params\">(List&lt;Clothes&gt; clothes)</span> &#123;<br>    Map&lt;Size, Integer&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EnumMap</span>&lt;&gt;(Size.class);<br>    <span class=\"hljs-keyword\">for</span> (Clothes c : clothes) &#123;<br>        <span class=\"hljs-type\">Size</span> <span class=\"hljs-variable\">size</span> <span class=\"hljs-operator\">=</span> c.getSize();<br>        <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> map.get(size);<br>        <span class=\"hljs-keyword\">if</span> (count != <span class=\"hljs-literal\">null</span>) &#123;<br>            map.put(size, count + <span class=\"hljs-number\">1</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            map.put(size, <span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>EnumSet使用了极为精简和高效的位向量实现，位向量是计算机程序中解决问题的一种方式。</li>\n<li>EnumSet不能通过new的方式创建，如果需要创建EnumSet对象，需要调用其内部的静态工厂方法；</li>\n<li>位向量是用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种。</li>\n<li>对于只有两种状态，且需要进行集合运算的数据、使用位向量进行表示、位运算进行处理。是计算机程序中常用的思维方式。</li>\n</ol>\n<h1 id=\"4-堆与优先级队列\"><a href=\"#4-堆与优先级队列\" class=\"headerlink\" title=\"4 堆与优先级队列\"></a>4 堆与优先级队列</h1><h2 id=\"4-1-完全二叉树\"><a href=\"#4-1-完全二叉树\" class=\"headerlink\" title=\"4.1 完全二叉树\"></a>4.1 完全二叉树</h2><ol>\n<li>完全二叉树的特点：给定任意一个节点，可以根据其编号直接快速计算出其<strong>父节点</strong>和<strong>孩子节点</strong>的编号。<strong>例如：如果节点编号为i，则父亲节点编号为i / 2，左孩子的节点编号为2 * i，右孩子节点编号为2 * i + 1;</strong></li>\n<li>基于上述特点，完全二叉树可以很方便的存储到一个连续数组中；</li>\n</ol>\n<h2 id=\"4-2-PriorityQueue\"><a href=\"#4-2-PriorityQueue\" class=\"headerlink\" title=\"4.2 PriorityQueue\"></a>4.2 PriorityQueue</h2><ol>\n<li>PriorityQueue内部使用堆实现，可以实现很高的存取效率，逐个出队列可以得到有序，但内部不一定是有序的。基本例子如下，模拟一个任务队列，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Task</span> &#123;<br>    <span class=\"hljs-type\">int</span> priority; <span class=\"hljs-comment\">// 数值越大，优先级越高</span><br>    String name; <span class=\"hljs-comment\">// 表示任务的名称</span><br>    <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Comparator&lt;Task&gt; taskComparator = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Comparator</span>() &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">compare</span><span class=\"hljs-params\">(Task o1, Task o2)</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> (o1.getPriority() &gt; o2.getPriority()) &#123;<br>                <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (o1.getPriority() &lt; o2.getPriority())&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Queue&lt;Task&gt; tasks = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Priority</span>&lt;&gt;(<span class=\"hljs-number\">11</span>, taskComparator);<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">&quot;写日记&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&quot;看电视&quot;</span>));<br>tasks.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">&quot;写代码&quot;</span>));<br><span class=\"hljs-type\">Task</span> <span class=\"hljs-variable\">task</span> <span class=\"hljs-operator\">=</span> tasks.poll();<br><span class=\"hljs-keyword\">while</span> (task != <span class=\"hljs-literal\">null</span>) &#123;<br>    System.out.print(<span class=\"hljs-string\">&quot;处理任务：&quot;</span> + task.getName() + <span class=\"hljs-string\">&quot;, 优先级：&quot;</span> + task.getPriority());<br>    task = tasks.poll();<br>&#125;<br><span class=\"hljs-comment\">// 结果如下：</span><br>处理任务：写代码，优先级：<span class=\"hljs-number\">100</span><br>处理任务：写日记，优先级：<span class=\"hljs-number\">20</span><br>处理任务：看电视，优先级：<span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>PriorityQueue有如下特点：</li>\n</ol>\n<ul>\n<li>实现了优先级队列，最先出队的总是优先级最高的；</li>\n<li>优先级相同时，内部元素不完全有序；</li>\n<li>查询头部元素效率很高，入队、出队效率很高；</li>\n<li>根据值查找和删除元素效率很低</li>\n<li>具体两个应用场景：求前K个最大的元素，且数据源源不断进来或者是求数据的中间值，且数据源源不断来；</li>\n</ul>\n<h1 id=\"5-通用容器类\"><a href=\"#5-通用容器类\" class=\"headerlink\" title=\"5 通用容器类\"></a>5 通用容器类</h1><ol>\n<li>Collections提供了很多针对容器接口的通用算法和功能；</li>\n<li>容器接口有如下六种，分别是：Collection、List、Set、Queue、Deque和Map；</li>\n<li>容器类中运用了大量的适配器模式</li>\n</ol>\n<ul>\n<li>空容器方法：类似于将null或者“空”转换成一个标准的容器接口对象；例如：emptyMap, emptyList或者是emptySet;（不可变对象）</li>\n<li>单一对象方法：讲一个单独的对象转换为一个标准的容器接口对象；例如：singletonList, singletonMap或者singletonSet;（不可变对象）</li>\n<li>其他适配方法，例如将Map转换为Set等。</li>\n</ul>\n<ol>\n<li>基本容器类都是线程不安全的，因此在不需要并发的场景下可以放心使用；</li>\n</ol>\n"},{"title":"Java编程原理——动态与函数式编程","date":"2022-02-16T14:33:55.000Z","updated":"2022-02-16T14:33:55.000Z","_content":"\n# 反射\n\n1. 反射是在类运行时动态获取类型的信息。比如接口信息、成员信息、方法信息、构造函数信息等。根据动态获取到的信息创建对象、访问/修改成员、调用方法等。\n2. 使用反射可以得到类的名称，调用方法getName()。其中还包括getSimpleName()，getCanonicalName()以及getPackage()。\n3. 类中定义的静态和实例变量称之为字段，使用Field类表示，可以获取字段的访问权限，设置访问权限，获得字段值以及设置字段值。除此之外，还可以获得字段的修饰符以及基本类型。需要注意的是使用反射返回的修饰符是一个整型。如果需要查看具体的返回值类型，可以使用Modifier进行再次判断。\n4. 通过反射也可以获取类中的方法信息：对于invoke方法而言，如果Method是静态方法，则obj被忽略为null，args可以为null；\n5. 创建对象和构造方法：`public T newInstance() throws InstantiationException, IllegalAccessException`；\n6. 类型检查和转换：使用`instanceof`关键字可以用于判断变量指向的实际对象类型，instanceof后面的类型是在代码中确定的；\n7. 除此之外，Class方法中还有其他的一些方法可以用于获取类的声明信息、修饰符、父类、接口以及注解等；\n8. 对于数组类型可以使用`public native Class<T> getComponentType()`获取其元素类型；\n9. 反射与枚举：枚举类型也有一个专门的方法：`public T[] getEnumConstants()`；\n10. 反射与泛型：可以获取泛型参数的信息：\n\n+ Class类有如下方法：`public TypeVariable<Class<T>>[] getTypeParameters()`\n+ Field有如下方法：`public Type getGenericType()`\n+ Method有如下方法：`public Type getGenericReturnType()`，`public Type[] getGenericParameterTypes()`和`public Type[] getGenericExceptionTypes()`\n+ Constructor有如下方法：`public Type[] getGenericParameterTypes()`\n\n1. Type实现了Class方法，其中还实现了下列方法：\n\n+ TypeVariable类型参数可以有上界；\n+ ParameterizedType参数化的类型，有原始类型和具体类型；\n+ WildcardType通配符类型\n+ 通过反射获取泛型示例\n\n```java\npublic class GenericDemo {\n    static class GenericTest<U extends Comparable<U, V> {\n        U u;\n        V v;\n        List<String> list;\n        public U test(List<? extends Number> numbers) {\n            return null;\n        }\n    }\n    public static void main(String[] args) {\n        Class<?> cls = GenericTest.class;\n        for (TypeVariable t : cls.getTypeParameters()) {\n            System.out.println(t.getName() + \" extends \" + Arrays.toString(t.getBounds()));\n        }\n        Field fu = cls.getDeclaredField(\"u\");\n        System.out.println(fu.getGenericType());\n        Field first = cls.getDeclaredField(\"list\");\n        Type listType = first.getGenericType();\n        if (!listType instanceof ParameterizedType) {\n            ParameterizedType pType = (ParameterizedType)listType;\n            System.out.println(\"raw type: \" + pType.getRawType() + \" ,type arguments:\" + Arrays.toString(pType.getActualTypeArguments()));\n        }\n        // 省略代码\n    }\n}\n```\n\n1. 总结：反射虽然灵活，但一般情况下我们并不优先建议，原因有如下：\n\n+ 反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力；\n+ 反射会降低性能，在访问字段、调用方法前，反射要先查找对应的Field/Method，要慢一些；\n\n1. 如果能用接口实现同样的灵活性，就不要使用反射；\n\n# 注解\n\n1. 注解是给程序添加一些信息，这些信息可以用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序；\n2. Java内置`@Override`，`@Deprecated`和`@SuppressWarning`三个注解，这三个注解远远不能满足日常开发需求，因此自定义注解产生。\n3. 注解是声明式编程中的一种巧妙应用，在这种风格中，程序通常由下列三部分实现：\n\n+ 声明的关键字和语法本身；\n+ 系统/框架/库，它们负责解释，执行声明式的语句；\n+ 应用程序，使用声明式编程风格编写程序；\n\n1. 创建注解：使用`@interface`关键字声明注解，另外是需要在声明的注解标明元注解。以`@Override`注解为例：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n4.1 ElementType是一个枚举，可以取下列值：\n\n+ TYPE：表示类、接口（包括注解），或者是枚举类型\n+ FIELD：字段，包括枚举常量\n+ METHOD：方法\n+ PARAMETER：方法中的参数\n+ CONSTRUCTOR：构造方法\n+ LOCAL_VARIABLE：本地变量\n+ MODULE：模块（Java 9引入）\n+ \n\n4.2 如果没有声明`@Target`，默认适用于所有类型；\n\n4.3 `@Retention`表示注解信息保留到什么时候，取值只有一个，类型为RetentionPolicy，它是一个枚举，有三个值：\n\n+ SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后去掉；\n+ CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留（默认值）；\n+ RUNTIME：一直保留到运行时\n\n4.4 `@Documented`注解表示注解信息包含到生成文档中；\n\n4.5 注解不能继承，但是使用了注解的父类一旦被子类继承，那么子类就可以继承父类的注解，如果要实现这样的效果，需要在父类的注解中加上`@Inherited`\n\n1. 总结：注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离。框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作；\n\n# 动态代理\n\n1. 静态代理\n\n```java\npublic class SImpleStaticProxy {\n    interface IService {\n        void sayHello();\n    }\n\n    // 真实对象\n    static class RealService implements IService {\n        @Override\n        public void sayHello() {\n            System.out.println(\"RealService Say Hello!\");\n        }\n    }\n\n    // 代理对象\n    static class TraceProxy implements IService {\n        private IService realService;\n\n        TraceProxy(IService realService) {\n            this.realService = realService;\n        }\n\n        @Override\n        public void sayHello() {\n            System.out.println(\"entering say hello...\");\n            this.realService.sayHello();\n            System.out.println(\"exited say hello...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = new TraceProxy(realService);\n        proxyService.sayHello();\n    }\n}\n```\n\n1. 动态代理\n\n```java\npublic class SimpleDynamicProxy {\n    interface IService {\n        void sayHello();\n    }\n    \n    // 真实对象\n    static class RealService implements IService {\n        @Override\n        public void sayHello() {\n            System.out.println(\"Real Service Say Hello\");\n        }\n    }\n    \n    // 代理对象实现JDK中的InvocationHandler接口\n    static class SimpleInvocationHandle implements InvocationHandler {\n        private Object realObj;\n\n        SimpleInvocationHandle(Object realObj) {\n            this.realObj = realObj;\n        }\n        \n        // 重写invoke方法\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            // proxy：表示代理对象本身，不是被代理对象，一般用处不大\n            // method：表示正在被调用的方法\n            // args：表示方法的参数\n            System.out.println(\"entering \" + method.getName());\n            Object result = method.invoke(realObj, args);\n            System.out.println(\"leaving \" + method.getName());\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = (IService) Proxy.newProxyInstance(IService.class.getClassLoader(), new Class<?>[]{IService.class},\n                new SimpleInvocationHandle(realService)); // 使用Proxy.newProxyInstance生成一个代理对象\n        proxyService.sayHello();\n    }\n}\n```\n\n+ newProxyInstance的声明如下：\n\n```java\npublic static Object newProxyInstance(ClassLoader classLoader, Class<?>[] interfaces, InvocationHandler h);\n// ClassLoader：表示类加载器；\n// Class<?>[] interfaces：表示代理类要实现的接口列表，元素类型只能是接口，不能是普通类；\n// InvocationHandler：是一个接口，对代理接口所有方法的调用都会转给该方法；\n// newProxyInstance是Object类型，它不能强制转换为某个类型，只能转换为接口类型；\n```\n\n1. 类定义本身与被代理的对象没有关系，与InvocationHandler的具体实现也没有关系，而主要与接口数组有关，给定的接口数组会动态地创建每个接口的实现代码，实现就是转发给InvocationHandler，与被代理对象的关系以及对它的调用由InvocationHandler实现管理。\n2. 总结：使用动态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每个被代理的类型都是创建一个静态代理类。\n3. 局限性：JDK中的动态代理只能为接口创建代理，返回的代理对象也只能转换到某个接口类型；如果一个类没有接口，或者希望代理非接口中定义的方法，就无能为力了。\n4. 使用cglib的动态代理类可以解决上述的痛点。示例如下：\n\n```java\npublic class SimpleCGLibDemo {\n    static class RealService {\n        public void sayHello() {\n            System.out.println(\"hello\");\n        }\n    }\n    static class SimpleInterceptor implements MethodInterceptor {\n        @Override\n        public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            System.out.println(\"entering \" + method.getName());\n            Object result = proxy.invokeSuper(object, args);\n            System.out.println(\"leaving \" + method.getName());\n        }\n    }\n    private static <T> T getProxy(Class<T> cls) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(cls);\n        enhancer.setCallback(new SimpleInterceptor());\n        return (T)enhancer.create();\n    }\n    \n    public static void main(String[] args) {\n        RealService proxyService = getProxy(RealService.class);\n        proxyService.sayHello();\n    }\n}\n```\n\n1. cglib代理面向的一个具体的类，创建对象只有一个；而SDK代理面向的是接口；\n\n# 类加载机制\n\n1. 类加载机制可以应用于下列场景：\n\n+ 热部署：不重启程序的情况下动态替换\n+ 应用模块化和互相隔离：不同的ClassLoader可以加载相同的类，但是互相隔离、互不影响。例如：Tomcat管理多个Web应用程序；\n+ 从不同地方灵活加载：系统默认从本地.class文件或者.jar包中加载字节码文件，通过自定义ClassLoader可以从共享服务器、数据库、缓存服务器等其他地方加载字节码文件；\n\n1. 类加载机制组成部分：\n\n+ 启动类型加载器（Bootstrap Classloader）：一般由C++实现的，它负责加载Java的基础类，主要是<JAVA_HOME>/lib/rt.jar；\n+ 扩展类加载器（Extension Classloader）：加载器的实现类sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类；\n+ 应用程序类加载器（Application ClassLoader）：实现类是sun.misc.Launcher$AppClassLoader。负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类；\n\n1. 类加载的全过程：\n\n+ 1）判断是否已经加载过，如果加载过直接返回Class对象，一个类只会被一个ClassLoader加载过一次；\n+ 2）如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象；\n+ 3）在父ClassLoader没有加载成功的前提下，自己尝试加载类；\n\n1. 这个过程称之为“双亲委派”模型。优先让父ClassLoader去加载。\n2. 类加载都按照“双亲委派”模型，但是也有例外：\n\n+ 自定义加载顺序：即自定义的类加载器可以不遵循“双亲委派”模型，但一般上是不推荐的；\n+ 网状加载顺序：在OSGI和Java9中存在网状加载的情况。\n+ 父加载器委派给子加载器：典型应用有JNDI。\n\n1. 类加载器的例子：\n\n```java\npublic class ClassLoaderDemo {\n    public static void main(String[] args) {\n        ClassLoader c1 = ClassLoaderDemo.class.getClassLoader();\n        while (c1 != null) {\n            System.out.println(c1.getClass().getName());\n            c1 = c1.getParent();\n        }\n        System.out.println(String.class.getClassLoader());\n    }\n}\n// 输出结果为：\n// sun.misc.Launcher.$AppClassLoader\n// sun.misc.Launcher.$ExtClassLoader\n```\n\n1. ClassLoader中有一个默认方法`public static ClassLoader getSystemClassLoader()`，还有一个默认方法用于加载类： `public class<?> loadClass(String name) throws ClassNotFoundException`。示例如下：\n\n```java\nClassLoader c1 = ClassLoader.getSystemClassLoader();\ntry {\n    Class<?> cls = c1.loadClass(\"java.util.ArrayList\");\n    ClassLoader actualLoader = cls.getClassLoader();\n    System.out.println(actualloader);\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n}\n```\n\n1. 类加载器是一个抽象类。Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader以及sun.misc.Launcher$ExtClassLoader。Bootstrap ClassLoader不是由Java实现的。因此没有实现类。需要说明的是，由于是委派机制。使用getClassLoader()方法返回的不一定调用load-Class.\n2. ClassLoader中的loadClass方法只会加载类但是不会执行。示例如下：\n\n```java\npublic class CLInitDemo {\n    public static class Hello {\n        static {\n            System.out.println(\"hello\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ClassLoader c1 = ClassLoader.getSystemClassLoader();\n        String className = CLInitDemo.class.getName() + \"$Hello\";\n        try {\n            Class<?> cls = c1.loadClass(className); // 不会输出\"hello\"\n            // Class<?> cls = Class.forName(className); // 会输出\"hello\"\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n1. 通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，也是一种策略模式。\n\n# 正则表达式\n\n## 单个字符\n\n1. 用字符本身表示\n2. 特殊字符：例如制表符'\\t'，换行符'\\n'以及回车符'\\r'；\n3. 八进制表示的字符：以'\\0'开头，后面加上1~3位数字，例如\\0141(8) -> 97(10)\n4. 十六进制表示的字符：以'\\x'开头，后面跟两位字符，比如\\x6A(16) -> 106(10)\n5. Unicode表示字符，以'\\u'开头，后面跟4位字符\n6. 斜杠本身就是特殊字符，如果需要使用斜杠需要用一个斜杠进行转义；\n7. 元字符：例如“.、*、?、+”等，如果要皮匹配自身，需要在前面加''进行转义\n\n## 字符祖\n\n1. '.'字符匹配除了换行符以外的任意字符，也可以使用“单行匹配模式”或者“点号匹配模式”。可以以(?s)开头，s表示single line；\n2. 中括号[]表示匹配字符组中的任意一个字符，例如[abcd]匹配任意一个字母；\n3. '^'表示排除符号；\n4. \\d：匹配一个数字字符，等同于[0-9]；\n5. \\w：匹配一个单词字符，等同于[a-zA-Z_0-9]；\n6. \\s：匹配一个空白字符，等同于[\\t\\n\\x0B\\f\\r]\n7. \\D：匹配一个非数字字符，即[^\\d]；\n8. \\W：匹配一个非单词字符，即[^\\w]；\n9. \\S：匹配一个非空白字符，即[^\\s]；\n\n## 量词\n\n1. 量词是指定出现次数的元字符，常见的有三种+、*、？\n2. '+'表示前面字符的一次或多次出现。比如正则表达式ab+c，既能匹配abc，也能匹配abbc:\n3. '*'表示前面的字符的零次或多次出现，例如：ab*c。既能匹配abc，也能匹配ac或abbbc；\n4. '?'表示前面字符可能出现，也可能不出现。例如正则表达式ab?c，既能匹配abc，也能匹配ac；\n5. 通用表示出现次数的语法为{m,n}，出现次数从m到n，包括m和n。如果n没有限制可以省略。如果m和n一样，可以省略一个写为{m}。例如：\n\n+ ab{1,10}c：b可以出现1次到10次\n+ ab{3}c：b必须出现三次\n+ ab{1,}c：等同于ab+c\n+ ab{0,}c：等同于ab*c\n+ ab{0,1}c：等同于ab?c\n\n1. 量词默认是贪婪的，也就是说会从正则开始匹配到结束内的所有字符，如果需要在匹配到第一个就终止，需要使用懒惰量词。即在两次后面加上一个符号'?'；\n\n## 分组\n\n1. 可以用括号将表达式括起来，表示一个分组。分组匹配的子字符串可以在后续访问，好像被被捕获了一样，所以默认分组称之为捕获分组；\n2. 在正则表达式中，可以使用斜杠\\加分组编号引用之前匹配的分组，称之为回溯引用；\n\n## 特殊边界匹配\n\n1. 常见的特殊边界的元字符有^、$、\\A、\\Z、\\z和\\b。\n2. ‘’匹配整个字符串的开始，此外‘’也表示排除，默认单行匹配；\n3. ‘$’匹配整个字符串的结束，默认单行匹配；\n4. 多行匹配的方式如下：以(?m)开头。例如：(?m)^abc$\n5. \\A和^类似；\n6. \\Z和$类似；\\z匹配的总是结束的边界；\n7. \\b匹配的是单词的边界；\n8. 边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界；\n\n## 环视边界匹配\n\n1. 此部分内容比较晦涩，暂不做了解；\n\n# 函数式编程\n\n## 函数是接口：\n\n1. Java中预定义了大量的函数式接口：\n\n| 函数接口            | 方法定义               | 说明                                 |\n| ------------------- | ---------------------- | ------------------------------------ |\n| Predicate<T>        | boolean test(T t)      | 谓词，测试输入条件是否满足要求       |\n| Function<T, R>      | R apply(T t)           | 函数转换，输入类型T，输出类型R       |\n| Consumer<T>         | void accept(T t)       | 消费者，输入类型T                    |\n| Supplier<T>         | T get()                | 工厂方法                             |\n| UnaryOperator<T>    | T apply(T t)           | 函数转换的特例，输入和输出类型一样   |\n| BiFunction<T, U, R> | R apply(T t, U u)      | 函数转换，接受两个参数，输出R        |\n| BinaryOperator<T>   | T apply(T t, T u)      | BiFunction的特例，输入和输出类型一样 |\n| BiConsumer<T, U>    | void accept(T t, U u)  | 消费者，接受两个参数                 |\n| BiPredicate<T, U>   | boolean test(T t, U u) | 谓词，接受两个参数                   |\n\n1. Predicate示例：\n\n```java\nstatic class Student {\n    String name;\n    double score;\n    // 省略getter/setter\n}\n\n// 借助Predicate撰写一个filter的逻辑，例如：\nstudents = filter(students, t -> t.getScore() > 90);\n```\n\n1. Function示例：数据转换\n\n```java\n// 根据学生列表返回名称列表的代码：\nList<Student> names = map(students, t -> t.getName());\n\n// 将学生名称转换为大写：\nstudents = map(students, t -> new Student(t.getName().toUpperCase(), t.getScore()))\n```\n\n1. Consumer示例：直接对原值进行修改\n\n```java\nforeach(students, t -> t.setName(t.getName(),.toUpperCase()))\n```\n\n## 方法引用\n\n1. 示例代码中`Student::getName`称之为方法引用，使用::分隔开。分隔符前面是类型或变量名，后者是方法名。方法可以是实例方法，也可以是静态方法。例如：\n\n```java\npublic static String getColleageName() {\n    return \"Test String\";\n}\n// 下面两条句子的等价的\nSupplier<String> s = Student::getColleageName;\nSupplier<String> s = () -> Student.getColleageName()；\n```\n\n## 函数的复合\n\n1. 函数式接口和Lambda表达式可以用作方法的返回值，传递代码回调者，将上述两种方法结合起来，可以构造复合的函数，使程序简洁易读；\n2. 复合Comparator中的复合方法：\n\n```java\nArrays.sort(files, (f1, f2) -> f1.getName().compareTo(f2.getName()));\n// 进一步简化\nArrays.sort(files, Comparator.comparing(File::getName()));\n```\n\n## Stream API\n\n1. 基本过滤\n\n```java\n// 使用Stream API之前\nList<Student> above90List = new ArrayList<>();\nfor (Student t : students) {\n    if (t.getScore() > 90) {\n        above90List.add(t);\n    }\n}\n\n// 使用Stream API之后\nList<Student> above90List = students.stream()\n    .filter(t -> t.getScore() > 90).collect(Collectors.toList());\n```\n\n+ 没有显式的迭代循环，循环过程被Stream隐藏；\n+ 提供了声明式的处理函数；\n+ 流畅式接口；\n\n1. 基本转换\n\n```java\n// 使用Stream API之前\nList<String> nameList = new ArrayList<>();\nfor (Student t : students) {\n    nameList.add(t.getName());\n}\n\n// 使用Stream API之后\nList<String> nameList = students.stream()\n    .map(Student::getName).collect(Collectors.toList());\n```\n\n1. 基本过滤和转换组合\n\n```java\nList<String> above90List = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .map(Student::getName)\n    .collect(Collectors.toList());\n```\n\n1. distinct运算\n\n+ 用于过滤重复元素，只留下唯一元素，是否重复根据equals()方法来比较。\n\n```java\nList<String> list = Arrays.asList(new String[]{\"abc\", \"def\", \"hello\", \"Abc\"});\nList<String> retList = list.stream()\n    .filter(s -> s.length() <= 3).map(String::toLowerCase).distinct()\n    .collect(Collectors.toList());\n```\n\n1. sorted方法\n\n+ 对流中的元素进行排序，返回一个排序后的stream。例如：\n\n```java\nList<Student> list = students.stream().filter(t -> t.getScore() > 0)\n    .sorted(Comparator.comparing(Student::getScore)\n    .reversed().thenComparing(Student::getName))\n    .collect(Collectors.toList());\n```\n\n1. skip/limit\n\n+ 跳过流中的n个元素，如果流的长度不足n个，返回一个空流。例如：\n\n```java\nList<Student> list = students.stream()\n    .sorted(Comparator.comparing(Student::getScore).reversed()\n    .skip(2).limit(3).collect(Coolectors.toList()));\n```\n\n1. peek\n\n+ 返回一个与之前一样的流，没有变化。但是提供一个Consumer，会将流中的每一个元素传给Consumer。这个方法主要目的用于支持调试，可以使用该方法观察在流水线中流转的元素。例如：\n\n```java\nList<String> above90Names = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .peek(System.out::println).map(Student::getName)\n    .collect(Collectors.toList());\n```\n\n1. mapToLong/mapToInt/mapToDouble\n\n+ map函数接受函数参数是一个`Function<T, R>`，为避免拆箱，装箱提高性能。例如：\n\n```java\ndouble sum = students.stream()\n    .mapToDouble(Student::getScore).sum();\n```\n\n1. flatMap\n\n+ 接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换成一个流Stream。然后将新生成流的每一个元素传递给下一个操作。比如：\n\n```java\nList<String> lines = Arrays.asList(new String[]{\"hello abc\", \"laoma biancheng\"});\nList<String> words = lines.stream()\n    .flatMap(line -> Arrays.stream(line.split(\"\\\\s+\")))\n    .collect(Collectors.toList());\nSystem.out.println(words); // [hello, abc. laoma, biancheng]\n```\n\n## 终端操作\n\n1. 中间操作不触发实际执行，返回值是Stream，而终端操作触发执行，返回一个具体的值。除了collect之外还有：max, min, count, allMatch, anyMatch, noneMatch, findFirst, findAny, forEach, toArray, reduce等。\n2. max/min: 返回流中的最大值/最小值。其返回类型为Optional<T>而非T。Optional表明可能为null，程序应当进行适当的处理。例子：\n\n```java\nStudent student = students.stream()\n    .max(Comparator.comparing(Student::getScore).reversed()).get();\n```\n\n1. count：返回流中的元素个数，例如：\n\n```java\nlong above90Count = students.stream()\n    .filter(t -> t.getScore() > 90).count();\n```\n\n1. allMatch/anyMatch/noneMatch：用于判定流中额元素是否满足一定的条件，区别在于：\n\n+ allMatch：流中所有元素都满足条件的情况下返回true;\n+ anyMatch：流中的元素只要有一个元素满足条件即返回true;\n+ noneMatch：只有流中的所有元素都不满足条件才返回true;\n+ 示例如下：\n\n```java\nboolean allPass = students.stream()\n    .allMatch(t -> t.getScore() >= 60);\n```\n\n1. findFirst/findAny：返回类型均为Optional，如果流为空则返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素。均为短路操作。示例：\n\n```java\nOptional<Student> student = students.stream()\n    .filter(t -> t.getScore() < 60)\n    .findAny();\nif (student.isPresent()) {\n    // 处理不符合要求的数据\n}\n```\n\n1. forEach/forEachOrdered：并行流中forEach不保证顺序，forEachOrdered能保证顺序。例如：\n\n```java\nstudents.stream()\n    .filter(t -> t.getScore() > 90)\n    .forEach(System.out::println);\n```\n\n1. toArray：将流转换为数组，包含两个方法。\n\n```java\nObject[] toArray() // 返回值为Object[]\n<A> A[] toArray(IntFunction<A[]> generator) // 得到指定类型的数组\n```\n\n+ 示例为：\n\n```java\nStudent[] above90Arr = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .toArray(Student[]::new); // Student[]::new就是一个IntFunction类型的ggenerator\n```\n\n1. reduce：归约或折叠，将流中的元素归约为一个值，有三种reduce函数：\n\n```java\nOptional<T> reduce(BinaryOperator<T> accumulator);\nT reduce(T identity, BinaryOperator<T> accumulator);\n<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);\n```\n\n+ 第一个reduce函数的使用\n\n```java\nStudent topStudent = students.stream()\n    .reduce((acc, t) -> {\n        if(acc.getScore() >= t.getScore()) {\n            return acc;\n        } else {\n            return t;\n        }\n    }).get();\n```\n\n+ 第二个reduce函数比第一个多了identity参数，表示初始值\n+ 第三个reduce函数更为通用，可以自定义归约类型，另外还多了一个combiner参数，在并行流中用于合并子线程结果。还有示例：\n\n```java\ndouble sumScore = students.stream()\n    .reduce(0d, (sum, t) -> sum += t.getScore(), \n    (sum1, sum2) -> sum1 += sum2)\n    );\n```\n\n1. 迭代Map的过程删除元素，直接使用forEach会报ConcurrentModificationException\n\n```java\nMap<String, Object> map = other.getHashMap<>();\nmap.entrySet().removeIf(entryElement -> \"some condition\".equals(entryElement.getKey()))\n```\n","source":"_posts/java-core/ch06.md","raw":"---\ntitle: Java编程原理——动态与函数式编程\ndate: 2022-02-16 22:33:55\nupdated: 2022-02-16 22:33:55\ntags: Java基础\ncategories: Java\n---\n\n# 反射\n\n1. 反射是在类运行时动态获取类型的信息。比如接口信息、成员信息、方法信息、构造函数信息等。根据动态获取到的信息创建对象、访问/修改成员、调用方法等。\n2. 使用反射可以得到类的名称，调用方法getName()。其中还包括getSimpleName()，getCanonicalName()以及getPackage()。\n3. 类中定义的静态和实例变量称之为字段，使用Field类表示，可以获取字段的访问权限，设置访问权限，获得字段值以及设置字段值。除此之外，还可以获得字段的修饰符以及基本类型。需要注意的是使用反射返回的修饰符是一个整型。如果需要查看具体的返回值类型，可以使用Modifier进行再次判断。\n4. 通过反射也可以获取类中的方法信息：对于invoke方法而言，如果Method是静态方法，则obj被忽略为null，args可以为null；\n5. 创建对象和构造方法：`public T newInstance() throws InstantiationException, IllegalAccessException`；\n6. 类型检查和转换：使用`instanceof`关键字可以用于判断变量指向的实际对象类型，instanceof后面的类型是在代码中确定的；\n7. 除此之外，Class方法中还有其他的一些方法可以用于获取类的声明信息、修饰符、父类、接口以及注解等；\n8. 对于数组类型可以使用`public native Class<T> getComponentType()`获取其元素类型；\n9. 反射与枚举：枚举类型也有一个专门的方法：`public T[] getEnumConstants()`；\n10. 反射与泛型：可以获取泛型参数的信息：\n\n+ Class类有如下方法：`public TypeVariable<Class<T>>[] getTypeParameters()`\n+ Field有如下方法：`public Type getGenericType()`\n+ Method有如下方法：`public Type getGenericReturnType()`，`public Type[] getGenericParameterTypes()`和`public Type[] getGenericExceptionTypes()`\n+ Constructor有如下方法：`public Type[] getGenericParameterTypes()`\n\n1. Type实现了Class方法，其中还实现了下列方法：\n\n+ TypeVariable类型参数可以有上界；\n+ ParameterizedType参数化的类型，有原始类型和具体类型；\n+ WildcardType通配符类型\n+ 通过反射获取泛型示例\n\n```java\npublic class GenericDemo {\n    static class GenericTest<U extends Comparable<U, V> {\n        U u;\n        V v;\n        List<String> list;\n        public U test(List<? extends Number> numbers) {\n            return null;\n        }\n    }\n    public static void main(String[] args) {\n        Class<?> cls = GenericTest.class;\n        for (TypeVariable t : cls.getTypeParameters()) {\n            System.out.println(t.getName() + \" extends \" + Arrays.toString(t.getBounds()));\n        }\n        Field fu = cls.getDeclaredField(\"u\");\n        System.out.println(fu.getGenericType());\n        Field first = cls.getDeclaredField(\"list\");\n        Type listType = first.getGenericType();\n        if (!listType instanceof ParameterizedType) {\n            ParameterizedType pType = (ParameterizedType)listType;\n            System.out.println(\"raw type: \" + pType.getRawType() + \" ,type arguments:\" + Arrays.toString(pType.getActualTypeArguments()));\n        }\n        // 省略代码\n    }\n}\n```\n\n1. 总结：反射虽然灵活，但一般情况下我们并不优先建议，原因有如下：\n\n+ 反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力；\n+ 反射会降低性能，在访问字段、调用方法前，反射要先查找对应的Field/Method，要慢一些；\n\n1. 如果能用接口实现同样的灵活性，就不要使用反射；\n\n# 注解\n\n1. 注解是给程序添加一些信息，这些信息可以用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序；\n2. Java内置`@Override`，`@Deprecated`和`@SuppressWarning`三个注解，这三个注解远远不能满足日常开发需求，因此自定义注解产生。\n3. 注解是声明式编程中的一种巧妙应用，在这种风格中，程序通常由下列三部分实现：\n\n+ 声明的关键字和语法本身；\n+ 系统/框架/库，它们负责解释，执行声明式的语句；\n+ 应用程序，使用声明式编程风格编写程序；\n\n1. 创建注解：使用`@interface`关键字声明注解，另外是需要在声明的注解标明元注解。以`@Override`注解为例：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n4.1 ElementType是一个枚举，可以取下列值：\n\n+ TYPE：表示类、接口（包括注解），或者是枚举类型\n+ FIELD：字段，包括枚举常量\n+ METHOD：方法\n+ PARAMETER：方法中的参数\n+ CONSTRUCTOR：构造方法\n+ LOCAL_VARIABLE：本地变量\n+ MODULE：模块（Java 9引入）\n+ \n\n4.2 如果没有声明`@Target`，默认适用于所有类型；\n\n4.3 `@Retention`表示注解信息保留到什么时候，取值只有一个，类型为RetentionPolicy，它是一个枚举，有三个值：\n\n+ SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后去掉；\n+ CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留（默认值）；\n+ RUNTIME：一直保留到运行时\n\n4.4 `@Documented`注解表示注解信息包含到生成文档中；\n\n4.5 注解不能继承，但是使用了注解的父类一旦被子类继承，那么子类就可以继承父类的注解，如果要实现这样的效果，需要在父类的注解中加上`@Inherited`\n\n1. 总结：注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离。框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作；\n\n# 动态代理\n\n1. 静态代理\n\n```java\npublic class SImpleStaticProxy {\n    interface IService {\n        void sayHello();\n    }\n\n    // 真实对象\n    static class RealService implements IService {\n        @Override\n        public void sayHello() {\n            System.out.println(\"RealService Say Hello!\");\n        }\n    }\n\n    // 代理对象\n    static class TraceProxy implements IService {\n        private IService realService;\n\n        TraceProxy(IService realService) {\n            this.realService = realService;\n        }\n\n        @Override\n        public void sayHello() {\n            System.out.println(\"entering say hello...\");\n            this.realService.sayHello();\n            System.out.println(\"exited say hello...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = new TraceProxy(realService);\n        proxyService.sayHello();\n    }\n}\n```\n\n1. 动态代理\n\n```java\npublic class SimpleDynamicProxy {\n    interface IService {\n        void sayHello();\n    }\n    \n    // 真实对象\n    static class RealService implements IService {\n        @Override\n        public void sayHello() {\n            System.out.println(\"Real Service Say Hello\");\n        }\n    }\n    \n    // 代理对象实现JDK中的InvocationHandler接口\n    static class SimpleInvocationHandle implements InvocationHandler {\n        private Object realObj;\n\n        SimpleInvocationHandle(Object realObj) {\n            this.realObj = realObj;\n        }\n        \n        // 重写invoke方法\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            // proxy：表示代理对象本身，不是被代理对象，一般用处不大\n            // method：表示正在被调用的方法\n            // args：表示方法的参数\n            System.out.println(\"entering \" + method.getName());\n            Object result = method.invoke(realObj, args);\n            System.out.println(\"leaving \" + method.getName());\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = (IService) Proxy.newProxyInstance(IService.class.getClassLoader(), new Class<?>[]{IService.class},\n                new SimpleInvocationHandle(realService)); // 使用Proxy.newProxyInstance生成一个代理对象\n        proxyService.sayHello();\n    }\n}\n```\n\n+ newProxyInstance的声明如下：\n\n```java\npublic static Object newProxyInstance(ClassLoader classLoader, Class<?>[] interfaces, InvocationHandler h);\n// ClassLoader：表示类加载器；\n// Class<?>[] interfaces：表示代理类要实现的接口列表，元素类型只能是接口，不能是普通类；\n// InvocationHandler：是一个接口，对代理接口所有方法的调用都会转给该方法；\n// newProxyInstance是Object类型，它不能强制转换为某个类型，只能转换为接口类型；\n```\n\n1. 类定义本身与被代理的对象没有关系，与InvocationHandler的具体实现也没有关系，而主要与接口数组有关，给定的接口数组会动态地创建每个接口的实现代码，实现就是转发给InvocationHandler，与被代理对象的关系以及对它的调用由InvocationHandler实现管理。\n2. 总结：使用动态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每个被代理的类型都是创建一个静态代理类。\n3. 局限性：JDK中的动态代理只能为接口创建代理，返回的代理对象也只能转换到某个接口类型；如果一个类没有接口，或者希望代理非接口中定义的方法，就无能为力了。\n4. 使用cglib的动态代理类可以解决上述的痛点。示例如下：\n\n```java\npublic class SimpleCGLibDemo {\n    static class RealService {\n        public void sayHello() {\n            System.out.println(\"hello\");\n        }\n    }\n    static class SimpleInterceptor implements MethodInterceptor {\n        @Override\n        public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            System.out.println(\"entering \" + method.getName());\n            Object result = proxy.invokeSuper(object, args);\n            System.out.println(\"leaving \" + method.getName());\n        }\n    }\n    private static <T> T getProxy(Class<T> cls) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(cls);\n        enhancer.setCallback(new SimpleInterceptor());\n        return (T)enhancer.create();\n    }\n    \n    public static void main(String[] args) {\n        RealService proxyService = getProxy(RealService.class);\n        proxyService.sayHello();\n    }\n}\n```\n\n1. cglib代理面向的一个具体的类，创建对象只有一个；而SDK代理面向的是接口；\n\n# 类加载机制\n\n1. 类加载机制可以应用于下列场景：\n\n+ 热部署：不重启程序的情况下动态替换\n+ 应用模块化和互相隔离：不同的ClassLoader可以加载相同的类，但是互相隔离、互不影响。例如：Tomcat管理多个Web应用程序；\n+ 从不同地方灵活加载：系统默认从本地.class文件或者.jar包中加载字节码文件，通过自定义ClassLoader可以从共享服务器、数据库、缓存服务器等其他地方加载字节码文件；\n\n1. 类加载机制组成部分：\n\n+ 启动类型加载器（Bootstrap Classloader）：一般由C++实现的，它负责加载Java的基础类，主要是<JAVA_HOME>/lib/rt.jar；\n+ 扩展类加载器（Extension Classloader）：加载器的实现类sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类；\n+ 应用程序类加载器（Application ClassLoader）：实现类是sun.misc.Launcher$AppClassLoader。负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类；\n\n1. 类加载的全过程：\n\n+ 1）判断是否已经加载过，如果加载过直接返回Class对象，一个类只会被一个ClassLoader加载过一次；\n+ 2）如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象；\n+ 3）在父ClassLoader没有加载成功的前提下，自己尝试加载类；\n\n1. 这个过程称之为“双亲委派”模型。优先让父ClassLoader去加载。\n2. 类加载都按照“双亲委派”模型，但是也有例外：\n\n+ 自定义加载顺序：即自定义的类加载器可以不遵循“双亲委派”模型，但一般上是不推荐的；\n+ 网状加载顺序：在OSGI和Java9中存在网状加载的情况。\n+ 父加载器委派给子加载器：典型应用有JNDI。\n\n1. 类加载器的例子：\n\n```java\npublic class ClassLoaderDemo {\n    public static void main(String[] args) {\n        ClassLoader c1 = ClassLoaderDemo.class.getClassLoader();\n        while (c1 != null) {\n            System.out.println(c1.getClass().getName());\n            c1 = c1.getParent();\n        }\n        System.out.println(String.class.getClassLoader());\n    }\n}\n// 输出结果为：\n// sun.misc.Launcher.$AppClassLoader\n// sun.misc.Launcher.$ExtClassLoader\n```\n\n1. ClassLoader中有一个默认方法`public static ClassLoader getSystemClassLoader()`，还有一个默认方法用于加载类： `public class<?> loadClass(String name) throws ClassNotFoundException`。示例如下：\n\n```java\nClassLoader c1 = ClassLoader.getSystemClassLoader();\ntry {\n    Class<?> cls = c1.loadClass(\"java.util.ArrayList\");\n    ClassLoader actualLoader = cls.getClassLoader();\n    System.out.println(actualloader);\n} catch (ClassNotFoundException e) {\n    e.printStackTrace();\n}\n```\n\n1. 类加载器是一个抽象类。Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader以及sun.misc.Launcher$ExtClassLoader。Bootstrap ClassLoader不是由Java实现的。因此没有实现类。需要说明的是，由于是委派机制。使用getClassLoader()方法返回的不一定调用load-Class.\n2. ClassLoader中的loadClass方法只会加载类但是不会执行。示例如下：\n\n```java\npublic class CLInitDemo {\n    public static class Hello {\n        static {\n            System.out.println(\"hello\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ClassLoader c1 = ClassLoader.getSystemClassLoader();\n        String className = CLInitDemo.class.getName() + \"$Hello\";\n        try {\n            Class<?> cls = c1.loadClass(className); // 不会输出\"hello\"\n            // Class<?> cls = Class.forName(className); // 会输出\"hello\"\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n1. 通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，也是一种策略模式。\n\n# 正则表达式\n\n## 单个字符\n\n1. 用字符本身表示\n2. 特殊字符：例如制表符'\\t'，换行符'\\n'以及回车符'\\r'；\n3. 八进制表示的字符：以'\\0'开头，后面加上1~3位数字，例如\\0141(8) -> 97(10)\n4. 十六进制表示的字符：以'\\x'开头，后面跟两位字符，比如\\x6A(16) -> 106(10)\n5. Unicode表示字符，以'\\u'开头，后面跟4位字符\n6. 斜杠本身就是特殊字符，如果需要使用斜杠需要用一个斜杠进行转义；\n7. 元字符：例如“.、*、?、+”等，如果要皮匹配自身，需要在前面加''进行转义\n\n## 字符祖\n\n1. '.'字符匹配除了换行符以外的任意字符，也可以使用“单行匹配模式”或者“点号匹配模式”。可以以(?s)开头，s表示single line；\n2. 中括号[]表示匹配字符组中的任意一个字符，例如[abcd]匹配任意一个字母；\n3. '^'表示排除符号；\n4. \\d：匹配一个数字字符，等同于[0-9]；\n5. \\w：匹配一个单词字符，等同于[a-zA-Z_0-9]；\n6. \\s：匹配一个空白字符，等同于[\\t\\n\\x0B\\f\\r]\n7. \\D：匹配一个非数字字符，即[^\\d]；\n8. \\W：匹配一个非单词字符，即[^\\w]；\n9. \\S：匹配一个非空白字符，即[^\\s]；\n\n## 量词\n\n1. 量词是指定出现次数的元字符，常见的有三种+、*、？\n2. '+'表示前面字符的一次或多次出现。比如正则表达式ab+c，既能匹配abc，也能匹配abbc:\n3. '*'表示前面的字符的零次或多次出现，例如：ab*c。既能匹配abc，也能匹配ac或abbbc；\n4. '?'表示前面字符可能出现，也可能不出现。例如正则表达式ab?c，既能匹配abc，也能匹配ac；\n5. 通用表示出现次数的语法为{m,n}，出现次数从m到n，包括m和n。如果n没有限制可以省略。如果m和n一样，可以省略一个写为{m}。例如：\n\n+ ab{1,10}c：b可以出现1次到10次\n+ ab{3}c：b必须出现三次\n+ ab{1,}c：等同于ab+c\n+ ab{0,}c：等同于ab*c\n+ ab{0,1}c：等同于ab?c\n\n1. 量词默认是贪婪的，也就是说会从正则开始匹配到结束内的所有字符，如果需要在匹配到第一个就终止，需要使用懒惰量词。即在两次后面加上一个符号'?'；\n\n## 分组\n\n1. 可以用括号将表达式括起来，表示一个分组。分组匹配的子字符串可以在后续访问，好像被被捕获了一样，所以默认分组称之为捕获分组；\n2. 在正则表达式中，可以使用斜杠\\加分组编号引用之前匹配的分组，称之为回溯引用；\n\n## 特殊边界匹配\n\n1. 常见的特殊边界的元字符有^、$、\\A、\\Z、\\z和\\b。\n2. ‘’匹配整个字符串的开始，此外‘’也表示排除，默认单行匹配；\n3. ‘$’匹配整个字符串的结束，默认单行匹配；\n4. 多行匹配的方式如下：以(?m)开头。例如：(?m)^abc$\n5. \\A和^类似；\n6. \\Z和$类似；\\z匹配的总是结束的边界；\n7. \\b匹配的是单词的边界；\n8. 边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界；\n\n## 环视边界匹配\n\n1. 此部分内容比较晦涩，暂不做了解；\n\n# 函数式编程\n\n## 函数是接口：\n\n1. Java中预定义了大量的函数式接口：\n\n| 函数接口            | 方法定义               | 说明                                 |\n| ------------------- | ---------------------- | ------------------------------------ |\n| Predicate<T>        | boolean test(T t)      | 谓词，测试输入条件是否满足要求       |\n| Function<T, R>      | R apply(T t)           | 函数转换，输入类型T，输出类型R       |\n| Consumer<T>         | void accept(T t)       | 消费者，输入类型T                    |\n| Supplier<T>         | T get()                | 工厂方法                             |\n| UnaryOperator<T>    | T apply(T t)           | 函数转换的特例，输入和输出类型一样   |\n| BiFunction<T, U, R> | R apply(T t, U u)      | 函数转换，接受两个参数，输出R        |\n| BinaryOperator<T>   | T apply(T t, T u)      | BiFunction的特例，输入和输出类型一样 |\n| BiConsumer<T, U>    | void accept(T t, U u)  | 消费者，接受两个参数                 |\n| BiPredicate<T, U>   | boolean test(T t, U u) | 谓词，接受两个参数                   |\n\n1. Predicate示例：\n\n```java\nstatic class Student {\n    String name;\n    double score;\n    // 省略getter/setter\n}\n\n// 借助Predicate撰写一个filter的逻辑，例如：\nstudents = filter(students, t -> t.getScore() > 90);\n```\n\n1. Function示例：数据转换\n\n```java\n// 根据学生列表返回名称列表的代码：\nList<Student> names = map(students, t -> t.getName());\n\n// 将学生名称转换为大写：\nstudents = map(students, t -> new Student(t.getName().toUpperCase(), t.getScore()))\n```\n\n1. Consumer示例：直接对原值进行修改\n\n```java\nforeach(students, t -> t.setName(t.getName(),.toUpperCase()))\n```\n\n## 方法引用\n\n1. 示例代码中`Student::getName`称之为方法引用，使用::分隔开。分隔符前面是类型或变量名，后者是方法名。方法可以是实例方法，也可以是静态方法。例如：\n\n```java\npublic static String getColleageName() {\n    return \"Test String\";\n}\n// 下面两条句子的等价的\nSupplier<String> s = Student::getColleageName;\nSupplier<String> s = () -> Student.getColleageName()；\n```\n\n## 函数的复合\n\n1. 函数式接口和Lambda表达式可以用作方法的返回值，传递代码回调者，将上述两种方法结合起来，可以构造复合的函数，使程序简洁易读；\n2. 复合Comparator中的复合方法：\n\n```java\nArrays.sort(files, (f1, f2) -> f1.getName().compareTo(f2.getName()));\n// 进一步简化\nArrays.sort(files, Comparator.comparing(File::getName()));\n```\n\n## Stream API\n\n1. 基本过滤\n\n```java\n// 使用Stream API之前\nList<Student> above90List = new ArrayList<>();\nfor (Student t : students) {\n    if (t.getScore() > 90) {\n        above90List.add(t);\n    }\n}\n\n// 使用Stream API之后\nList<Student> above90List = students.stream()\n    .filter(t -> t.getScore() > 90).collect(Collectors.toList());\n```\n\n+ 没有显式的迭代循环，循环过程被Stream隐藏；\n+ 提供了声明式的处理函数；\n+ 流畅式接口；\n\n1. 基本转换\n\n```java\n// 使用Stream API之前\nList<String> nameList = new ArrayList<>();\nfor (Student t : students) {\n    nameList.add(t.getName());\n}\n\n// 使用Stream API之后\nList<String> nameList = students.stream()\n    .map(Student::getName).collect(Collectors.toList());\n```\n\n1. 基本过滤和转换组合\n\n```java\nList<String> above90List = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .map(Student::getName)\n    .collect(Collectors.toList());\n```\n\n1. distinct运算\n\n+ 用于过滤重复元素，只留下唯一元素，是否重复根据equals()方法来比较。\n\n```java\nList<String> list = Arrays.asList(new String[]{\"abc\", \"def\", \"hello\", \"Abc\"});\nList<String> retList = list.stream()\n    .filter(s -> s.length() <= 3).map(String::toLowerCase).distinct()\n    .collect(Collectors.toList());\n```\n\n1. sorted方法\n\n+ 对流中的元素进行排序，返回一个排序后的stream。例如：\n\n```java\nList<Student> list = students.stream().filter(t -> t.getScore() > 0)\n    .sorted(Comparator.comparing(Student::getScore)\n    .reversed().thenComparing(Student::getName))\n    .collect(Collectors.toList());\n```\n\n1. skip/limit\n\n+ 跳过流中的n个元素，如果流的长度不足n个，返回一个空流。例如：\n\n```java\nList<Student> list = students.stream()\n    .sorted(Comparator.comparing(Student::getScore).reversed()\n    .skip(2).limit(3).collect(Coolectors.toList()));\n```\n\n1. peek\n\n+ 返回一个与之前一样的流，没有变化。但是提供一个Consumer，会将流中的每一个元素传给Consumer。这个方法主要目的用于支持调试，可以使用该方法观察在流水线中流转的元素。例如：\n\n```java\nList<String> above90Names = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .peek(System.out::println).map(Student::getName)\n    .collect(Collectors.toList());\n```\n\n1. mapToLong/mapToInt/mapToDouble\n\n+ map函数接受函数参数是一个`Function<T, R>`，为避免拆箱，装箱提高性能。例如：\n\n```java\ndouble sum = students.stream()\n    .mapToDouble(Student::getScore).sum();\n```\n\n1. flatMap\n\n+ 接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换成一个流Stream。然后将新生成流的每一个元素传递给下一个操作。比如：\n\n```java\nList<String> lines = Arrays.asList(new String[]{\"hello abc\", \"laoma biancheng\"});\nList<String> words = lines.stream()\n    .flatMap(line -> Arrays.stream(line.split(\"\\\\s+\")))\n    .collect(Collectors.toList());\nSystem.out.println(words); // [hello, abc. laoma, biancheng]\n```\n\n## 终端操作\n\n1. 中间操作不触发实际执行，返回值是Stream，而终端操作触发执行，返回一个具体的值。除了collect之外还有：max, min, count, allMatch, anyMatch, noneMatch, findFirst, findAny, forEach, toArray, reduce等。\n2. max/min: 返回流中的最大值/最小值。其返回类型为Optional<T>而非T。Optional表明可能为null，程序应当进行适当的处理。例子：\n\n```java\nStudent student = students.stream()\n    .max(Comparator.comparing(Student::getScore).reversed()).get();\n```\n\n1. count：返回流中的元素个数，例如：\n\n```java\nlong above90Count = students.stream()\n    .filter(t -> t.getScore() > 90).count();\n```\n\n1. allMatch/anyMatch/noneMatch：用于判定流中额元素是否满足一定的条件，区别在于：\n\n+ allMatch：流中所有元素都满足条件的情况下返回true;\n+ anyMatch：流中的元素只要有一个元素满足条件即返回true;\n+ noneMatch：只有流中的所有元素都不满足条件才返回true;\n+ 示例如下：\n\n```java\nboolean allPass = students.stream()\n    .allMatch(t -> t.getScore() >= 60);\n```\n\n1. findFirst/findAny：返回类型均为Optional，如果流为空则返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素。均为短路操作。示例：\n\n```java\nOptional<Student> student = students.stream()\n    .filter(t -> t.getScore() < 60)\n    .findAny();\nif (student.isPresent()) {\n    // 处理不符合要求的数据\n}\n```\n\n1. forEach/forEachOrdered：并行流中forEach不保证顺序，forEachOrdered能保证顺序。例如：\n\n```java\nstudents.stream()\n    .filter(t -> t.getScore() > 90)\n    .forEach(System.out::println);\n```\n\n1. toArray：将流转换为数组，包含两个方法。\n\n```java\nObject[] toArray() // 返回值为Object[]\n<A> A[] toArray(IntFunction<A[]> generator) // 得到指定类型的数组\n```\n\n+ 示例为：\n\n```java\nStudent[] above90Arr = students.stream()\n    .filter(t -> t.getScore() > 90)\n    .toArray(Student[]::new); // Student[]::new就是一个IntFunction类型的ggenerator\n```\n\n1. reduce：归约或折叠，将流中的元素归约为一个值，有三种reduce函数：\n\n```java\nOptional<T> reduce(BinaryOperator<T> accumulator);\nT reduce(T identity, BinaryOperator<T> accumulator);\n<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);\n```\n\n+ 第一个reduce函数的使用\n\n```java\nStudent topStudent = students.stream()\n    .reduce((acc, t) -> {\n        if(acc.getScore() >= t.getScore()) {\n            return acc;\n        } else {\n            return t;\n        }\n    }).get();\n```\n\n+ 第二个reduce函数比第一个多了identity参数，表示初始值\n+ 第三个reduce函数更为通用，可以自定义归约类型，另外还多了一个combiner参数，在并行流中用于合并子线程结果。还有示例：\n\n```java\ndouble sumScore = students.stream()\n    .reduce(0d, (sum, t) -> sum += t.getScore(), \n    (sum1, sum2) -> sum1 += sum2)\n    );\n```\n\n1. 迭代Map的过程删除元素，直接使用forEach会报ConcurrentModificationException\n\n```java\nMap<String, Object> map = other.getHashMap<>();\nmap.entrySet().removeIf(entryElement -> \"some condition\".equals(entryElement.getKey()))\n```\n","slug":"java-core/ch06","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2m00082y615d9j7bav","content":"<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><ol>\n<li>反射是在类运行时动态获取类型的信息。比如接口信息、成员信息、方法信息、构造函数信息等。根据动态获取到的信息创建对象、访问/修改成员、调用方法等。</li>\n<li>使用反射可以得到类的名称，调用方法getName()。其中还包括getSimpleName()，getCanonicalName()以及getPackage()。</li>\n<li>类中定义的静态和实例变量称之为字段，使用Field类表示，可以获取字段的访问权限，设置访问权限，获得字段值以及设置字段值。除此之外，还可以获得字段的修饰符以及基本类型。需要注意的是使用反射返回的修饰符是一个整型。如果需要查看具体的返回值类型，可以使用Modifier进行再次判断。</li>\n<li>通过反射也可以获取类中的方法信息：对于invoke方法而言，如果Method是静态方法，则obj被忽略为null，args可以为null；</li>\n<li>创建对象和构造方法：<code>public T newInstance() throws InstantiationException, IllegalAccessException</code>；</li>\n<li>类型检查和转换：使用<code>instanceof</code>关键字可以用于判断变量指向的实际对象类型，instanceof后面的类型是在代码中确定的；</li>\n<li>除此之外，Class方法中还有其他的一些方法可以用于获取类的声明信息、修饰符、父类、接口以及注解等；</li>\n<li>对于数组类型可以使用<code>public native Class&lt;T&gt; getComponentType()</code>获取其元素类型；</li>\n<li>反射与枚举：枚举类型也有一个专门的方法：<code>public T[] getEnumConstants()</code>；</li>\n<li>反射与泛型：可以获取泛型参数的信息：</li>\n</ol>\n<ul>\n<li>Class类有如下方法：<code>public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters()</code></li>\n<li>Field有如下方法：<code>public Type getGenericType()</code></li>\n<li>Method有如下方法：<code>public Type getGenericReturnType()</code>，<code>public Type[] getGenericParameterTypes()</code>和<code>public Type[] getGenericExceptionTypes()</code></li>\n<li>Constructor有如下方法：<code>public Type[] getGenericParameterTypes()</code></li>\n</ul>\n<ol>\n<li>Type实现了Class方法，其中还实现了下列方法：</li>\n</ol>\n<ul>\n<li>TypeVariable类型参数可以有上界；</li>\n<li>ParameterizedType参数化的类型，有原始类型和具体类型；</li>\n<li>WildcardType通配符类型</li>\n<li>通过反射获取泛型示例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericTest</span>&lt;U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Comparable</span>&lt;U, V&gt; &#123;<br>        U u;<br>        V v;<br>        List&lt;String&gt; list;<br>        <span class=\"hljs-keyword\">public</span> U <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(List&lt;? extends Number&gt; numbers)</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        Class&lt;?&gt; cls = GenericTest.class;<br>        <span class=\"hljs-keyword\">for</span> (TypeVariable t : cls.getTypeParameters()) &#123;<br>            System.out.println(t.getName() + <span class=\"hljs-string\">&quot; extends &quot;</span> + Arrays.toString(t.getBounds()));<br>        &#125;<br>        <span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">fu</span> <span class=\"hljs-operator\">=</span> cls.getDeclaredField(<span class=\"hljs-string\">&quot;u&quot;</span>);<br>        System.out.println(fu.getGenericType());<br>        <span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> cls.getDeclaredField(<span class=\"hljs-string\">&quot;list&quot;</span>);<br>        <span class=\"hljs-type\">Type</span> <span class=\"hljs-variable\">listType</span> <span class=\"hljs-operator\">=</span> first.getGenericType();<br>        <span class=\"hljs-keyword\">if</span> (!listType <span class=\"hljs-keyword\">instanceof</span> ParameterizedType) &#123;<br>            <span class=\"hljs-type\">ParameterizedType</span> <span class=\"hljs-variable\">pType</span> <span class=\"hljs-operator\">=</span> (ParameterizedType)listType;<br>            System.out.println(<span class=\"hljs-string\">&quot;raw type: &quot;</span> + pType.getRawType() + <span class=\"hljs-string\">&quot; ,type arguments:&quot;</span> + Arrays.toString(pType.getActualTypeArguments()));<br>        &#125;<br>        <span class=\"hljs-comment\">// 省略代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>总结：反射虽然灵活，但一般情况下我们并不优先建议，原因有如下：</li>\n</ol>\n<ul>\n<li>反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力；</li>\n<li>反射会降低性能，在访问字段、调用方法前，反射要先查找对应的Field/Method，要慢一些；</li>\n</ul>\n<ol>\n<li>如果能用接口实现同样的灵活性，就不要使用反射；</li>\n</ol>\n<h1 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h1><ol>\n<li>注解是给程序添加一些信息，这些信息可以用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序；</li>\n<li>Java内置<code>@Override</code>，<code>@Deprecated</code>和<code>@SuppressWarning</code>三个注解，这三个注解远远不能满足日常开发需求，因此自定义注解产生。</li>\n<li>注解是声明式编程中的一种巧妙应用，在这种风格中，程序通常由下列三部分实现：</li>\n</ol>\n<ul>\n<li>声明的关键字和语法本身；</li>\n<li>系统/框架/库，它们负责解释，执行声明式的语句；</li>\n<li>应用程序，使用声明式编程风格编写程序；</li>\n</ul>\n<ol>\n<li>创建注解：使用<code>@interface</code>关键字声明注解，另外是需要在声明的注解标明元注解。以<code>@Override</code>注解为例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Target(ElementType.METHOD)</span><br><span class=\"hljs-meta\">@Retention(RetentionPolicy.SOURCE)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>4.1 ElementType是一个枚举，可以取下列值：</p>\n<ul>\n<li>TYPE：表示类、接口（包括注解），或者是枚举类型</li>\n<li>FIELD：字段，包括枚举常量</li>\n<li>METHOD：方法</li>\n<li>PARAMETER：方法中的参数</li>\n<li>CONSTRUCTOR：构造方法</li>\n<li>LOCAL_VARIABLE：本地变量</li>\n<li>MODULE：模块（Java 9引入）</li>\n<li></li>\n</ul>\n<p>4.2 如果没有声明<code>@Target</code>，默认适用于所有类型；</p>\n<p>4.3 <code>@Retention</code>表示注解信息保留到什么时候，取值只有一个，类型为RetentionPolicy，它是一个枚举，有三个值：</p>\n<ul>\n<li>SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后去掉；</li>\n<li>CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留（默认值）；</li>\n<li>RUNTIME：一直保留到运行时</li>\n</ul>\n<p>4.4 <code>@Documented</code>注解表示注解信息包含到生成文档中；</p>\n<p>4.5 注解不能继承，但是使用了注解的父类一旦被子类继承，那么子类就可以继承父类的注解，如果要实现这样的效果，需要在父类的注解中加上<code>@Inherited</code></p>\n<ol>\n<li>总结：注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离。框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作；</li>\n</ol>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><ol>\n<li>静态代理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SImpleStaticProxy</span> &#123;<br>    <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 真实对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;RealService Say Hello!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 代理对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TraceProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">private</span> IService realService;<br><br>        TraceProxy(IService realService) &#123;<br>            <span class=\"hljs-built_in\">this</span>.realService = realService;<br>        &#125;<br><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;entering say hello...&quot;</span>);<br>            <span class=\"hljs-built_in\">this</span>.realService.sayHello();<br>            System.out.println(<span class=\"hljs-string\">&quot;exited say hello...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">realService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RealService</span>();<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TraceProxy</span>(realService);<br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>动态代理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleDynamicProxy</span> &#123;<br>    <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 真实对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;Real Service Say Hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 代理对象实现JDK中的InvocationHandler接口</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleInvocationHandle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">InvocationHandler</span> &#123;<br>        <span class=\"hljs-keyword\">private</span> Object realObj;<br><br>        SimpleInvocationHandle(Object realObj) &#123;<br>            <span class=\"hljs-built_in\">this</span>.realObj = realObj;<br>        &#125;<br>        <br>        <span class=\"hljs-comment\">// 重写invoke方法</span><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title function_\">invoke</span><span class=\"hljs-params\">(Object proxy, Method method, Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable &#123;<br>            <span class=\"hljs-comment\">// proxy：表示代理对象本身，不是被代理对象，一般用处不大</span><br>            <span class=\"hljs-comment\">// method：表示正在被调用的方法</span><br>            <span class=\"hljs-comment\">// args：表示方法的参数</span><br>            System.out.println(<span class=\"hljs-string\">&quot;entering &quot;</span> + method.getName());<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> method.invoke(realObj, args);<br>            System.out.println(<span class=\"hljs-string\">&quot;leaving &quot;</span> + method.getName());<br>            <span class=\"hljs-keyword\">return</span> result;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">realService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RealService</span>();<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> (IService) Proxy.newProxyInstance(IService.class.getClassLoader(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Class</span>&lt;?&gt;[]&#123;IService.class&#125;,<br>                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleInvocationHandle</span>(realService)); <span class=\"hljs-comment\">// 使用Proxy.newProxyInstance生成一个代理对象</span><br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>newProxyInstance的声明如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Object <span class=\"hljs-title function_\">newProxyInstance</span><span class=\"hljs-params\">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;<br><span class=\"hljs-comment\">// ClassLoader：表示类加载器；</span><br><span class=\"hljs-comment\">// Class&lt;?&gt;[] interfaces：表示代理类要实现的接口列表，元素类型只能是接口，不能是普通类；</span><br><span class=\"hljs-comment\">// InvocationHandler：是一个接口，对代理接口所有方法的调用都会转给该方法；</span><br><span class=\"hljs-comment\">// newProxyInstance是Object类型，它不能强制转换为某个类型，只能转换为接口类型；</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>类定义本身与被代理的对象没有关系，与InvocationHandler的具体实现也没有关系，而主要与接口数组有关，给定的接口数组会动态地创建每个接口的实现代码，实现就是转发给InvocationHandler，与被代理对象的关系以及对它的调用由InvocationHandler实现管理。</li>\n<li>总结：使用动态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每个被代理的类型都是创建一个静态代理类。</li>\n<li>局限性：JDK中的动态代理只能为接口创建代理，返回的代理对象也只能转换到某个接口类型；如果一个类没有接口，或者希望代理非接口中定义的方法，就无能为力了。</li>\n<li>使用cglib的动态代理类可以解决上述的痛点。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleCGLibDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">MethodInterceptor</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title function_\">intercept</span><span class=\"hljs-params\">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"hljs-keyword\">throws</span> Throwable &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;entering &quot;</span> + method.getName());<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> proxy.invokeSuper(object, args);<br>            System.out.println(<span class=\"hljs-string\">&quot;leaving &quot;</span> + method.getName());<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; T <span class=\"hljs-title function_\">getProxy</span><span class=\"hljs-params\">(Class&lt;T&gt; cls)</span> &#123;<br>        <span class=\"hljs-type\">Enhancer</span> <span class=\"hljs-variable\">enhancer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Enhancer</span>();<br>        enhancer.setSuperclass(cls);<br>        enhancer.setCallback(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleInterceptor</span>());<br>        <span class=\"hljs-keyword\">return</span> (T)enhancer.create();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">RealService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> getProxy(RealService.class);<br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>cglib代理面向的一个具体的类，创建对象只有一个；而SDK代理面向的是接口；</li>\n</ol>\n<h1 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h1><ol>\n<li>类加载机制可以应用于下列场景：</li>\n</ol>\n<ul>\n<li>热部署：不重启程序的情况下动态替换</li>\n<li>应用模块化和互相隔离：不同的ClassLoader可以加载相同的类，但是互相隔离、互不影响。例如：Tomcat管理多个Web应用程序；</li>\n<li>从不同地方灵活加载：系统默认从本地.class文件或者.jar包中加载字节码文件，通过自定义ClassLoader可以从共享服务器、数据库、缓存服务器等其他地方加载字节码文件；</li>\n</ul>\n<ol>\n<li>类加载机制组成部分：</li>\n</ol>\n<ul>\n<li>启动类型加载器（Bootstrap Classloader）：一般由C++实现的，它负责加载Java的基础类，主要是<JAVA_HOME>/lib/rt.jar；</li>\n<li>扩展类加载器（Extension Classloader）：加载器的实现类sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类；</li>\n<li>应用程序类加载器（Application ClassLoader）：实现类是sun.misc.Launcher$AppClassLoader。负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类；</li>\n</ul>\n<ol>\n<li>类加载的全过程：</li>\n</ol>\n<ul>\n<li>1）判断是否已经加载过，如果加载过直接返回Class对象，一个类只会被一个ClassLoader加载过一次；</li>\n<li>2）如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象；</li>\n<li>3）在父ClassLoader没有加载成功的前提下，自己尝试加载类；</li>\n</ul>\n<ol>\n<li>这个过程称之为“双亲委派”模型。优先让父ClassLoader去加载。</li>\n<li>类加载都按照“双亲委派”模型，但是也有例外：</li>\n</ol>\n<ul>\n<li>自定义加载顺序：即自定义的类加载器可以不遵循“双亲委派”模型，但一般上是不推荐的；</li>\n<li>网状加载顺序：在OSGI和Java9中存在网状加载的情况。</li>\n<li>父加载器委派给子加载器：典型应用有JNDI。</li>\n</ul>\n<ol>\n<li>类加载器的例子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassLoaderDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoaderDemo.class.getClassLoader();<br>        <span class=\"hljs-keyword\">while</span> (c1 != <span class=\"hljs-literal\">null</span>) &#123;<br>            System.out.println(c1.getClass().getName());<br>            c1 = c1.getParent();<br>        &#125;<br>        System.out.println(String.class.getClassLoader());<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 输出结果为：</span><br><span class=\"hljs-comment\">// sun.misc.Launcher.$AppClassLoader</span><br><span class=\"hljs-comment\">// sun.misc.Launcher.$ExtClassLoader</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>ClassLoader中有一个默认方法<code>public static ClassLoader getSystemClassLoader()</code>，还有一个默认方法用于加载类： <code>public class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br><span class=\"hljs-keyword\">try</span> &#123;<br>    Class&lt;?&gt; cls = c1.loadClass(<span class=\"hljs-string\">&quot;java.util.ArrayList&quot;</span>);<br>    <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">actualLoader</span> <span class=\"hljs-operator\">=</span> cls.getClassLoader();<br>    System.out.println(actualloader);<br>&#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>类加载器是一个抽象类。Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader以及sun.misc.Launcher$ExtClassLoader。Bootstrap ClassLoader不是由Java实现的。因此没有实现类。需要说明的是，由于是委派机制。使用getClassLoader()方法返回的不一定调用load-Class.</li>\n<li>ClassLoader中的loadClass方法只会加载类但是不会执行。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CLInitDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hello</span> &#123;<br>        <span class=\"hljs-keyword\">static</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> CLInitDemo.class.getName() + <span class=\"hljs-string\">&quot;$Hello&quot;</span>;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            Class&lt;?&gt; cls = c1.loadClass(className); <span class=\"hljs-comment\">// 不会输出&quot;hello&quot;</span><br>            <span class=\"hljs-comment\">// Class&lt;?&gt; cls = Class.forName(className); // 会输出&quot;hello&quot;</span><br>        &#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，也是一种策略模式。</li>\n</ol>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"单个字符\"><a href=\"#单个字符\" class=\"headerlink\" title=\"单个字符\"></a>单个字符</h2><ol>\n<li>用字符本身表示</li>\n<li>特殊字符：例如制表符’\\t’，换行符’\\n’以及回车符’\\r’；</li>\n<li>八进制表示的字符：以’\\0’开头，后面加上1~3位数字，例如\\0141(8) -&gt; 97(10)</li>\n<li>十六进制表示的字符：以’\\x’开头，后面跟两位字符，比如\\x6A(16) -&gt; 106(10)</li>\n<li>Unicode表示字符，以’\\u’开头，后面跟4位字符</li>\n<li>斜杠本身就是特殊字符，如果需要使用斜杠需要用一个斜杠进行转义；</li>\n<li>元字符：例如“.、*、?、+”等，如果要皮匹配自身，需要在前面加’’进行转义</li>\n</ol>\n<h2 id=\"字符祖\"><a href=\"#字符祖\" class=\"headerlink\" title=\"字符祖\"></a>字符祖</h2><ol>\n<li>‘.’字符匹配除了换行符以外的任意字符，也可以使用“单行匹配模式”或者“点号匹配模式”。可以以(?s)开头，s表示single line；</li>\n<li>中括号[]表示匹配字符组中的任意一个字符，例如[abcd]匹配任意一个字母；</li>\n<li>‘^’表示排除符号；</li>\n<li>\\d：匹配一个数字字符，等同于[0-9]；</li>\n<li>\\w：匹配一个单词字符，等同于[a-zA-Z_0-9]；</li>\n<li>\\s：匹配一个空白字符，等同于[\\t\\n\\x0B\\f\\r]</li>\n<li>\\D：匹配一个非数字字符，即<sup><a href=\"#fn_\\d\" id=\"reffn_\\d\">\\d</a></sup>；</li>\n<li>\\W：匹配一个非单词字符，即<sup><a href=\"#fn_\\w\" id=\"reffn_\\w\">\\w</a></sup>；</li>\n<li>\\S：匹配一个非空白字符，即<sup><a href=\"#fn_\\s\" id=\"reffn_\\s\">\\s</a></sup>；</li>\n</ol>\n<h2 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h2><ol>\n<li>量词是指定出现次数的元字符，常见的有三种+、*、？</li>\n<li>‘+’表示前面字符的一次或多次出现。比如正则表达式ab+c，既能匹配abc，也能匹配abbc:</li>\n<li>‘<em>‘表示前面的字符的零次或多次出现，例如：ab</em>c。既能匹配abc，也能匹配ac或abbbc；</li>\n<li>‘?’表示前面字符可能出现，也可能不出现。例如正则表达式ab?c，既能匹配abc，也能匹配ac；</li>\n<li>通用表示出现次数的语法为{m,n}，出现次数从m到n，包括m和n。如果n没有限制可以省略。如果m和n一样，可以省略一个写为{m}。例如：</li>\n</ol>\n<ul>\n<li>ab{1,10}c：b可以出现1次到10次</li>\n<li>ab{3}c：b必须出现三次</li>\n<li>ab{1,}c：等同于ab+c</li>\n<li>ab{0,}c：等同于ab*c</li>\n<li>ab{0,1}c：等同于ab?c</li>\n</ul>\n<ol>\n<li>量词默认是贪婪的，也就是说会从正则开始匹配到结束内的所有字符，如果需要在匹配到第一个就终止，需要使用懒惰量词。即在两次后面加上一个符号’?’；</li>\n</ol>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><ol>\n<li>可以用括号将表达式括起来，表示一个分组。分组匹配的子字符串可以在后续访问，好像被被捕获了一样，所以默认分组称之为捕获分组；</li>\n<li>在正则表达式中，可以使用斜杠\\加分组编号引用之前匹配的分组，称之为回溯引用；</li>\n</ol>\n<h2 id=\"特殊边界匹配\"><a href=\"#特殊边界匹配\" class=\"headerlink\" title=\"特殊边界匹配\"></a>特殊边界匹配</h2><ol>\n<li>常见的特殊边界的元字符有^、$、\\A、\\Z、\\z和\\b。</li>\n<li>‘’匹配整个字符串的开始，此外‘’也表示排除，默认单行匹配；</li>\n<li>‘$’匹配整个字符串的结束，默认单行匹配；</li>\n<li>多行匹配的方式如下：以(?m)开头。例如：(?m)^abc$</li>\n<li>\\A和^类似；</li>\n<li>\\Z和$类似；\\z匹配的总是结束的边界；</li>\n<li>\\b匹配的是单词的边界；</li>\n<li>边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界；</li>\n</ol>\n<h2 id=\"环视边界匹配\"><a href=\"#环视边界匹配\" class=\"headerlink\" title=\"环视边界匹配\"></a>环视边界匹配</h2><ol>\n<li>此部分内容比较晦涩，暂不做了解；</li>\n</ol>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><h2 id=\"函数是接口：\"><a href=\"#函数是接口：\" class=\"headerlink\" title=\"函数是接口：\"></a>函数是接口：</h2><ol>\n<li>Java中预定义了大量的函数式接口：</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数接口</th>\n<th>方法定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Predicate<T></td>\n<td>boolean test(T t)</td>\n<td>谓词，测试输入条件是否满足要求</td>\n</tr>\n<tr>\n<td>Function<T, R></td>\n<td>R apply(T t)</td>\n<td>函数转换，输入类型T，输出类型R</td>\n</tr>\n<tr>\n<td>Consumer<T></td>\n<td>void accept(T t)</td>\n<td>消费者，输入类型T</td>\n</tr>\n<tr>\n<td>Supplier<T></td>\n<td>T get()</td>\n<td>工厂方法</td>\n</tr>\n<tr>\n<td>UnaryOperator<T></td>\n<td>T apply(T t)</td>\n<td>函数转换的特例，输入和输出类型一样</td>\n</tr>\n<tr>\n<td>BiFunction<T, U, R></td>\n<td>R apply(T t, U u)</td>\n<td>函数转换，接受两个参数，输出R</td>\n</tr>\n<tr>\n<td>BinaryOperator<T></td>\n<td>T apply(T t, T u)</td>\n<td>BiFunction的特例，输入和输出类型一样</td>\n</tr>\n<tr>\n<td>BiConsumer<T, U></td>\n<td>void accept(T t, U u)</td>\n<td>消费者，接受两个参数</td>\n</tr>\n<tr>\n<td>BiPredicate<T, U></td>\n<td>boolean test(T t, U u)</td>\n<td>谓词，接受两个参数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li>Predicate示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br>    String name;<br>    <span class=\"hljs-type\">double</span> score;<br>    <span class=\"hljs-comment\">// 省略getter/setter</span><br>&#125;<br><br><span class=\"hljs-comment\">// 借助Predicate撰写一个filter的逻辑，例如：</span><br>students = filter(students, t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Function示例：数据转换</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 根据学生列表返回名称列表的代码：</span><br>List&lt;Student&gt; names = map(students, t -&gt; t.getName());<br><br><span class=\"hljs-comment\">// 将学生名称转换为大写：</span><br>students = map(students, t -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>(t.getName().toUpperCase(), t.getScore()))<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Consumer示例：直接对原值进行修改</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">foreach(students, t -&gt; t.setName(t.getName(),.toUpperCase()))<br></code></pre></td></tr></table></figure>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><ol>\n<li>示例代码中<code>Student::getName</code>称之为方法引用，使用::分隔开。分隔符前面是类型或变量名，后者是方法名。方法可以是实例方法，也可以是静态方法。例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">getColleageName</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Test String&quot;</span>;<br>&#125;<br><span class=\"hljs-comment\">// 下面两条句子的等价的</span><br>Supplier&lt;String&gt; s = Student::getColleageName;<br>Supplier&lt;String&gt; s = () -&gt; Student.getColleageName()；<br></code></pre></td></tr></table></figure>\n<h2 id=\"函数的复合\"><a href=\"#函数的复合\" class=\"headerlink\" title=\"函数的复合\"></a>函数的复合</h2><ol>\n<li>函数式接口和Lambda表达式可以用作方法的返回值，传递代码回调者，将上述两种方法结合起来，可以构造复合的函数，使程序简洁易读；</li>\n<li>复合Comparator中的复合方法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Arrays.sort(files, (f1, f2) -&gt; f1.getName().compareTo(f2.getName()));<br><span class=\"hljs-comment\">// 进一步简化</span><br>Arrays.sort(files, Comparator.comparing(File::getName()));<br></code></pre></td></tr></table></figure>\n<h2 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h2><ol>\n<li>基本过滤</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用Stream API之前</span><br>List&lt;Student&gt; above90List = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><span class=\"hljs-keyword\">for</span> (Student t : students) &#123;<br>    <span class=\"hljs-keyword\">if</span> (t.getScore() &gt; <span class=\"hljs-number\">90</span>) &#123;<br>        above90List.add(t);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用Stream API之后</span><br>List&lt;Student&gt; above90List = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ul>\n<li>没有显式的迭代循环，循环过程被Stream隐藏；</li>\n<li>提供了声明式的处理函数；</li>\n<li>流畅式接口；</li>\n</ul>\n<ol>\n<li>基本转换</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用Stream API之前</span><br>List&lt;String&gt; nameList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><span class=\"hljs-keyword\">for</span> (Student t : students) &#123;<br>    nameList.add(t.getName());<br>&#125;<br><br><span class=\"hljs-comment\">// 使用Stream API之后</span><br>List&lt;String&gt; nameList = students.stream()<br>    .map(Student::getName).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>基本过滤和转换组合</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; above90List = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .map(Student::getName)<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>distinct运算</li>\n</ol>\n<ul>\n<li>用于过滤重复元素，只留下唯一元素，是否重复根据equals()方法来比较。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;abc&quot;</span>, <span class=\"hljs-string\">&quot;def&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-string\">&quot;Abc&quot;</span>&#125;);<br>List&lt;String&gt; retList = list.stream()<br>    .filter(s -&gt; s.length() &lt;= <span class=\"hljs-number\">3</span>).map(String::toLowerCase).distinct()<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>sorted方法</li>\n</ol>\n<ul>\n<li>对流中的元素进行排序，返回一个排序后的stream。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Student&gt; list = students.stream().filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">0</span>)<br>    .sorted(Comparator.comparing(Student::getScore)<br>    .reversed().thenComparing(Student::getName))<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>skip/limit</li>\n</ol>\n<ul>\n<li>跳过流中的n个元素，如果流的长度不足n个，返回一个空流。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Student&gt; list = students.stream()<br>    .sorted(Comparator.comparing(Student::getScore).reversed()<br>    .skip(<span class=\"hljs-number\">2</span>).limit(<span class=\"hljs-number\">3</span>).collect(Coolectors.toList()));<br></code></pre></td></tr></table></figure>\n<ol>\n<li>peek</li>\n</ol>\n<ul>\n<li>返回一个与之前一样的流，没有变化。但是提供一个Consumer，会将流中的每一个元素传给Consumer。这个方法主要目的用于支持调试，可以使用该方法观察在流水线中流转的元素。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; above90Names = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .peek(System.out::println).map(Student::getName)<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>mapToLong/mapToInt/mapToDouble</li>\n</ol>\n<ul>\n<li>map函数接受函数参数是一个<code>Function&lt;T, R&gt;</code>，为避免拆箱，装箱提高性能。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .mapToDouble(Student::getScore).sum();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>flatMap</li>\n</ol>\n<ul>\n<li>接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换成一个流Stream。然后将新生成流的每一个元素传递给下一个操作。比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; lines = Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello abc&quot;</span>, <span class=\"hljs-string\">&quot;laoma biancheng&quot;</span>&#125;);<br>List&lt;String&gt; words = lines.stream()<br>    .flatMap(line -&gt; Arrays.stream(line.split(<span class=\"hljs-string\">&quot;\\\\s+&quot;</span>)))<br>    .collect(Collectors.toList());<br>System.out.println(words); <span class=\"hljs-comment\">// [hello, abc. laoma, biancheng]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"终端操作\"><a href=\"#终端操作\" class=\"headerlink\" title=\"终端操作\"></a>终端操作</h2><ol>\n<li>中间操作不触发实际执行，返回值是Stream，而终端操作触发执行，返回一个具体的值。除了collect之外还有：max, min, count, allMatch, anyMatch, noneMatch, findFirst, findAny, forEach, toArray, reduce等。</li>\n<li>max/min: 返回流中的最大值/最小值。其返回类型为Optional<T>而非T。Optional表明可能为null，程序应当进行适当的处理。例子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">student</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .max(Comparator.comparing(Student::getScore).reversed()).get();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>count：返回流中的元素个数，例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">above90Count</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>).count();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>allMatch/anyMatch/noneMatch：用于判定流中额元素是否满足一定的条件，区别在于：</li>\n</ol>\n<ul>\n<li>allMatch：流中所有元素都满足条件的情况下返回true;</li>\n<li>anyMatch：流中的元素只要有一个元素满足条件即返回true;</li>\n<li>noneMatch：只有流中的所有元素都不满足条件才返回true;</li>\n<li>示例如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">allPass</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .allMatch(t -&gt; t.getScore() &gt;= <span class=\"hljs-number\">60</span>);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>findFirst/findAny：返回类型均为Optional，如果流为空则返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素。均为短路操作。示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Optional&lt;Student&gt; student = students.stream()<br>    .filter(t -&gt; t.getScore() &lt; <span class=\"hljs-number\">60</span>)<br>    .findAny();<br><span class=\"hljs-keyword\">if</span> (student.isPresent()) &#123;<br>    <span class=\"hljs-comment\">// 处理不符合要求的数据</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>forEach/forEachOrdered：并行流中forEach不保证顺序，forEachOrdered能保证顺序。例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>toArray：将流转换为数组，包含两个方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Object[] toArray() <span class=\"hljs-comment\">// 返回值为Object[]</span><br>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) <span class=\"hljs-comment\">// 得到指定类型的数组</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>示例为：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Student[] above90Arr = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .toArray(Student[]::<span class=\"hljs-keyword\">new</span>); <span class=\"hljs-comment\">// Student[]::new就是一个IntFunction类型的ggenerator</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>reduce：归约或折叠，将流中的元素归约为一个值，有三种reduce函数：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Optional&lt;T&gt; <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(BinaryOperator&lt;T&gt; accumulator)</span>;<br>T <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;<br>&lt;U&gt; U <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(U identity, BiFunction&lt;U, ? <span class=\"hljs-built_in\">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第一个reduce函数的使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">topStudent</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .reduce((acc, t) -&gt; &#123;<br>        <span class=\"hljs-keyword\">if</span>(acc.getScore() &gt;= t.getScore()) &#123;<br>            <span class=\"hljs-keyword\">return</span> acc;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> t;<br>        &#125;<br>    &#125;).get();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第二个reduce函数比第一个多了identity参数，表示初始值</li>\n<li>第三个reduce函数更为通用，可以自定义归约类型，另外还多了一个combiner参数，在并行流中用于合并子线程结果。还有示例：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">sumScore</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .reduce(<span class=\"hljs-number\">0d</span>, (sum, t) -&gt; sum += t.getScore(), <br>    (sum1, sum2) -&gt; sum1 += sum2)<br>    );<br></code></pre></td></tr></table></figure>\n<ol>\n<li>迭代Map的过程删除元素，直接使用forEach会报ConcurrentModificationException</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Object&gt; map = other.getHashMap&lt;&gt;();<br>map.entrySet().removeIf(entryElement -&gt; <span class=\"hljs-string\">&quot;some condition&quot;</span>.equals(entryElement.getKey()))<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":15854,"excerpt":"","more":"<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><ol>\n<li>反射是在类运行时动态获取类型的信息。比如接口信息、成员信息、方法信息、构造函数信息等。根据动态获取到的信息创建对象、访问/修改成员、调用方法等。</li>\n<li>使用反射可以得到类的名称，调用方法getName()。其中还包括getSimpleName()，getCanonicalName()以及getPackage()。</li>\n<li>类中定义的静态和实例变量称之为字段，使用Field类表示，可以获取字段的访问权限，设置访问权限，获得字段值以及设置字段值。除此之外，还可以获得字段的修饰符以及基本类型。需要注意的是使用反射返回的修饰符是一个整型。如果需要查看具体的返回值类型，可以使用Modifier进行再次判断。</li>\n<li>通过反射也可以获取类中的方法信息：对于invoke方法而言，如果Method是静态方法，则obj被忽略为null，args可以为null；</li>\n<li>创建对象和构造方法：<code>public T newInstance() throws InstantiationException, IllegalAccessException</code>；</li>\n<li>类型检查和转换：使用<code>instanceof</code>关键字可以用于判断变量指向的实际对象类型，instanceof后面的类型是在代码中确定的；</li>\n<li>除此之外，Class方法中还有其他的一些方法可以用于获取类的声明信息、修饰符、父类、接口以及注解等；</li>\n<li>对于数组类型可以使用<code>public native Class&lt;T&gt; getComponentType()</code>获取其元素类型；</li>\n<li>反射与枚举：枚举类型也有一个专门的方法：<code>public T[] getEnumConstants()</code>；</li>\n<li>反射与泛型：可以获取泛型参数的信息：</li>\n</ol>\n<ul>\n<li>Class类有如下方法：<code>public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters()</code></li>\n<li>Field有如下方法：<code>public Type getGenericType()</code></li>\n<li>Method有如下方法：<code>public Type getGenericReturnType()</code>，<code>public Type[] getGenericParameterTypes()</code>和<code>public Type[] getGenericExceptionTypes()</code></li>\n<li>Constructor有如下方法：<code>public Type[] getGenericParameterTypes()</code></li>\n</ul>\n<ol>\n<li>Type实现了Class方法，其中还实现了下列方法：</li>\n</ol>\n<ul>\n<li>TypeVariable类型参数可以有上界；</li>\n<li>ParameterizedType参数化的类型，有原始类型和具体类型；</li>\n<li>WildcardType通配符类型</li>\n<li>通过反射获取泛型示例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GenericTest</span>&lt;U <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Comparable</span>&lt;U, V&gt; &#123;<br>        U u;<br>        V v;<br>        List&lt;String&gt; list;<br>        <span class=\"hljs-keyword\">public</span> U <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(List&lt;? extends Number&gt; numbers)</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        Class&lt;?&gt; cls = GenericTest.class;<br>        <span class=\"hljs-keyword\">for</span> (TypeVariable t : cls.getTypeParameters()) &#123;<br>            System.out.println(t.getName() + <span class=\"hljs-string\">&quot; extends &quot;</span> + Arrays.toString(t.getBounds()));<br>        &#125;<br>        <span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">fu</span> <span class=\"hljs-operator\">=</span> cls.getDeclaredField(<span class=\"hljs-string\">&quot;u&quot;</span>);<br>        System.out.println(fu.getGenericType());<br>        <span class=\"hljs-type\">Field</span> <span class=\"hljs-variable\">first</span> <span class=\"hljs-operator\">=</span> cls.getDeclaredField(<span class=\"hljs-string\">&quot;list&quot;</span>);<br>        <span class=\"hljs-type\">Type</span> <span class=\"hljs-variable\">listType</span> <span class=\"hljs-operator\">=</span> first.getGenericType();<br>        <span class=\"hljs-keyword\">if</span> (!listType <span class=\"hljs-keyword\">instanceof</span> ParameterizedType) &#123;<br>            <span class=\"hljs-type\">ParameterizedType</span> <span class=\"hljs-variable\">pType</span> <span class=\"hljs-operator\">=</span> (ParameterizedType)listType;<br>            System.out.println(<span class=\"hljs-string\">&quot;raw type: &quot;</span> + pType.getRawType() + <span class=\"hljs-string\">&quot; ,type arguments:&quot;</span> + Arrays.toString(pType.getActualTypeArguments()));<br>        &#125;<br>        <span class=\"hljs-comment\">// 省略代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>总结：反射虽然灵活，但一般情况下我们并不优先建议，原因有如下：</li>\n</ol>\n<ul>\n<li>反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力；</li>\n<li>反射会降低性能，在访问字段、调用方法前，反射要先查找对应的Field/Method，要慢一些；</li>\n</ul>\n<ol>\n<li>如果能用接口实现同样的灵活性，就不要使用反射；</li>\n</ol>\n<h1 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h1><ol>\n<li>注解是给程序添加一些信息，这些信息可以用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序；</li>\n<li>Java内置<code>@Override</code>，<code>@Deprecated</code>和<code>@SuppressWarning</code>三个注解，这三个注解远远不能满足日常开发需求，因此自定义注解产生。</li>\n<li>注解是声明式编程中的一种巧妙应用，在这种风格中，程序通常由下列三部分实现：</li>\n</ol>\n<ul>\n<li>声明的关键字和语法本身；</li>\n<li>系统/框架/库，它们负责解释，执行声明式的语句；</li>\n<li>应用程序，使用声明式编程风格编写程序；</li>\n</ul>\n<ol>\n<li>创建注解：使用<code>@interface</code>关键字声明注解，另外是需要在声明的注解标明元注解。以<code>@Override</code>注解为例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Target(ElementType.METHOD)</span><br><span class=\"hljs-meta\">@Retention(RetentionPolicy.SOURCE)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>4.1 ElementType是一个枚举，可以取下列值：</p>\n<ul>\n<li>TYPE：表示类、接口（包括注解），或者是枚举类型</li>\n<li>FIELD：字段，包括枚举常量</li>\n<li>METHOD：方法</li>\n<li>PARAMETER：方法中的参数</li>\n<li>CONSTRUCTOR：构造方法</li>\n<li>LOCAL_VARIABLE：本地变量</li>\n<li>MODULE：模块（Java 9引入）</li>\n<li></li>\n</ul>\n<p>4.2 如果没有声明<code>@Target</code>，默认适用于所有类型；</p>\n<p>4.3 <code>@Retention</code>表示注解信息保留到什么时候，取值只有一个，类型为RetentionPolicy，它是一个枚举，有三个值：</p>\n<ul>\n<li>SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后去掉；</li>\n<li>CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留（默认值）；</li>\n<li>RUNTIME：一直保留到运行时</li>\n</ul>\n<p>4.4 <code>@Documented</code>注解表示注解信息包含到生成文档中；</p>\n<p>4.5 注解不能继承，但是使用了注解的父类一旦被子类继承，那么子类就可以继承父类的注解，如果要实现这样的效果，需要在父类的注解中加上<code>@Inherited</code></p>\n<ol>\n<li>总结：注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离。框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作；</li>\n</ol>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><ol>\n<li>静态代理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SImpleStaticProxy</span> &#123;<br>    <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 真实对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;RealService Say Hello!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 代理对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TraceProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">private</span> IService realService;<br><br>        TraceProxy(IService realService) &#123;<br>            <span class=\"hljs-built_in\">this</span>.realService = realService;<br>        &#125;<br><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;entering say hello...&quot;</span>);<br>            <span class=\"hljs-built_in\">this</span>.realService.sayHello();<br>            System.out.println(<span class=\"hljs-string\">&quot;exited say hello...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">realService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RealService</span>();<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TraceProxy</span>(realService);<br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>动态代理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleDynamicProxy</span> &#123;<br>    <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 真实对象</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">IService</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;Real Service Say Hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 代理对象实现JDK中的InvocationHandler接口</span><br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleInvocationHandle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">InvocationHandler</span> &#123;<br>        <span class=\"hljs-keyword\">private</span> Object realObj;<br><br>        SimpleInvocationHandle(Object realObj) &#123;<br>            <span class=\"hljs-built_in\">this</span>.realObj = realObj;<br>        &#125;<br>        <br>        <span class=\"hljs-comment\">// 重写invoke方法</span><br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title function_\">invoke</span><span class=\"hljs-params\">(Object proxy, Method method, Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable &#123;<br>            <span class=\"hljs-comment\">// proxy：表示代理对象本身，不是被代理对象，一般用处不大</span><br>            <span class=\"hljs-comment\">// method：表示正在被调用的方法</span><br>            <span class=\"hljs-comment\">// args：表示方法的参数</span><br>            System.out.println(<span class=\"hljs-string\">&quot;entering &quot;</span> + method.getName());<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> method.invoke(realObj, args);<br>            System.out.println(<span class=\"hljs-string\">&quot;leaving &quot;</span> + method.getName());<br>            <span class=\"hljs-keyword\">return</span> result;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">realService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RealService</span>();<br>        <span class=\"hljs-type\">IService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> (IService) Proxy.newProxyInstance(IService.class.getClassLoader(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Class</span>&lt;?&gt;[]&#123;IService.class&#125;,<br>                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleInvocationHandle</span>(realService)); <span class=\"hljs-comment\">// 使用Proxy.newProxyInstance生成一个代理对象</span><br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>newProxyInstance的声明如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Object <span class=\"hljs-title function_\">newProxyInstance</span><span class=\"hljs-params\">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;<br><span class=\"hljs-comment\">// ClassLoader：表示类加载器；</span><br><span class=\"hljs-comment\">// Class&lt;?&gt;[] interfaces：表示代理类要实现的接口列表，元素类型只能是接口，不能是普通类；</span><br><span class=\"hljs-comment\">// InvocationHandler：是一个接口，对代理接口所有方法的调用都会转给该方法；</span><br><span class=\"hljs-comment\">// newProxyInstance是Object类型，它不能强制转换为某个类型，只能转换为接口类型；</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>类定义本身与被代理的对象没有关系，与InvocationHandler的具体实现也没有关系，而主要与接口数组有关，给定的接口数组会动态地创建每个接口的实现代码，实现就是转发给InvocationHandler，与被代理对象的关系以及对它的调用由InvocationHandler实现管理。</li>\n<li>总结：使用动态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每个被代理的类型都是创建一个静态代理类。</li>\n<li>局限性：JDK中的动态代理只能为接口创建代理，返回的代理对象也只能转换到某个接口类型；如果一个类没有接口，或者希望代理非接口中定义的方法，就无能为力了。</li>\n<li>使用cglib的动态代理类可以解决上述的痛点。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleCGLibDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RealService</span> &#123;<br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">MethodInterceptor</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title function_\">intercept</span><span class=\"hljs-params\">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"hljs-keyword\">throws</span> Throwable &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;entering &quot;</span> + method.getName());<br>            <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> proxy.invokeSuper(object, args);<br>            System.out.println(<span class=\"hljs-string\">&quot;leaving &quot;</span> + method.getName());<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; T <span class=\"hljs-title function_\">getProxy</span><span class=\"hljs-params\">(Class&lt;T&gt; cls)</span> &#123;<br>        <span class=\"hljs-type\">Enhancer</span> <span class=\"hljs-variable\">enhancer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Enhancer</span>();<br>        enhancer.setSuperclass(cls);<br>        enhancer.setCallback(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleInterceptor</span>());<br>        <span class=\"hljs-keyword\">return</span> (T)enhancer.create();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">RealService</span> <span class=\"hljs-variable\">proxyService</span> <span class=\"hljs-operator\">=</span> getProxy(RealService.class);<br>        proxyService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>cglib代理面向的一个具体的类，创建对象只有一个；而SDK代理面向的是接口；</li>\n</ol>\n<h1 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h1><ol>\n<li>类加载机制可以应用于下列场景：</li>\n</ol>\n<ul>\n<li>热部署：不重启程序的情况下动态替换</li>\n<li>应用模块化和互相隔离：不同的ClassLoader可以加载相同的类，但是互相隔离、互不影响。例如：Tomcat管理多个Web应用程序；</li>\n<li>从不同地方灵活加载：系统默认从本地.class文件或者.jar包中加载字节码文件，通过自定义ClassLoader可以从共享服务器、数据库、缓存服务器等其他地方加载字节码文件；</li>\n</ul>\n<ol>\n<li>类加载机制组成部分：</li>\n</ol>\n<ul>\n<li>启动类型加载器（Bootstrap Classloader）：一般由C++实现的，它负责加载Java的基础类，主要是<JAVA_HOME>/lib/rt.jar；</li>\n<li>扩展类加载器（Extension Classloader）：加载器的实现类sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类；</li>\n<li>应用程序类加载器（Application ClassLoader）：实现类是sun.misc.Launcher$AppClassLoader。负责加载应用程序的类，包括自己写的和引入的第三方类库，即所有在类路径中指定的类；</li>\n</ul>\n<ol>\n<li>类加载的全过程：</li>\n</ol>\n<ul>\n<li>1）判断是否已经加载过，如果加载过直接返回Class对象，一个类只会被一个ClassLoader加载过一次；</li>\n<li>2）如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象；</li>\n<li>3）在父ClassLoader没有加载成功的前提下，自己尝试加载类；</li>\n</ul>\n<ol>\n<li>这个过程称之为“双亲委派”模型。优先让父ClassLoader去加载。</li>\n<li>类加载都按照“双亲委派”模型，但是也有例外：</li>\n</ol>\n<ul>\n<li>自定义加载顺序：即自定义的类加载器可以不遵循“双亲委派”模型，但一般上是不推荐的；</li>\n<li>网状加载顺序：在OSGI和Java9中存在网状加载的情况。</li>\n<li>父加载器委派给子加载器：典型应用有JNDI。</li>\n</ul>\n<ol>\n<li>类加载器的例子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassLoaderDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoaderDemo.class.getClassLoader();<br>        <span class=\"hljs-keyword\">while</span> (c1 != <span class=\"hljs-literal\">null</span>) &#123;<br>            System.out.println(c1.getClass().getName());<br>            c1 = c1.getParent();<br>        &#125;<br>        System.out.println(String.class.getClassLoader());<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 输出结果为：</span><br><span class=\"hljs-comment\">// sun.misc.Launcher.$AppClassLoader</span><br><span class=\"hljs-comment\">// sun.misc.Launcher.$ExtClassLoader</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>ClassLoader中有一个默认方法<code>public static ClassLoader getSystemClassLoader()</code>，还有一个默认方法用于加载类： <code>public class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br><span class=\"hljs-keyword\">try</span> &#123;<br>    Class&lt;?&gt; cls = c1.loadClass(<span class=\"hljs-string\">&quot;java.util.ArrayList&quot;</span>);<br>    <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">actualLoader</span> <span class=\"hljs-operator\">=</span> cls.getClassLoader();<br>    System.out.println(actualloader);<br>&#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>类加载器是一个抽象类。Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader以及sun.misc.Launcher$ExtClassLoader。Bootstrap ClassLoader不是由Java实现的。因此没有实现类。需要说明的是，由于是委派机制。使用getClassLoader()方法返回的不一定调用load-Class.</li>\n<li>ClassLoader中的loadClass方法只会加载类但是不会执行。示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CLInitDemo</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hello</span> &#123;<br>        <span class=\"hljs-keyword\">static</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span> ClassLoader.getSystemClassLoader();<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">className</span> <span class=\"hljs-operator\">=</span> CLInitDemo.class.getName() + <span class=\"hljs-string\">&quot;$Hello&quot;</span>;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            Class&lt;?&gt; cls = c1.loadClass(className); <span class=\"hljs-comment\">// 不会输出&quot;hello&quot;</span><br>            <span class=\"hljs-comment\">// Class&lt;?&gt; cls = Class.forName(className); // 会输出&quot;hello&quot;</span><br>        &#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，也是一种策略模式。</li>\n</ol>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"单个字符\"><a href=\"#单个字符\" class=\"headerlink\" title=\"单个字符\"></a>单个字符</h2><ol>\n<li>用字符本身表示</li>\n<li>特殊字符：例如制表符’\\t’，换行符’\\n’以及回车符’\\r’；</li>\n<li>八进制表示的字符：以’\\0’开头，后面加上1~3位数字，例如\\0141(8) -&gt; 97(10)</li>\n<li>十六进制表示的字符：以’\\x’开头，后面跟两位字符，比如\\x6A(16) -&gt; 106(10)</li>\n<li>Unicode表示字符，以’\\u’开头，后面跟4位字符</li>\n<li>斜杠本身就是特殊字符，如果需要使用斜杠需要用一个斜杠进行转义；</li>\n<li>元字符：例如“.、*、?、+”等，如果要皮匹配自身，需要在前面加’’进行转义</li>\n</ol>\n<h2 id=\"字符祖\"><a href=\"#字符祖\" class=\"headerlink\" title=\"字符祖\"></a>字符祖</h2><ol>\n<li>‘.’字符匹配除了换行符以外的任意字符，也可以使用“单行匹配模式”或者“点号匹配模式”。可以以(?s)开头，s表示single line；</li>\n<li>中括号[]表示匹配字符组中的任意一个字符，例如[abcd]匹配任意一个字母；</li>\n<li>‘^’表示排除符号；</li>\n<li>\\d：匹配一个数字字符，等同于[0-9]；</li>\n<li>\\w：匹配一个单词字符，等同于[a-zA-Z_0-9]；</li>\n<li>\\s：匹配一个空白字符，等同于[\\t\\n\\x0B\\f\\r]</li>\n<li>\\D：匹配一个非数字字符，即<sup><a href=\"#fn_\\d\" id=\"reffn_\\d\">\\d</a></sup>；</li>\n<li>\\W：匹配一个非单词字符，即<sup><a href=\"#fn_\\w\" id=\"reffn_\\w\">\\w</a></sup>；</li>\n<li>\\S：匹配一个非空白字符，即<sup><a href=\"#fn_\\s\" id=\"reffn_\\s\">\\s</a></sup>；</li>\n</ol>\n<h2 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h2><ol>\n<li>量词是指定出现次数的元字符，常见的有三种+、*、？</li>\n<li>‘+’表示前面字符的一次或多次出现。比如正则表达式ab+c，既能匹配abc，也能匹配abbc:</li>\n<li>‘<em>‘表示前面的字符的零次或多次出现，例如：ab</em>c。既能匹配abc，也能匹配ac或abbbc；</li>\n<li>‘?’表示前面字符可能出现，也可能不出现。例如正则表达式ab?c，既能匹配abc，也能匹配ac；</li>\n<li>通用表示出现次数的语法为{m,n}，出现次数从m到n，包括m和n。如果n没有限制可以省略。如果m和n一样，可以省略一个写为{m}。例如：</li>\n</ol>\n<ul>\n<li>ab{1,10}c：b可以出现1次到10次</li>\n<li>ab{3}c：b必须出现三次</li>\n<li>ab{1,}c：等同于ab+c</li>\n<li>ab{0,}c：等同于ab*c</li>\n<li>ab{0,1}c：等同于ab?c</li>\n</ul>\n<ol>\n<li>量词默认是贪婪的，也就是说会从正则开始匹配到结束内的所有字符，如果需要在匹配到第一个就终止，需要使用懒惰量词。即在两次后面加上一个符号’?’；</li>\n</ol>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><ol>\n<li>可以用括号将表达式括起来，表示一个分组。分组匹配的子字符串可以在后续访问，好像被被捕获了一样，所以默认分组称之为捕获分组；</li>\n<li>在正则表达式中，可以使用斜杠\\加分组编号引用之前匹配的分组，称之为回溯引用；</li>\n</ol>\n<h2 id=\"特殊边界匹配\"><a href=\"#特殊边界匹配\" class=\"headerlink\" title=\"特殊边界匹配\"></a>特殊边界匹配</h2><ol>\n<li>常见的特殊边界的元字符有^、$、\\A、\\Z、\\z和\\b。</li>\n<li>‘’匹配整个字符串的开始，此外‘’也表示排除，默认单行匹配；</li>\n<li>‘$’匹配整个字符串的结束，默认单行匹配；</li>\n<li>多行匹配的方式如下：以(?m)开头。例如：(?m)^abc$</li>\n<li>\\A和^类似；</li>\n<li>\\Z和$类似；\\z匹配的总是结束的边界；</li>\n<li>\\b匹配的是单词的边界；</li>\n<li>边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界；</li>\n</ol>\n<h2 id=\"环视边界匹配\"><a href=\"#环视边界匹配\" class=\"headerlink\" title=\"环视边界匹配\"></a>环视边界匹配</h2><ol>\n<li>此部分内容比较晦涩，暂不做了解；</li>\n</ol>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><h2 id=\"函数是接口：\"><a href=\"#函数是接口：\" class=\"headerlink\" title=\"函数是接口：\"></a>函数是接口：</h2><ol>\n<li>Java中预定义了大量的函数式接口：</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数接口</th>\n<th>方法定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Predicate<T></td>\n<td>boolean test(T t)</td>\n<td>谓词，测试输入条件是否满足要求</td>\n</tr>\n<tr>\n<td>Function<T, R></td>\n<td>R apply(T t)</td>\n<td>函数转换，输入类型T，输出类型R</td>\n</tr>\n<tr>\n<td>Consumer<T></td>\n<td>void accept(T t)</td>\n<td>消费者，输入类型T</td>\n</tr>\n<tr>\n<td>Supplier<T></td>\n<td>T get()</td>\n<td>工厂方法</td>\n</tr>\n<tr>\n<td>UnaryOperator<T></td>\n<td>T apply(T t)</td>\n<td>函数转换的特例，输入和输出类型一样</td>\n</tr>\n<tr>\n<td>BiFunction<T, U, R></td>\n<td>R apply(T t, U u)</td>\n<td>函数转换，接受两个参数，输出R</td>\n</tr>\n<tr>\n<td>BinaryOperator<T></td>\n<td>T apply(T t, T u)</td>\n<td>BiFunction的特例，输入和输出类型一样</td>\n</tr>\n<tr>\n<td>BiConsumer<T, U></td>\n<td>void accept(T t, U u)</td>\n<td>消费者，接受两个参数</td>\n</tr>\n<tr>\n<td>BiPredicate<T, U></td>\n<td>boolean test(T t, U u)</td>\n<td>谓词，接受两个参数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li>Predicate示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br>    String name;<br>    <span class=\"hljs-type\">double</span> score;<br>    <span class=\"hljs-comment\">// 省略getter/setter</span><br>&#125;<br><br><span class=\"hljs-comment\">// 借助Predicate撰写一个filter的逻辑，例如：</span><br>students = filter(students, t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Function示例：数据转换</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 根据学生列表返回名称列表的代码：</span><br>List&lt;Student&gt; names = map(students, t -&gt; t.getName());<br><br><span class=\"hljs-comment\">// 将学生名称转换为大写：</span><br>students = map(students, t -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>(t.getName().toUpperCase(), t.getScore()))<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Consumer示例：直接对原值进行修改</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">foreach(students, t -&gt; t.setName(t.getName(),.toUpperCase()))<br></code></pre></td></tr></table></figure>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><ol>\n<li>示例代码中<code>Student::getName</code>称之为方法引用，使用::分隔开。分隔符前面是类型或变量名，后者是方法名。方法可以是实例方法，也可以是静态方法。例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">getColleageName</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Test String&quot;</span>;<br>&#125;<br><span class=\"hljs-comment\">// 下面两条句子的等价的</span><br>Supplier&lt;String&gt; s = Student::getColleageName;<br>Supplier&lt;String&gt; s = () -&gt; Student.getColleageName()；<br></code></pre></td></tr></table></figure>\n<h2 id=\"函数的复合\"><a href=\"#函数的复合\" class=\"headerlink\" title=\"函数的复合\"></a>函数的复合</h2><ol>\n<li>函数式接口和Lambda表达式可以用作方法的返回值，传递代码回调者，将上述两种方法结合起来，可以构造复合的函数，使程序简洁易读；</li>\n<li>复合Comparator中的复合方法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Arrays.sort(files, (f1, f2) -&gt; f1.getName().compareTo(f2.getName()));<br><span class=\"hljs-comment\">// 进一步简化</span><br>Arrays.sort(files, Comparator.comparing(File::getName()));<br></code></pre></td></tr></table></figure>\n<h2 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h2><ol>\n<li>基本过滤</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用Stream API之前</span><br>List&lt;Student&gt; above90List = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><span class=\"hljs-keyword\">for</span> (Student t : students) &#123;<br>    <span class=\"hljs-keyword\">if</span> (t.getScore() &gt; <span class=\"hljs-number\">90</span>) &#123;<br>        above90List.add(t);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用Stream API之后</span><br>List&lt;Student&gt; above90List = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ul>\n<li>没有显式的迭代循环，循环过程被Stream隐藏；</li>\n<li>提供了声明式的处理函数；</li>\n<li>流畅式接口；</li>\n</ul>\n<ol>\n<li>基本转换</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用Stream API之前</span><br>List&lt;String&gt; nameList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br><span class=\"hljs-keyword\">for</span> (Student t : students) &#123;<br>    nameList.add(t.getName());<br>&#125;<br><br><span class=\"hljs-comment\">// 使用Stream API之后</span><br>List&lt;String&gt; nameList = students.stream()<br>    .map(Student::getName).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>基本过滤和转换组合</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; above90List = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .map(Student::getName)<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>distinct运算</li>\n</ol>\n<ul>\n<li>用于过滤重复元素，只留下唯一元素，是否重复根据equals()方法来比较。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; list = Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;abc&quot;</span>, <span class=\"hljs-string\">&quot;def&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-string\">&quot;Abc&quot;</span>&#125;);<br>List&lt;String&gt; retList = list.stream()<br>    .filter(s -&gt; s.length() &lt;= <span class=\"hljs-number\">3</span>).map(String::toLowerCase).distinct()<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>sorted方法</li>\n</ol>\n<ul>\n<li>对流中的元素进行排序，返回一个排序后的stream。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Student&gt; list = students.stream().filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">0</span>)<br>    .sorted(Comparator.comparing(Student::getScore)<br>    .reversed().thenComparing(Student::getName))<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>skip/limit</li>\n</ol>\n<ul>\n<li>跳过流中的n个元素，如果流的长度不足n个，返回一个空流。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;Student&gt; list = students.stream()<br>    .sorted(Comparator.comparing(Student::getScore).reversed()<br>    .skip(<span class=\"hljs-number\">2</span>).limit(<span class=\"hljs-number\">3</span>).collect(Coolectors.toList()));<br></code></pre></td></tr></table></figure>\n<ol>\n<li>peek</li>\n</ol>\n<ul>\n<li>返回一个与之前一样的流，没有变化。但是提供一个Consumer，会将流中的每一个元素传给Consumer。这个方法主要目的用于支持调试，可以使用该方法观察在流水线中流转的元素。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; above90Names = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .peek(System.out::println).map(Student::getName)<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure>\n<ol>\n<li>mapToLong/mapToInt/mapToDouble</li>\n</ol>\n<ul>\n<li>map函数接受函数参数是一个<code>Function&lt;T, R&gt;</code>，为避免拆箱，装箱提高性能。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .mapToDouble(Student::getScore).sum();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>flatMap</li>\n</ol>\n<ul>\n<li>接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换成一个流Stream。然后将新生成流的每一个元素传递给下一个操作。比如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; lines = Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[]&#123;<span class=\"hljs-string\">&quot;hello abc&quot;</span>, <span class=\"hljs-string\">&quot;laoma biancheng&quot;</span>&#125;);<br>List&lt;String&gt; words = lines.stream()<br>    .flatMap(line -&gt; Arrays.stream(line.split(<span class=\"hljs-string\">&quot;\\\\s+&quot;</span>)))<br>    .collect(Collectors.toList());<br>System.out.println(words); <span class=\"hljs-comment\">// [hello, abc. laoma, biancheng]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"终端操作\"><a href=\"#终端操作\" class=\"headerlink\" title=\"终端操作\"></a>终端操作</h2><ol>\n<li>中间操作不触发实际执行，返回值是Stream，而终端操作触发执行，返回一个具体的值。除了collect之外还有：max, min, count, allMatch, anyMatch, noneMatch, findFirst, findAny, forEach, toArray, reduce等。</li>\n<li>max/min: 返回流中的最大值/最小值。其返回类型为Optional<T>而非T。Optional表明可能为null，程序应当进行适当的处理。例子：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">student</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .max(Comparator.comparing(Student::getScore).reversed()).get();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>count：返回流中的元素个数，例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">above90Count</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>).count();<br></code></pre></td></tr></table></figure>\n<ol>\n<li>allMatch/anyMatch/noneMatch：用于判定流中额元素是否满足一定的条件，区别在于：</li>\n</ol>\n<ul>\n<li>allMatch：流中所有元素都满足条件的情况下返回true;</li>\n<li>anyMatch：流中的元素只要有一个元素满足条件即返回true;</li>\n<li>noneMatch：只有流中的所有元素都不满足条件才返回true;</li>\n<li>示例如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">allPass</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .allMatch(t -&gt; t.getScore() &gt;= <span class=\"hljs-number\">60</span>);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>findFirst/findAny：返回类型均为Optional，如果流为空则返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素。均为短路操作。示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Optional&lt;Student&gt; student = students.stream()<br>    .filter(t -&gt; t.getScore() &lt; <span class=\"hljs-number\">60</span>)<br>    .findAny();<br><span class=\"hljs-keyword\">if</span> (student.isPresent()) &#123;<br>    <span class=\"hljs-comment\">// 处理不符合要求的数据</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>forEach/forEachOrdered：并行流中forEach不保证顺序，forEachOrdered能保证顺序。例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>toArray：将流转换为数组，包含两个方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Object[] toArray() <span class=\"hljs-comment\">// 返回值为Object[]</span><br>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) <span class=\"hljs-comment\">// 得到指定类型的数组</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>示例为：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Student[] above90Arr = students.stream()<br>    .filter(t -&gt; t.getScore() &gt; <span class=\"hljs-number\">90</span>)<br>    .toArray(Student[]::<span class=\"hljs-keyword\">new</span>); <span class=\"hljs-comment\">// Student[]::new就是一个IntFunction类型的ggenerator</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>reduce：归约或折叠，将流中的元素归约为一个值，有三种reduce函数：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Optional&lt;T&gt; <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(BinaryOperator&lt;T&gt; accumulator)</span>;<br>T <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;<br>&lt;U&gt; U <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(U identity, BiFunction&lt;U, ? <span class=\"hljs-built_in\">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第一个reduce函数的使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Student</span> <span class=\"hljs-variable\">topStudent</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .reduce((acc, t) -&gt; &#123;<br>        <span class=\"hljs-keyword\">if</span>(acc.getScore() &gt;= t.getScore()) &#123;<br>            <span class=\"hljs-keyword\">return</span> acc;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> t;<br>        &#125;<br>    &#125;).get();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第二个reduce函数比第一个多了identity参数，表示初始值</li>\n<li>第三个reduce函数更为通用，可以自定义归约类型，另外还多了一个combiner参数，在并行流中用于合并子线程结果。还有示例：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">sumScore</span> <span class=\"hljs-operator\">=</span> students.stream()<br>    .reduce(<span class=\"hljs-number\">0d</span>, (sum, t) -&gt; sum += t.getScore(), <br>    (sum1, sum2) -&gt; sum1 += sum2)<br>    );<br></code></pre></td></tr></table></figure>\n<ol>\n<li>迭代Map的过程删除元素，直接使用forEach会报ConcurrentModificationException</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Map&lt;String, Object&gt; map = other.getHashMap&lt;&gt;();<br>map.entrySet().removeIf(entryElement -&gt; <span class=\"hljs-string\">&quot;some condition&quot;</span>.equals(entryElement.getKey()))<br></code></pre></td></tr></table></figure>\n"},{"title":"Java编程原理——并发","date":"2022-02-16T14:31:00.000Z","updated":"2022-02-16T14:31:00.000Z","_content":"\n# 并发基础\n\n1. 线程表示一条单独的执行流，它有自己的执行计数器，有自己的栈；\n2. 使用线程的方式有两种，继承Thread类以及实现Runnable接口，两种达到的效果是一样的。\n3. 线程具有下列状态：\n\n+ NEW：没有调用start方法线程状态；\n+ TERMINATED：线程运行结束后状态；\n+ RUNNABLE：调用start后线程执行run方法且没有阻塞时状态；\n+ BLOCKED、WAITING、TIMED_WAITING：线程被阻塞；\n\n1. join方法：可以让调用join方法的线程等待该线程结束；\n2. 竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确；\n\n## synchronized关键字\n\n1. synchronized实例方法实际保护的是同一个对象的方法调用，每次只能被一个线程持有；\n2. synchronized关键字保护的是对象，针对实例对象保护的是当前，对于静态方法保护的类对象；\n3. 被synchronized关键字保护的对象都维护着1个锁以及等待队列；\n4. synchronized具有下列特点：\n\n+ 可重入性：对于同一个执行线程在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用；\n+ 内存可见性：释放锁时会将所有的更改写回内存；但是开销有些过高，可以使用volatile关键字实现相同的效果；\n+ 死锁：尽量避免在持有一个锁的同时再去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁；（使用开发过程中可以使用JDK提供的jstack检测死锁）\n\n1. 对于同步容器对象，单个操作是线程安全的，迭代却不是线程安全的。（因为在多线程操作中容易对容器产生结构性变化）；\n2. 如果需要在迭代容器的过程中保证线程安全，需要在遍历整个容器的过程中给整个容器对象加锁；\n3. 除11中所写到的方法，推荐使用并发容器类：\n\n+ CopyOnWriteArrayList\n+ ConcurrentHashMap;\n+ CocurrentLinkedQueue;\n+ ConcurrentSkipSet;\n\n## 线程协作机制\n\n1. 生产/消费者模式：生产者生产数据并放至消费队列中，消费者从消费队列中消费数据，如果队列为空消费者等待，如果队列满，生产者等待；\n2. 同时开始：在模拟仿真程序中，多个线程同时开始；\n3. 等待结束：主线程将任务拆解成多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕；\n4. 异步结果：将子线程封装为异步调用，子线程在正确返回结果前先返回一个Future对象，通过Future对象可以获得子线程最终的执行结果；\n5. Map/Reduce操作：也需要使用线程进行操作；\n\n## wait/notify机制：\n\n1. 每个同步对象都拥有一个锁以及一个等待队列，当调用wait方法，系统会将对象放入等待队列，直到调用notify方法再将其从等待队列中取出。\n2. 设计多线程程序的时候需要想清楚共享变量和条件，这是设计多线程协作的核心。\n3. 以生产者/消费者模式为例：生产者生产产品，并放入缓冲队列；消费者从缓冲队列取出产品进行消费。当生产者生产速度过快导致缓冲队列满了，此时生产者应停止生产。同样，当生产者生产过慢导致缓冲队列空，此时消费者应停止消费。等待生产者生产。\n4. 同时进行：一个主线程以及N个子线程，当主线程发送指令后，子线程开始同时执行；\n5. 各个线程分头行动，给咱达到一个集合点，在集合点需要集齐所有线程交换数据。然后再进行下一步动作。\n\n## 取消/关闭线程机制\n\n1. 停止一个线程的手段主要是中断，中断线程的目的并不是强迫线程终止，而是给线程发送一个停止信号，由线程自行决定中断的时机。本质上依旧是一种协作机制。\n2. Java中关于中断的方法有如下三种：\n\n```java\npublic boolean isInterrupted(); // 返回对应线程的中断标志位是否为true\npublic void interrupt(); // 表示中断对应的线程\npublic static boolean interrupted(); // 返回当前线程的中断标志位是否为true，但还有一个副作用：清空中断标志位。\n```\n\n1. 对于以线程提供的服务的应用程序模块而言，应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用库应该调用这些方法而不是直接调用interrupt方法；\n\n# 并发包基石\n\n## 原子变量\n\n1. 原子变量即为操作一次性完成，期间不进行线程上下文切换，并且能保证线程安全的原子变量。\n2. 原子变量有AtomicBoolean, AtomicInteger, AtomicLong以及AtomicReference（原子引用类型）类型\n3. 之所以称之为原子变量，是因为其包含一些原子方法实现组合操作的方法\n4. compareAndSet方法，也就是常说的CAS。如果当前值等于expect，则更新为update，否则不更新。如果更新成功，返回true，否则返回false。\n5. 乐观锁与悲观锁的区别：乐观锁假设每次操作都是不会出现冲突，因此在更新时不管是否出现冲突都会先进行一次更新，即便冲突了只需要再检测一次即可；而别管锁假设每次操作都会产生冲突，因此每次操作前都需要获得锁才能继续操作（例如：synchronized关键字）；\n6. 使用CAS会出现一个ABA问题：假设当前值为A，如果另一个线程将A改为B然后再修改回A，当前线程的CAS操作是无法分辨当前值发生过变化的。解决ABA可以在线程修改值时加上一个时间戳，以此来判断当前线程持有变量的版本；\n\n```java\nPair pair = new Pair(100, 200);\nint stamp = 1;\nAtomicStampedReference<Pair> pairRef = new AtomicStampedReference<>(pair, stamp);\nint newStamp = 2;\npairRef.copareAndSet(pair, new Pair(200, 200), stamp, newStamp);\n```\n\n1. 总结：CAS是并发包的基础，基于它可以实现高效、乐观、非阻塞式数据结构的算法，它也是并发包中锁、同步工具以及各种容器的基础；\n\n## 显式锁\n\n1. 包括锁Lock，主要实现类为ReentrantLock；读写锁接口ReadWriteLock，主要实现类是ReetrantReadWriteLock;\n2. 显式锁一般有下列方法：\n\n+ lock()/unlock()：普通获取锁和释放锁方法；会阻塞直至成功；\n+ lockInterruptibly()：可以响应中断，如果被其他线程中断会抛出InterruptedException；\n+ tryLock()：只是尝试获取锁，立即返回；如果获取成功返回true，否则返回false;\n+ newCondition()：新建一个条件\n\n1. 相比于synchronized，显式锁支持非阻塞方式获取锁、可以响应中断、可以限时；\n2. Lock是可重入的（一个线程持有一个锁的前提下可以继续获得该锁）、可以解决竞态条件、可以保证内存的可见性（volatile）\n3. 保证竞态条件的公平性会影响性能，一般情况下我们不作保证；例如：\n\n```java\npublic class Counter {\n    private final Lock lock = new ReetrantLock();\n    private volatile int count;\n    \n    public void incr() {\n        lock.lock(); // 使用lock获得显式锁\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // 用完要及时释放掉\n        }\n    }\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n1. 使用tryLock()可以避免死锁，在持有一个锁获另一个锁而获取不到的时候，可以释放自己已持有的锁，给其他线程获得锁的机会，然后重试获取所有锁；例如下面这样写会产生死锁，使用tryLock()判断可以避免死锁问题：\n\n```java\n// Account.java\npublic class Account {\n    private Lock lock = new ReetrantLock();\n    private volatile double money;\n    \n    public Account(double money) {\n        lock.lock();\n        try {\n            this.money += money;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public void reduce(double money) {\n        lock.lock();\n        try {\n            this.money -= money;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public double getMoney() {\n        return money;\n    }\n    \n    void lock() {\n        lock.lock();\n    }\n    \n    void unlock() {\n        lock.unlock();\n    }\n    \n    boolean tryLock() {\n        return lock.tryLock();\n    }\n}\n\n// AccountMgr.java\npublic class AccountMgr {\n    public static class NoEnoughMoneyException extends Exception{}\n    public static void transfer(Account from, Account to, double money)throws NoEnoughMoneyException {\n        from.lock(); // from获得锁\n        try {\n            to.lock(); // to获得锁\n            try {\n                if (from.getMoney() >= money) {\n                    from.reduce(money);\n                    to.add(money);\n                } else {\n                    throw new NoEnoughMoneyException();\n                } finally {\n                    to.unlock(); // to释放锁\n                }\n            } finally {\n                from.unlock(); // from释放锁\n            }\n        }\n    }\n}\n```\n\n1. Java中封装了一个抽象类AQS用于简化并发工具类的实现。AQS全称（AbstractQueuedSynchronizer）。AQS的实现比较复杂。AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。\n2. Lock锁的基本原理如下：能获得锁就立即获得，否则加入等待队列，被唤醒后检查自己是否是第一个等待的线程，如果是且能获得锁则返回；否则继续等待，这个过程如果发生了中断，lock会记录中断标志位，但不会提前返回或者是抛出异常；\n3. 保证公平性的结果是整体性能会降低，低的原因不在于检查速度慢，而是会让活跃线程得不到锁，进入等待状态，引起频繁上下文切换，降低整体的效率。需要说明的是即便fair参数为true，ReetrantLock中不带参数的tryLock方法也是不保证公平的。\n4. synchronized关键字是声明式编程，而Lock是命令式编程，所有内部的细节都需要自己实现。目前JVM对synchronized的优化已经相当的好。因此能用synchronized的地方建议使用synchronized，不能使用synchronized关键字的地方再考虑Lock；\n\n## 显式条件\n\n1. 锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，显式条件和wait/notify相对应。\n2. 实现显式锁的显式条件为Condition类，该类为一个接口，其中包含下列方法：其中绝大部分是响应中断的。即：当出现中断会清空标志位：\n\n```java\nvoid await() // 相当于Object中的wait();\nvoid awaitUnInterruptibly(); // 不响应中断\nlong awaitNanos(long nanoTimeout);\nboolean await(long times, TimeUnit unit);\nboolean awaitUntil(Date deadline);\nvoid signal(); // 相当于notify();\nvoid signalAll(); // 相当于notifyAll();\n```\n\n1. await在进入等待队列后，会释放锁以及CPU，当其他线程将它唤醒后、等待超时后以及发生中断退出后都需要重新获得锁，获取锁后才从await方法中退出。\n2. 使用显式锁的示例如下：\n\n```java\npublic class WaitThread extends Thread {\n    private volatile boolean fire = false;\n    private Lock lock = new ReetrantLock();\n    private Condition condition = lock.newCondition();\n    \n    @Override\n    public void run() {\n        try {\n            lock.lock();\n            try {\n                while(!fire) {\n                    condition.await();\n                }\n            } finally {\n                lock.unlock();\n            }\n            System.out.println(\"fired\");\n        } catch (InterruptedException e) {\n            Thread.interrupted();\n        }\n    }\n    \n    public void fire() {\n        lock.lock();\n        try {\n            this.fire = true;\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException{\n        WaitThread waitThread = new WaitThread();\n        waitThread.start();\n        Thread.sleep(1000);\n        System.out.println(\"fire\");\n        waitThread.fire();\n    }\n}\n```\n\n1. await()/signal()方法与显式锁配合使用；而wait()/notify()要与synchronized方法使用，不能使用混淆。否则即便编译器不报错也会出现IllegalStateException方法。\n\n# 并发容器\n\n## CopyOnWriteArrayList以及CopyOnWriteArraySet\n\n1. 特点：线程安全，可以被多个线程并发访问；\n2. 迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；\n3. 以原子方式支持一些复合操作\n4. 写时复制的技术思路为：每次出现修改操作时，都会新建一个数组，复制原数组内容到新数组，在新数组上进行需要的修改，然后一原子方式设置内部数组引用。同理：所有的读操作都是**先拿到当前引用的数组**，然后**直接访问**该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响操作，它依旧访问原数组内容。\n5. 截至当前保证线程安全的思路有三种：\n\n+ 使用锁：例如synchronized关键字以及ReetrantLock；\n+ 使用CAS：\n+ 写时复制也是一种常见的线程安全保证思路，在操作系统内部的进程管理和内存管理经常会使用到。\n\n1. 总结：CopyOnWriteList和CopyOnWriteSet适用于读远多于写、集合不太大的场景，它们采用了写时复制技术，这也是计算机中一种重要的思维和技术。\n\n## ConcurrentHashMap\n\n1. 特点：并发安全、支持一些原子复合操作、支持高并发，读完全并行、弱一致性；\n2. HashMap不是线程安全的，在高并发场景下容易出现死循环以及占满CPU的问题；\n3. Collections.synchronizedMap()在调用一些更新操作时需要加锁，而ConcurrentHashMap()就不存在这个问题；\n4. ConcurrentHashMap使用了很复杂的技术实现高并发，但是简要概括下有下列两种：\n\n+ 分段锁：将读取的数据分为多段，每段都拥有自己的锁，每个段都相当于独立的Hash表。使用分段锁可以有效地提高并发效率。\n+ 读不需要锁：对于写操作需要获取锁，不能并行，但是读操作可以并行。写的同时也可以读。\n\n1. 弱一致性：ConcurrentHashMap在创建完迭代器后，会按照哈希表中反映的结构迭代元素。如果结构的变化发生在已经迭代过的元素上，则结构性变化不会反映出来。反之，若结构变化发生在未发生改变的元素上，结构变化就可以被反映出来。这种现象就称之为弱一致性；\n\n## 基于SkipList的Map和Set\n\n1. 特点：所有的操作都可以并行，包括读和写；\n2. 与TreeMap/TreeSet一样，可以实现按键的自然排序；使用方法如下：\n\n```java\npublic void CurrentSkipMapDemo {\n    public static void main(String[] args) {\n        Map<String, Object> map = new ConcurrentSkipMap<>(Collections.reverseOrder());\n        map.put(\"a\", \"abstract\");\n        map.put(\"b\", \"basic\");\n        map.put(\"c\", \"call\");\n        System.out.println(map.toString());\n    }\n}\n```\n\n1. SkipMap和SkipSet是基于跳表实现，跳表是基于链表实现的。在链表的基础上增加了多层索引结构。跳表实际上一个类似于二分查找的数据结构。因此有了这样的数据结构就可以更好地实现，关于其复杂度就不再赘述。\n\n## 并发队列\n\n1. Java中的并发队列一般包括下列几种：\n\n+ 无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque\n+ 普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque；\n+ 优先级阻塞队列：PriorityBlockingQueue；\n+ 延时阻塞队列：DelayQueue；\n+ 其他阻塞队列：SynchronousQueue和LinkedTransferQueue；\n\n1. 这里的无锁指的是不使用锁，使用CAS方式实现；\n2. 普通阻塞队列适用于生产者/消费者模式；\n3. 优先级队列是按照优先级出队列的，优先级高的先出\n4. 延时阻塞队列可以用于定时任务，按照元素的延时时间出队，其特殊点在于只有当元素的延时过期之后才能从队列中被拿走\n5. SynchronousQueue没有存储空间，适用于两进程之间传递信息；LinkedTransferQueue适用于一些消息传递类型的应用中。\n\n# 异步执行任务\n\n## 执行接口\n\n+ Runnable（没有返回结果）和Callable（有返回结果）：表示要执行的异步任务\n+ Executor和ExecutorService：表示执行服务\n+ Future：表示异步任务的结果\n\n## Future接口的使用\n\n1. 示例代码\n\n```java\npublic class BasicDemo {\n    static class Task implements Callable<Integer> {\n        @Override\n        public Integer call() throws Exception {\n            int sleepSeconds = new Random().nextInt(1000);\n            Thread.sleep(sleepSeconds);\n            return sleepSeconds;\n        }\n    }\n    public static void main(String[] args) throws InterruptedException{\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<Integer> future = executor.submit(new Task());\n        Thread.sleep(100);\n        try {\n            System.out.println(future.get());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        executor.shutdown();\n    }\n}\n```\n\n1. 实现原理：ExecutorService的主要实现类是ThreadPoolExecutor，是基于线程池实现的。\n2. 总结：并发包执行任务执行服务体现了并发异步开发中的“关注点分离”的思想，使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。\n\n## 线程池\n\n1. 线程池主要有任务队列以及工作者线程组成；\n2. 线程池有下列优点：\n\n+ 可以重用线程，避免线程创建的开销；\n+ 任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争；\n\n1. Java中最常用的线程池类是ThreadPoolExecutor；其中最重要的4个参数是：corePoolSize（核心线程个数）,maximumPoolSize（最大线程个数）keepAliveTime和unit（空闲线程存活时间）\n2. ThreadPoolExecutor中的队列均为阻塞队列，分为有界和无界两种类型。需要说明的是如果使用了无界队列，线程个数最多只能达到corePoolSize，达到corePoolSize之后新的任务总会排队，参数maximumPoolSize也就没有意义了。\n3. 当队列有界并且maximumPoolSize有限时，只要队列排满，新任务总会被拒绝，因此也会出发任务拒绝策略。不过任务拒绝策略是可以自定义的。\n\n+ ThreadPoolExecutor.AbortPolicy：默认方式，抛出异常\n+ ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛出异常也不执行\n+ ThreadPoolExecutor.DiscardOldestPolicy：扔掉等待时间最长的任务，然后自己排队\n+ ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，不交给线程池中的线程执行\n\n## 定时任务\n\n1. TimerTask表示一个定时任务，具体的定时任务需要继承该抽象类，实现run方法。示例：\n\n```java\npublic class BasicTimer {\n    static class DelayTask extends TimerTask {\n        @Override\n        public void run() {\n            System.out.println(\"delayed task\");\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        Timer timer = new Timer();\n        timer.schedule(new DelayTask(), 1000);\n        Thread.sleep(2000);\n        timer.cancel();\n    }\n}\n```\n\n1. Timer内部主要是由任务队列和Timer线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。一个Timer对象只有一个Timer线程。\n2. 对于固定延时任务，延时相对的是任务执行前的当前时间；对于固定频率任务，延时相对的是最优先计划；\n3. 在执行一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的定时任务都会被取消。因此，如果希望各个定时任务不互相干扰，一定要在run方法内捕获异常。\n4. 并发包中使用ScheduledExecutorService来实现定时任务，其为一个接口，多线程执行定时任务的示例如下：\n\n```java\npublic class ScheduledFixedDelay {\n    static class LongRunningTask implements Runnable {}\n    static class FixedDelayTask implements Runnable {}\n    public static void main(String[] args) {\n        ScheduledExecutorService timer = Executors.newScheduledThreadPool(10);\n        timer.schedule(new LongRunningTask(), 10, TimeUnit.MILLISECONDS);\n        timer.scheduleWithFixedDelay(new FixedDelayTask(), 100, 1000, TimeUnit.MILLISECONDS);\n    }\n}\n```\n\n1. ScheduledExecutorService的实现原理如下：\n\n+ 实现背后是线程池，可以有多个线程执行任务；\n+ 在任务执行后再设置下次执行的时间，对于固定延时的任务更合理；\n+ 任务执行线程会捕获任务执行过程中的所有异常。一个定时任务的异常不会影响其他定时任务；\n\n# 同步以及协作工具类\n\n1. 同步工具类包括：\n\n+ ReetrantReadWriteLock：读写显式锁\n+ Semaphore：信号量\n+ CountDownLatch：倒计时门栓\n+ CyclicBarrier：循环栅栏\n+ ThreadLocal：线程本地 2.ReetrantReadWriteLock读写显式锁：只有“读-读”可以并行，“读-写”和“写-写”都是不可以的。只有一个线程可以进行写操作。是基于CAS实现的；\n\n1. Semaphore：限制并发数量，是基于AQS实现的；\n2. CountDownLatch：默认是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过。门栓是一次性的，打开了就不能再关上了。\n3. CyclicBarrier：所有线程在到达该栅栏后都需要等待其他线程，等待所有线程都到达后在一起通过。它是循环的，可以用重复的同步。\n4. ThreadLocal：每个线程都有同一个变量的独有拷贝，也就是说每个线程都拥有一个属于自己的独立值。一般来说ThreadLocal都定义为静态类型便于引用\n\n# 并发总结\n","source":"_posts/java-core/ch05.md","raw":"---\ntitle: Java编程原理——并发\ndate: 2022-02-16 22:31:00\nupdated: 2022-02-16 22:31:00\ntags: Java基础\ncategories: Java\n---\n\n# 并发基础\n\n1. 线程表示一条单独的执行流，它有自己的执行计数器，有自己的栈；\n2. 使用线程的方式有两种，继承Thread类以及实现Runnable接口，两种达到的效果是一样的。\n3. 线程具有下列状态：\n\n+ NEW：没有调用start方法线程状态；\n+ TERMINATED：线程运行结束后状态；\n+ RUNNABLE：调用start后线程执行run方法且没有阻塞时状态；\n+ BLOCKED、WAITING、TIMED_WAITING：线程被阻塞；\n\n1. join方法：可以让调用join方法的线程等待该线程结束；\n2. 竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确；\n\n## synchronized关键字\n\n1. synchronized实例方法实际保护的是同一个对象的方法调用，每次只能被一个线程持有；\n2. synchronized关键字保护的是对象，针对实例对象保护的是当前，对于静态方法保护的类对象；\n3. 被synchronized关键字保护的对象都维护着1个锁以及等待队列；\n4. synchronized具有下列特点：\n\n+ 可重入性：对于同一个执行线程在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用；\n+ 内存可见性：释放锁时会将所有的更改写回内存；但是开销有些过高，可以使用volatile关键字实现相同的效果；\n+ 死锁：尽量避免在持有一个锁的同时再去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁；（使用开发过程中可以使用JDK提供的jstack检测死锁）\n\n1. 对于同步容器对象，单个操作是线程安全的，迭代却不是线程安全的。（因为在多线程操作中容易对容器产生结构性变化）；\n2. 如果需要在迭代容器的过程中保证线程安全，需要在遍历整个容器的过程中给整个容器对象加锁；\n3. 除11中所写到的方法，推荐使用并发容器类：\n\n+ CopyOnWriteArrayList\n+ ConcurrentHashMap;\n+ CocurrentLinkedQueue;\n+ ConcurrentSkipSet;\n\n## 线程协作机制\n\n1. 生产/消费者模式：生产者生产数据并放至消费队列中，消费者从消费队列中消费数据，如果队列为空消费者等待，如果队列满，生产者等待；\n2. 同时开始：在模拟仿真程序中，多个线程同时开始；\n3. 等待结束：主线程将任务拆解成多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕；\n4. 异步结果：将子线程封装为异步调用，子线程在正确返回结果前先返回一个Future对象，通过Future对象可以获得子线程最终的执行结果；\n5. Map/Reduce操作：也需要使用线程进行操作；\n\n## wait/notify机制：\n\n1. 每个同步对象都拥有一个锁以及一个等待队列，当调用wait方法，系统会将对象放入等待队列，直到调用notify方法再将其从等待队列中取出。\n2. 设计多线程程序的时候需要想清楚共享变量和条件，这是设计多线程协作的核心。\n3. 以生产者/消费者模式为例：生产者生产产品，并放入缓冲队列；消费者从缓冲队列取出产品进行消费。当生产者生产速度过快导致缓冲队列满了，此时生产者应停止生产。同样，当生产者生产过慢导致缓冲队列空，此时消费者应停止消费。等待生产者生产。\n4. 同时进行：一个主线程以及N个子线程，当主线程发送指令后，子线程开始同时执行；\n5. 各个线程分头行动，给咱达到一个集合点，在集合点需要集齐所有线程交换数据。然后再进行下一步动作。\n\n## 取消/关闭线程机制\n\n1. 停止一个线程的手段主要是中断，中断线程的目的并不是强迫线程终止，而是给线程发送一个停止信号，由线程自行决定中断的时机。本质上依旧是一种协作机制。\n2. Java中关于中断的方法有如下三种：\n\n```java\npublic boolean isInterrupted(); // 返回对应线程的中断标志位是否为true\npublic void interrupt(); // 表示中断对应的线程\npublic static boolean interrupted(); // 返回当前线程的中断标志位是否为true，但还有一个副作用：清空中断标志位。\n```\n\n1. 对于以线程提供的服务的应用程序模块而言，应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用库应该调用这些方法而不是直接调用interrupt方法；\n\n# 并发包基石\n\n## 原子变量\n\n1. 原子变量即为操作一次性完成，期间不进行线程上下文切换，并且能保证线程安全的原子变量。\n2. 原子变量有AtomicBoolean, AtomicInteger, AtomicLong以及AtomicReference（原子引用类型）类型\n3. 之所以称之为原子变量，是因为其包含一些原子方法实现组合操作的方法\n4. compareAndSet方法，也就是常说的CAS。如果当前值等于expect，则更新为update，否则不更新。如果更新成功，返回true，否则返回false。\n5. 乐观锁与悲观锁的区别：乐观锁假设每次操作都是不会出现冲突，因此在更新时不管是否出现冲突都会先进行一次更新，即便冲突了只需要再检测一次即可；而别管锁假设每次操作都会产生冲突，因此每次操作前都需要获得锁才能继续操作（例如：synchronized关键字）；\n6. 使用CAS会出现一个ABA问题：假设当前值为A，如果另一个线程将A改为B然后再修改回A，当前线程的CAS操作是无法分辨当前值发生过变化的。解决ABA可以在线程修改值时加上一个时间戳，以此来判断当前线程持有变量的版本；\n\n```java\nPair pair = new Pair(100, 200);\nint stamp = 1;\nAtomicStampedReference<Pair> pairRef = new AtomicStampedReference<>(pair, stamp);\nint newStamp = 2;\npairRef.copareAndSet(pair, new Pair(200, 200), stamp, newStamp);\n```\n\n1. 总结：CAS是并发包的基础，基于它可以实现高效、乐观、非阻塞式数据结构的算法，它也是并发包中锁、同步工具以及各种容器的基础；\n\n## 显式锁\n\n1. 包括锁Lock，主要实现类为ReentrantLock；读写锁接口ReadWriteLock，主要实现类是ReetrantReadWriteLock;\n2. 显式锁一般有下列方法：\n\n+ lock()/unlock()：普通获取锁和释放锁方法；会阻塞直至成功；\n+ lockInterruptibly()：可以响应中断，如果被其他线程中断会抛出InterruptedException；\n+ tryLock()：只是尝试获取锁，立即返回；如果获取成功返回true，否则返回false;\n+ newCondition()：新建一个条件\n\n1. 相比于synchronized，显式锁支持非阻塞方式获取锁、可以响应中断、可以限时；\n2. Lock是可重入的（一个线程持有一个锁的前提下可以继续获得该锁）、可以解决竞态条件、可以保证内存的可见性（volatile）\n3. 保证竞态条件的公平性会影响性能，一般情况下我们不作保证；例如：\n\n```java\npublic class Counter {\n    private final Lock lock = new ReetrantLock();\n    private volatile int count;\n    \n    public void incr() {\n        lock.lock(); // 使用lock获得显式锁\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // 用完要及时释放掉\n        }\n    }\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n1. 使用tryLock()可以避免死锁，在持有一个锁获另一个锁而获取不到的时候，可以释放自己已持有的锁，给其他线程获得锁的机会，然后重试获取所有锁；例如下面这样写会产生死锁，使用tryLock()判断可以避免死锁问题：\n\n```java\n// Account.java\npublic class Account {\n    private Lock lock = new ReetrantLock();\n    private volatile double money;\n    \n    public Account(double money) {\n        lock.lock();\n        try {\n            this.money += money;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public void reduce(double money) {\n        lock.lock();\n        try {\n            this.money -= money;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public double getMoney() {\n        return money;\n    }\n    \n    void lock() {\n        lock.lock();\n    }\n    \n    void unlock() {\n        lock.unlock();\n    }\n    \n    boolean tryLock() {\n        return lock.tryLock();\n    }\n}\n\n// AccountMgr.java\npublic class AccountMgr {\n    public static class NoEnoughMoneyException extends Exception{}\n    public static void transfer(Account from, Account to, double money)throws NoEnoughMoneyException {\n        from.lock(); // from获得锁\n        try {\n            to.lock(); // to获得锁\n            try {\n                if (from.getMoney() >= money) {\n                    from.reduce(money);\n                    to.add(money);\n                } else {\n                    throw new NoEnoughMoneyException();\n                } finally {\n                    to.unlock(); // to释放锁\n                }\n            } finally {\n                from.unlock(); // from释放锁\n            }\n        }\n    }\n}\n```\n\n1. Java中封装了一个抽象类AQS用于简化并发工具类的实现。AQS全称（AbstractQueuedSynchronizer）。AQS的实现比较复杂。AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。\n2. Lock锁的基本原理如下：能获得锁就立即获得，否则加入等待队列，被唤醒后检查自己是否是第一个等待的线程，如果是且能获得锁则返回；否则继续等待，这个过程如果发生了中断，lock会记录中断标志位，但不会提前返回或者是抛出异常；\n3. 保证公平性的结果是整体性能会降低，低的原因不在于检查速度慢，而是会让活跃线程得不到锁，进入等待状态，引起频繁上下文切换，降低整体的效率。需要说明的是即便fair参数为true，ReetrantLock中不带参数的tryLock方法也是不保证公平的。\n4. synchronized关键字是声明式编程，而Lock是命令式编程，所有内部的细节都需要自己实现。目前JVM对synchronized的优化已经相当的好。因此能用synchronized的地方建议使用synchronized，不能使用synchronized关键字的地方再考虑Lock；\n\n## 显式条件\n\n1. 锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，显式条件和wait/notify相对应。\n2. 实现显式锁的显式条件为Condition类，该类为一个接口，其中包含下列方法：其中绝大部分是响应中断的。即：当出现中断会清空标志位：\n\n```java\nvoid await() // 相当于Object中的wait();\nvoid awaitUnInterruptibly(); // 不响应中断\nlong awaitNanos(long nanoTimeout);\nboolean await(long times, TimeUnit unit);\nboolean awaitUntil(Date deadline);\nvoid signal(); // 相当于notify();\nvoid signalAll(); // 相当于notifyAll();\n```\n\n1. await在进入等待队列后，会释放锁以及CPU，当其他线程将它唤醒后、等待超时后以及发生中断退出后都需要重新获得锁，获取锁后才从await方法中退出。\n2. 使用显式锁的示例如下：\n\n```java\npublic class WaitThread extends Thread {\n    private volatile boolean fire = false;\n    private Lock lock = new ReetrantLock();\n    private Condition condition = lock.newCondition();\n    \n    @Override\n    public void run() {\n        try {\n            lock.lock();\n            try {\n                while(!fire) {\n                    condition.await();\n                }\n            } finally {\n                lock.unlock();\n            }\n            System.out.println(\"fired\");\n        } catch (InterruptedException e) {\n            Thread.interrupted();\n        }\n    }\n    \n    public void fire() {\n        lock.lock();\n        try {\n            this.fire = true;\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException{\n        WaitThread waitThread = new WaitThread();\n        waitThread.start();\n        Thread.sleep(1000);\n        System.out.println(\"fire\");\n        waitThread.fire();\n    }\n}\n```\n\n1. await()/signal()方法与显式锁配合使用；而wait()/notify()要与synchronized方法使用，不能使用混淆。否则即便编译器不报错也会出现IllegalStateException方法。\n\n# 并发容器\n\n## CopyOnWriteArrayList以及CopyOnWriteArraySet\n\n1. 特点：线程安全，可以被多个线程并发访问；\n2. 迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；\n3. 以原子方式支持一些复合操作\n4. 写时复制的技术思路为：每次出现修改操作时，都会新建一个数组，复制原数组内容到新数组，在新数组上进行需要的修改，然后一原子方式设置内部数组引用。同理：所有的读操作都是**先拿到当前引用的数组**，然后**直接访问**该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响操作，它依旧访问原数组内容。\n5. 截至当前保证线程安全的思路有三种：\n\n+ 使用锁：例如synchronized关键字以及ReetrantLock；\n+ 使用CAS：\n+ 写时复制也是一种常见的线程安全保证思路，在操作系统内部的进程管理和内存管理经常会使用到。\n\n1. 总结：CopyOnWriteList和CopyOnWriteSet适用于读远多于写、集合不太大的场景，它们采用了写时复制技术，这也是计算机中一种重要的思维和技术。\n\n## ConcurrentHashMap\n\n1. 特点：并发安全、支持一些原子复合操作、支持高并发，读完全并行、弱一致性；\n2. HashMap不是线程安全的，在高并发场景下容易出现死循环以及占满CPU的问题；\n3. Collections.synchronizedMap()在调用一些更新操作时需要加锁，而ConcurrentHashMap()就不存在这个问题；\n4. ConcurrentHashMap使用了很复杂的技术实现高并发，但是简要概括下有下列两种：\n\n+ 分段锁：将读取的数据分为多段，每段都拥有自己的锁，每个段都相当于独立的Hash表。使用分段锁可以有效地提高并发效率。\n+ 读不需要锁：对于写操作需要获取锁，不能并行，但是读操作可以并行。写的同时也可以读。\n\n1. 弱一致性：ConcurrentHashMap在创建完迭代器后，会按照哈希表中反映的结构迭代元素。如果结构的变化发生在已经迭代过的元素上，则结构性变化不会反映出来。反之，若结构变化发生在未发生改变的元素上，结构变化就可以被反映出来。这种现象就称之为弱一致性；\n\n## 基于SkipList的Map和Set\n\n1. 特点：所有的操作都可以并行，包括读和写；\n2. 与TreeMap/TreeSet一样，可以实现按键的自然排序；使用方法如下：\n\n```java\npublic void CurrentSkipMapDemo {\n    public static void main(String[] args) {\n        Map<String, Object> map = new ConcurrentSkipMap<>(Collections.reverseOrder());\n        map.put(\"a\", \"abstract\");\n        map.put(\"b\", \"basic\");\n        map.put(\"c\", \"call\");\n        System.out.println(map.toString());\n    }\n}\n```\n\n1. SkipMap和SkipSet是基于跳表实现，跳表是基于链表实现的。在链表的基础上增加了多层索引结构。跳表实际上一个类似于二分查找的数据结构。因此有了这样的数据结构就可以更好地实现，关于其复杂度就不再赘述。\n\n## 并发队列\n\n1. Java中的并发队列一般包括下列几种：\n\n+ 无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque\n+ 普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque；\n+ 优先级阻塞队列：PriorityBlockingQueue；\n+ 延时阻塞队列：DelayQueue；\n+ 其他阻塞队列：SynchronousQueue和LinkedTransferQueue；\n\n1. 这里的无锁指的是不使用锁，使用CAS方式实现；\n2. 普通阻塞队列适用于生产者/消费者模式；\n3. 优先级队列是按照优先级出队列的，优先级高的先出\n4. 延时阻塞队列可以用于定时任务，按照元素的延时时间出队，其特殊点在于只有当元素的延时过期之后才能从队列中被拿走\n5. SynchronousQueue没有存储空间，适用于两进程之间传递信息；LinkedTransferQueue适用于一些消息传递类型的应用中。\n\n# 异步执行任务\n\n## 执行接口\n\n+ Runnable（没有返回结果）和Callable（有返回结果）：表示要执行的异步任务\n+ Executor和ExecutorService：表示执行服务\n+ Future：表示异步任务的结果\n\n## Future接口的使用\n\n1. 示例代码\n\n```java\npublic class BasicDemo {\n    static class Task implements Callable<Integer> {\n        @Override\n        public Integer call() throws Exception {\n            int sleepSeconds = new Random().nextInt(1000);\n            Thread.sleep(sleepSeconds);\n            return sleepSeconds;\n        }\n    }\n    public static void main(String[] args) throws InterruptedException{\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<Integer> future = executor.submit(new Task());\n        Thread.sleep(100);\n        try {\n            System.out.println(future.get());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        executor.shutdown();\n    }\n}\n```\n\n1. 实现原理：ExecutorService的主要实现类是ThreadPoolExecutor，是基于线程池实现的。\n2. 总结：并发包执行任务执行服务体现了并发异步开发中的“关注点分离”的思想，使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。\n\n## 线程池\n\n1. 线程池主要有任务队列以及工作者线程组成；\n2. 线程池有下列优点：\n\n+ 可以重用线程，避免线程创建的开销；\n+ 任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争；\n\n1. Java中最常用的线程池类是ThreadPoolExecutor；其中最重要的4个参数是：corePoolSize（核心线程个数）,maximumPoolSize（最大线程个数）keepAliveTime和unit（空闲线程存活时间）\n2. ThreadPoolExecutor中的队列均为阻塞队列，分为有界和无界两种类型。需要说明的是如果使用了无界队列，线程个数最多只能达到corePoolSize，达到corePoolSize之后新的任务总会排队，参数maximumPoolSize也就没有意义了。\n3. 当队列有界并且maximumPoolSize有限时，只要队列排满，新任务总会被拒绝，因此也会出发任务拒绝策略。不过任务拒绝策略是可以自定义的。\n\n+ ThreadPoolExecutor.AbortPolicy：默认方式，抛出异常\n+ ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛出异常也不执行\n+ ThreadPoolExecutor.DiscardOldestPolicy：扔掉等待时间最长的任务，然后自己排队\n+ ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，不交给线程池中的线程执行\n\n## 定时任务\n\n1. TimerTask表示一个定时任务，具体的定时任务需要继承该抽象类，实现run方法。示例：\n\n```java\npublic class BasicTimer {\n    static class DelayTask extends TimerTask {\n        @Override\n        public void run() {\n            System.out.println(\"delayed task\");\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        Timer timer = new Timer();\n        timer.schedule(new DelayTask(), 1000);\n        Thread.sleep(2000);\n        timer.cancel();\n    }\n}\n```\n\n1. Timer内部主要是由任务队列和Timer线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。一个Timer对象只有一个Timer线程。\n2. 对于固定延时任务，延时相对的是任务执行前的当前时间；对于固定频率任务，延时相对的是最优先计划；\n3. 在执行一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的定时任务都会被取消。因此，如果希望各个定时任务不互相干扰，一定要在run方法内捕获异常。\n4. 并发包中使用ScheduledExecutorService来实现定时任务，其为一个接口，多线程执行定时任务的示例如下：\n\n```java\npublic class ScheduledFixedDelay {\n    static class LongRunningTask implements Runnable {}\n    static class FixedDelayTask implements Runnable {}\n    public static void main(String[] args) {\n        ScheduledExecutorService timer = Executors.newScheduledThreadPool(10);\n        timer.schedule(new LongRunningTask(), 10, TimeUnit.MILLISECONDS);\n        timer.scheduleWithFixedDelay(new FixedDelayTask(), 100, 1000, TimeUnit.MILLISECONDS);\n    }\n}\n```\n\n1. ScheduledExecutorService的实现原理如下：\n\n+ 实现背后是线程池，可以有多个线程执行任务；\n+ 在任务执行后再设置下次执行的时间，对于固定延时的任务更合理；\n+ 任务执行线程会捕获任务执行过程中的所有异常。一个定时任务的异常不会影响其他定时任务；\n\n# 同步以及协作工具类\n\n1. 同步工具类包括：\n\n+ ReetrantReadWriteLock：读写显式锁\n+ Semaphore：信号量\n+ CountDownLatch：倒计时门栓\n+ CyclicBarrier：循环栅栏\n+ ThreadLocal：线程本地 2.ReetrantReadWriteLock读写显式锁：只有“读-读”可以并行，“读-写”和“写-写”都是不可以的。只有一个线程可以进行写操作。是基于CAS实现的；\n\n1. Semaphore：限制并发数量，是基于AQS实现的；\n2. CountDownLatch：默认是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过。门栓是一次性的，打开了就不能再关上了。\n3. CyclicBarrier：所有线程在到达该栅栏后都需要等待其他线程，等待所有线程都到达后在一起通过。它是循环的，可以用重复的同步。\n4. ThreadLocal：每个线程都有同一个变量的独有拷贝，也就是说每个线程都拥有一个属于自己的独立值。一般来说ThreadLocal都定义为静态类型便于引用\n\n# 并发总结\n","slug":"java-core/ch05","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2o000c2y61fm9z9f0z","content":"<h1 id=\"并发基础\"><a href=\"#并发基础\" class=\"headerlink\" title=\"并发基础\"></a>并发基础</h1><ol>\n<li>线程表示一条单独的执行流，它有自己的执行计数器，有自己的栈；</li>\n<li>使用线程的方式有两种，继承Thread类以及实现Runnable接口，两种达到的效果是一样的。</li>\n<li>线程具有下列状态：</li>\n</ol>\n<ul>\n<li>NEW：没有调用start方法线程状态；</li>\n<li>TERMINATED：线程运行结束后状态；</li>\n<li>RUNNABLE：调用start后线程执行run方法且没有阻塞时状态；</li>\n<li>BLOCKED、WAITING、TIMED_WAITING：线程被阻塞；</li>\n</ul>\n<ol>\n<li>join方法：可以让调用join方法的线程等待该线程结束；</li>\n<li>竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确；</li>\n</ol>\n<h2 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h2><ol>\n<li>synchronized实例方法实际保护的是同一个对象的方法调用，每次只能被一个线程持有；</li>\n<li>synchronized关键字保护的是对象，针对实例对象保护的是当前，对于静态方法保护的类对象；</li>\n<li>被synchronized关键字保护的对象都维护着1个锁以及等待队列；</li>\n<li>synchronized具有下列特点：</li>\n</ol>\n<ul>\n<li>可重入性：对于同一个执行线程在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用；</li>\n<li>内存可见性：释放锁时会将所有的更改写回内存；但是开销有些过高，可以使用volatile关键字实现相同的效果；</li>\n<li>死锁：尽量避免在持有一个锁的同时再去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁；（使用开发过程中可以使用JDK提供的jstack检测死锁）</li>\n</ul>\n<ol>\n<li>对于同步容器对象，单个操作是线程安全的，迭代却不是线程安全的。（因为在多线程操作中容易对容器产生结构性变化）；</li>\n<li>如果需要在迭代容器的过程中保证线程安全，需要在遍历整个容器的过程中给整个容器对象加锁；</li>\n<li>除11中所写到的方法，推荐使用并发容器类：</li>\n</ol>\n<ul>\n<li>CopyOnWriteArrayList</li>\n<li>ConcurrentHashMap;</li>\n<li>CocurrentLinkedQueue;</li>\n<li>ConcurrentSkipSet;</li>\n</ul>\n<h2 id=\"线程协作机制\"><a href=\"#线程协作机制\" class=\"headerlink\" title=\"线程协作机制\"></a>线程协作机制</h2><ol>\n<li>生产/消费者模式：生产者生产数据并放至消费队列中，消费者从消费队列中消费数据，如果队列为空消费者等待，如果队列满，生产者等待；</li>\n<li>同时开始：在模拟仿真程序中，多个线程同时开始；</li>\n<li>等待结束：主线程将任务拆解成多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕；</li>\n<li>异步结果：将子线程封装为异步调用，子线程在正确返回结果前先返回一个Future对象，通过Future对象可以获得子线程最终的执行结果；</li>\n<li>Map/Reduce操作：也需要使用线程进行操作；</li>\n</ol>\n<h2 id=\"wait-notify机制：\"><a href=\"#wait-notify机制：\" class=\"headerlink\" title=\"wait/notify机制：\"></a>wait/notify机制：</h2><ol>\n<li>每个同步对象都拥有一个锁以及一个等待队列，当调用wait方法，系统会将对象放入等待队列，直到调用notify方法再将其从等待队列中取出。</li>\n<li>设计多线程程序的时候需要想清楚共享变量和条件，这是设计多线程协作的核心。</li>\n<li>以生产者/消费者模式为例：生产者生产产品，并放入缓冲队列；消费者从缓冲队列取出产品进行消费。当生产者生产速度过快导致缓冲队列满了，此时生产者应停止生产。同样，当生产者生产过慢导致缓冲队列空，此时消费者应停止消费。等待生产者生产。</li>\n<li>同时进行：一个主线程以及N个子线程，当主线程发送指令后，子线程开始同时执行；</li>\n<li>各个线程分头行动，给咱达到一个集合点，在集合点需要集齐所有线程交换数据。然后再进行下一步动作。</li>\n</ol>\n<h2 id=\"取消-关闭线程机制\"><a href=\"#取消-关闭线程机制\" class=\"headerlink\" title=\"取消/关闭线程机制\"></a>取消/关闭线程机制</h2><ol>\n<li>停止一个线程的手段主要是中断，中断线程的目的并不是强迫线程终止，而是给线程发送一个停止信号，由线程自行决定中断的时机。本质上依旧是一种协作机制。</li>\n<li>Java中关于中断的方法有如下三种：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isInterrupted</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 返回对应线程的中断标志位是否为true</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">interrupt</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 表示中断对应的线程</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">interrupted</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 返回当前线程的中断标志位是否为true，但还有一个副作用：清空中断标志位。</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>对于以线程提供的服务的应用程序模块而言，应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用库应该调用这些方法而不是直接调用interrupt方法；</li>\n</ol>\n<h1 id=\"并发包基石\"><a href=\"#并发包基石\" class=\"headerlink\" title=\"并发包基石\"></a>并发包基石</h1><h2 id=\"原子变量\"><a href=\"#原子变量\" class=\"headerlink\" title=\"原子变量\"></a>原子变量</h2><ol>\n<li>原子变量即为操作一次性完成，期间不进行线程上下文切换，并且能保证线程安全的原子变量。</li>\n<li>原子变量有AtomicBoolean, AtomicInteger, AtomicLong以及AtomicReference（原子引用类型）类型</li>\n<li>之所以称之为原子变量，是因为其包含一些原子方法实现组合操作的方法</li>\n<li>compareAndSet方法，也就是常说的CAS。如果当前值等于expect，则更新为update，否则不更新。如果更新成功，返回true，否则返回false。</li>\n<li>乐观锁与悲观锁的区别：乐观锁假设每次操作都是不会出现冲突，因此在更新时不管是否出现冲突都会先进行一次更新，即便冲突了只需要再检测一次即可；而别管锁假设每次操作都会产生冲突，因此每次操作前都需要获得锁才能继续操作（例如：synchronized关键字）；</li>\n<li>使用CAS会出现一个ABA问题：假设当前值为A，如果另一个线程将A改为B然后再修改回A，当前线程的CAS操作是无法分辨当前值发生过变化的。解决ABA可以在线程修改值时加上一个时间戳，以此来判断当前线程持有变量的版本；</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Pair</span> <span class=\"hljs-variable\">pair</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pair</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">stamp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>AtomicStampedReference&lt;Pair&gt; pairRef = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicStampedReference</span>&lt;&gt;(pair, stamp);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newStamp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br>pairRef.copareAndSet(pair, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pair</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>), stamp, newStamp);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>总结：CAS是并发包的基础，基于它可以实现高效、乐观、非阻塞式数据结构的算法，它也是并发包中锁、同步工具以及各种容器的基础；</li>\n</ol>\n<h2 id=\"显式锁\"><a href=\"#显式锁\" class=\"headerlink\" title=\"显式锁\"></a>显式锁</h2><ol>\n<li>包括锁Lock，主要实现类为ReentrantLock；读写锁接口ReadWriteLock，主要实现类是ReetrantReadWriteLock;</li>\n<li>显式锁一般有下列方法：</li>\n</ol>\n<ul>\n<li>lock()/unlock()：普通获取锁和释放锁方法；会阻塞直至成功；</li>\n<li>lockInterruptibly()：可以响应中断，如果被其他线程中断会抛出InterruptedException；</li>\n<li>tryLock()：只是尝试获取锁，立即返回；如果获取成功返回true，否则返回false;</li>\n<li>newCondition()：新建一个条件</li>\n</ul>\n<ol>\n<li>相比于synchronized，显式锁支持非阻塞方式获取锁、可以响应中断、可以限时；</li>\n<li>Lock是可重入的（一个线程持有一个锁的前提下可以继续获得该锁）、可以解决竞态条件、可以保证内存的可见性（volatile）</li>\n<li>保证竞态条件的公平性会影响性能，一般情况下我们不作保证；例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">int</span> count;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">incr</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock(); <span class=\"hljs-comment\">// 使用lock获得显式锁</span><br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            count++;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock(); <span class=\"hljs-comment\">// 用完要及时释放掉</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getCount</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用tryLock()可以避免死锁，在持有一个锁获另一个锁而获取不到的时候，可以释放自己已持有的锁，给其他线程获得锁的机会，然后重试获取所有锁；例如下面这样写会产生死锁，使用tryLock()判断可以避免死锁问题：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// Account.java</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Account</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">double</span> money;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Account</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> money)</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.money += money;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> money)</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.money -= money;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getMoney</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> money;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">lock</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">unlock</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <br>    <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">tryLock</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> lock.tryLock();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// AccountMgr.java</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AccountMgr</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NoEnoughMoneyException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Exception</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">transfer</span><span class=\"hljs-params\">(Account from, Account to, <span class=\"hljs-type\">double</span> money)</span><span class=\"hljs-keyword\">throws</span> NoEnoughMoneyException &#123;<br>        from.lock(); <span class=\"hljs-comment\">// from获得锁</span><br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            to.lock(); <span class=\"hljs-comment\">// to获得锁</span><br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-keyword\">if</span> (from.getMoney() &gt;= money) &#123;<br>                    from.reduce(money);<br>                    to.add(money);<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoEnoughMoneyException</span>();<br>                &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                    to.unlock(); <span class=\"hljs-comment\">// to释放锁</span><br>                &#125;<br>            &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                from.unlock(); <span class=\"hljs-comment\">// from释放锁</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Java中封装了一个抽象类AQS用于简化并发工具类的实现。AQS全称（AbstractQueuedSynchronizer）。AQS的实现比较复杂。AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。</li>\n<li>Lock锁的基本原理如下：能获得锁就立即获得，否则加入等待队列，被唤醒后检查自己是否是第一个等待的线程，如果是且能获得锁则返回；否则继续等待，这个过程如果发生了中断，lock会记录中断标志位，但不会提前返回或者是抛出异常；</li>\n<li>保证公平性的结果是整体性能会降低，低的原因不在于检查速度慢，而是会让活跃线程得不到锁，进入等待状态，引起频繁上下文切换，降低整体的效率。需要说明的是即便fair参数为true，ReetrantLock中不带参数的tryLock方法也是不保证公平的。</li>\n<li>synchronized关键字是声明式编程，而Lock是命令式编程，所有内部的细节都需要自己实现。目前JVM对synchronized的优化已经相当的好。因此能用synchronized的地方建议使用synchronized，不能使用synchronized关键字的地方再考虑Lock；</li>\n</ol>\n<h2 id=\"显式条件\"><a href=\"#显式条件\" class=\"headerlink\" title=\"显式条件\"></a>显式条件</h2><ol>\n<li>锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，显式条件和wait/notify相对应。</li>\n<li>实现显式锁的显式条件为Condition类，该类为一个接口，其中包含下列方法：其中绝大部分是响应中断的。即：当出现中断会清空标志位：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">await</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 相当于Object中的wait();</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">awaitUnInterruptibly</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 不响应中断</span><br><span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">awaitNanos</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> nanoTimeout)</span>;<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">await</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> times, TimeUnit unit)</span>;<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">awaitUntil</span><span class=\"hljs-params\">(Date deadline)</span>;<br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">signal</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 相当于notify();</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">signalAll</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 相当于notifyAll();</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>await在进入等待队列后，会释放锁以及CPU，当其他线程将它唤醒后、等待超时后以及发生中断退出后都需要重新获得锁，获取锁后才从await方法中退出。</li>\n<li>使用显式锁的示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WaitThread</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Thread</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">fire</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Condition</span> <span class=\"hljs-variable\">condition</span> <span class=\"hljs-operator\">=</span> lock.newCondition();<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            lock.lock();<br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-keyword\">while</span>(!fire) &#123;<br>                    condition.await();<br>                &#125;<br>            &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>            System.out.println(<span class=\"hljs-string\">&quot;fired&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;<br>            Thread.interrupted();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fire</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.fire = <span class=\"hljs-literal\">true</span>;<br>            condition.signal();<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException&#123;<br>        <span class=\"hljs-type\">WaitThread</span> <span class=\"hljs-variable\">waitThread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WaitThread</span>();<br>        waitThread.start();<br>        Thread.sleep(<span class=\"hljs-number\">1000</span>);<br>        System.out.println(<span class=\"hljs-string\">&quot;fire&quot;</span>);<br>        waitThread.fire();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>await()/signal()方法与显式锁配合使用；而wait()/notify()要与synchronized方法使用，不能使用混淆。否则即便编译器不报错也会出现IllegalStateException方法。</li>\n</ol>\n<h1 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h1><h2 id=\"CopyOnWriteArrayList以及CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArrayList以及CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArrayList以及CopyOnWriteArraySet\"></a>CopyOnWriteArrayList以及CopyOnWriteArraySet</h2><ol>\n<li>特点：线程安全，可以被多个线程并发访问；</li>\n<li>迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；</li>\n<li>以原子方式支持一些复合操作</li>\n<li>写时复制的技术思路为：每次出现修改操作时，都会新建一个数组，复制原数组内容到新数组，在新数组上进行需要的修改，然后一原子方式设置内部数组引用。同理：所有的读操作都是<strong>先拿到当前引用的数组</strong>，然后<strong>直接访问</strong>该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响操作，它依旧访问原数组内容。</li>\n<li>截至当前保证线程安全的思路有三种：</li>\n</ol>\n<ul>\n<li>使用锁：例如synchronized关键字以及ReetrantLock；</li>\n<li>使用CAS：</li>\n<li>写时复制也是一种常见的线程安全保证思路，在操作系统内部的进程管理和内存管理经常会使用到。</li>\n</ul>\n<ol>\n<li>总结：CopyOnWriteList和CopyOnWriteSet适用于读远多于写、集合不太大的场景，它们采用了写时复制技术，这也是计算机中一种重要的思维和技术。</li>\n</ol>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><ol>\n<li>特点：并发安全、支持一些原子复合操作、支持高并发，读完全并行、弱一致性；</li>\n<li>HashMap不是线程安全的，在高并发场景下容易出现死循环以及占满CPU的问题；</li>\n<li>Collections.synchronizedMap()在调用一些更新操作时需要加锁，而ConcurrentHashMap()就不存在这个问题；</li>\n<li>ConcurrentHashMap使用了很复杂的技术实现高并发，但是简要概括下有下列两种：</li>\n</ol>\n<ul>\n<li>分段锁：将读取的数据分为多段，每段都拥有自己的锁，每个段都相当于独立的Hash表。使用分段锁可以有效地提高并发效率。</li>\n<li>读不需要锁：对于写操作需要获取锁，不能并行，但是读操作可以并行。写的同时也可以读。</li>\n</ul>\n<ol>\n<li>弱一致性：ConcurrentHashMap在创建完迭代器后，会按照哈希表中反映的结构迭代元素。如果结构的变化发生在已经迭代过的元素上，则结构性变化不会反映出来。反之，若结构变化发生在未发生改变的元素上，结构变化就可以被反映出来。这种现象就称之为弱一致性；</li>\n</ol>\n<h2 id=\"基于SkipList的Map和Set\"><a href=\"#基于SkipList的Map和Set\" class=\"headerlink\" title=\"基于SkipList的Map和Set\"></a>基于SkipList的Map和Set</h2><ol>\n<li>特点：所有的操作都可以并行，包括读和写；</li>\n<li>与TreeMap/TreeSet一样，可以实现按键的自然排序；使用方法如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> CurrentSkipMapDemo &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentSkipMap</span>&lt;&gt;(Collections.reverseOrder());<br>        map.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>        map.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>        map.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>        System.out.println(map.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>SkipMap和SkipSet是基于跳表实现，跳表是基于链表实现的。在链表的基础上增加了多层索引结构。跳表实际上一个类似于二分查找的数据结构。因此有了这样的数据结构就可以更好地实现，关于其复杂度就不再赘述。</li>\n</ol>\n<h2 id=\"并发队列\"><a href=\"#并发队列\" class=\"headerlink\" title=\"并发队列\"></a>并发队列</h2><ol>\n<li>Java中的并发队列一般包括下列几种：</li>\n</ol>\n<ul>\n<li>无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque</li>\n<li>普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque；</li>\n<li>优先级阻塞队列：PriorityBlockingQueue；</li>\n<li>延时阻塞队列：DelayQueue；</li>\n<li>其他阻塞队列：SynchronousQueue和LinkedTransferQueue；</li>\n</ul>\n<ol>\n<li>这里的无锁指的是不使用锁，使用CAS方式实现；</li>\n<li>普通阻塞队列适用于生产者/消费者模式；</li>\n<li>优先级队列是按照优先级出队列的，优先级高的先出</li>\n<li>延时阻塞队列可以用于定时任务，按照元素的延时时间出队，其特殊点在于只有当元素的延时过期之后才能从队列中被拿走</li>\n<li>SynchronousQueue没有存储空间，适用于两进程之间传递信息；LinkedTransferQueue适用于一些消息传递类型的应用中。</li>\n</ol>\n<h1 id=\"异步执行任务\"><a href=\"#异步执行任务\" class=\"headerlink\" title=\"异步执行任务\"></a>异步执行任务</h1><h2 id=\"执行接口\"><a href=\"#执行接口\" class=\"headerlink\" title=\"执行接口\"></a>执行接口</h2><ul>\n<li>Runnable（没有返回结果）和Callable（有返回结果）：表示要执行的异步任务</li>\n<li>Executor和ExecutorService：表示执行服务</li>\n<li>Future：表示异步任务的结果</li>\n</ul>\n<h2 id=\"Future接口的使用\"><a href=\"#Future接口的使用\" class=\"headerlink\" title=\"Future接口的使用\"></a>Future接口的使用</h2><ol>\n<li>示例代码</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Callable</span>&lt;Integer&gt; &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Integer <span class=\"hljs-title function_\">call</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sleepSeconds</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>().nextInt(<span class=\"hljs-number\">1000</span>);<br>            Thread.sleep(sleepSeconds);<br>            <span class=\"hljs-keyword\">return</span> sleepSeconds;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException&#123;<br>        <span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newSingleThreadExecutor();<br>        Future&lt;Integer&gt; future = executor.submit(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>());<br>        Thread.sleep(<span class=\"hljs-number\">100</span>);<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            System.out.println(future.get());<br>        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>实现原理：ExecutorService的主要实现类是ThreadPoolExecutor，是基于线程池实现的。</li>\n<li>总结：并发包执行任务执行服务体现了并发异步开发中的“关注点分离”的思想，使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。</li>\n</ol>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><ol>\n<li>线程池主要有任务队列以及工作者线程组成；</li>\n<li>线程池有下列优点：</li>\n</ol>\n<ul>\n<li>可以重用线程，避免线程创建的开销；</li>\n<li>任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争；</li>\n</ul>\n<ol>\n<li>Java中最常用的线程池类是ThreadPoolExecutor；其中最重要的4个参数是：corePoolSize（核心线程个数）,maximumPoolSize（最大线程个数）keepAliveTime和unit（空闲线程存活时间）</li>\n<li>ThreadPoolExecutor中的队列均为阻塞队列，分为有界和无界两种类型。需要说明的是如果使用了无界队列，线程个数最多只能达到corePoolSize，达到corePoolSize之后新的任务总会排队，参数maximumPoolSize也就没有意义了。</li>\n<li>当队列有界并且maximumPoolSize有限时，只要队列排满，新任务总会被拒绝，因此也会出发任务拒绝策略。不过任务拒绝策略是可以自定义的。</li>\n</ol>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy：默认方式，抛出异常</li>\n<li>ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛出异常也不执行</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：扔掉等待时间最长的任务，然后自己排队</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，不交给线程池中的线程执行</li>\n</ul>\n<h2 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h2><ol>\n<li>TimerTask表示一个定时任务，具体的定时任务需要继承该抽象类，实现run方法。示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicTimer</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DelayTask</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">TimerTask</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;delayed task&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br>        <span class=\"hljs-type\">Timer</span> <span class=\"hljs-variable\">timer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Timer</span>();<br>        timer.schedule(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DelayTask</span>(), <span class=\"hljs-number\">1000</span>);<br>        Thread.sleep(<span class=\"hljs-number\">2000</span>);<br>        timer.cancel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Timer内部主要是由任务队列和Timer线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。一个Timer对象只有一个Timer线程。</li>\n<li>对于固定延时任务，延时相对的是任务执行前的当前时间；对于固定频率任务，延时相对的是最优先计划；</li>\n<li>在执行一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的定时任务都会被取消。因此，如果希望各个定时任务不互相干扰，一定要在run方法内捕获异常。</li>\n<li>并发包中使用ScheduledExecutorService来实现定时任务，其为一个接口，多线程执行定时任务的示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ScheduledFixedDelay</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LongRunningTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;&#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FixedDelayTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ScheduledExecutorService</span> <span class=\"hljs-variable\">timer</span> <span class=\"hljs-operator\">=</span> Executors.newScheduledThreadPool(<span class=\"hljs-number\">10</span>);<br>        timer.schedule(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LongRunningTask</span>(), <span class=\"hljs-number\">10</span>, TimeUnit.MILLISECONDS);<br>        timer.scheduleWithFixedDelay(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FixedDelayTask</span>(), <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1000</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>ScheduledExecutorService的实现原理如下：</li>\n</ol>\n<ul>\n<li>实现背后是线程池，可以有多个线程执行任务；</li>\n<li>在任务执行后再设置下次执行的时间，对于固定延时的任务更合理；</li>\n<li>任务执行线程会捕获任务执行过程中的所有异常。一个定时任务的异常不会影响其他定时任务；</li>\n</ul>\n<h1 id=\"同步以及协作工具类\"><a href=\"#同步以及协作工具类\" class=\"headerlink\" title=\"同步以及协作工具类\"></a>同步以及协作工具类</h1><ol>\n<li>同步工具类包括：</li>\n</ol>\n<ul>\n<li>ReetrantReadWriteLock：读写显式锁</li>\n<li>Semaphore：信号量</li>\n<li>CountDownLatch：倒计时门栓</li>\n<li>CyclicBarrier：循环栅栏</li>\n<li>ThreadLocal：线程本地 2.ReetrantReadWriteLock读写显式锁：只有“读-读”可以并行，“读-写”和“写-写”都是不可以的。只有一个线程可以进行写操作。是基于CAS实现的；</li>\n</ul>\n<ol>\n<li>Semaphore：限制并发数量，是基于AQS实现的；</li>\n<li>CountDownLatch：默认是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过。门栓是一次性的，打开了就不能再关上了。</li>\n<li>CyclicBarrier：所有线程在到达该栅栏后都需要等待其他线程，等待所有线程都到达后在一起通过。它是循环的，可以用重复的同步。</li>\n<li>ThreadLocal：每个线程都有同一个变量的独有拷贝，也就是说每个线程都拥有一个属于自己的独立值。一般来说ThreadLocal都定义为静态类型便于引用</li>\n</ol>\n<h1 id=\"并发总结\"><a href=\"#并发总结\" class=\"headerlink\" title=\"并发总结\"></a>并发总结</h1>","site":{"data":{}},"wordcount":11172,"excerpt":"","more":"<h1 id=\"并发基础\"><a href=\"#并发基础\" class=\"headerlink\" title=\"并发基础\"></a>并发基础</h1><ol>\n<li>线程表示一条单独的执行流，它有自己的执行计数器，有自己的栈；</li>\n<li>使用线程的方式有两种，继承Thread类以及实现Runnable接口，两种达到的效果是一样的。</li>\n<li>线程具有下列状态：</li>\n</ol>\n<ul>\n<li>NEW：没有调用start方法线程状态；</li>\n<li>TERMINATED：线程运行结束后状态；</li>\n<li>RUNNABLE：调用start后线程执行run方法且没有阻塞时状态；</li>\n<li>BLOCKED、WAITING、TIMED_WAITING：线程被阻塞；</li>\n</ul>\n<ol>\n<li>join方法：可以让调用join方法的线程等待该线程结束；</li>\n<li>竞态条件：当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，可能正确也可能不正确；</li>\n</ol>\n<h2 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h2><ol>\n<li>synchronized实例方法实际保护的是同一个对象的方法调用，每次只能被一个线程持有；</li>\n<li>synchronized关键字保护的是对象，针对实例对象保护的是当前，对于静态方法保护的类对象；</li>\n<li>被synchronized关键字保护的对象都维护着1个锁以及等待队列；</li>\n<li>synchronized具有下列特点：</li>\n</ol>\n<ul>\n<li>可重入性：对于同一个执行线程在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用；</li>\n<li>内存可见性：释放锁时会将所有的更改写回内存；但是开销有些过高，可以使用volatile关键字实现相同的效果；</li>\n<li>死锁：尽量避免在持有一个锁的同时再去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁；（使用开发过程中可以使用JDK提供的jstack检测死锁）</li>\n</ul>\n<ol>\n<li>对于同步容器对象，单个操作是线程安全的，迭代却不是线程安全的。（因为在多线程操作中容易对容器产生结构性变化）；</li>\n<li>如果需要在迭代容器的过程中保证线程安全，需要在遍历整个容器的过程中给整个容器对象加锁；</li>\n<li>除11中所写到的方法，推荐使用并发容器类：</li>\n</ol>\n<ul>\n<li>CopyOnWriteArrayList</li>\n<li>ConcurrentHashMap;</li>\n<li>CocurrentLinkedQueue;</li>\n<li>ConcurrentSkipSet;</li>\n</ul>\n<h2 id=\"线程协作机制\"><a href=\"#线程协作机制\" class=\"headerlink\" title=\"线程协作机制\"></a>线程协作机制</h2><ol>\n<li>生产/消费者模式：生产者生产数据并放至消费队列中，消费者从消费队列中消费数据，如果队列为空消费者等待，如果队列满，生产者等待；</li>\n<li>同时开始：在模拟仿真程序中，多个线程同时开始；</li>\n<li>等待结束：主线程将任务拆解成多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕；</li>\n<li>异步结果：将子线程封装为异步调用，子线程在正确返回结果前先返回一个Future对象，通过Future对象可以获得子线程最终的执行结果；</li>\n<li>Map/Reduce操作：也需要使用线程进行操作；</li>\n</ol>\n<h2 id=\"wait-notify机制：\"><a href=\"#wait-notify机制：\" class=\"headerlink\" title=\"wait/notify机制：\"></a>wait/notify机制：</h2><ol>\n<li>每个同步对象都拥有一个锁以及一个等待队列，当调用wait方法，系统会将对象放入等待队列，直到调用notify方法再将其从等待队列中取出。</li>\n<li>设计多线程程序的时候需要想清楚共享变量和条件，这是设计多线程协作的核心。</li>\n<li>以生产者/消费者模式为例：生产者生产产品，并放入缓冲队列；消费者从缓冲队列取出产品进行消费。当生产者生产速度过快导致缓冲队列满了，此时生产者应停止生产。同样，当生产者生产过慢导致缓冲队列空，此时消费者应停止消费。等待生产者生产。</li>\n<li>同时进行：一个主线程以及N个子线程，当主线程发送指令后，子线程开始同时执行；</li>\n<li>各个线程分头行动，给咱达到一个集合点，在集合点需要集齐所有线程交换数据。然后再进行下一步动作。</li>\n</ol>\n<h2 id=\"取消-关闭线程机制\"><a href=\"#取消-关闭线程机制\" class=\"headerlink\" title=\"取消/关闭线程机制\"></a>取消/关闭线程机制</h2><ol>\n<li>停止一个线程的手段主要是中断，中断线程的目的并不是强迫线程终止，而是给线程发送一个停止信号，由线程自行决定中断的时机。本质上依旧是一种协作机制。</li>\n<li>Java中关于中断的方法有如下三种：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isInterrupted</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 返回对应线程的中断标志位是否为true</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">interrupt</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 表示中断对应的线程</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">interrupted</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 返回当前线程的中断标志位是否为true，但还有一个副作用：清空中断标志位。</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>对于以线程提供的服务的应用程序模块而言，应该封装取消/关闭操作，提供单独的取消/关闭方法给调用者，外部调用库应该调用这些方法而不是直接调用interrupt方法；</li>\n</ol>\n<h1 id=\"并发包基石\"><a href=\"#并发包基石\" class=\"headerlink\" title=\"并发包基石\"></a>并发包基石</h1><h2 id=\"原子变量\"><a href=\"#原子变量\" class=\"headerlink\" title=\"原子变量\"></a>原子变量</h2><ol>\n<li>原子变量即为操作一次性完成，期间不进行线程上下文切换，并且能保证线程安全的原子变量。</li>\n<li>原子变量有AtomicBoolean, AtomicInteger, AtomicLong以及AtomicReference（原子引用类型）类型</li>\n<li>之所以称之为原子变量，是因为其包含一些原子方法实现组合操作的方法</li>\n<li>compareAndSet方法，也就是常说的CAS。如果当前值等于expect，则更新为update，否则不更新。如果更新成功，返回true，否则返回false。</li>\n<li>乐观锁与悲观锁的区别：乐观锁假设每次操作都是不会出现冲突，因此在更新时不管是否出现冲突都会先进行一次更新，即便冲突了只需要再检测一次即可；而别管锁假设每次操作都会产生冲突，因此每次操作前都需要获得锁才能继续操作（例如：synchronized关键字）；</li>\n<li>使用CAS会出现一个ABA问题：假设当前值为A，如果另一个线程将A改为B然后再修改回A，当前线程的CAS操作是无法分辨当前值发生过变化的。解决ABA可以在线程修改值时加上一个时间戳，以此来判断当前线程持有变量的版本；</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">Pair</span> <span class=\"hljs-variable\">pair</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pair</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">stamp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br>AtomicStampedReference&lt;Pair&gt; pairRef = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicStampedReference</span>&lt;&gt;(pair, stamp);<br><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newStamp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br>pairRef.copareAndSet(pair, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pair</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>), stamp, newStamp);<br></code></pre></td></tr></table></figure>\n<ol>\n<li>总结：CAS是并发包的基础，基于它可以实现高效、乐观、非阻塞式数据结构的算法，它也是并发包中锁、同步工具以及各种容器的基础；</li>\n</ol>\n<h2 id=\"显式锁\"><a href=\"#显式锁\" class=\"headerlink\" title=\"显式锁\"></a>显式锁</h2><ol>\n<li>包括锁Lock，主要实现类为ReentrantLock；读写锁接口ReadWriteLock，主要实现类是ReetrantReadWriteLock;</li>\n<li>显式锁一般有下列方法：</li>\n</ol>\n<ul>\n<li>lock()/unlock()：普通获取锁和释放锁方法；会阻塞直至成功；</li>\n<li>lockInterruptibly()：可以响应中断，如果被其他线程中断会抛出InterruptedException；</li>\n<li>tryLock()：只是尝试获取锁，立即返回；如果获取成功返回true，否则返回false;</li>\n<li>newCondition()：新建一个条件</li>\n</ul>\n<ol>\n<li>相比于synchronized，显式锁支持非阻塞方式获取锁、可以响应中断、可以限时；</li>\n<li>Lock是可重入的（一个线程持有一个锁的前提下可以继续获得该锁）、可以解决竞态条件、可以保证内存的可见性（volatile）</li>\n<li>保证竞态条件的公平性会影响性能，一般情况下我们不作保证；例如：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">int</span> count;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">incr</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock(); <span class=\"hljs-comment\">// 使用lock获得显式锁</span><br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            count++;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock(); <span class=\"hljs-comment\">// 用完要及时释放掉</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getCount</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>使用tryLock()可以避免死锁，在持有一个锁获另一个锁而获取不到的时候，可以释放自己已持有的锁，给其他线程获得锁的机会，然后重试获取所有锁；例如下面这样写会产生死锁，使用tryLock()判断可以避免死锁问题：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// Account.java</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Account</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">double</span> money;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Account</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> money)</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.money += money;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">reduce</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> money)</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.money -= money;<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">getMoney</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> money;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">lock</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock();<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">unlock</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <br>    <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">tryLock</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> lock.tryLock();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// AccountMgr.java</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AccountMgr</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NoEnoughMoneyException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Exception</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">transfer</span><span class=\"hljs-params\">(Account from, Account to, <span class=\"hljs-type\">double</span> money)</span><span class=\"hljs-keyword\">throws</span> NoEnoughMoneyException &#123;<br>        from.lock(); <span class=\"hljs-comment\">// from获得锁</span><br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            to.lock(); <span class=\"hljs-comment\">// to获得锁</span><br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-keyword\">if</span> (from.getMoney() &gt;= money) &#123;<br>                    from.reduce(money);<br>                    to.add(money);<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoEnoughMoneyException</span>();<br>                &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                    to.unlock(); <span class=\"hljs-comment\">// to释放锁</span><br>                &#125;<br>            &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                from.unlock(); <span class=\"hljs-comment\">// from释放锁</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Java中封装了一个抽象类AQS用于简化并发工具类的实现。AQS全称（AbstractQueuedSynchronizer）。AQS的实现比较复杂。AQS内部维护了一个等待队列，借助CAS方法实现了无阻塞算法进行更新。</li>\n<li>Lock锁的基本原理如下：能获得锁就立即获得，否则加入等待队列，被唤醒后检查自己是否是第一个等待的线程，如果是且能获得锁则返回；否则继续等待，这个过程如果发生了中断，lock会记录中断标志位，但不会提前返回或者是抛出异常；</li>\n<li>保证公平性的结果是整体性能会降低，低的原因不在于检查速度慢，而是会让活跃线程得不到锁，进入等待状态，引起频繁上下文切换，降低整体的效率。需要说明的是即便fair参数为true，ReetrantLock中不带参数的tryLock方法也是不保证公平的。</li>\n<li>synchronized关键字是声明式编程，而Lock是命令式编程，所有内部的细节都需要自己实现。目前JVM对synchronized的优化已经相当的好。因此能用synchronized的地方建议使用synchronized，不能使用synchronized关键字的地方再考虑Lock；</li>\n</ol>\n<h2 id=\"显式条件\"><a href=\"#显式条件\" class=\"headerlink\" title=\"显式条件\"></a>显式条件</h2><ol>\n<li>锁用于解决竞态条件问题，条件是线程间的协作机制。显式锁与synchronized相对应，显式条件和wait/notify相对应。</li>\n<li>实现显式锁的显式条件为Condition类，该类为一个接口，其中包含下列方法：其中绝大部分是响应中断的。即：当出现中断会清空标志位：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">await</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 相当于Object中的wait();</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">awaitUnInterruptibly</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 不响应中断</span><br><span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">awaitNanos</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> nanoTimeout)</span>;<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">await</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> times, TimeUnit unit)</span>;<br><span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">awaitUntil</span><span class=\"hljs-params\">(Date deadline)</span>;<br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">signal</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 相当于notify();</span><br><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">signalAll</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// 相当于notifyAll();</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>await在进入等待队列后，会释放锁以及CPU，当其他线程将它唤醒后、等待超时后以及发生中断退出后都需要重新获得锁，获取锁后才从await方法中退出。</li>\n<li>使用显式锁的示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WaitThread</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Thread</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">fire</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReetrantLock</span>();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Condition</span> <span class=\"hljs-variable\">condition</span> <span class=\"hljs-operator\">=</span> lock.newCondition();<br>    <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            lock.lock();<br>            <span class=\"hljs-keyword\">try</span> &#123;<br>                <span class=\"hljs-keyword\">while</span>(!fire) &#123;<br>                    condition.await();<br>                &#125;<br>            &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>            System.out.println(<span class=\"hljs-string\">&quot;fired&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;<br>            Thread.interrupted();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fire</span><span class=\"hljs-params\">()</span> &#123;<br>        lock.lock();<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-built_in\">this</span>.fire = <span class=\"hljs-literal\">true</span>;<br>            condition.signal();<br>        &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException&#123;<br>        <span class=\"hljs-type\">WaitThread</span> <span class=\"hljs-variable\">waitThread</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WaitThread</span>();<br>        waitThread.start();<br>        Thread.sleep(<span class=\"hljs-number\">1000</span>);<br>        System.out.println(<span class=\"hljs-string\">&quot;fire&quot;</span>);<br>        waitThread.fire();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>await()/signal()方法与显式锁配合使用；而wait()/notify()要与synchronized方法使用，不能使用混淆。否则即便编译器不报错也会出现IllegalStateException方法。</li>\n</ol>\n<h1 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h1><h2 id=\"CopyOnWriteArrayList以及CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArrayList以及CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArrayList以及CopyOnWriteArraySet\"></a>CopyOnWriteArrayList以及CopyOnWriteArraySet</h2><ol>\n<li>特点：线程安全，可以被多个线程并发访问；</li>\n<li>迭代器不支持修改操作，但也不会抛出ConcurrentModificationException；</li>\n<li>以原子方式支持一些复合操作</li>\n<li>写时复制的技术思路为：每次出现修改操作时，都会新建一个数组，复制原数组内容到新数组，在新数组上进行需要的修改，然后一原子方式设置内部数组引用。同理：所有的读操作都是<strong>先拿到当前引用的数组</strong>，然后<strong>直接访问</strong>该数组。在读的过程中，可能内部的数组引用已经被修改了，但不会影响操作，它依旧访问原数组内容。</li>\n<li>截至当前保证线程安全的思路有三种：</li>\n</ol>\n<ul>\n<li>使用锁：例如synchronized关键字以及ReetrantLock；</li>\n<li>使用CAS：</li>\n<li>写时复制也是一种常见的线程安全保证思路，在操作系统内部的进程管理和内存管理经常会使用到。</li>\n</ul>\n<ol>\n<li>总结：CopyOnWriteList和CopyOnWriteSet适用于读远多于写、集合不太大的场景，它们采用了写时复制技术，这也是计算机中一种重要的思维和技术。</li>\n</ol>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><ol>\n<li>特点：并发安全、支持一些原子复合操作、支持高并发，读完全并行、弱一致性；</li>\n<li>HashMap不是线程安全的，在高并发场景下容易出现死循环以及占满CPU的问题；</li>\n<li>Collections.synchronizedMap()在调用一些更新操作时需要加锁，而ConcurrentHashMap()就不存在这个问题；</li>\n<li>ConcurrentHashMap使用了很复杂的技术实现高并发，但是简要概括下有下列两种：</li>\n</ol>\n<ul>\n<li>分段锁：将读取的数据分为多段，每段都拥有自己的锁，每个段都相当于独立的Hash表。使用分段锁可以有效地提高并发效率。</li>\n<li>读不需要锁：对于写操作需要获取锁，不能并行，但是读操作可以并行。写的同时也可以读。</li>\n</ul>\n<ol>\n<li>弱一致性：ConcurrentHashMap在创建完迭代器后，会按照哈希表中反映的结构迭代元素。如果结构的变化发生在已经迭代过的元素上，则结构性变化不会反映出来。反之，若结构变化发生在未发生改变的元素上，结构变化就可以被反映出来。这种现象就称之为弱一致性；</li>\n</ol>\n<h2 id=\"基于SkipList的Map和Set\"><a href=\"#基于SkipList的Map和Set\" class=\"headerlink\" title=\"基于SkipList的Map和Set\"></a>基于SkipList的Map和Set</h2><ol>\n<li>特点：所有的操作都可以并行，包括读和写；</li>\n<li>与TreeMap/TreeSet一样，可以实现按键的自然排序；使用方法如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> CurrentSkipMapDemo &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentSkipMap</span>&lt;&gt;(Collections.reverseOrder());<br>        map.put(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;abstract&quot;</span>);<br>        map.put(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;basic&quot;</span>);<br>        map.put(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;call&quot;</span>);<br>        System.out.println(map.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>SkipMap和SkipSet是基于跳表实现，跳表是基于链表实现的。在链表的基础上增加了多层索引结构。跳表实际上一个类似于二分查找的数据结构。因此有了这样的数据结构就可以更好地实现，关于其复杂度就不再赘述。</li>\n</ol>\n<h2 id=\"并发队列\"><a href=\"#并发队列\" class=\"headerlink\" title=\"并发队列\"></a>并发队列</h2><ol>\n<li>Java中的并发队列一般包括下列几种：</li>\n</ol>\n<ul>\n<li>无锁非阻塞并发队列：ConcurrentLinkedQueue和ConcurrentLinkedDeque</li>\n<li>普通阻塞队列：基于数组的ArrayBlockingQueue，基于链表的LinkedBlockingQueue和LinkedBlockingDeque；</li>\n<li>优先级阻塞队列：PriorityBlockingQueue；</li>\n<li>延时阻塞队列：DelayQueue；</li>\n<li>其他阻塞队列：SynchronousQueue和LinkedTransferQueue；</li>\n</ul>\n<ol>\n<li>这里的无锁指的是不使用锁，使用CAS方式实现；</li>\n<li>普通阻塞队列适用于生产者/消费者模式；</li>\n<li>优先级队列是按照优先级出队列的，优先级高的先出</li>\n<li>延时阻塞队列可以用于定时任务，按照元素的延时时间出队，其特殊点在于只有当元素的延时过期之后才能从队列中被拿走</li>\n<li>SynchronousQueue没有存储空间，适用于两进程之间传递信息；LinkedTransferQueue适用于一些消息传递类型的应用中。</li>\n</ol>\n<h1 id=\"异步执行任务\"><a href=\"#异步执行任务\" class=\"headerlink\" title=\"异步执行任务\"></a>异步执行任务</h1><h2 id=\"执行接口\"><a href=\"#执行接口\" class=\"headerlink\" title=\"执行接口\"></a>执行接口</h2><ul>\n<li>Runnable（没有返回结果）和Callable（有返回结果）：表示要执行的异步任务</li>\n<li>Executor和ExecutorService：表示执行服务</li>\n<li>Future：表示异步任务的结果</li>\n</ul>\n<h2 id=\"Future接口的使用\"><a href=\"#Future接口的使用\" class=\"headerlink\" title=\"Future接口的使用\"></a>Future接口的使用</h2><ol>\n<li>示例代码</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicDemo</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Callable</span>&lt;Integer&gt; &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> Integer <span class=\"hljs-title function_\">call</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception &#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sleepSeconds</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>().nextInt(<span class=\"hljs-number\">1000</span>);<br>            Thread.sleep(sleepSeconds);<br>            <span class=\"hljs-keyword\">return</span> sleepSeconds;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException&#123;<br>        <span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newSingleThreadExecutor();<br>        Future&lt;Integer&gt; future = executor.submit(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Task</span>());<br>        Thread.sleep(<span class=\"hljs-number\">100</span>);<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            System.out.println(future.get());<br>        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>实现原理：ExecutorService的主要实现类是ThreadPoolExecutor，是基于线程池实现的。</li>\n<li>总结：并发包执行任务执行服务体现了并发异步开发中的“关注点分离”的思想，使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。</li>\n</ol>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><ol>\n<li>线程池主要有任务队列以及工作者线程组成；</li>\n<li>线程池有下列优点：</li>\n</ol>\n<ul>\n<li>可以重用线程，避免线程创建的开销；</li>\n<li>任务过多时，通过排队避免创建过多线程，减少系统资源消耗和竞争；</li>\n</ul>\n<ol>\n<li>Java中最常用的线程池类是ThreadPoolExecutor；其中最重要的4个参数是：corePoolSize（核心线程个数）,maximumPoolSize（最大线程个数）keepAliveTime和unit（空闲线程存活时间）</li>\n<li>ThreadPoolExecutor中的队列均为阻塞队列，分为有界和无界两种类型。需要说明的是如果使用了无界队列，线程个数最多只能达到corePoolSize，达到corePoolSize之后新的任务总会排队，参数maximumPoolSize也就没有意义了。</li>\n<li>当队列有界并且maximumPoolSize有限时，只要队列排满，新任务总会被拒绝，因此也会出发任务拒绝策略。不过任务拒绝策略是可以自定义的。</li>\n</ol>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy：默认方式，抛出异常</li>\n<li>ThreadPoolExecutor.DiscardPolicy：静默处理，忽略新任务，不抛出异常也不执行</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：扔掉等待时间最长的任务，然后自己排队</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：在任务提交者线程中执行任务，不交给线程池中的线程执行</li>\n</ul>\n<h2 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h2><ol>\n<li>TimerTask表示一个定时任务，具体的定时任务需要继承该抽象类，实现run方法。示例：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicTimer</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DelayTask</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">TimerTask</span> &#123;<br>        <span class=\"hljs-meta\">@Override</span><br>        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">()</span> &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;delayed task&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br>        <span class=\"hljs-type\">Timer</span> <span class=\"hljs-variable\">timer</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Timer</span>();<br>        timer.schedule(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DelayTask</span>(), <span class=\"hljs-number\">1000</span>);<br>        Thread.sleep(<span class=\"hljs-number\">2000</span>);<br>        timer.cancel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Timer内部主要是由任务队列和Timer线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。一个Timer对象只有一个Timer线程。</li>\n<li>对于固定延时任务，延时相对的是任务执行前的当前时间；对于固定频率任务，延时相对的是最优先计划；</li>\n<li>在执行一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的定时任务都会被取消。因此，如果希望各个定时任务不互相干扰，一定要在run方法内捕获异常。</li>\n<li>并发包中使用ScheduledExecutorService来实现定时任务，其为一个接口，多线程执行定时任务的示例如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ScheduledFixedDelay</span> &#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LongRunningTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;&#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FixedDelayTask</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Runnable</span> &#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        <span class=\"hljs-type\">ScheduledExecutorService</span> <span class=\"hljs-variable\">timer</span> <span class=\"hljs-operator\">=</span> Executors.newScheduledThreadPool(<span class=\"hljs-number\">10</span>);<br>        timer.schedule(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LongRunningTask</span>(), <span class=\"hljs-number\">10</span>, TimeUnit.MILLISECONDS);<br>        timer.scheduleWithFixedDelay(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FixedDelayTask</span>(), <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1000</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>ScheduledExecutorService的实现原理如下：</li>\n</ol>\n<ul>\n<li>实现背后是线程池，可以有多个线程执行任务；</li>\n<li>在任务执行后再设置下次执行的时间，对于固定延时的任务更合理；</li>\n<li>任务执行线程会捕获任务执行过程中的所有异常。一个定时任务的异常不会影响其他定时任务；</li>\n</ul>\n<h1 id=\"同步以及协作工具类\"><a href=\"#同步以及协作工具类\" class=\"headerlink\" title=\"同步以及协作工具类\"></a>同步以及协作工具类</h1><ol>\n<li>同步工具类包括：</li>\n</ol>\n<ul>\n<li>ReetrantReadWriteLock：读写显式锁</li>\n<li>Semaphore：信号量</li>\n<li>CountDownLatch：倒计时门栓</li>\n<li>CyclicBarrier：循环栅栏</li>\n<li>ThreadLocal：线程本地 2.ReetrantReadWriteLock读写显式锁：只有“读-读”可以并行，“读-写”和“写-写”都是不可以的。只有一个线程可以进行写操作。是基于CAS实现的；</li>\n</ul>\n<ol>\n<li>Semaphore：限制并发数量，是基于AQS实现的；</li>\n<li>CountDownLatch：默认是关闭的，所有希望通过该门的线程都需要等待，然后开始倒计时，倒计时变为0后，门栓打开，等待的所有线程都可以通过。门栓是一次性的，打开了就不能再关上了。</li>\n<li>CyclicBarrier：所有线程在到达该栅栏后都需要等待其他线程，等待所有线程都到达后在一起通过。它是循环的，可以用重复的同步。</li>\n<li>ThreadLocal：每个线程都有同一个变量的独有拷贝，也就是说每个线程都拥有一个属于自己的独立值。一般来说ThreadLocal都定义为静态类型便于引用</li>\n</ol>\n<h1 id=\"并发总结\"><a href=\"#并发总结\" class=\"headerlink\" title=\"并发总结\"></a>并发总结</h1>"},{"title":"初识Spring Cloud","date":"2022-02-19T03:21:30.000Z","updated":"2022-02-19T03:21:30.000Z","_content":"\n# Spring Cloud是什么？\n\n一个基于Spring Boot实现的云应用开发工具，为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话以及集群状态管理等操作提供了一种简单的开发方式。\n\n# 微服务架构\n\n“微服务架构”这几年非常火热，以至于关注微服务架构相关的开源产品被反复提及（比如：Netflix和Dubbo），Spring Cloud也因Spring社区强大的知名度和影响力被广大架构师和开发者备受关注。\n\n简单来说：微服务架构是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每隔服务都能独立部署、独立维护、独立扩展，服务之间通过诸如RESTful API的方式相互调用。\n\n# 服务治理\n\n服务治理就是提供了微服务架构中各个微服务实例的快速上线或下线且保持各服务能正常通信的能力方案总称。\n\n## 服务治理可以带来什么好处呢\n\n+ **更高的可用性**\n\n  支持动态的服务实例集群环境，任何服务实例都可以随时上线下线。并且当一个微服务实例不可用时，治理服务器可以将请求转发其他服务提供者，当新服务上线时，也能够快速分担服务调用请求；\n\n  \n\n+ **负载均衡**\n\n  提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；\n\n  \n\n+ **提升应用弹性**\n\n  服务治理客户端定时从服务治理服务器中复制一份实例信息缓存到本地，即使当服务治理服务器不可用时，服务消费者也可以使用本地的缓存去访问相应的服务，而不至于中断服务。通过这种机制，极大提高应用的弹性；\n\n  \n\n+ **高可用性集群**\n\n  可以构建服务治理集群，通过互相注册机制，将每隔治理服务器所管辖的服务信息列表进行交换，使服务治理拥有更高的可用性；\n\n# Spring Cloud的基本使用\n\n从上面对于微服务的治理和定义，我们搭建一个最基础和简单的微服务架构：\n\n+ 服务注册中心\n+ 服务提供方\n\n这里我们使用Spring Cloud Eureka的基础服务来搭建，下面按照操作手册来做一下看看。\n\n## 创建服务发现中心\n\n使用IntelliJ IDEA创建一个Spring Boot项目，依赖管理工具选择Gradle。你可以使用Spring Initializer来生成项目：\n\n<img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-143445@2x.png\" alt=\"s\" style=\"zoom:50%;\" />\n\n生成项目后，我们找到项目目录的启动入口文件\n\n```java\n// 新增EnableEurekaServer注解，将该工程标识为一个服务注册中心\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n\n}\n```\n\n找到`application.properties`文件，将其更改为`application.yml`（只是习惯用YML文件），修改一下Eureka Server的配置如下：\n\n```yaml\n# 服务注册中心的名称\nspring:\n  application:\n    name: eureka-server\n\n# 服务注册中心监听的端口\nserver:\n  port: 1001\n\n# 暂时禁用服务端注册客户端的行为\neureka:\n  instance:\n    hostname: 127.0.0.1\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n到此，服务注册中心搭建完成，运行这个项目并且打开浏览器输入`http://localhost:1001/`就可以看到服务注册中心的基本页面了：\n\n![](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-144301@2x.png)\n\n## 创建服务提供方\n\n如法炮制，我们通过Spring Initializer再创建一个Spring Boot项目，名为eureka-client，对应的gradle依赖如下：\n\n主要提供的是：\n\n+ spring-cloud-starter-netflix-eureka-client\n+ spring-boot-starter-web\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.6.3'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'com.hhp.registry'\nversion = '0.0.1'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\next {\n    set('springCloudVersion', \"2021.0.1\")\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n\n```\n\n我们新建一个Rest接口：\n\n> 需要注意的是：这里的DiscoveryClient会出现Netflix和Spring Cloud的，选择Spring Cloud的官方依赖\n\n```java\n@RestController\npublic class DcController {\n\n    // 选择Spring Cloud的依赖包导入\n    @Resource\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping(\"/dc\")\n    public String dc() {\n        String services = \"Service: \" + discoveryClient.getServices();\n        System.out.println(services);\n        return services;\n    }\n}\n```\n\n回到eureka-client的启动类，我们加上`@EnableDiscoveryClient`注解\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaClientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n```\n\n打开eureka-client的`application.yml`文件，将下列的配置贴进去：\n\n```yaml\nspring:\n  application:\n    name: eureka-client\nserver:\n  port: 2001\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1001/eureka/\n```\n\n至此，服务提供方也创建成功。将服务注册中心和服务提供方都运行起来，打开注册中心可以看到eureka-client已经成功被注册。\n\n![image-20220219162841266](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220219162841266.png)\n\n# Spring Cloud Consul服务注册\n\n使用Spring Cloud Consul实现，可以轻松将基于Spring Boot的微服务应用注册到Consul上，并通此实现微服务架构中的服务治理。\n\n如果需要将上述的eureka-client转换成使用consul来，只需要按照下面2步操作即可：\n\n+ 将spring-cloud-eureka-client依赖替换成spring-cloud-consul-discovery依赖\n+ 修改application.yml中的配置\n\n```yaml\nspring:\n  cloud:\n    consul:\n      host: 127.0.0.1\n      port: 8500\n```\n\n其他配置不需要更改，并且由于Consul本身已经集成了服务端，所以不需要额外创建`eureka-server`这样的服务。直接通过下载consul服务端程序即可使用。此过程不再赘述。\n\n更多关于Consul的使用指南，可以查看官方文档：https://www.consul.io/\n","source":"_posts/springcloud/springcloud-getting-started.md","raw":"---\ntitle: 初识Spring Cloud\ndate: 2022-02-19 11:21:30\nupdated: 2022-02-19 11:21:30\ntags: Spring Cloud\ncategories: 微服务架构学习\n---\n\n# Spring Cloud是什么？\n\n一个基于Spring Boot实现的云应用开发工具，为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话以及集群状态管理等操作提供了一种简单的开发方式。\n\n# 微服务架构\n\n“微服务架构”这几年非常火热，以至于关注微服务架构相关的开源产品被反复提及（比如：Netflix和Dubbo），Spring Cloud也因Spring社区强大的知名度和影响力被广大架构师和开发者备受关注。\n\n简单来说：微服务架构是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每隔服务都能独立部署、独立维护、独立扩展，服务之间通过诸如RESTful API的方式相互调用。\n\n# 服务治理\n\n服务治理就是提供了微服务架构中各个微服务实例的快速上线或下线且保持各服务能正常通信的能力方案总称。\n\n## 服务治理可以带来什么好处呢\n\n+ **更高的可用性**\n\n  支持动态的服务实例集群环境，任何服务实例都可以随时上线下线。并且当一个微服务实例不可用时，治理服务器可以将请求转发其他服务提供者，当新服务上线时，也能够快速分担服务调用请求；\n\n  \n\n+ **负载均衡**\n\n  提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；\n\n  \n\n+ **提升应用弹性**\n\n  服务治理客户端定时从服务治理服务器中复制一份实例信息缓存到本地，即使当服务治理服务器不可用时，服务消费者也可以使用本地的缓存去访问相应的服务，而不至于中断服务。通过这种机制，极大提高应用的弹性；\n\n  \n\n+ **高可用性集群**\n\n  可以构建服务治理集群，通过互相注册机制，将每隔治理服务器所管辖的服务信息列表进行交换，使服务治理拥有更高的可用性；\n\n# Spring Cloud的基本使用\n\n从上面对于微服务的治理和定义，我们搭建一个最基础和简单的微服务架构：\n\n+ 服务注册中心\n+ 服务提供方\n\n这里我们使用Spring Cloud Eureka的基础服务来搭建，下面按照操作手册来做一下看看。\n\n## 创建服务发现中心\n\n使用IntelliJ IDEA创建一个Spring Boot项目，依赖管理工具选择Gradle。你可以使用Spring Initializer来生成项目：\n\n<img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-143445@2x.png\" alt=\"s\" style=\"zoom:50%;\" />\n\n生成项目后，我们找到项目目录的启动入口文件\n\n```java\n// 新增EnableEurekaServer注解，将该工程标识为一个服务注册中心\n@EnableEurekaServer\n@SpringBootApplication\npublic class EurekaServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n\n}\n```\n\n找到`application.properties`文件，将其更改为`application.yml`（只是习惯用YML文件），修改一下Eureka Server的配置如下：\n\n```yaml\n# 服务注册中心的名称\nspring:\n  application:\n    name: eureka-server\n\n# 服务注册中心监听的端口\nserver:\n  port: 1001\n\n# 暂时禁用服务端注册客户端的行为\neureka:\n  instance:\n    hostname: 127.0.0.1\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n到此，服务注册中心搭建完成，运行这个项目并且打开浏览器输入`http://localhost:1001/`就可以看到服务注册中心的基本页面了：\n\n![](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-144301@2x.png)\n\n## 创建服务提供方\n\n如法炮制，我们通过Spring Initializer再创建一个Spring Boot项目，名为eureka-client，对应的gradle依赖如下：\n\n主要提供的是：\n\n+ spring-cloud-starter-netflix-eureka-client\n+ spring-boot-starter-web\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.6.3'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'com.hhp.registry'\nversion = '0.0.1'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\next {\n    set('springCloudVersion', \"2021.0.1\")\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n\n```\n\n我们新建一个Rest接口：\n\n> 需要注意的是：这里的DiscoveryClient会出现Netflix和Spring Cloud的，选择Spring Cloud的官方依赖\n\n```java\n@RestController\npublic class DcController {\n\n    // 选择Spring Cloud的依赖包导入\n    @Resource\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping(\"/dc\")\n    public String dc() {\n        String services = \"Service: \" + discoveryClient.getServices();\n        System.out.println(services);\n        return services;\n    }\n}\n```\n\n回到eureka-client的启动类，我们加上`@EnableDiscoveryClient`注解\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaClientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n```\n\n打开eureka-client的`application.yml`文件，将下列的配置贴进去：\n\n```yaml\nspring:\n  application:\n    name: eureka-client\nserver:\n  port: 2001\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1001/eureka/\n```\n\n至此，服务提供方也创建成功。将服务注册中心和服务提供方都运行起来，打开注册中心可以看到eureka-client已经成功被注册。\n\n![image-20220219162841266](https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220219162841266.png)\n\n# Spring Cloud Consul服务注册\n\n使用Spring Cloud Consul实现，可以轻松将基于Spring Boot的微服务应用注册到Consul上，并通此实现微服务架构中的服务治理。\n\n如果需要将上述的eureka-client转换成使用consul来，只需要按照下面2步操作即可：\n\n+ 将spring-cloud-eureka-client依赖替换成spring-cloud-consul-discovery依赖\n+ 修改application.yml中的配置\n\n```yaml\nspring:\n  cloud:\n    consul:\n      host: 127.0.0.1\n      port: 8500\n```\n\n其他配置不需要更改，并且由于Consul本身已经集成了服务端，所以不需要额外创建`eureka-server`这样的服务。直接通过下载consul服务端程序即可使用。此过程不再赘述。\n\n更多关于Consul的使用指南，可以查看官方文档：https://www.consul.io/\n","slug":"springcloud/springcloud-getting-started","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2p000e2y618wm8hbn5","content":"<h1 id=\"Spring-Cloud是什么？\"><a href=\"#Spring-Cloud是什么？\" class=\"headerlink\" title=\"Spring Cloud是什么？\"></a>Spring Cloud是什么？</h1><p>一个基于Spring Boot实现的云应用开发工具，为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话以及集群状态管理等操作提供了一种简单的开发方式。</p>\n<h1 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h1><p>“微服务架构”这几年非常火热，以至于关注微服务架构相关的开源产品被反复提及（比如：Netflix和Dubbo），Spring Cloud也因Spring社区强大的知名度和影响力被广大架构师和开发者备受关注。</p>\n<p>简单来说：微服务架构是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每隔服务都能独立部署、独立维护、独立扩展，服务之间通过诸如RESTful API的方式相互调用。</p>\n<h1 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h1><p>服务治理就是提供了微服务架构中各个微服务实例的快速上线或下线且保持各服务能正常通信的能力方案总称。</p>\n<h2 id=\"服务治理可以带来什么好处呢\"><a href=\"#服务治理可以带来什么好处呢\" class=\"headerlink\" title=\"服务治理可以带来什么好处呢\"></a>服务治理可以带来什么好处呢</h2><ul>\n<li><p><strong>更高的可用性</strong></p>\n<p>支持动态的服务实例集群环境，任何服务实例都可以随时上线下线。并且当一个微服务实例不可用时，治理服务器可以将请求转发其他服务提供者，当新服务上线时，也能够快速分担服务调用请求；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>负载均衡</strong></p>\n<p>提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>提升应用弹性</strong></p>\n<p>服务治理客户端定时从服务治理服务器中复制一份实例信息缓存到本地，即使当服务治理服务器不可用时，服务消费者也可以使用本地的缓存去访问相应的服务，而不至于中断服务。通过这种机制，极大提高应用的弹性；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>高可用性集群</strong></p>\n<p>可以构建服务治理集群，通过互相注册机制，将每隔治理服务器所管辖的服务信息列表进行交换，使服务治理拥有更高的可用性；</p>\n</li>\n</ul>\n<h1 id=\"Spring-Cloud的基本使用\"><a href=\"#Spring-Cloud的基本使用\" class=\"headerlink\" title=\"Spring Cloud的基本使用\"></a>Spring Cloud的基本使用</h1><p>从上面对于微服务的治理和定义，我们搭建一个最基础和简单的微服务架构：</p>\n<ul>\n<li>服务注册中心</li>\n<li>服务提供方</li>\n</ul>\n<p>这里我们使用Spring Cloud Eureka的基础服务来搭建，下面按照操作手册来做一下看看。</p>\n<h2 id=\"创建服务发现中心\"><a href=\"#创建服务发现中心\" class=\"headerlink\" title=\"创建服务发现中心\"></a>创建服务发现中心</h2><p>使用IntelliJ IDEA创建一个Spring Boot项目，依赖管理工具选择Gradle。你可以使用Spring Initializer来生成项目：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-143445@2x.png\" alt=\"s\" style=\"zoom:50%;\" /></p>\n<p>生成项目后，我们找到项目目录的启动入口文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 新增EnableEurekaServer注解，将该工程标识为一个服务注册中心</span><br><span class=\"hljs-meta\">@EnableEurekaServer</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaServerApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>找到<code>application.properties</code>文件，将其更改为<code>application.yml</code>（只是习惯用YML文件），修改一下Eureka Server的配置如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\"># 服务注册中心的名称</span><br><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-server</span><br><br><span class=\"hljs-comment\"># 服务注册中心监听的端口</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">1001</span><br><br><span class=\"hljs-comment\"># 暂时禁用服务端注册客户端的行为</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">instance:</span><br>    <span class=\"hljs-attr\">hostname:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">register-with-eureka:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">fetch-registry:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>到此，服务注册中心搭建完成，运行这个项目并且打开浏览器输入<code>http://localhost:1001/</code>就可以看到服务注册中心的基本页面了：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-144301@2x.png\" alt=\"\"></p>\n<h2 id=\"创建服务提供方\"><a href=\"#创建服务提供方\" class=\"headerlink\" title=\"创建服务提供方\"></a>创建服务提供方</h2><p>如法炮制，我们通过Spring Initializer再创建一个Spring Boot项目，名为eureka-client，对应的gradle依赖如下：</p>\n<p>主要提供的是：</p>\n<ul>\n<li>spring-cloud-starter-netflix-eureka-client</li>\n<li>spring-boot-starter-web</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.registry&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>我们新建一个Rest接口：</p>\n<blockquote>\n<p>需要注意的是：这里的DiscoveryClient会出现Netflix和Spring Cloud的，选择Spring Cloud的官方依赖</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-comment\">// 选择Spring Cloud的依赖包导入</span><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> DiscoveryClient discoveryClient;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/dc&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">services</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Service: &quot;</span> + discoveryClient.getServices();<br>        System.out.println(services);<br>        <span class=\"hljs-keyword\">return</span> services;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>回到eureka-client的启动类，我们加上<code>@EnableDiscoveryClient</code>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaClientApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaClientApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>打开eureka-client的<code>application.yml</code>文件，将下列的配置贴进去：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-client</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2001</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://localhost:1001/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>至此，服务提供方也创建成功。将服务注册中心和服务提供方都运行起来，打开注册中心可以看到eureka-client已经成功被注册。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220219162841266.png\" alt=\"image-20220219162841266\"></p>\n<h1 id=\"Spring-Cloud-Consul服务注册\"><a href=\"#Spring-Cloud-Consul服务注册\" class=\"headerlink\" title=\"Spring Cloud Consul服务注册\"></a>Spring Cloud Consul服务注册</h1><p>使用Spring Cloud Consul实现，可以轻松将基于Spring Boot的微服务应用注册到Consul上，并通此实现微服务架构中的服务治理。</p>\n<p>如果需要将上述的eureka-client转换成使用consul来，只需要按照下面2步操作即可：</p>\n<ul>\n<li>将spring-cloud-eureka-client依赖替换成spring-cloud-consul-discovery依赖</li>\n<li>修改application.yml中的配置</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">consul:</span><br>      <span class=\"hljs-attr\">host:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><br>      <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">8500</span><br></code></pre></td></tr></table></figure>\n<p>其他配置不需要更改，并且由于Consul本身已经集成了服务端，所以不需要额外创建<code>eureka-server</code>这样的服务。直接通过下载consul服务端程序即可使用。此过程不再赘述。</p>\n<p>更多关于Consul的使用指南，可以查看官方文档：<a href=\"https://www.consul.io/\">https://www.consul.io/</a></p>\n","site":{"data":{}},"wordcount":4042,"excerpt":"","more":"<h1 id=\"Spring-Cloud是什么？\"><a href=\"#Spring-Cloud是什么？\" class=\"headerlink\" title=\"Spring Cloud是什么？\"></a>Spring Cloud是什么？</h1><p>一个基于Spring Boot实现的云应用开发工具，为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话以及集群状态管理等操作提供了一种简单的开发方式。</p>\n<h1 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h1><p>“微服务架构”这几年非常火热，以至于关注微服务架构相关的开源产品被反复提及（比如：Netflix和Dubbo），Spring Cloud也因Spring社区强大的知名度和影响力被广大架构师和开发者备受关注。</p>\n<p>简单来说：微服务架构是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每隔服务都能独立部署、独立维护、独立扩展，服务之间通过诸如RESTful API的方式相互调用。</p>\n<h1 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h1><p>服务治理就是提供了微服务架构中各个微服务实例的快速上线或下线且保持各服务能正常通信的能力方案总称。</p>\n<h2 id=\"服务治理可以带来什么好处呢\"><a href=\"#服务治理可以带来什么好处呢\" class=\"headerlink\" title=\"服务治理可以带来什么好处呢\"></a>服务治理可以带来什么好处呢</h2><ul>\n<li><p><strong>更高的可用性</strong></p>\n<p>支持动态的服务实例集群环境，任何服务实例都可以随时上线下线。并且当一个微服务实例不可用时，治理服务器可以将请求转发其他服务提供者，当新服务上线时，也能够快速分担服务调用请求；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>负载均衡</strong></p>\n<p>提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>提升应用弹性</strong></p>\n<p>服务治理客户端定时从服务治理服务器中复制一份实例信息缓存到本地，即使当服务治理服务器不可用时，服务消费者也可以使用本地的缓存去访问相应的服务，而不至于中断服务。通过这种机制，极大提高应用的弹性；</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>高可用性集群</strong></p>\n<p>可以构建服务治理集群，通过互相注册机制，将每隔治理服务器所管辖的服务信息列表进行交换，使服务治理拥有更高的可用性；</p>\n</li>\n</ul>\n<h1 id=\"Spring-Cloud的基本使用\"><a href=\"#Spring-Cloud的基本使用\" class=\"headerlink\" title=\"Spring Cloud的基本使用\"></a>Spring Cloud的基本使用</h1><p>从上面对于微服务的治理和定义，我们搭建一个最基础和简单的微服务架构：</p>\n<ul>\n<li>服务注册中心</li>\n<li>服务提供方</li>\n</ul>\n<p>这里我们使用Spring Cloud Eureka的基础服务来搭建，下面按照操作手册来做一下看看。</p>\n<h2 id=\"创建服务发现中心\"><a href=\"#创建服务发现中心\" class=\"headerlink\" title=\"创建服务发现中心\"></a>创建服务发现中心</h2><p>使用IntelliJ IDEA创建一个Spring Boot项目，依赖管理工具选择Gradle。你可以使用Spring Initializer来生成项目：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-143445@2x.png\" alt=\"s\" style=\"zoom:50%;\" /></p>\n<p>生成项目后，我们找到项目目录的启动入口文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 新增EnableEurekaServer注解，将该工程标识为一个服务注册中心</span><br><span class=\"hljs-meta\">@EnableEurekaServer</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaServerApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>找到<code>application.properties</code>文件，将其更改为<code>application.yml</code>（只是习惯用YML文件），修改一下Eureka Server的配置如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\"># 服务注册中心的名称</span><br><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-server</span><br><br><span class=\"hljs-comment\"># 服务注册中心监听的端口</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">1001</span><br><br><span class=\"hljs-comment\"># 暂时禁用服务端注册客户端的行为</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">instance:</span><br>    <span class=\"hljs-attr\">hostname:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">register-with-eureka:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">fetch-registry:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>到此，服务注册中心搭建完成，运行这个项目并且打开浏览器输入<code>http://localhost:1001/</code>就可以看到服务注册中心的基本页面了：</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/WX20220219-144301@2x.png\" alt=\"\"></p>\n<h2 id=\"创建服务提供方\"><a href=\"#创建服务提供方\" class=\"headerlink\" title=\"创建服务提供方\"></a>创建服务提供方</h2><p>如法炮制，我们通过Spring Initializer再创建一个Spring Boot项目，名为eureka-client，对应的gradle依赖如下：</p>\n<p>主要提供的是：</p>\n<ul>\n<li>spring-cloud-starter-netflix-eureka-client</li>\n<li>spring-boot-starter-web</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.registry&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>我们新建一个Rest接口：</p>\n<blockquote>\n<p>需要注意的是：这里的DiscoveryClient会出现Netflix和Spring Cloud的，选择Spring Cloud的官方依赖</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-comment\">// 选择Spring Cloud的依赖包导入</span><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> DiscoveryClient discoveryClient;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/dc&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">services</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;Service: &quot;</span> + discoveryClient.getServices();<br>        System.out.println(services);<br>        <span class=\"hljs-keyword\">return</span> services;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>回到eureka-client的启动类，我们加上<code>@EnableDiscoveryClient</code>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaClientApplication</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaClientApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>打开eureka-client的<code>application.yml</code>文件，将下列的配置贴进去：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-client</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2001</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://localhost:1001/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>至此，服务提供方也创建成功。将服务注册中心和服务提供方都运行起来，打开注册中心可以看到eureka-client已经成功被注册。</p>\n<p><img src=\"https://humphrey-blogs-bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20220219162841266.png\" alt=\"image-20220219162841266\"></p>\n<h1 id=\"Spring-Cloud-Consul服务注册\"><a href=\"#Spring-Cloud-Consul服务注册\" class=\"headerlink\" title=\"Spring Cloud Consul服务注册\"></a>Spring Cloud Consul服务注册</h1><p>使用Spring Cloud Consul实现，可以轻松将基于Spring Boot的微服务应用注册到Consul上，并通此实现微服务架构中的服务治理。</p>\n<p>如果需要将上述的eureka-client转换成使用consul来，只需要按照下面2步操作即可：</p>\n<ul>\n<li>将spring-cloud-eureka-client依赖替换成spring-cloud-consul-discovery依赖</li>\n<li>修改application.yml中的配置</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">cloud:</span><br>    <span class=\"hljs-attr\">consul:</span><br>      <span class=\"hljs-attr\">host:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><br>      <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">8500</span><br></code></pre></td></tr></table></figure>\n<p>其他配置不需要更改，并且由于Consul本身已经集成了服务端，所以不需要额外创建<code>eureka-server</code>这样的服务。直接通过下载consul服务端程序即可使用。此过程不再赘述。</p>\n<p>更多关于Consul的使用指南，可以查看官方文档：<a href=\"https://www.consul.io/\">https://www.consul.io/</a></p>\n"},{"title":"Spring Cloud服务消费（基础）","date":"2022-02-19T13:02:44.000Z","updated":"2022-02-19T13:02:44.000Z","_content":"\n# 使用LoadBalancerClient\n\n这是一个负载均衡客户端的抽象定义，负载均衡的好处在于：\n\n+ 提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；\n\n所以在分布式系统设计中，负载均衡可以用来实现系统的高可用、集群扩容等功能。负载均衡也分为“客户端负载均衡”和“服务端负载均衡”两种模式。\n\n我们的Spring Cloud Eureka属于客户端负载均衡的情况，所以这里我们用一个具体的例子来演示客户端负载均衡的具体实现。\n\n> 此Demo需要结合前面已有的eureka-server和eureka-client一起看效果\n\n# 创建消费服务\n\n还是按照之前的套路，使用Spring Initializer新建一个Spring Boot工程，叫`eureka-consumer`。\n\n## 添加依赖\n\n对应的gradle文件如下：\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.6.3'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'com.hhp.registry'\nversion = '0.0.1'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\next {\n    set('springCloudVersion', \"2021.0.1\")\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n```\n\n## 配置服务发现\n\n打开`application.yml`文件，贴入下列配置：\n\n```yaml\nspring:\n  application:\n    name: eureka-consumer\nserver:\n  port: 2101\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1001/eureka/\n```\n\n找到Spring Boot启动入口类，在上面加上`@EnableDiscoveryClient`注解，这里我们把RestTemplate带入我们的配置中：\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaConsumerApplication {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaConsumerApplication.class, args);\n    }\n\n}\n```\n\n## 创建服务消费接口\n\n我们新建一个接口来消费eureka-client服务\n\n```java\n@RestController\npublic class DcController {\n\n    @Resource\n    private LoadBalancerClient loadBalancerClient;\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        ServiceInstance serviceInstance = loadBalancerClient.choose(\"eureka-client\");\n        String url = \"http://\" + serviceInstance.getHost() + \":\" + serviceInstance.getPort() + \"/dc\";\n        System.out.println(url);\n        return restTemplate.getForObject(url, String.class);\n    }\n}\n```\n\n可以看出：\n\n1. 我们注入了`LoadBalancerClient`和`RestTemplate`，并在`/consumer`接口中实现；\n2. 通过`LoadBalancerClient.choose`选择出`eureka-client`的服务实例；\n3. 然后通过`ServiceInstance`服务的信息拼接出`/dc`接口的详细地址；\n4. 利用`RestTemplate`对象实现对服务提供者接口的调用；\n\n# 最终效果\n\n将`eureka-server`，`eureka-client`和`eureka-consumer`三个服务同时运行起来，然后访问`http://localhost:2101/consumer`。可以看到当服务器请求过程中，真正调用的是`eureka-client`，而`eureka-consumer`会把请求通过网络分发出去。\n","source":"_posts/springcloud/springcloud-service-consumer.md","raw":"---\ntitle: Spring Cloud服务消费（基础）\ndate: 2022-02-19 21:02:44\nupdated: 2022-02-19 21:02:44\ntags: Spring Cloud\ncategories: 微服务架构学习\n---\n\n# 使用LoadBalancerClient\n\n这是一个负载均衡客户端的抽象定义，负载均衡的好处在于：\n\n+ 提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；\n\n所以在分布式系统设计中，负载均衡可以用来实现系统的高可用、集群扩容等功能。负载均衡也分为“客户端负载均衡”和“服务端负载均衡”两种模式。\n\n我们的Spring Cloud Eureka属于客户端负载均衡的情况，所以这里我们用一个具体的例子来演示客户端负载均衡的具体实现。\n\n> 此Demo需要结合前面已有的eureka-server和eureka-client一起看效果\n\n# 创建消费服务\n\n还是按照之前的套路，使用Spring Initializer新建一个Spring Boot工程，叫`eureka-consumer`。\n\n## 添加依赖\n\n对应的gradle文件如下：\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.6.3'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'com.hhp.registry'\nversion = '0.0.1'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/public/' }\n    mavenLocal()\n    mavenCentral()\n}\n\next {\n    set('springCloudVersion', \"2021.0.1\")\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n```\n\n## 配置服务发现\n\n打开`application.yml`文件，贴入下列配置：\n\n```yaml\nspring:\n  application:\n    name: eureka-consumer\nserver:\n  port: 2101\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1001/eureka/\n```\n\n找到Spring Boot启动入口类，在上面加上`@EnableDiscoveryClient`注解，这里我们把RestTemplate带入我们的配置中：\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class EurekaConsumerApplication {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaConsumerApplication.class, args);\n    }\n\n}\n```\n\n## 创建服务消费接口\n\n我们新建一个接口来消费eureka-client服务\n\n```java\n@RestController\npublic class DcController {\n\n    @Resource\n    private LoadBalancerClient loadBalancerClient;\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/consumer\")\n    public String dc() {\n        ServiceInstance serviceInstance = loadBalancerClient.choose(\"eureka-client\");\n        String url = \"http://\" + serviceInstance.getHost() + \":\" + serviceInstance.getPort() + \"/dc\";\n        System.out.println(url);\n        return restTemplate.getForObject(url, String.class);\n    }\n}\n```\n\n可以看出：\n\n1. 我们注入了`LoadBalancerClient`和`RestTemplate`，并在`/consumer`接口中实现；\n2. 通过`LoadBalancerClient.choose`选择出`eureka-client`的服务实例；\n3. 然后通过`ServiceInstance`服务的信息拼接出`/dc`接口的详细地址；\n4. 利用`RestTemplate`对象实现对服务提供者接口的调用；\n\n# 最终效果\n\n将`eureka-server`，`eureka-client`和`eureka-consumer`三个服务同时运行起来，然后访问`http://localhost:2101/consumer`。可以看到当服务器请求过程中，真正调用的是`eureka-client`，而`eureka-consumer`会把请求通过网络分发出去。\n","slug":"springcloud/springcloud-service-consumer","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2r000j2y61a229cfvf","content":"<h1 id=\"使用LoadBalancerClient\"><a href=\"#使用LoadBalancerClient\" class=\"headerlink\" title=\"使用LoadBalancerClient\"></a>使用LoadBalancerClient</h1><p>这是一个负载均衡客户端的抽象定义，负载均衡的好处在于：</p>\n<ul>\n<li>提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；</li>\n</ul>\n<p>所以在分布式系统设计中，负载均衡可以用来实现系统的高可用、集群扩容等功能。负载均衡也分为“客户端负载均衡”和“服务端负载均衡”两种模式。</p>\n<p>我们的Spring Cloud Eureka属于客户端负载均衡的情况，所以这里我们用一个具体的例子来演示客户端负载均衡的具体实现。</p>\n<blockquote>\n<p>此Demo需要结合前面已有的eureka-server和eureka-client一起看效果</p>\n</blockquote>\n<h1 id=\"创建消费服务\"><a href=\"#创建消费服务\" class=\"headerlink\" title=\"创建消费服务\"></a>创建消费服务</h1><p>还是按照之前的套路，使用Spring Initializer新建一个Spring Boot工程，叫<code>eureka-consumer</code>。</p>\n<h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><p>对应的gradle文件如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.registry&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置服务发现\"><a href=\"#配置服务发现\" class=\"headerlink\" title=\"配置服务发现\"></a>配置服务发现</h2><p>打开<code>application.yml</code>文件，贴入下列配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-consumer</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2101</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://localhost:1001/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>找到Spring Boot启动入口类，在上面加上<code>@EnableDiscoveryClient</code>注解，这里我们把RestTemplate带入我们的配置中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaConsumerApplication</span> &#123;<br><br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-keyword\">public</span> RestTemplate <span class=\"hljs-title function_\">restTemplate</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建服务消费接口\"><a href=\"#创建服务消费接口\" class=\"headerlink\" title=\"创建服务消费接口\"></a>创建服务消费接口</h2><p>我们新建一个接口来消费eureka-client服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> LoadBalancerClient loadBalancerClient;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> RestTemplate restTemplate;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/consumer&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">ServiceInstance</span> <span class=\"hljs-variable\">serviceInstance</span> <span class=\"hljs-operator\">=</span> loadBalancerClient.choose(<span class=\"hljs-string\">&quot;eureka-client&quot;</span>);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">url</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;http://&quot;</span> + serviceInstance.getHost() + <span class=\"hljs-string\">&quot;:&quot;</span> + serviceInstance.getPort() + <span class=\"hljs-string\">&quot;/dc&quot;</span>;<br>        System.out.println(url);<br>        <span class=\"hljs-keyword\">return</span> restTemplate.getForObject(url, String.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看出：</p>\n<ol>\n<li>我们注入了<code>LoadBalancerClient</code>和<code>RestTemplate</code>，并在<code>/consumer</code>接口中实现；</li>\n<li>通过<code>LoadBalancerClient.choose</code>选择出<code>eureka-client</code>的服务实例；</li>\n<li>然后通过<code>ServiceInstance</code>服务的信息拼接出<code>/dc</code>接口的详细地址；</li>\n<li>利用<code>RestTemplate</code>对象实现对服务提供者接口的调用；</li>\n</ol>\n<h1 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h1><p>将<code>eureka-server</code>，<code>eureka-client</code>和<code>eureka-consumer</code>三个服务同时运行起来，然后访问<code>http://localhost:2101/consumer</code>。可以看到当服务器请求过程中，真正调用的是<code>eureka-client</code>，而<code>eureka-consumer</code>会把请求通过网络分发出去。</p>\n","site":{"data":{}},"wordcount":2841,"excerpt":"","more":"<h1 id=\"使用LoadBalancerClient\"><a href=\"#使用LoadBalancerClient\" class=\"headerlink\" title=\"使用LoadBalancerClient\"></a>使用LoadBalancerClient</h1><p>这是一个负载均衡客户端的抽象定义，负载均衡的好处在于：</p>\n<ul>\n<li>提供动态的负载均衡功能，可以将所有请求动态分布到其所管理的所有服务实例中进行处理；</li>\n</ul>\n<p>所以在分布式系统设计中，负载均衡可以用来实现系统的高可用、集群扩容等功能。负载均衡也分为“客户端负载均衡”和“服务端负载均衡”两种模式。</p>\n<p>我们的Spring Cloud Eureka属于客户端负载均衡的情况，所以这里我们用一个具体的例子来演示客户端负载均衡的具体实现。</p>\n<blockquote>\n<p>此Demo需要结合前面已有的eureka-server和eureka-client一起看效果</p>\n</blockquote>\n<h1 id=\"创建消费服务\"><a href=\"#创建消费服务\" class=\"headerlink\" title=\"创建消费服务\"></a>创建消费服务</h1><p>还是按照之前的套路，使用Spring Initializer新建一个Spring Boot工程，叫<code>eureka-consumer</code>。</p>\n<h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><p>对应的gradle文件如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs groovy\">plugins &#123;<br>    id <span class=\"hljs-string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"hljs-string\">&#x27;2.6.3&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"hljs-string\">&#x27;1.0.11.RELEASE&#x27;</span><br>    id <span class=\"hljs-string\">&#x27;java&#x27;</span><br>&#125;<br><br>group = <span class=\"hljs-string\">&#x27;com.hhp.registry&#x27;</span><br>version = <span class=\"hljs-string\">&#x27;0.0.1&#x27;</span><br>sourceCompatibility = <span class=\"hljs-string\">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    maven &#123; url <span class=\"hljs-string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;<br>    mavenLocal()<br>    mavenCentral()<br>&#125;<br><br>ext &#123;<br>    set(<span class=\"hljs-string\">&#x27;springCloudVersion&#x27;</span>, <span class=\"hljs-string\">&quot;2021.0.1&quot;</span>)<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    implementation <span class=\"hljs-string\">&#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;</span><br>    testImplementation <span class=\"hljs-string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br><br>dependencyManagement &#123;<br>    imports &#123;<br>        mavenBom <span class=\"hljs-string\">&quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br>    &#125;<br>&#125;<br><br>tasks.named(<span class=\"hljs-string\">&#x27;test&#x27;</span>) &#123;<br>    useJUnitPlatform()<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置服务发现\"><a href=\"#配置服务发现\" class=\"headerlink\" title=\"配置服务发现\"></a>配置服务发现</h2><p>打开<code>application.yml</code>文件，贴入下列配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">spring:</span><br>  <span class=\"hljs-attr\">application:</span><br>    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">eureka-consumer</span><br><span class=\"hljs-attr\">server:</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">2101</span><br><span class=\"hljs-attr\">eureka:</span><br>  <span class=\"hljs-attr\">client:</span><br>    <span class=\"hljs-attr\">service-url:</span><br>      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://localhost:1001/eureka/</span><br></code></pre></td></tr></table></figure>\n<p>找到Spring Boot启动入口类，在上面加上<code>@EnableDiscoveryClient</code>注解，这里我们把RestTemplate带入我们的配置中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableDiscoveryClient</span><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaConsumerApplication</span> &#123;<br><br>    <span class=\"hljs-meta\">@Bean</span><br>    <span class=\"hljs-keyword\">public</span> RestTemplate <span class=\"hljs-title function_\">restTemplate</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"创建服务消费接口\"><a href=\"#创建服务消费接口\" class=\"headerlink\" title=\"创建服务消费接口\"></a>创建服务消费接口</h2><p>我们新建一个接口来消费eureka-client服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DcController</span> &#123;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> LoadBalancerClient loadBalancerClient;<br><br>    <span class=\"hljs-meta\">@Resource</span><br>    <span class=\"hljs-keyword\">private</span> RestTemplate restTemplate;<br><br>    <span class=\"hljs-meta\">@GetMapping(&quot;/consumer&quot;)</span><br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">dc</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-type\">ServiceInstance</span> <span class=\"hljs-variable\">serviceInstance</span> <span class=\"hljs-operator\">=</span> loadBalancerClient.choose(<span class=\"hljs-string\">&quot;eureka-client&quot;</span>);<br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">url</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;http://&quot;</span> + serviceInstance.getHost() + <span class=\"hljs-string\">&quot;:&quot;</span> + serviceInstance.getPort() + <span class=\"hljs-string\">&quot;/dc&quot;</span>;<br>        System.out.println(url);<br>        <span class=\"hljs-keyword\">return</span> restTemplate.getForObject(url, String.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以看出：</p>\n<ol>\n<li>我们注入了<code>LoadBalancerClient</code>和<code>RestTemplate</code>，并在<code>/consumer</code>接口中实现；</li>\n<li>通过<code>LoadBalancerClient.choose</code>选择出<code>eureka-client</code>的服务实例；</li>\n<li>然后通过<code>ServiceInstance</code>服务的信息拼接出<code>/dc</code>接口的详细地址；</li>\n<li>利用<code>RestTemplate</code>对象实现对服务提供者接口的调用；</li>\n</ol>\n<h1 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h1><p>将<code>eureka-server</code>，<code>eureka-client</code>和<code>eureka-consumer</code>三个服务同时运行起来，然后访问<code>http://localhost:2101/consumer</code>。可以看到当服务器请求过程中，真正调用的是<code>eureka-client</code>，而<code>eureka-consumer</code>会把请求通过网络分发出去。</p>\n"},{"title":"ES6 数组扩展","date":"2022-02-17T07:06:02.000Z","updated":"2022-02-17T07:06:02.000Z","_content":"\n# 数组扩展\n\n## Array.from()\n\n用于将类似数组的对象和可遍历的对象（部署了Iterator接口）转换为数组。例子如下：\n\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5\nvar arr1 = [].slice.call(arrayLike);\n\n// ES6\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n\n实际应用中，常见的类似数组对象是DOM操作返回的NodeList集合以及函数内部arguments对象。Array.from都可以将它们转为真正的数组。\n\n```javascript\nlet ps = document.querySelectorAll('p');\nArray.from(ps).forEach(function (p) {\n    console.log(p);\n});\n\nfunction add(a, b) {\n    var args = Array.from(arguments);\n    console.log(args);\n    return a + b;\n}\n\nadd(1, 2);\n// [1, 2]\n// 3\n\n// 字符串和Set都部署了Iterator接口，所以可以用Array.from生成数组，这点和Java很像\nArray.from('hello'); // ['h', 'e', 'l', 'l', 'o']\nlet nameSet = new Set(['a', 'b']);\nArray.from(nameSet) // ['a', 'b']\n```\n\n除此之外，扩展运算符`...`也可以将某些数据结构转换为数组（注：扩展运算符跟Java中的多参数表达式功能类似）。扩展运算符背地也是调用Iterator接口，如果对象没有部署这个接口，则无法完成转换；\n\n```javascript\nfunction foo () {\n    var args = [...arguments];\n}\n\n[...document.querySelectorAll('div')]\n```\n\n## Array.of()\n\nArray.of用于将一组值，转换为数组；这个方法的主要目的是弥补Array()方法的不足。因为参数个数的不同，会导致Array()的行为有差异。\n\n```javascript\nArray.of(3, 11, 8); // [3, 11, 8]\nArray(3, 11, 8); // [3, 11, 8]\nArray(3); // [, , ,] 长度为3的空数组\nArray.of(3); // [3] 长度为1的数组，只有一个元素3\n```\n\n## 数组实例的copyWithin()\n\n在当前数组的内部，将指定位置的成员复制到其他位置，然后返回当前数组。也就是说该方法会修改当前数组。\n\n```javascript\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n// target（必需）：从该位置开始替换数据\n// start（可选）：从该位置开始读取数据，默认为0，如果为负值则表示倒数；\n// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数；\n\n[1, 2, 3, 4, 5].copyWithin(0, 3); // [4, 5, 3, 4, 5]\n```\n\n## 数组实例find()和findIndex()\n\n`find()`方法用于找出第一个符合条件的数组成员。其第一个参数是回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没找到符合条件的成员则返回`undefined`。\n\n`findIndex()`方法的作用与`find()`方法非常类似。这里就不再赘述。可以看出新增的两个方法极大地弥补了`indexOf()`方法的不足。\n\n```javascript\n[1, 4, -5. 10].find((n) => n < 0); // -5\n\n[1, 5, 10, 15].find(function(value, index, arr){\n    return value > 9;\n}); // 10\n\n[1, 5, 10, 15].findIndex(function(value, index, arr){\n    return value > 9;\n}) // 2（正好是元素10对应的数组索引）\n```\n\n## 数组实例fill()\n\n`fill()`可以使用给定值来填充数组，因此在初始化数组元素的过程中非常方便。\n\n初次之外，fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置\n\n```javascript\n['a', 'b', 'c'].fill(7); // [7, 7, 7]\n\nnew Array(3).fill(7); // [7, 7, 7]\n\n['a', 'b', 'c'].fill(7, 1, 2); // ['a', '7', 'c'] 用7填充，从1号位开始，到2号位结束\n```\n\n## 数组实例entries(), keys()和values()\n\nES6新增了上述的3个方法，英语遍历数组。它们都是返回一个遍历器对象，可以使用`for...of`循环遍历，唯一区别是`keys()`是对键名的遍历、`values()`是对键值得遍历，`entries()`是对键值对的遍历。\n\n```javascript\nfor (let index of ['a', 'b'].keys()) {\n    console.log(index)\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n    console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n    console.log(index, elem);\n}\n// 0 'a'\n// 1 'b'\n```\n\n## 数组实例includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否是否已经包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但是Babel转码器已经支持。\n\n```javascript\n[1, 2, 3].includes(2); // true\n[1, 2, 3].includes(4); // false\n[1, 2, NaN].includes(NaN); // true\n```\n\n该方法还有第二个参数表示搜索的起始位置，默认为0 ，如果为负数则表示倒数位置。\n\n## 数组的空位\n\n数组的某一个位置没有任何值。比如`Array`构造函数返回的数组都是空位。注意：空位不等于`undefined`\n\n```javascript\nvar arr = new Array(3);\n0 in arr // false\nundefined in arr // false\n\nvar arr = new Array(3).fill(undefined)\n0 in arr // true\n```\n\n在ES6中会明确将空位转换为`undefined`， `copyWithin()`会将空位一起拷贝，`fill()`会将空位当做正常位置，循环也会迭代空位。总之ES6中会保留空位。由于空位的处理规则不统一，因此应当避免出现空位。\n\n```javascript\n[...['a',,'b']]\n// ['a', undefined, 'b']\n```\n","source":"_posts/javascript/es6-array-expand.md","raw":"---\ntitle: ES6 数组扩展\ndate: 2022-02-17 15:06:02\nupdated: 2022-02-17 15:06:02\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 数组扩展\n\n## Array.from()\n\n用于将类似数组的对象和可遍历的对象（部署了Iterator接口）转换为数组。例子如下：\n\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5\nvar arr1 = [].slice.call(arrayLike);\n\n// ES6\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n\n实际应用中，常见的类似数组对象是DOM操作返回的NodeList集合以及函数内部arguments对象。Array.from都可以将它们转为真正的数组。\n\n```javascript\nlet ps = document.querySelectorAll('p');\nArray.from(ps).forEach(function (p) {\n    console.log(p);\n});\n\nfunction add(a, b) {\n    var args = Array.from(arguments);\n    console.log(args);\n    return a + b;\n}\n\nadd(1, 2);\n// [1, 2]\n// 3\n\n// 字符串和Set都部署了Iterator接口，所以可以用Array.from生成数组，这点和Java很像\nArray.from('hello'); // ['h', 'e', 'l', 'l', 'o']\nlet nameSet = new Set(['a', 'b']);\nArray.from(nameSet) // ['a', 'b']\n```\n\n除此之外，扩展运算符`...`也可以将某些数据结构转换为数组（注：扩展运算符跟Java中的多参数表达式功能类似）。扩展运算符背地也是调用Iterator接口，如果对象没有部署这个接口，则无法完成转换；\n\n```javascript\nfunction foo () {\n    var args = [...arguments];\n}\n\n[...document.querySelectorAll('div')]\n```\n\n## Array.of()\n\nArray.of用于将一组值，转换为数组；这个方法的主要目的是弥补Array()方法的不足。因为参数个数的不同，会导致Array()的行为有差异。\n\n```javascript\nArray.of(3, 11, 8); // [3, 11, 8]\nArray(3, 11, 8); // [3, 11, 8]\nArray(3); // [, , ,] 长度为3的空数组\nArray.of(3); // [3] 长度为1的数组，只有一个元素3\n```\n\n## 数组实例的copyWithin()\n\n在当前数组的内部，将指定位置的成员复制到其他位置，然后返回当前数组。也就是说该方法会修改当前数组。\n\n```javascript\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n// target（必需）：从该位置开始替换数据\n// start（可选）：从该位置开始读取数据，默认为0，如果为负值则表示倒数；\n// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数；\n\n[1, 2, 3, 4, 5].copyWithin(0, 3); // [4, 5, 3, 4, 5]\n```\n\n## 数组实例find()和findIndex()\n\n`find()`方法用于找出第一个符合条件的数组成员。其第一个参数是回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没找到符合条件的成员则返回`undefined`。\n\n`findIndex()`方法的作用与`find()`方法非常类似。这里就不再赘述。可以看出新增的两个方法极大地弥补了`indexOf()`方法的不足。\n\n```javascript\n[1, 4, -5. 10].find((n) => n < 0); // -5\n\n[1, 5, 10, 15].find(function(value, index, arr){\n    return value > 9;\n}); // 10\n\n[1, 5, 10, 15].findIndex(function(value, index, arr){\n    return value > 9;\n}) // 2（正好是元素10对应的数组索引）\n```\n\n## 数组实例fill()\n\n`fill()`可以使用给定值来填充数组，因此在初始化数组元素的过程中非常方便。\n\n初次之外，fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置\n\n```javascript\n['a', 'b', 'c'].fill(7); // [7, 7, 7]\n\nnew Array(3).fill(7); // [7, 7, 7]\n\n['a', 'b', 'c'].fill(7, 1, 2); // ['a', '7', 'c'] 用7填充，从1号位开始，到2号位结束\n```\n\n## 数组实例entries(), keys()和values()\n\nES6新增了上述的3个方法，英语遍历数组。它们都是返回一个遍历器对象，可以使用`for...of`循环遍历，唯一区别是`keys()`是对键名的遍历、`values()`是对键值得遍历，`entries()`是对键值对的遍历。\n\n```javascript\nfor (let index of ['a', 'b'].keys()) {\n    console.log(index)\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n    console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n    console.log(index, elem);\n}\n// 0 'a'\n// 1 'b'\n```\n\n## 数组实例includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否是否已经包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但是Babel转码器已经支持。\n\n```javascript\n[1, 2, 3].includes(2); // true\n[1, 2, 3].includes(4); // false\n[1, 2, NaN].includes(NaN); // true\n```\n\n该方法还有第二个参数表示搜索的起始位置，默认为0 ，如果为负数则表示倒数位置。\n\n## 数组的空位\n\n数组的某一个位置没有任何值。比如`Array`构造函数返回的数组都是空位。注意：空位不等于`undefined`\n\n```javascript\nvar arr = new Array(3);\n0 in arr // false\nundefined in arr // false\n\nvar arr = new Array(3).fill(undefined)\n0 in arr // true\n```\n\n在ES6中会明确将空位转换为`undefined`， `copyWithin()`会将空位一起拷贝，`fill()`会将空位当做正常位置，循环也会迭代空位。总之ES6中会保留空位。由于空位的处理规则不统一，因此应当避免出现空位。\n\n```javascript\n[...['a',,'b']]\n// ['a', undefined, 'b']\n```\n","slug":"javascript/es6-array-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2s000m2y61ahq7bwcs","content":"<h1 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h1><h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p>用于将类似数组的对象和可遍历的对象（部署了Iterator接口）转换为数组。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arrayLike = &#123;<br>    <span class=\"hljs-string\">&#x27;0&#x27;</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;1&#x27;</span>: <span class=\"hljs-string\">&#x27;b&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;2&#x27;</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>,<br>    <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">3</span><br>&#125;;<br><br><span class=\"hljs-comment\">// ES5</span><br><span class=\"hljs-keyword\">var</span> arr1 = [].<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(arrayLike);<br><br><span class=\"hljs-comment\">// ES6</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(arrayLike); <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>实际应用中，常见的类似数组对象是DOM操作返回的NodeList集合以及函数内部arguments对象。Array.from都可以将它们转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> ps = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;p&#x27;</span>);<br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(ps).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">p</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p);<br>&#125;);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(args);<br>    <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-comment\">// [1, 2]</span><br><span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// 字符串和Set都部署了Iterator接口，所以可以用Array.from生成数组，这点和Java很像</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>); <span class=\"hljs-comment\">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class=\"hljs-keyword\">let</span> nameSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(nameSet) <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>除此之外，扩展运算符<code>...</code>也可以将某些数据结构转换为数组（注：扩展运算符跟Java中的多参数表达式功能类似）。扩展运算符背地也是调用Iterator接口，如果对象没有部署这个接口，则无法完成转换；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;<br>    <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>];<br>&#125;<br><br>[...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)]<br></code></pre></td></tr></table></figure>\n<h2 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h2><p>Array.of用于将一组值，转换为数组；这个方法的主要目的是弥补Array()方法的不足。因为参数个数的不同，会导致Array()的行为有差异。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// [3, 11, 8]</span><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// [3, 11, 8]</span><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [, , ,] 长度为3的空数组</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [3] 长度为1的数组，只有一个元素3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例的copyWithin\"><a href=\"#数组实例的copyWithin\" class=\"headerlink\" title=\"数组实例的copyWithin()\"></a>数组实例的copyWithin()</h2><p>在当前数组的内部，将指定位置的成员复制到其他位置，然后返回当前数组。也就是说该方法会修改当前数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">copyWithin</span>(target, start = <span class=\"hljs-number\">0</span>, end = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">length</span>)<br><span class=\"hljs-comment\">// target（必需）：从该位置开始替换数据</span><br><span class=\"hljs-comment\">// start（可选）：从该位置开始读取数据，默认为0，如果为负值则表示倒数；</span><br><span class=\"hljs-comment\">// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数；</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [4, 5, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例find-和findIndex\"><a href=\"#数组实例find-和findIndex\" class=\"headerlink\" title=\"数组实例find()和findIndex()\"></a>数组实例find()和findIndex()</h2><p><code>find()</code>方法用于找出第一个符合条件的数组成员。其第一个参数是回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没找到符合条件的成员则返回<code>undefined</code>。</p>\n<p><code>findIndex()</code>方法的作用与<code>find()</code>方法非常类似。这里就不再赘述。可以看出新增的两个方法极大地弥补了<code>indexOf()</code>方法的不足。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">5.</span> <span class=\"hljs-number\">10</span>].<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> n &lt; <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -5</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>].<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, index, arr</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> value &gt; <span class=\"hljs-number\">9</span>;<br>&#125;); <span class=\"hljs-comment\">// 10</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>].<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, index, arr</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> value &gt; <span class=\"hljs-number\">9</span>;<br>&#125;) <span class=\"hljs-comment\">// 2（正好是元素10对应的数组索引）</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例fill\"><a href=\"#数组实例fill\" class=\"headerlink\" title=\"数组实例fill()\"></a>数组实例fill()</h2><p><code>fill()</code>可以使用给定值来填充数组，因此在初始化数组元素的过程中非常方便。</p>\n<p>初次之外，fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>].<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// [7, 7, 7]</span><br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// [7, 7, 7]</span><br><br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>].<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;7&#x27;, &#x27;c&#x27;] 用7填充，从1号位开始，到2号位结束</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例entries-keys-和values\"><a href=\"#数组实例entries-keys-和values\" class=\"headerlink\" title=\"数组实例entries(), keys()和values()\"></a>数组实例entries(), keys()和values()</h2><p>ES6新增了上述的3个方法，英语遍历数组。它们都是返回一个遍历器对象，可以使用<code>for...of</code>循环遍历，唯一区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值得遍历，<code>entries()</code>是对键值对的遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index)<br>&#125;<br><span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> elem <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(elem);<br>&#125;<br><span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [index, elem] <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index, elem);<br>&#125;<br><span class=\"hljs-comment\">// 0 &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// 1 &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例includes\"><a href=\"#数组实例includes\" class=\"headerlink\" title=\"数组实例includes()\"></a>数组实例includes()</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否是否已经包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但是Babel转码器已经支持。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// true</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// false</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">NaN</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>该方法还有第二个参数表示搜索的起始位置，默认为0 ，如果为负数则表示倒数位置。</p>\n<h2 id=\"数组的空位\"><a href=\"#数组的空位\" class=\"headerlink\" title=\"数组的空位\"></a>数组的空位</h2><p>数组的某一个位置没有任何值。比如<code>Array</code>构造函数返回的数组都是空位。注意：空位不等于<code>undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>);<br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-literal\">undefined</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-literal\">undefined</span>)<br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>在ES6中会明确将空位转换为<code>undefined</code>， <code>copyWithin()</code>会将空位一起拷贝，<code>fill()</code>会将空位当做正常位置，循环也会迭代空位。总之ES6中会保留空位。由于空位的处理规则不统一，因此应当避免出现空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[...[<span class=\"hljs-string\">&#x27;a&#x27;</span>,,<span class=\"hljs-string\">&#x27;b&#x27;</span>]]<br><span class=\"hljs-comment\">// [&#x27;a&#x27;, undefined, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":3331,"excerpt":"","more":"<h1 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h1><h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p>用于将类似数组的对象和可遍历的对象（部署了Iterator接口）转换为数组。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arrayLike = &#123;<br>    <span class=\"hljs-string\">&#x27;0&#x27;</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;1&#x27;</span>: <span class=\"hljs-string\">&#x27;b&#x27;</span>,<br>    <span class=\"hljs-string\">&#x27;2&#x27;</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>,<br>    <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">3</span><br>&#125;;<br><br><span class=\"hljs-comment\">// ES5</span><br><span class=\"hljs-keyword\">var</span> arr1 = [].<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(arrayLike);<br><br><span class=\"hljs-comment\">// ES6</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(arrayLike); <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>实际应用中，常见的类似数组对象是DOM操作返回的NodeList集合以及函数内部arguments对象。Array.from都可以将它们转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> ps = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;p&#x27;</span>);<br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(ps).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">p</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p);<br>&#125;);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> args = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(args);<br>    <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-comment\">// [1, 2]</span><br><span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// 字符串和Set都部署了Iterator接口，所以可以用Array.from生成数组，这点和Java很像</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>); <span class=\"hljs-comment\">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class=\"hljs-keyword\">let</span> nameSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(nameSet) <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>除此之外，扩展运算符<code>...</code>也可以将某些数据结构转换为数组（注：扩展运算符跟Java中的多参数表达式功能类似）。扩展运算符背地也是调用Iterator接口，如果对象没有部署这个接口，则无法完成转换；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;<br>    <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>];<br>&#125;<br><br>[...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)]<br></code></pre></td></tr></table></figure>\n<h2 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h2><p>Array.of用于将一组值，转换为数组；这个方法的主要目的是弥补Array()方法的不足。因为参数个数的不同，会导致Array()的行为有差异。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// [3, 11, 8]</span><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// [3, 11, 8]</span><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [, , ,] 长度为3的空数组</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [3] 长度为1的数组，只有一个元素3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例的copyWithin\"><a href=\"#数组实例的copyWithin\" class=\"headerlink\" title=\"数组实例的copyWithin()\"></a>数组实例的copyWithin()</h2><p>在当前数组的内部，将指定位置的成员复制到其他位置，然后返回当前数组。也就是说该方法会修改当前数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">copyWithin</span>(target, start = <span class=\"hljs-number\">0</span>, end = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">length</span>)<br><span class=\"hljs-comment\">// target（必需）：从该位置开始替换数据</span><br><span class=\"hljs-comment\">// start（可选）：从该位置开始读取数据，默认为0，如果为负值则表示倒数；</span><br><span class=\"hljs-comment\">// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数；</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [4, 5, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例find-和findIndex\"><a href=\"#数组实例find-和findIndex\" class=\"headerlink\" title=\"数组实例find()和findIndex()\"></a>数组实例find()和findIndex()</h2><p><code>find()</code>方法用于找出第一个符合条件的数组成员。其第一个参数是回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没找到符合条件的成员则返回<code>undefined</code>。</p>\n<p><code>findIndex()</code>方法的作用与<code>find()</code>方法非常类似。这里就不再赘述。可以看出新增的两个方法极大地弥补了<code>indexOf()</code>方法的不足。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">5.</span> <span class=\"hljs-number\">10</span>].<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =&gt;</span> n &lt; <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -5</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>].<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, index, arr</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> value &gt; <span class=\"hljs-number\">9</span>;<br>&#125;); <span class=\"hljs-comment\">// 10</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>].<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, index, arr</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> value &gt; <span class=\"hljs-number\">9</span>;<br>&#125;) <span class=\"hljs-comment\">// 2（正好是元素10对应的数组索引）</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例fill\"><a href=\"#数组实例fill\" class=\"headerlink\" title=\"数组实例fill()\"></a>数组实例fill()</h2><p><code>fill()</code>可以使用给定值来填充数组，因此在初始化数组元素的过程中非常方便。</p>\n<p>初次之外，fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>].<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// [7, 7, 7]</span><br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// [7, 7, 7]</span><br><br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>].<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;7&#x27;, &#x27;c&#x27;] 用7填充，从1号位开始，到2号位结束</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例entries-keys-和values\"><a href=\"#数组实例entries-keys-和values\" class=\"headerlink\" title=\"数组实例entries(), keys()和values()\"></a>数组实例entries(), keys()和values()</h2><p>ES6新增了上述的3个方法，英语遍历数组。它们都是返回一个遍历器对象，可以使用<code>for...of</code>循环遍历，唯一区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值得遍历，<code>entries()</code>是对键值对的遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index)<br>&#125;<br><span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> elem <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(elem);<br>&#125;<br><span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [index, elem] <span class=\"hljs-keyword\">of</span> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index, elem);<br>&#125;<br><span class=\"hljs-comment\">// 0 &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// 1 &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组实例includes\"><a href=\"#数组实例includes\" class=\"headerlink\" title=\"数组实例includes()\"></a>数组实例includes()</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否是否已经包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但是Babel转码器已经支持。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// true</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// false</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">NaN</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>该方法还有第二个参数表示搜索的起始位置，默认为0 ，如果为负数则表示倒数位置。</p>\n<h2 id=\"数组的空位\"><a href=\"#数组的空位\" class=\"headerlink\" title=\"数组的空位\"></a>数组的空位</h2><p>数组的某一个位置没有任何值。比如<code>Array</code>构造函数返回的数组都是空位。注意：空位不等于<code>undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>);<br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-literal\">undefined</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-literal\">undefined</span>)<br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> arr <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>在ES6中会明确将空位转换为<code>undefined</code>， <code>copyWithin()</code>会将空位一起拷贝，<code>fill()</code>会将空位当做正常位置，循环也会迭代空位。总之ES6中会保留空位。由于空位的处理规则不统一，因此应当避免出现空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[...[<span class=\"hljs-string\">&#x27;a&#x27;</span>,,<span class=\"hljs-string\">&#x27;b&#x27;</span>]]<br><span class=\"hljs-comment\">// [&#x27;a&#x27;, undefined, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 异步操作","date":"2022-02-17T14:23:01.000Z","updated":"2022-02-17T14:23:01.000Z","_content":"\n# 异步操作和Async函数\n\n## 基本概念\n\n前面提到，JavaScript本身是不支持异步编程的，但是不支持异步处理，那么处理速度会特别慢。因此引入异步编程的特性便迫在眉睫。\n\n按照前面章节提到的，JS在异步编程中实现的方式有下面几个：\n\n- 回调函数\n- Promise\n- Generator函数 + 协程\n\n## Thunk函数\n\n简单来说：所谓的“船名调用”实现：就是将参数方法放到一个临时函数中，再将这个临时函数传入函数体，这个临时函数就称作“Thunk函数”：\n\n```javascript\nvar thunk = function() {\n  return x + 5;\n}\n\nfunction (thunk) {\n  return thunk() * 2;\n}\n```\n\n在JavaScript中函数替换的不是表达式，而是多参数函数，将其替换程单参数的版本。且只接受回调函数作为参数。因此，任何函数只要有回调函数，就可以写成Thunk函数的形式。\n\n```javascript\nvar thunk = function(fn) {\n\treturn function (...args) {\n    return function(callback) {\n      return fn.call(this, ...args, callback);\n    }\n  }\n}\n```\n\n举一个具体的例子：\n\n```javascript\nfunction f(a, b) {\n  cb(a);\n}\nlet ft = Thunk(f);\n\nlet log = console.log.bind(console);\nft(1)(log) // 1\n```\n\n## Thunkify模块\n\n生产环境下转换器，可以使用Thunkify模块。使用`npm install thunkify`安装；\n\n```javascript\nvar thunkify = require('thunkify');\nvar fs = require('fs');\n\nvar read = thunkify(rs.readFile);\nread('package.json')(function(err, str){\n  // concrete code\n});\n```\n\n## 看到这你可能会问，这有什么用？\n\n因为ES6现在新增了Generator函数，因此结合Thunk以后可以很好地管理Generartor流程。例子如下：\n\n```javascript\nvar fs = require('fs');\nvar thunkify = require('thunkify');\nvar readFile = thunkify(fs.readFile);\n\nvar gen = function* () {\n  var r1 = yield readFile('/etc/fstab');\n  console.log(r1.toString());\n  var r2 = yield readFile('/etc/shells');\n  console.log(r2.toString());\n}\n```\n\n上面的代码：yield命令用于将程序的执行权移出Generator函数。Thunk函数正好可以完成这个需求。\n\n## 还没结束\n\n看完上面，你可能已经知道Thunk函数现在可以做到什么事情：没错，Thunk函数的真正威力是：可以自动执行Generator函数。\n\n```javascript\nfunction run(fn) {\n  var gen = fn();\n  \n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n  \n  next();\n}\n\nfunction* g() {\n  // ...\n}\n\nrun(g);\n```\n\n有了上面的执行器，那么下面执行Generator函数就简单了很多。不关内部有多少个异步操作，直接把Generator函数传入run函数即可。前提是每一个异步操作都必须是Thunk函数。\n\n```javascript\nvar g = function* () {\n  var f1 = yield readFile('fileA');\n  var f2 = yield readFile('fileB');\n  // ...\n  var fn = yield readFile('fileN');\n}\n\nrun(g);\n```\n\n## CO模块\n\nco模块是著名程序员TJ Holowaychuk发布一个小工具，用于Generator函数的自动执行。有了co模块，你可以不必自己编写Generator函数的执行器。\n\n```javascript\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\nvar co = require('co');\nco(gen).then(function() {\n  console.log('Generator execute success.')\n});\n```\n\nco支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。\n\n```javascript\n// 数组写法\nco(function* (){\n  var res = yield [\n    Promise.resolve(1),\n    Promise.resolve(2)\n  ];\n  console.log(res);\n}).catch(onerror);\n\n// 对象写法\nco(function* (){\n  var res = yield {\n    1: Promise.resolve(1),\n    2: Promise.resolve(2)\n  };\n  console.log(res);\n}).catch(onerror);\n```\n\n## async函数\n\nES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话：async函数就是Generator函数的语法糖。\n\n```javascript\nvar asyncReadFile = async function() {\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n语法上来看，跟Generator函数的使用基本类似，但是在其基础上还是有一点改进：\n\n- （1）内置执行器：因此async函数执行和普通函数一样，只需要一行即可；\n- （2）更好的语义，这个一目了然；\n- （3）更广的适用性：即可支持Promise，也可以支持普通对象；\n- （4）返回值是Promise，因此可以使用then指定下一步操作；\n\n如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的对象会被catch方法回调接收到。\n\n```javascript\nasync function f() {\n  throw new Error('Wrong');\n}\n\nf().then(\n\tv => console.log(v),\n  e => console.log(e)\n)\n```\n\n其次：async函数返回的Promise对象，必须等到所有的await命令的Promise对象执行完，才发发生改变。\n\n```javascript\nasync function getTitle(url) {\n\tlet response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\n\ngetTitle('https://github.com/Humphrey75432').then(console.log);\n```\n\n### 注意点\n\n（1）`await`命令后面的`Promise`对象，运行结果可能是`reject`，所以最好把`await`命令放入`try...catch`块中。\n\n```javascript\nasync function myFunction() {\n    try {\n        await somethingThatReturnsAPromise();\n    } catch (err) {\n        console.log(err);\n    }\n}\n\n// Another grammar\n\nasync function myFunction() {\n    await somethingThatReturnsAPromise()\n    \t.catch(function (err) {\n        console.log(err);\n    });\n}\n```\n\n（2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。这样会提升执行效率\n\n```javascript\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// second grammar\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n```\n\n（3）如果确实希望多个请求并发执行，可以使用`Promise.all`方法。\n\n```javascript\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n","source":"_posts/javascript/es6-async-operate.md","raw":"---\ntitle: ES6 异步操作\ndate: 2022-02-17 22:23:01\nupdated: 2022-02-17 22:23:01\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 异步操作和Async函数\n\n## 基本概念\n\n前面提到，JavaScript本身是不支持异步编程的，但是不支持异步处理，那么处理速度会特别慢。因此引入异步编程的特性便迫在眉睫。\n\n按照前面章节提到的，JS在异步编程中实现的方式有下面几个：\n\n- 回调函数\n- Promise\n- Generator函数 + 协程\n\n## Thunk函数\n\n简单来说：所谓的“船名调用”实现：就是将参数方法放到一个临时函数中，再将这个临时函数传入函数体，这个临时函数就称作“Thunk函数”：\n\n```javascript\nvar thunk = function() {\n  return x + 5;\n}\n\nfunction (thunk) {\n  return thunk() * 2;\n}\n```\n\n在JavaScript中函数替换的不是表达式，而是多参数函数，将其替换程单参数的版本。且只接受回调函数作为参数。因此，任何函数只要有回调函数，就可以写成Thunk函数的形式。\n\n```javascript\nvar thunk = function(fn) {\n\treturn function (...args) {\n    return function(callback) {\n      return fn.call(this, ...args, callback);\n    }\n  }\n}\n```\n\n举一个具体的例子：\n\n```javascript\nfunction f(a, b) {\n  cb(a);\n}\nlet ft = Thunk(f);\n\nlet log = console.log.bind(console);\nft(1)(log) // 1\n```\n\n## Thunkify模块\n\n生产环境下转换器，可以使用Thunkify模块。使用`npm install thunkify`安装；\n\n```javascript\nvar thunkify = require('thunkify');\nvar fs = require('fs');\n\nvar read = thunkify(rs.readFile);\nread('package.json')(function(err, str){\n  // concrete code\n});\n```\n\n## 看到这你可能会问，这有什么用？\n\n因为ES6现在新增了Generator函数，因此结合Thunk以后可以很好地管理Generartor流程。例子如下：\n\n```javascript\nvar fs = require('fs');\nvar thunkify = require('thunkify');\nvar readFile = thunkify(fs.readFile);\n\nvar gen = function* () {\n  var r1 = yield readFile('/etc/fstab');\n  console.log(r1.toString());\n  var r2 = yield readFile('/etc/shells');\n  console.log(r2.toString());\n}\n```\n\n上面的代码：yield命令用于将程序的执行权移出Generator函数。Thunk函数正好可以完成这个需求。\n\n## 还没结束\n\n看完上面，你可能已经知道Thunk函数现在可以做到什么事情：没错，Thunk函数的真正威力是：可以自动执行Generator函数。\n\n```javascript\nfunction run(fn) {\n  var gen = fn();\n  \n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n  \n  next();\n}\n\nfunction* g() {\n  // ...\n}\n\nrun(g);\n```\n\n有了上面的执行器，那么下面执行Generator函数就简单了很多。不关内部有多少个异步操作，直接把Generator函数传入run函数即可。前提是每一个异步操作都必须是Thunk函数。\n\n```javascript\nvar g = function* () {\n  var f1 = yield readFile('fileA');\n  var f2 = yield readFile('fileB');\n  // ...\n  var fn = yield readFile('fileN');\n}\n\nrun(g);\n```\n\n## CO模块\n\nco模块是著名程序员TJ Holowaychuk发布一个小工具，用于Generator函数的自动执行。有了co模块，你可以不必自己编写Generator函数的执行器。\n\n```javascript\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\nvar co = require('co');\nco(gen).then(function() {\n  console.log('Generator execute success.')\n});\n```\n\nco支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。\n\n```javascript\n// 数组写法\nco(function* (){\n  var res = yield [\n    Promise.resolve(1),\n    Promise.resolve(2)\n  ];\n  console.log(res);\n}).catch(onerror);\n\n// 对象写法\nco(function* (){\n  var res = yield {\n    1: Promise.resolve(1),\n    2: Promise.resolve(2)\n  };\n  console.log(res);\n}).catch(onerror);\n```\n\n## async函数\n\nES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话：async函数就是Generator函数的语法糖。\n\n```javascript\nvar asyncReadFile = async function() {\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n语法上来看，跟Generator函数的使用基本类似，但是在其基础上还是有一点改进：\n\n- （1）内置执行器：因此async函数执行和普通函数一样，只需要一行即可；\n- （2）更好的语义，这个一目了然；\n- （3）更广的适用性：即可支持Promise，也可以支持普通对象；\n- （4）返回值是Promise，因此可以使用then指定下一步操作；\n\n如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的对象会被catch方法回调接收到。\n\n```javascript\nasync function f() {\n  throw new Error('Wrong');\n}\n\nf().then(\n\tv => console.log(v),\n  e => console.log(e)\n)\n```\n\n其次：async函数返回的Promise对象，必须等到所有的await命令的Promise对象执行完，才发发生改变。\n\n```javascript\nasync function getTitle(url) {\n\tlet response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\n\ngetTitle('https://github.com/Humphrey75432').then(console.log);\n```\n\n### 注意点\n\n（1）`await`命令后面的`Promise`对象，运行结果可能是`reject`，所以最好把`await`命令放入`try...catch`块中。\n\n```javascript\nasync function myFunction() {\n    try {\n        await somethingThatReturnsAPromise();\n    } catch (err) {\n        console.log(err);\n    }\n}\n\n// Another grammar\n\nasync function myFunction() {\n    await somethingThatReturnsAPromise()\n    \t.catch(function (err) {\n        console.log(err);\n    });\n}\n```\n\n（2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。这样会提升执行效率\n\n```javascript\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// second grammar\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n```\n\n（3）如果确实希望多个请求并发执行，可以使用`Promise.all`方法。\n\n```javascript\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n","slug":"javascript/es6-async-operate","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2u000r2y61hjka4qyw","content":"<h1 id=\"异步操作和Async函数\"><a href=\"#异步操作和Async函数\" class=\"headerlink\" title=\"异步操作和Async函数\"></a>异步操作和Async函数</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>前面提到，JavaScript本身是不支持异步编程的，但是不支持异步处理，那么处理速度会特别慢。因此引入异步编程的特性便迫在眉睫。</p>\n<p>按照前面章节提到的，JS在异步编程中实现的方式有下面几个：</p>\n<ul>\n<li>回调函数</li>\n<li>Promise</li>\n<li>Generator函数 + 协程</li>\n</ul>\n<h2 id=\"Thunk函数\"><a href=\"#Thunk函数\" class=\"headerlink\" title=\"Thunk函数\"></a>Thunk函数</h2><p>简单来说：所谓的“船名调用”实现：就是将参数方法放到一个临时函数中，再将这个临时函数传入函数体，这个临时函数就称作“Thunk函数”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunk = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">5</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thunk</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">thunk</span>() * <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在JavaScript中函数替换的不是表达式，而是多参数函数，将其替换程单参数的版本。且只接受回调函数作为参数。因此，任何函数只要有回调函数，就可以写成Thunk函数的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunk = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, ...args, callback);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>举一个具体的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-title function_\">cb</span>(a);<br>&#125;<br><span class=\"hljs-keyword\">let</span> ft = <span class=\"hljs-title class_\">Thunk</span>(f);<br><br><span class=\"hljs-keyword\">let</span> log = <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">console</span>);<br><span class=\"hljs-title function_\">ft</span>(<span class=\"hljs-number\">1</span>)(log) <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Thunkify模块\"><a href=\"#Thunkify模块\" class=\"headerlink\" title=\"Thunkify模块\"></a>Thunkify模块</h2><p>生产环境下转换器，可以使用Thunkify模块。使用<code>npm install thunkify</code>安装；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunkify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;thunkify&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><br><span class=\"hljs-keyword\">var</span> read = <span class=\"hljs-title function_\">thunkify</span>(rs.<span class=\"hljs-property\">readFile</span>);<br><span class=\"hljs-title function_\">read</span>(<span class=\"hljs-string\">&#x27;package.json&#x27;</span>)(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, str</span>)&#123;<br>  <span class=\"hljs-comment\">// concrete code</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"看到这你可能会问，这有什么用？\"><a href=\"#看到这你可能会问，这有什么用？\" class=\"headerlink\" title=\"看到这你可能会问，这有什么用？\"></a>看到这你可能会问，这有什么用？</h2><p>因为ES6现在新增了Generator函数，因此结合Thunk以后可以很好地管理Generartor流程。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> thunkify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;thunkify&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> readFile = <span class=\"hljs-title function_\">thunkify</span>(fs.<span class=\"hljs-property\">readFile</span>);<br><br><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> r1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-keyword\">var</span> r2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面的代码：yield命令用于将程序的执行权移出Generator函数。Thunk函数正好可以完成这个需求。</p>\n<h2 id=\"还没结束\"><a href=\"#还没结束\" class=\"headerlink\" title=\"还没结束\"></a>还没结束</h2><p>看完上面，你可能已经知道Thunk函数现在可以做到什么事情：没错，Thunk函数的真正威力是：可以自动执行Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-title function_\">fn</span>();<br>  <br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\">err, data</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = gen.<span class=\"hljs-title function_\">next</span>(data);<br>    <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">done</span>) <span class=\"hljs-keyword\">return</span>;<br>    result.<span class=\"hljs-title function_\">value</span>(next);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">next</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-title function_\">run</span>(g);<br></code></pre></td></tr></table></figure>\n<p>有了上面的执行器，那么下面执行Generator函数就简单了很多。不关内部有多少个异步操作，直接把Generator函数传入run函数即可。前提是每一个异步操作都必须是Thunk函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileA&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileB&#x27;</span>);<br>  <span class=\"hljs-comment\">// ...</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileN&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">run</span>(g);<br></code></pre></td></tr></table></figure>\n<h2 id=\"CO模块\"><a href=\"#CO模块\" class=\"headerlink\" title=\"CO模块\"></a>CO模块</h2><p>co模块是著名程序员TJ Holowaychuk发布一个小工具，用于Generator函数的自动执行。有了co模块，你可以不必自己编写Generator函数的执行器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> co = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;co&#x27;</span>);<br><span class=\"hljs-title function_\">co</span>(gen).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Generator execute success.&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 数组写法</span><br><span class=\"hljs-title function_\">co</span>(<span class=\"hljs-keyword\">function</span>* ()&#123;<br>  <span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-keyword\">yield</span> [<br>    <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>),<br>    <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">2</span>)<br>  ];<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);<br>&#125;).<span class=\"hljs-title function_\">catch</span>(onerror);<br><br><span class=\"hljs-comment\">// 对象写法</span><br><span class=\"hljs-title function_\">co</span>(<span class=\"hljs-keyword\">function</span>* ()&#123;<br>  <span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-keyword\">yield</span> &#123;<br>    <span class=\"hljs-number\">1</span>: <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>),<br>    <span class=\"hljs-number\">2</span>: <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">2</span>)<br>  &#125;;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);<br>&#125;).<span class=\"hljs-title function_\">catch</span>(onerror);<br></code></pre></td></tr></table></figure>\n<h2 id=\"async函数\"><a href=\"#async函数\" class=\"headerlink\" title=\"async函数\"></a>async函数</h2><p>ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话：async函数就是Generator函数的语法糖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> asyncReadFile = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>语法上来看，跟Generator函数的使用基本类似，但是在其基础上还是有一点改进：</p>\n<ul>\n<li>（1）内置执行器：因此async函数执行和普通函数一样，只需要一行即可；</li>\n<li>（2）更好的语义，这个一目了然；</li>\n<li>（3）更广的适用性：即可支持Promise，也可以支持普通对象；</li>\n<li>（4）返回值是Promise，因此可以使用then指定下一步操作；</li>\n</ul>\n<p>如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的对象会被catch方法回调接收到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Wrong&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>().<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v),<br>  <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e)<br>)<br></code></pre></td></tr></table></figure>\n<p>其次：async函数返回的Promise对象，必须等到所有的await命令的Promise对象执行完，才发发生改变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getTitle</span>(<span class=\"hljs-params\">url</span>) &#123;<br>\t<span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);<br>  <span class=\"hljs-keyword\">let</span> html = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">text</span>();<br>  <span class=\"hljs-keyword\">return</span> html.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"hljs-number\">1</span>];<br>&#125;<br><br><span class=\"hljs-title function_\">getTitle</span>(<span class=\"hljs-string\">&#x27;https://github.com/Humphrey75432&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>（1）<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>reject</code>，所以最好把<code>await</code>命令放入<code>try...catch</code>块中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">somethingThatReturnsAPromise</span>();<br>    &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// Another grammar</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">somethingThatReturnsAPromise</span>()<br>    \t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>（2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。这样会提升执行效率</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [foo, bar] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<span class=\"hljs-title function_\">getFoo</span>(), <span class=\"hljs-title function_\">getBar</span>()]);<br><br><span class=\"hljs-comment\">// second grammar</span><br><span class=\"hljs-keyword\">let</span> fooPromise = <span class=\"hljs-title function_\">getFoo</span>();<br><span class=\"hljs-keyword\">let</span> barPromise = <span class=\"hljs-title function_\">getBar</span>();<br><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-keyword\">await</span> fooPromise;<br><span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-keyword\">await</span> barPromise;<br></code></pre></td></tr></table></figure>\n<p>（3）如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dbFuc</span>(<span class=\"hljs-params\">db</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.<span class=\"hljs-title function_\">post</span>(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results);<br>&#125;<br><br><span class=\"hljs-comment\">// 或者使用下面的写法</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dbFuc</span>(<span class=\"hljs-params\">db</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.<span class=\"hljs-title function_\">post</span>(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = [];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> promise <span class=\"hljs-keyword\">of</span> promises) &#123;<br>    results.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-keyword\">await</span> promise);<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results);<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":4506,"excerpt":"","more":"<h1 id=\"异步操作和Async函数\"><a href=\"#异步操作和Async函数\" class=\"headerlink\" title=\"异步操作和Async函数\"></a>异步操作和Async函数</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>前面提到，JavaScript本身是不支持异步编程的，但是不支持异步处理，那么处理速度会特别慢。因此引入异步编程的特性便迫在眉睫。</p>\n<p>按照前面章节提到的，JS在异步编程中实现的方式有下面几个：</p>\n<ul>\n<li>回调函数</li>\n<li>Promise</li>\n<li>Generator函数 + 协程</li>\n</ul>\n<h2 id=\"Thunk函数\"><a href=\"#Thunk函数\" class=\"headerlink\" title=\"Thunk函数\"></a>Thunk函数</h2><p>简单来说：所谓的“船名调用”实现：就是将参数方法放到一个临时函数中，再将这个临时函数传入函数体，这个临时函数就称作“Thunk函数”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunk = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">5</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thunk</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">thunk</span>() * <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在JavaScript中函数替换的不是表达式，而是多参数函数，将其替换程单参数的版本。且只接受回调函数作为参数。因此，任何函数只要有回调函数，就可以写成Thunk函数的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunk = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, ...args, callback);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>举一个具体的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-title function_\">cb</span>(a);<br>&#125;<br><span class=\"hljs-keyword\">let</span> ft = <span class=\"hljs-title class_\">Thunk</span>(f);<br><br><span class=\"hljs-keyword\">let</span> log = <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">console</span>);<br><span class=\"hljs-title function_\">ft</span>(<span class=\"hljs-number\">1</span>)(log) <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Thunkify模块\"><a href=\"#Thunkify模块\" class=\"headerlink\" title=\"Thunkify模块\"></a>Thunkify模块</h2><p>生产环境下转换器，可以使用Thunkify模块。使用<code>npm install thunkify</code>安装；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> thunkify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;thunkify&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><br><span class=\"hljs-keyword\">var</span> read = <span class=\"hljs-title function_\">thunkify</span>(rs.<span class=\"hljs-property\">readFile</span>);<br><span class=\"hljs-title function_\">read</span>(<span class=\"hljs-string\">&#x27;package.json&#x27;</span>)(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, str</span>)&#123;<br>  <span class=\"hljs-comment\">// concrete code</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"看到这你可能会问，这有什么用？\"><a href=\"#看到这你可能会问，这有什么用？\" class=\"headerlink\" title=\"看到这你可能会问，这有什么用？\"></a>看到这你可能会问，这有什么用？</h2><p>因为ES6现在新增了Generator函数，因此结合Thunk以后可以很好地管理Generartor流程。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> thunkify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;thunkify&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> readFile = <span class=\"hljs-title function_\">thunkify</span>(fs.<span class=\"hljs-property\">readFile</span>);<br><br><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> r1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-keyword\">var</span> r2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(r2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面的代码：yield命令用于将程序的执行权移出Generator函数。Thunk函数正好可以完成这个需求。</p>\n<h2 id=\"还没结束\"><a href=\"#还没结束\" class=\"headerlink\" title=\"还没结束\"></a>还没结束</h2><p>看完上面，你可能已经知道Thunk函数现在可以做到什么事情：没错，Thunk函数的真正威力是：可以自动执行Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">run</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-title function_\">fn</span>();<br>  <br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\">err, data</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = gen.<span class=\"hljs-title function_\">next</span>(data);<br>    <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">done</span>) <span class=\"hljs-keyword\">return</span>;<br>    result.<span class=\"hljs-title function_\">value</span>(next);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">next</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-title function_\">run</span>(g);<br></code></pre></td></tr></table></figure>\n<p>有了上面的执行器，那么下面执行Generator函数就简单了很多。不关内部有多少个异步操作，直接把Generator函数传入run函数即可。前提是每一个异步操作都必须是Thunk函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileA&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileB&#x27;</span>);<br>  <span class=\"hljs-comment\">// ...</span><br>  <span class=\"hljs-keyword\">var</span> fn = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;fileN&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">run</span>(g);<br></code></pre></td></tr></table></figure>\n<h2 id=\"CO模块\"><a href=\"#CO模块\" class=\"headerlink\" title=\"CO模块\"></a>CO模块</h2><p>co模块是著名程序员TJ Holowaychuk发布一个小工具，用于Generator函数的自动执行。有了co模块，你可以不必自己编写Generator函数的执行器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> co = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;co&#x27;</span>);<br><span class=\"hljs-title function_\">co</span>(gen).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Generator execute success.&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 数组写法</span><br><span class=\"hljs-title function_\">co</span>(<span class=\"hljs-keyword\">function</span>* ()&#123;<br>  <span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-keyword\">yield</span> [<br>    <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>),<br>    <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">2</span>)<br>  ];<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);<br>&#125;).<span class=\"hljs-title function_\">catch</span>(onerror);<br><br><span class=\"hljs-comment\">// 对象写法</span><br><span class=\"hljs-title function_\">co</span>(<span class=\"hljs-keyword\">function</span>* ()&#123;<br>  <span class=\"hljs-keyword\">var</span> res = <span class=\"hljs-keyword\">yield</span> &#123;<br>    <span class=\"hljs-number\">1</span>: <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>),<br>    <span class=\"hljs-number\">2</span>: <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">2</span>)<br>  &#125;;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);<br>&#125;).<span class=\"hljs-title function_\">catch</span>(onerror);<br></code></pre></td></tr></table></figure>\n<h2 id=\"async函数\"><a href=\"#async函数\" class=\"headerlink\" title=\"async函数\"></a>async函数</h2><p>ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话：async函数就是Generator函数的语法糖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> asyncReadFile = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> f1 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/fstab&#x27;</span>);<br>  <span class=\"hljs-keyword\">var</span> f2 = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;/etc/shells&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f1.<span class=\"hljs-title function_\">toString</span>());<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f2.<span class=\"hljs-title function_\">toString</span>());<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>语法上来看，跟Generator函数的使用基本类似，但是在其基础上还是有一点改进：</p>\n<ul>\n<li>（1）内置执行器：因此async函数执行和普通函数一样，只需要一行即可；</li>\n<li>（2）更好的语义，这个一目了然；</li>\n<li>（3）更广的适用性：即可支持Promise，也可以支持普通对象；</li>\n<li>（4）返回值是Promise，因此可以使用then指定下一步操作；</li>\n</ul>\n<p>如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的对象会被catch方法回调接收到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Wrong&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>().<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v),<br>  <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e)<br>)<br></code></pre></td></tr></table></figure>\n<p>其次：async函数返回的Promise对象，必须等到所有的await命令的Promise对象执行完，才发发生改变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getTitle</span>(<span class=\"hljs-params\">url</span>) &#123;<br>\t<span class=\"hljs-keyword\">let</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);<br>  <span class=\"hljs-keyword\">let</span> html = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">text</span>();<br>  <span class=\"hljs-keyword\">return</span> html.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"hljs-number\">1</span>];<br>&#125;<br><br><span class=\"hljs-title function_\">getTitle</span>(<span class=\"hljs-string\">&#x27;https://github.com/Humphrey75432&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>（1）<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>reject</code>，所以最好把<code>await</code>命令放入<code>try...catch</code>块中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">somethingThatReturnsAPromise</span>();<br>    &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// Another grammar</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">somethingThatReturnsAPromise</span>()<br>    \t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>（2）多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。这样会提升执行效率</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [foo, bar] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<span class=\"hljs-title function_\">getFoo</span>(), <span class=\"hljs-title function_\">getBar</span>()]);<br><br><span class=\"hljs-comment\">// second grammar</span><br><span class=\"hljs-keyword\">let</span> fooPromise = <span class=\"hljs-title function_\">getFoo</span>();<br><span class=\"hljs-keyword\">let</span> barPromise = <span class=\"hljs-title function_\">getBar</span>();<br><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-keyword\">await</span> fooPromise;<br><span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-keyword\">await</span> barPromise;<br></code></pre></td></tr></table></figure>\n<p>（3）如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dbFuc</span>(<span class=\"hljs-params\">db</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.<span class=\"hljs-title function_\">post</span>(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results);<br>&#125;<br><br><span class=\"hljs-comment\">// 或者使用下面的写法</span><br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dbFuc</span>(<span class=\"hljs-params\">db</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br>  <span class=\"hljs-keyword\">let</span> promises = docs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">doc</span>) =&gt;</span> db.<span class=\"hljs-title function_\">post</span>(doc));<br><br>  <span class=\"hljs-keyword\">let</span> results = [];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> promise <span class=\"hljs-keyword\">of</span> promises) &#123;<br>    results.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-keyword\">await</span> promise);<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results);<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 类","date":"2022-02-17T14:21:01.000Z","updated":"2022-02-17T14:21:01.000Z","_content":"\n# ES6 Class\n\n## 基本概念\n\nES6为了使JavaScript更接近C++、Java等面向对象的高级语言，引入了Class的概念。语法角度来说Class仅仅是一个语法糖，其绝大部分功能都是ES5的实现。所以是对编程人员友好而设计的。有个例子能充分说明这个问题。\n\n```javascript\n// ES5\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype.toString = function() {\n    return '(' + this.x + ', ' + this.y + ')';\n}\n\nvar p = new Point(1, 2);\n\n// ES6 更加符合面向对象语言的习惯\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    toString() {\n        return '(' + this.x + ', ' + this.y + ')';\n    }\n}\nvar p = new Point(1, 2);\n```\n\n可以看出，调用类的实例方法，实际上就是调用对象的原型方法。那么对Object的操作对于Class完全适用。例如我可以使用Object.assign方法给类新增很多方法。\n\n```javascript\nclass Point {\n    constructor() {\n        // ...\n    }\n}\n\nObject.assign(Point.prototype, {\n    toString() {},\n    toValue() {}\n});\n```\n\n## constructor方法\n\n对象的构造函数，会在对象创建的时候调用，可以用来初始化对象的属性。除此之外，和C++/Java等语言不同的是，constructor中完全可以指定返回另外一个对象。\n\n```javascript\nclass Foo {\n    constructor() {\n        return Object.create(null);\n    }\n}\n\nnew Foo() instanceof Foo // false\n```\n\n## 类的实例对象\n\n需要使用`new`关键字来生成。如果忘记使用new关键字而是直接像使用函数那样使用Class会报错。和ES5一样，除非属性显示定义在其本身，否则都是定义在原型上的。\n\n```javascript\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n## 不存在变量提升\n\nClass不存在变量提升，这一点和ES5完全不同：由于ES6不会把类的声明提升到代码头部。必须保证子类在父类之后定义。\n\n## Class表达式\n\n与函数一样，类也可以使用表达式的形式定义。需要注明的是`const`关键字后面的才是真正的类名，而`class`后面的仅仅是内部类名，可以使用`this`关键字指代。\n\n```javascript\nconst MyClass = class Me {\n    getClassName() {\n        return Me.name;\n    }\n};\n```\n\n使用Class表达式，可以立即写出执行的Class\n\n```javascript\nlet person = new class {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    sayName() {\n        console.log(this.name);\n    }\n}('ZhangSan');\n\nperson.sayName(); // 'ZhangSan'\n```\n\n## 私有方法\n\n利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值，从而达到私有方法和私有属性的效果。\n\n```javascript\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass {\n    foo(baz) {\n        this[bar](baz);\n    }\n    \n    [bar](baz) {\n        return this[snaf] = baz;\n    }\n    \n    // ...\n}\n```\n\n## this的指向\n\n类的方法内部如果含有this，默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。\n\n```javascript\nclass Logger {\n    printName(name = 'there') {\n        this.print(`Hello ${name}`);\n    }\n    \n    print(text) {\n        console.log(text);\n    }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n```\n\n将printName提取出来使用会报错，因为默认情况下this是指向Logger类的实例。但是一旦将该方法提起出来单独使用，this就会指向该方法运行时所在的环境。为了解决这个问题可以使用下面两种方法。\n\n```javascript\n// 在构造函数中重新自动this关键字的指向\nclass Logger {\n    constructor(){\n        this.printName = this.printName.bind(this);\n    }\n}\n\n// 使用箭头函数来改变this关键字的指向\nclass Logger {\n    constructor() {\n        this.printName = (name = 'there') => {\n            this.print(`Hello ${name}`);\n        };\n    }\n}\n```\n\n还有一种方法是使用Proxy，获取方法的时候自动绑定this.\n\n```javascript\nfunction selfish(target) {\n    const cache = new WeakMap();\n    const handler = {\n        get(target, key){\n            const value = Reflect.get(target, key);\n            if (typeof value !== 'function') {\n                return value;\n            }\n            if (!cache.has(value)) {\n                cache.set(value, value.bind(target));\n            }\n            return cache.get(value);\n        }\n    };\n    const proxy = new Proxy(target, handler);\n    return proxy;\n}\n\nconst logger = selfish(new Logger());\n```\n\n## 严格模式\n\n类和模块的内部默认使用的就是严格模式，所以不需要显式指定。\n\n## Class继承\n\n### 基本用法\n\n和其他高级编程语言（C++，Java）一样，ES6也提供了类似`extends`关键字来实现继承。\n\n```javascript\nclass ColorPoint extends Point {}\n```\n\n需要注意的是：在子类的构造函数中，只有调用`super`关键字以后才可以使用`this`关键字，否则会报错。这是因为子类实例的构建是基于对父类的加工，因此只有super方法才能但会父类实例。\n\n```javascript\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y);\n        ths.color = color;\n    }\n}\n```\n\n## 类的prototype属性和\\_\\_proto\\_\\_属性\n\nClass作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。\n\n（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类；\n\n（2）子类的prototype属性和`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。\n\n```javascript\nclass A {\n    \n}\n\nclass B extends A {\n    \n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n```\n\n因此可以这样理解：作为一个对象，子类B的原型(\\_\\_proto\\_\\_)是父类A；作为一个构造函数，子类B的原型(prototype.\\_\\_proto\\_\\_)是父类A的实例；\n\n## super关键字\n\n`super`既可以当函数使用，也可以当对象使用，两种情况下的使用方法完全不同；\n\n### 当函数使用\n\n这个很简单：作为函数调用时，代表的是父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数。\n\n### 当对象使用\n\nsuper作为对象时，指向的是父类的原型对象。例子如下：\n\n```javascript\nclass A {\n    p() {\n        return 2;\n    }\n}\n\nclass B extends A {\n    constructor() {\n        super();\n        console.log(super.p());\n    }\n}\n\nlet b = new B();\n```\n\n这个时候子类B当中的`super.p()`就是将super当做一个对象使用。所以`super`指向的是`A.prototype`，所以`super.p()`就相当于`A.prototype.p()`。需要注意的是：由于`super`指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过`super`调用的。\n\n```javascript\nclass A {\n    constructor() {\n        this.p = 2;\n    }\n}\n\nclass B extends A {\n    get m() {\n        return super.p;\n    }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n如果是定义在父类原型上，`super`就可以取到。\n\n```javascript\nclass A {}\nA.prototype.x = 2;\n\nclass B extends A {\n    constructor() {\n        super();\n        console.log(super.x) // 2\n    }\n}\n\nlet b = new B();\n```\n\n上面代码中，由于属性x是定义在A.prototype上面的，因此super.x就可以取到它的值。\n\n## Class的取值函数（getter）和存值函数（setter）\n\n和其他高级语言一样，可以使用get、set关键字，对某个属性设置存值和取值函数，拦截该属性的存取行为。\n\n```javascript\nclass MyClass {\n    constructor() {\n        // ...\n    }\n    \n    get prop() {\n        return 'getter';\n    }\n    \n    set prop(value) {\n        console.log('setter: ' + value);\n    }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n\ninst.prop // 123\n```\n\n## Class的Generator方法\n\n如果某个方法之前加上星号，就表示该方法是一个Generator函数。\n\n```javascript\nclass Foo {\n    constructor(...args) {\n        this.args = args;\n    }\n    \n    * [Symbol.iterator]() {\n        for (let arg of this.arg) {\n            yield arg;\n        }\n    }\n}\n\nfor (let x of new Foo('hello', 'world')) {\n    console.log(x);\n}\n// hello\n// world\n```\n\n## Class的静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称之为静态方法。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n\n父类的静态方法可以被子类继承。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod(); // 'hello'\n```\n\n## Class的静态属性和实例属性\n\n静态属性指的是Class本身的属性，即`Class.propname`，而不是定义在实例对象（`this`)上的属性。目前Babel转码器提供了这两种写法的支持。\n\n- 类的实例属性\n\n  类的实例属性可以用等式，写入类的定义之中\n\n  ```javascript\n  class ReactCounter extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        count: 0\n      };\n    }\n    state;\n  }\n  ```\n\n- 类的静态属性\n\n类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。\n\n```javascript\nclass MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myProp); // 42\n  }\n}\n```\n\n## new.target属性\n\n`new`是从构造函数生成实例的命令，ES6为了`new`命令引入了一个`new.target`属性，返回`new`命令作用于那个构造函数。如果构造函数不是通过`new`命令调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是如何调用的。\n\n```javascript\nfunction Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n\n## Mixin模式的实现\n\nMixin模式指的是，将多个类的接口“混入”另一个类，在ES6的实现如下。\n\n```javascript\nfunction mix(...mixins) {\n  class Mix {}\n\n  for (let mixin of mixins) {\n    copyProperties(Mix, mixin);\n    copyProperties(Mix.prototype, mixin.prototype);\n  }\n\n  return Mix;\n}\n\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if ( key !== \"constructor\"\n      && key !== \"prototype\"\n      && key !== \"name\"\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n```\n","source":"_posts/javascript/es6-class.md","raw":"---\ntitle: ES6 类\ndate: 2022-02-17 22:21:01\nupdated: 2022-02-17 22:21:01\ntags: ES6基础\ncategories: JavaScript\n---\n\n# ES6 Class\n\n## 基本概念\n\nES6为了使JavaScript更接近C++、Java等面向对象的高级语言，引入了Class的概念。语法角度来说Class仅仅是一个语法糖，其绝大部分功能都是ES5的实现。所以是对编程人员友好而设计的。有个例子能充分说明这个问题。\n\n```javascript\n// ES5\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype.toString = function() {\n    return '(' + this.x + ', ' + this.y + ')';\n}\n\nvar p = new Point(1, 2);\n\n// ES6 更加符合面向对象语言的习惯\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    toString() {\n        return '(' + this.x + ', ' + this.y + ')';\n    }\n}\nvar p = new Point(1, 2);\n```\n\n可以看出，调用类的实例方法，实际上就是调用对象的原型方法。那么对Object的操作对于Class完全适用。例如我可以使用Object.assign方法给类新增很多方法。\n\n```javascript\nclass Point {\n    constructor() {\n        // ...\n    }\n}\n\nObject.assign(Point.prototype, {\n    toString() {},\n    toValue() {}\n});\n```\n\n## constructor方法\n\n对象的构造函数，会在对象创建的时候调用，可以用来初始化对象的属性。除此之外，和C++/Java等语言不同的是，constructor中完全可以指定返回另外一个对象。\n\n```javascript\nclass Foo {\n    constructor() {\n        return Object.create(null);\n    }\n}\n\nnew Foo() instanceof Foo // false\n```\n\n## 类的实例对象\n\n需要使用`new`关键字来生成。如果忘记使用new关键字而是直接像使用函数那样使用Class会报错。和ES5一样，除非属性显示定义在其本身，否则都是定义在原型上的。\n\n```javascript\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n## 不存在变量提升\n\nClass不存在变量提升，这一点和ES5完全不同：由于ES6不会把类的声明提升到代码头部。必须保证子类在父类之后定义。\n\n## Class表达式\n\n与函数一样，类也可以使用表达式的形式定义。需要注明的是`const`关键字后面的才是真正的类名，而`class`后面的仅仅是内部类名，可以使用`this`关键字指代。\n\n```javascript\nconst MyClass = class Me {\n    getClassName() {\n        return Me.name;\n    }\n};\n```\n\n使用Class表达式，可以立即写出执行的Class\n\n```javascript\nlet person = new class {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    sayName() {\n        console.log(this.name);\n    }\n}('ZhangSan');\n\nperson.sayName(); // 'ZhangSan'\n```\n\n## 私有方法\n\n利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值，从而达到私有方法和私有属性的效果。\n\n```javascript\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass {\n    foo(baz) {\n        this[bar](baz);\n    }\n    \n    [bar](baz) {\n        return this[snaf] = baz;\n    }\n    \n    // ...\n}\n```\n\n## this的指向\n\n类的方法内部如果含有this，默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。\n\n```javascript\nclass Logger {\n    printName(name = 'there') {\n        this.print(`Hello ${name}`);\n    }\n    \n    print(text) {\n        console.log(text);\n    }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n```\n\n将printName提取出来使用会报错，因为默认情况下this是指向Logger类的实例。但是一旦将该方法提起出来单独使用，this就会指向该方法运行时所在的环境。为了解决这个问题可以使用下面两种方法。\n\n```javascript\n// 在构造函数中重新自动this关键字的指向\nclass Logger {\n    constructor(){\n        this.printName = this.printName.bind(this);\n    }\n}\n\n// 使用箭头函数来改变this关键字的指向\nclass Logger {\n    constructor() {\n        this.printName = (name = 'there') => {\n            this.print(`Hello ${name}`);\n        };\n    }\n}\n```\n\n还有一种方法是使用Proxy，获取方法的时候自动绑定this.\n\n```javascript\nfunction selfish(target) {\n    const cache = new WeakMap();\n    const handler = {\n        get(target, key){\n            const value = Reflect.get(target, key);\n            if (typeof value !== 'function') {\n                return value;\n            }\n            if (!cache.has(value)) {\n                cache.set(value, value.bind(target));\n            }\n            return cache.get(value);\n        }\n    };\n    const proxy = new Proxy(target, handler);\n    return proxy;\n}\n\nconst logger = selfish(new Logger());\n```\n\n## 严格模式\n\n类和模块的内部默认使用的就是严格模式，所以不需要显式指定。\n\n## Class继承\n\n### 基本用法\n\n和其他高级编程语言（C++，Java）一样，ES6也提供了类似`extends`关键字来实现继承。\n\n```javascript\nclass ColorPoint extends Point {}\n```\n\n需要注意的是：在子类的构造函数中，只有调用`super`关键字以后才可以使用`this`关键字，否则会报错。这是因为子类实例的构建是基于对父类的加工，因此只有super方法才能但会父类实例。\n\n```javascript\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y);\n        ths.color = color;\n    }\n}\n```\n\n## 类的prototype属性和\\_\\_proto\\_\\_属性\n\nClass作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。\n\n（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类；\n\n（2）子类的prototype属性和`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。\n\n```javascript\nclass A {\n    \n}\n\nclass B extends A {\n    \n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n```\n\n因此可以这样理解：作为一个对象，子类B的原型(\\_\\_proto\\_\\_)是父类A；作为一个构造函数，子类B的原型(prototype.\\_\\_proto\\_\\_)是父类A的实例；\n\n## super关键字\n\n`super`既可以当函数使用，也可以当对象使用，两种情况下的使用方法完全不同；\n\n### 当函数使用\n\n这个很简单：作为函数调用时，代表的是父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数。\n\n### 当对象使用\n\nsuper作为对象时，指向的是父类的原型对象。例子如下：\n\n```javascript\nclass A {\n    p() {\n        return 2;\n    }\n}\n\nclass B extends A {\n    constructor() {\n        super();\n        console.log(super.p());\n    }\n}\n\nlet b = new B();\n```\n\n这个时候子类B当中的`super.p()`就是将super当做一个对象使用。所以`super`指向的是`A.prototype`，所以`super.p()`就相当于`A.prototype.p()`。需要注意的是：由于`super`指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过`super`调用的。\n\n```javascript\nclass A {\n    constructor() {\n        this.p = 2;\n    }\n}\n\nclass B extends A {\n    get m() {\n        return super.p;\n    }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\n如果是定义在父类原型上，`super`就可以取到。\n\n```javascript\nclass A {}\nA.prototype.x = 2;\n\nclass B extends A {\n    constructor() {\n        super();\n        console.log(super.x) // 2\n    }\n}\n\nlet b = new B();\n```\n\n上面代码中，由于属性x是定义在A.prototype上面的，因此super.x就可以取到它的值。\n\n## Class的取值函数（getter）和存值函数（setter）\n\n和其他高级语言一样，可以使用get、set关键字，对某个属性设置存值和取值函数，拦截该属性的存取行为。\n\n```javascript\nclass MyClass {\n    constructor() {\n        // ...\n    }\n    \n    get prop() {\n        return 'getter';\n    }\n    \n    set prop(value) {\n        console.log('setter: ' + value);\n    }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n\ninst.prop // 123\n```\n\n## Class的Generator方法\n\n如果某个方法之前加上星号，就表示该方法是一个Generator函数。\n\n```javascript\nclass Foo {\n    constructor(...args) {\n        this.args = args;\n    }\n    \n    * [Symbol.iterator]() {\n        for (let arg of this.arg) {\n            yield arg;\n        }\n    }\n}\n\nfor (let x of new Foo('hello', 'world')) {\n    console.log(x);\n}\n// hello\n// world\n```\n\n## Class的静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称之为静态方法。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n\n父类的静态方法可以被子类继承。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod(); // 'hello'\n```\n\n## Class的静态属性和实例属性\n\n静态属性指的是Class本身的属性，即`Class.propname`，而不是定义在实例对象（`this`)上的属性。目前Babel转码器提供了这两种写法的支持。\n\n- 类的实例属性\n\n  类的实例属性可以用等式，写入类的定义之中\n\n  ```javascript\n  class ReactCounter extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        count: 0\n      };\n    }\n    state;\n  }\n  ```\n\n- 类的静态属性\n\n类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。\n\n```javascript\nclass MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myProp); // 42\n  }\n}\n```\n\n## new.target属性\n\n`new`是从构造函数生成实例的命令，ES6为了`new`命令引入了一个`new.target`属性，返回`new`命令作用于那个构造函数。如果构造函数不是通过`new`命令调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是如何调用的。\n\n```javascript\nfunction Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n\n## Mixin模式的实现\n\nMixin模式指的是，将多个类的接口“混入”另一个类，在ES6的实现如下。\n\n```javascript\nfunction mix(...mixins) {\n  class Mix {}\n\n  for (let mixin of mixins) {\n    copyProperties(Mix, mixin);\n    copyProperties(Mix.prototype, mixin.prototype);\n  }\n\n  return Mix;\n}\n\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if ( key !== \"constructor\"\n      && key !== \"prototype\"\n      && key !== \"name\"\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n```\n","slug":"javascript/es6-class","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2v000u2y6159xu9gcu","content":"<h1 id=\"ES6-Class\"><a href=\"#ES6-Class\" class=\"headerlink\" title=\"ES6 Class\"></a>ES6 Class</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>ES6为了使JavaScript更接近C++、Java等面向对象的高级语言，引入了Class的概念。语法角度来说Class仅仅是一个语法糖，其绝大部分功能都是ES5的实现。所以是对编程人员友好而设计的。有个例子能充分说明这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Point</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>&#125;<br><br><span class=\"hljs-title class_\">Point</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-comment\">// ES6 更加符合面向对象语言的习惯</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>可以看出，调用类的实例方法，实际上就是调用对象的原型方法。那么对Object的操作对于Class完全适用。例如我可以使用Object.assign方法给类新增很多方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">Point</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, &#123;<br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;&#125;,<br>    <span class=\"hljs-title function_\">toValue</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h2><p>对象的构造函数，会在对象创建的时候调用，可以用来初始化对象的属性。除此之外，和C++/Java等语言不同的是，constructor中完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Foo</span> <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"类的实例对象\"><a href=\"#类的实例对象\" class=\"headerlink\" title=\"类的实例对象\"></a>类的实例对象</h2><p>需要使用<code>new</code>关键字来生成。如果忘记使用new关键字而是直接像使用函数那样使用Class会报错。和ES5一样，除非属性显示定义在其本身，否则都是定义在原型上的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//定义类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>  &#125;<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> point = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><br>point.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// (2, 3)</span><br><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;y&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;toString&#x27;</span>) <span class=\"hljs-comment\">// false</span><br>point.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;toString&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h2><p>Class不存在变量提升，这一点和ES5完全不同：由于ES6不会把类的声明提升到代码头部。必须保证子类在父类之后定义。</p>\n<h2 id=\"Class表达式\"><a href=\"#Class表达式\" class=\"headerlink\" title=\"Class表达式\"></a>Class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。需要注明的是<code>const</code>关键字后面的才是真正的类名，而<code>class</code>后面的仅仅是内部类名，可以使用<code>this</code>关键字指代。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MyClass</span> = <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Me</span> &#123;<br>    <span class=\"hljs-title function_\">getClassName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Me</span>.<span class=\"hljs-property\">name</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>使用Class表达式，可以立即写出执行的Class</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">class</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">sayName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;<br>&#125;(<span class=\"hljs-string\">&#x27;ZhangSan&#x27;</span>);<br><br>person.<span class=\"hljs-title function_\">sayName</span>(); <span class=\"hljs-comment\">// &#x27;ZhangSan&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h2><p>利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值，从而达到私有方法和私有属性的效果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> snaf = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;snaf&#x27;</span>);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myClass</span> &#123;<br>    <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">baz</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[bar](baz);<br>    &#125;<br>    <br>    [bar](baz) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>[snaf] = baz;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p>类的方法内部如果含有this，默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">printName</span>(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&#x27;there&#x27;</span></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>);<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\">text</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(text);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>();<br><span class=\"hljs-keyword\">const</span> &#123; printName &#125; = logger;<br><span class=\"hljs-title function_\">printName</span>(); <span class=\"hljs-comment\">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span><br></code></pre></td></tr></table></figure>\n<p>将printName提取出来使用会报错，因为默认情况下this是指向Logger类的实例。但是一旦将该方法提起出来单独使用，this就会指向该方法运行时所在的环境。为了解决这个问题可以使用下面两种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 在构造函数中重新自动this关键字的指向</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用箭头函数来改变this关键字的指向</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&#x27;there&#x27;</span></span>) =&gt;</span> &#123;<br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>还有一种方法是使用Proxy，获取方法的时候自动绑定this.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">selfish</span>(<span class=\"hljs-params\">target</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br>    <span class=\"hljs-keyword\">const</span> handler = &#123;<br>        <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, key</span>)&#123;<br>            <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key);<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> value !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>                <span class=\"hljs-keyword\">return</span> value;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (!cache.<span class=\"hljs-title function_\">has</span>(value)) &#123;<br>                cache.<span class=\"hljs-title function_\">set</span>(value, value.<span class=\"hljs-title function_\">bind</span>(target));<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> cache.<span class=\"hljs-title function_\">get</span>(value);<br>        &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br>    <span class=\"hljs-keyword\">return</span> proxy;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-title function_\">selfish</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>());<br></code></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>类和模块的内部默认使用的就是严格模式，所以不需要显式指定。</p>\n<h2 id=\"Class继承\"><a href=\"#Class继承\" class=\"headerlink\" title=\"Class继承\"></a>Class继承</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>和其他高级编程语言（C++，Java）一样，ES6也提供了类似<code>extends</code>关键字来实现继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Point</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：在子类的构造函数中，只有调用<code>super</code>关键字以后才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建是基于对父类的加工，因此只有super方法才能但会父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y, color</span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>(x, y);<br>        ths.<span class=\"hljs-property\">color</span> = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"类的prototype属性和-proto-属性\"><a href=\"#类的prototype属性和-proto-属性\" class=\"headerlink\" title=\"类的prototype属性和__proto__属性\"></a>类的prototype属性和__proto__属性</h2><p>Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>\n<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类；</p>\n<p>（2）子类的prototype属性和<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <br>&#125;<br><br>B.<span class=\"hljs-property\">__proto__</span> === A <span class=\"hljs-comment\">// true</span><br>B.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> === A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>因此可以这样理解：作为一个对象，子类B的原型(__proto__)是父类A；作为一个构造函数，子类B的原型(prototype.__proto__)是父类A的实例；</p>\n<h2 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h2><p><code>super</code>既可以当函数使用，也可以当对象使用，两种情况下的使用方法完全不同；</p>\n<h3 id=\"当函数使用\"><a href=\"#当函数使用\" class=\"headerlink\" title=\"当函数使用\"></a>当函数使用</h3><p>这个很简单：作为函数调用时，代表的是父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数。</p>\n<h3 id=\"当对象使用\"><a href=\"#当对象使用\" class=\"headerlink\" title=\"当对象使用\"></a>当对象使用</h3><p>super作为对象时，指向的是父类的原型对象。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-title function_\">p</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>();<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">p</span>());<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br></code></pre></td></tr></table></figure>\n<p>这个时候子类B当中的<code>super.p()</code>就是将super当做一个对象使用。所以<code>super</code>指向的是<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。需要注意的是：由于<code>super</code>指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">p</span> = <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">m</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">p</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br>b.<span class=\"hljs-property\">m</span> <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>如果是定义在父类原型上，<code>super</code>就可以取到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;&#125;<br>A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">2</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>();<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">x</span>) <span class=\"hljs-comment\">// 2</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br></code></pre></td></tr></table></figure>\n<p>上面代码中，由于属性x是定义在A.prototype上面的，因此super.x就可以取到它的值。</p>\n<h2 id=\"Class的取值函数（getter）和存值函数（setter）\"><a href=\"#Class的取值函数（getter）和存值函数（setter）\" class=\"headerlink\" title=\"Class的取值函数（getter）和存值函数（setter）\"></a>Class的取值函数（getter）和存值函数（setter）</h2><p>和其他高级语言一样，可以使用get、set关键字，对某个属性设置存值和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">prop</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;getter&#x27;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-params\">value</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;setter: &#x27;</span> + value);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> inst = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClass</span>();<br><br>inst.<span class=\"hljs-property\">prop</span> = <span class=\"hljs-number\">123</span>;<br><br>inst.<span class=\"hljs-property\">prop</span> <span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的Generator方法\"><a href=\"#Class的Generator方法\" class=\"headerlink\" title=\"Class的Generator方法\"></a>Class的Generator方法</h2><p>如果某个方法之前加上星号，就表示该方法是一个Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">args</span> = args;<br>    &#125;<br>    <br>    * [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> arg <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">arg</span>) &#123;<br>            <span class=\"hljs-keyword\">yield</span> arg;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br><span class=\"hljs-comment\">// hello</span><br><span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的静态方法\"><a href=\"#Class的静态方法\" class=\"headerlink\" title=\"Class的静态方法\"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称之为静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">classMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-title class_\">Foo</span>.<span class=\"hljs-title function_\">classMethod</span>() <span class=\"hljs-comment\">// &#x27;hello&#x27;</span><br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>();<br>foo.<span class=\"hljs-title function_\">classMethod</span>()<br><span class=\"hljs-comment\">// TypeError: foo.classMethod is not a function</span><br></code></pre></td></tr></table></figure>\n<p>父类的静态方法可以被子类继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">classMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bar</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Foo</span> &#123;<br>&#125;<br><br><span class=\"hljs-title class_\">Bar</span>.<span class=\"hljs-title function_\">classMethod</span>(); <span class=\"hljs-comment\">// &#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的静态属性和实例属性\"><a href=\"#Class的静态属性和实例属性\" class=\"headerlink\" title=\"Class的静态属性和实例属性\"></a>Class的静态属性和实例属性</h2><p>静态属性指的是Class本身的属性，即<code>Class.propname</code>，而不是定义在实例对象（<code>this</code>)上的属性。目前Babel转码器提供了这两种写法的支持。</p>\n<ul>\n<li><p>类的实例属性</p>\n<p>类的实例属性可以用等式，写入类的定义之中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ReactCounter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props</span>) &#123;<br>    <span class=\"hljs-variable language_\">super</span>(props);<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;;<br>  &#125;<br>  state;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>类的静态属性</p>\n</li>\n</ul>\n<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> myStaticProp = <span class=\"hljs-number\">42</span>;<br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\">myProp</span>); <span class=\"hljs-comment\">// 42</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"new-target属性\"><a href=\"#new-target属性\" class=\"headerlink\" title=\"new.target属性\"></a>new.target属性</h2><p><code>new</code>是从构造函数生成实例的命令，ES6为了<code>new</code>命令引入了一个<code>new.target</code>属性，返回<code>new</code>命令作用于那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是如何调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span> !== <span class=\"hljs-literal\">undefined</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;必须使用new生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span> === <span class=\"hljs-title class_\">Person</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;必须使用new生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;张三&#x27;</span>); <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">var</span> notAPerson = <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(person, <span class=\"hljs-string\">&#x27;张三&#x27;</span>);  <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Mixin模式的实现\"><a href=\"#Mixin模式的实现\" class=\"headerlink\" title=\"Mixin模式的实现\"></a>Mixin模式的实现</h2><p>Mixin模式指的是，将多个类的接口“混入”另一个类，在ES6的实现如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mix</span>(<span class=\"hljs-params\">...mixins</span>) &#123;<br>  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mix</span> &#123;&#125;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> mixin <span class=\"hljs-keyword\">of</span> mixins) &#123;<br>    <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-title class_\">Mix</span>, mixin);<br>    <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-title class_\">Mix</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, mixin.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Mix</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-params\">target, source</span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(source)) &#123;<br>    <span class=\"hljs-keyword\">if</span> ( key !== <span class=\"hljs-string\">&quot;constructor&quot;</span><br>      &amp;&amp; key !== <span class=\"hljs-string\">&quot;prototype&quot;</span><br>      &amp;&amp; key !== <span class=\"hljs-string\">&quot;name&quot;</span><br>    ) &#123;<br>      <span class=\"hljs-keyword\">let</span> desc = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(source, key);<br>      <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, key, desc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":7570,"excerpt":"","more":"<h1 id=\"ES6-Class\"><a href=\"#ES6-Class\" class=\"headerlink\" title=\"ES6 Class\"></a>ES6 Class</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>ES6为了使JavaScript更接近C++、Java等面向对象的高级语言，引入了Class的概念。语法角度来说Class仅仅是一个语法糖，其绝大部分功能都是ES5的实现。所以是对编程人员友好而设计的。有个例子能充分说明这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Point</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>&#125;<br><br><span class=\"hljs-title class_\">Point</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-comment\">// ES6 更加符合面向对象语言的习惯</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p>可以看出，调用类的实例方法，实际上就是调用对象的原型方法。那么对Object的操作对于Class完全适用。例如我可以使用Object.assign方法给类新增很多方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">Point</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, &#123;<br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;&#125;,<br>    <span class=\"hljs-title function_\">toValue</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h2><p>对象的构造函数，会在对象创建的时候调用，可以用来初始化对象的属性。除此之外，和C++/Java等语言不同的是，constructor中完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>() <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Foo</span> <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"类的实例对象\"><a href=\"#类的实例对象\" class=\"headerlink\" title=\"类的实例对象\"></a>类的实例对象</h2><p>需要使用<code>new</code>关键字来生成。如果忘记使用new关键字而是直接像使用函数那样使用Class会报错。和ES5一样，除非属性显示定义在其本身，否则都是定义在原型上的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//定义类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> + <span class=\"hljs-string\">&#x27;, &#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;<br>  &#125;<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> point = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><br>point.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// (2, 3)</span><br><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;y&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>point.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;toString&#x27;</span>) <span class=\"hljs-comment\">// false</span><br>point.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">&#x27;toString&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h2><p>Class不存在变量提升，这一点和ES5完全不同：由于ES6不会把类的声明提升到代码头部。必须保证子类在父类之后定义。</p>\n<h2 id=\"Class表达式\"><a href=\"#Class表达式\" class=\"headerlink\" title=\"Class表达式\"></a>Class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。需要注明的是<code>const</code>关键字后面的才是真正的类名，而<code>class</code>后面的仅仅是内部类名，可以使用<code>this</code>关键字指代。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MyClass</span> = <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Me</span> &#123;<br>    <span class=\"hljs-title function_\">getClassName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Me</span>.<span class=\"hljs-property\">name</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>使用Class表达式，可以立即写出执行的Class</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">class</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">sayName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;<br>&#125;(<span class=\"hljs-string\">&#x27;ZhangSan&#x27;</span>);<br><br>person.<span class=\"hljs-title function_\">sayName</span>(); <span class=\"hljs-comment\">// &#x27;ZhangSan&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h2><p>利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值，从而达到私有方法和私有属性的效果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> snaf = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;snaf&#x27;</span>);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myClass</span> &#123;<br>    <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">baz</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[bar](baz);<br>    &#125;<br>    <br>    [bar](baz) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>[snaf] = baz;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p>类的方法内部如果含有this，默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">printName</span>(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&#x27;there&#x27;</span></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>);<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\">text</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(text);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>();<br><span class=\"hljs-keyword\">const</span> &#123; printName &#125; = logger;<br><span class=\"hljs-title function_\">printName</span>(); <span class=\"hljs-comment\">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span><br></code></pre></td></tr></table></figure>\n<p>将printName提取出来使用会报错，因为默认情况下this是指向Logger类的实例。但是一旦将该方法提起出来单独使用，this就会指向该方法运行时所在的环境。为了解决这个问题可以使用下面两种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 在构造函数中重新自动this关键字的指向</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 使用箭头函数来改变this关键字的指向</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">printName</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&#x27;there&#x27;</span></span>) =&gt;</span> &#123;<br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>还有一种方法是使用Proxy，获取方法的时候自动绑定this.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">selfish</span>(<span class=\"hljs-params\">target</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br>    <span class=\"hljs-keyword\">const</span> handler = &#123;<br>        <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, key</span>)&#123;<br>            <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key);<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> value !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>                <span class=\"hljs-keyword\">return</span> value;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (!cache.<span class=\"hljs-title function_\">has</span>(value)) &#123;<br>                cache.<span class=\"hljs-title function_\">set</span>(value, value.<span class=\"hljs-title function_\">bind</span>(target));<br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> cache.<span class=\"hljs-title function_\">get</span>(value);<br>        &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br>    <span class=\"hljs-keyword\">return</span> proxy;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> logger = <span class=\"hljs-title function_\">selfish</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Logger</span>());<br></code></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>类和模块的内部默认使用的就是严格模式，所以不需要显式指定。</p>\n<h2 id=\"Class继承\"><a href=\"#Class继承\" class=\"headerlink\" title=\"Class继承\"></a>Class继承</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>和其他高级编程语言（C++，Java）一样，ES6也提供了类似<code>extends</code>关键字来实现继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Point</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：在子类的构造函数中，只有调用<code>super</code>关键字以后才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建是基于对父类的加工，因此只有super方法才能但会父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">x</span> = x;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">y</span> = y;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ColorPoint</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y, color</span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>(x, y);<br>        ths.<span class=\"hljs-property\">color</span> = color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"类的prototype属性和-proto-属性\"><a href=\"#类的prototype属性和-proto-属性\" class=\"headerlink\" title=\"类的prototype属性和__proto__属性\"></a>类的prototype属性和__proto__属性</h2><p>Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>\n<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类；</p>\n<p>（2）子类的prototype属性和<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <br>&#125;<br><br>B.<span class=\"hljs-property\">__proto__</span> === A <span class=\"hljs-comment\">// true</span><br>B.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> === A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>因此可以这样理解：作为一个对象，子类B的原型(__proto__)是父类A；作为一个构造函数，子类B的原型(prototype.__proto__)是父类A的实例；</p>\n<h2 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h2><p><code>super</code>既可以当函数使用，也可以当对象使用，两种情况下的使用方法完全不同；</p>\n<h3 id=\"当函数使用\"><a href=\"#当函数使用\" class=\"headerlink\" title=\"当函数使用\"></a>当函数使用</h3><p>这个很简单：作为函数调用时，代表的是父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数。</p>\n<h3 id=\"当对象使用\"><a href=\"#当对象使用\" class=\"headerlink\" title=\"当对象使用\"></a>当对象使用</h3><p>super作为对象时，指向的是父类的原型对象。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-title function_\">p</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>();<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">p</span>());<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br></code></pre></td></tr></table></figure>\n<p>这个时候子类B当中的<code>super.p()</code>就是将super当做一个对象使用。所以<code>super</code>指向的是<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。需要注意的是：由于<code>super</code>指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">p</span> = <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">m</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">p</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br>b.<span class=\"hljs-property\">m</span> <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>如果是定义在父类原型上，<code>super</code>就可以取到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;&#125;<br>A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">2</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">A</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>();<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">x</span>) <span class=\"hljs-comment\">// 2</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">B</span>();<br></code></pre></td></tr></table></figure>\n<p>上面代码中，由于属性x是定义在A.prototype上面的，因此super.x就可以取到它的值。</p>\n<h2 id=\"Class的取值函数（getter）和存值函数（setter）\"><a href=\"#Class的取值函数（getter）和存值函数（setter）\" class=\"headerlink\" title=\"Class的取值函数（getter）和存值函数（setter）\"></a>Class的取值函数（getter）和存值函数（setter）</h2><p>和其他高级语言一样，可以使用get、set关键字，对某个属性设置存值和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">prop</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;getter&#x27;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-params\">value</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;setter: &#x27;</span> + value);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> inst = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClass</span>();<br><br>inst.<span class=\"hljs-property\">prop</span> = <span class=\"hljs-number\">123</span>;<br><br>inst.<span class=\"hljs-property\">prop</span> <span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的Generator方法\"><a href=\"#Class的Generator方法\" class=\"headerlink\" title=\"Class的Generator方法\"></a>Class的Generator方法</h2><p>如果某个方法之前加上星号，就表示该方法是一个Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">args</span> = args;<br>    &#125;<br>    <br>    * [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> arg <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">arg</span>) &#123;<br>            <span class=\"hljs-keyword\">yield</span> arg;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br><span class=\"hljs-comment\">// hello</span><br><span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的静态方法\"><a href=\"#Class的静态方法\" class=\"headerlink\" title=\"Class的静态方法\"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称之为静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">classMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-title class_\">Foo</span>.<span class=\"hljs-title function_\">classMethod</span>() <span class=\"hljs-comment\">// &#x27;hello&#x27;</span><br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>();<br>foo.<span class=\"hljs-title function_\">classMethod</span>()<br><span class=\"hljs-comment\">// TypeError: foo.classMethod is not a function</span><br></code></pre></td></tr></table></figure>\n<p>父类的静态方法可以被子类继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">classMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bar</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Foo</span> &#123;<br>&#125;<br><br><span class=\"hljs-title class_\">Bar</span>.<span class=\"hljs-title function_\">classMethod</span>(); <span class=\"hljs-comment\">// &#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Class的静态属性和实例属性\"><a href=\"#Class的静态属性和实例属性\" class=\"headerlink\" title=\"Class的静态属性和实例属性\"></a>Class的静态属性和实例属性</h2><p>静态属性指的是Class本身的属性，即<code>Class.propname</code>，而不是定义在实例对象（<code>this</code>)上的属性。目前Babel转码器提供了这两种写法的支持。</p>\n<ul>\n<li><p>类的实例属性</p>\n<p>类的实例属性可以用等式，写入类的定义之中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ReactCounter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props</span>) &#123;<br>    <span class=\"hljs-variable language_\">super</span>(props);<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = &#123;<br>      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span><br>    &#125;;<br>  &#125;<br>  state;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>类的静态属性</p>\n</li>\n</ul>\n<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-keyword\">static</span> myStaticProp = <span class=\"hljs-number\">42</span>;<br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\">myProp</span>); <span class=\"hljs-comment\">// 42</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"new-target属性\"><a href=\"#new-target属性\" class=\"headerlink\" title=\"new.target属性\"></a>new.target属性</h2><p><code>new</code>是从构造函数生成实例的命令，ES6为了<code>new</code>命令引入了一个<code>new.target</code>属性，返回<code>new</code>命令作用于那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是如何调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span> !== <span class=\"hljs-literal\">undefined</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;必须使用new生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span> === <span class=\"hljs-title class_\">Person</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;必须使用new生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;张三&#x27;</span>); <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">var</span> notAPerson = <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(person, <span class=\"hljs-string\">&#x27;张三&#x27;</span>);  <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Mixin模式的实现\"><a href=\"#Mixin模式的实现\" class=\"headerlink\" title=\"Mixin模式的实现\"></a>Mixin模式的实现</h2><p>Mixin模式指的是，将多个类的接口“混入”另一个类，在ES6的实现如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mix</span>(<span class=\"hljs-params\">...mixins</span>) &#123;<br>  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mix</span> &#123;&#125;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> mixin <span class=\"hljs-keyword\">of</span> mixins) &#123;<br>    <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-title class_\">Mix</span>, mixin);<br>    <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-title class_\">Mix</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, mixin.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Mix</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">copyProperties</span>(<span class=\"hljs-params\">target, source</span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(source)) &#123;<br>    <span class=\"hljs-keyword\">if</span> ( key !== <span class=\"hljs-string\">&quot;constructor&quot;</span><br>      &amp;&amp; key !== <span class=\"hljs-string\">&quot;prototype&quot;</span><br>      &amp;&amp; key !== <span class=\"hljs-string\">&quot;name&quot;</span><br>    ) &#123;<br>      <span class=\"hljs-keyword\">let</span> desc = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(source, key);<br>      <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, key, desc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 函数扩展","date":"2022-02-17T07:07:14.000Z","updated":"2022-02-17T07:07:14.000Z","_content":"\n# 函数的扩展\n\n## 函数参数的默认值\n\nES6以前函数参数是不能有默认值的，而ES6中对这个规则进行了修改了，函数参数也可以带默认参数。即直接写在参数定义的后面。\n\n```javascript\nfunction log(x, y = 'World') {\n    console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n这样的写法有两个好处：一个是阅读代码的人可以立刻意识到哪些参数是可以省略的，不需要查看函数体；其次有利于代码将来的优化。即便在未来的版本对外接口中，彻底拿掉这个参数也不会导致原有代码无法运行。\n\n### 结合解构赋值\n\n参数默认值当然可以使用前面章节提到的解构特性进行赋值了。\n\n```javascript\nfunction foo({x, y = 5}) {\n    console.log(x, y);\n}\n\nfoo({}) // undefined, 5\nfoo({x: 1}) // 1, 5\nfoo({x: 1, y: 2}) // 1, 2\nfoo() // Error\n```\n\n### 参数默认值的位置\n\n一般情况下定义了默认值的参数应该是函数的尾部，这样比较容易看出来，如果是非尾部的参数设置默认值，实际上该参数是没法省略的。\n\n```javascript\nfunction (x = 1, y) {\n    return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined]\nf(, 1) // Error\nf(undefined, 1) // [1, 1]\n\nfunction (x, y = 5, z) {\n    return [x, y, z];\n}\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // Error\nf(1, undefinied, 2) // [1, 5, 2]\n```\n\n### length属性\n\n函数的length属性将返回没有指定默认值的参数个数。也就是说：指定了默认值后，length属性将失真；\n\n```javascript\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n```\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再记入后面的参数了。\n\n```javascript\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n```\n\n### 作用域\n\n如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。\n\n```javascript\nvar x = 1;\n\nfunction f(x, y = x) {\n    console.log(y);\n}\n\nf(2) // 2\n```\n\n如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域\n\n```javascript\nlet foo = 'outer';\n\n// func为一个默认匿名函数，返回值为变量foo\nfunction bar(func = x => foo) {\n    let foo = 'inner';\n    console.log(func());\n}\n\nbar(); // outer\n```\n\n### 默认参数的用途一目了然\n\n利用默认参数值，可以指定某一个参数不得省略，一旦省略就抛出一个错误；如果想省略这个参数，只要设置成`undefined`就行了。\n\n```javascript\nfunction throwIfMissing() {\n    throw new Error('Missing parameters');\n}\n\nfunction foo(mustBeProvided = throwIfMissing()) {\n    return mustBeProvided;\n}\n\nfoo(); // Error: Missing Parameters\n```\n\n### rest参数\n\n顾名思义：就是入参的个数是不确定的，跟Java中的多参数语法类似。这里就不再赘述了。\n\n```javascript\nfunction add(...values) {\n    let sum = 0;\n    \n    for (var val of values) {\n        sum += val;\n    }\n    \n    return sum;\n}\n\nadd(1, 2, 3, 4) // 10\n```\n\n## 扩展运算符\n\n扩展运算符为三个点`...`，是将一个数组转化为用逗号分隔的参数序列，是rest参数的逆运算。\n\n```javascript\nconsole.log(...[1, 2, 3]) // 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5\n\n[...document.querySelectorAll('div')] // [<div>, <div>, <div>]\n```\n\n该运算符主要用于函数调用\n\n```javascript\nfunction push(array, ...items) {\n    array.push(...items);\n}\n\nfunction add(x, y) {\n    return x + y;\n}\n\nvar numbers = [4, 38];\nadd(...numbers) // 42\n```\n\n### 扩展运算符的应用\n\n#### （1）合并数组\n\n```javascript\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['e', 'f'];\n\n[...arr1, ...arr2, ...arr3] // ['a', 'b', 'c', 'e', 'f']\n```\n\n#### （2） 与解构赋值结合\n\n```javascript\na = list[0], rest = list.slice(1)\n\n[a, ...rest] = list\n\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest // [2, 3, 4, 5]\n\nconst [first, ...rest] = []\nfirst // undefined\nrest // []\n\nconst [first, ...rest] = ['foo']\nfirst // foo\nrest // []\n```\n\n#### （3）函数返回值\n\nJavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种办法：\n\n```javascript\nvar dateFields = readDateFields(database);\nvar d = new Date(...dateFields);\n```\n\n#### （4）字符串\n\n可以将字符串转换为真正的数组。因为扩展运算符可以很好地识别Unicode字符，因此最好都用扩展运算符；\n\n```javascript\n[...'hello']\n// ['h', 'e', 'l', 'l', 'o']\n```\n\n#### （5）实现了Iterator接口的对象\n\n任何Iterator接口的对象，都可以用扩展运算符转换为真正的数组，之前已经提过了，这里不再赘述\n\n#### （6）Map和Set结构、Generator函数\n\n承接第（5）点，Map和Set也部署了Iterator接口，所以也可以使用扩展运算符，Generator函数运行后返回的是一个遍历器对象，因此也可以使用扩展运算符。\n\n```javascript\nvar go = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...go()] // [1, 2, 3]\n```\n\n## 严格模式\n\n从ES5开始，函数内部可以使用严格模式，在ES2016中做了一点修改。规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。\n\n这样规定的原因是：函数内部的严格模式同时适用于函数体和函数参数。但是函数执行时会先执行函数参数代码，再执行函数体代码。因此只有从函数体代码之中才能知道参数代码是否应该以严格模式执行，但是函数参数代码又要先于函数体执行。所以这就导致了不合理的存在。\n\n```javascript\nfunction doSomething(value = 070) { // value = 070 先执行\n    'use strict'; // 设置了严格模式\n    return value; // 后执行\n}\n// Illegal 'use strict' directive in function with non-simple parameter list\n```\n\n### 但是我想要用严格模式限定时该怎么办呢？\n\n```javascript\n'use strict' // 全局严格模式\n\nfunction doSomething(a, b = a) {}\n\n// 由于函数参数部分会先执行：那很简单，将函数包在一个无参数的立即执行函数中\nconst doSomething = (function(){\n    'use strict';\n    return function(value = 42) {\n        return value;\n    }\n});\n```\n\n## name属性\n\n函数的`name`属性返回的是函数的名称。如果是将匿名函数赋给一个变量，在ES5中会返回空串，但是在ES6中会将变量名作为函数的名称。\n\n```javascript\nfunction foo () {}\nfoo.name // 'foo'\n\nvar func1 = function () {}\n\n// ES5\nfunc1.name // \"\"\n\n// ES6\nfunc1.name // \"func1\"\n```\n\n## 箭头函数\n\nES6中允许使用箭头`=>`来定义函数，定义效果和你使用`function`创建函数是等价的。\n\n```javascript\nvar f = v => v;\n\n// 等同于\n\nvar f = function(v) {\n    return v;\n};\n```\n\n如果箭头函数不需要参数或者需要多个参数，就是用圆括号来代表参数部分。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () {return 5;}\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n```\n\n如果箭头函数的代码块部分超过一条语句，就是用大括号将它们围起来，必须在对象外面加上括号。\n\n```javascript\nvar sum = (num1, num2) => {return num1 + num2;}\n\n//大括号会解释为代码块，所以如果是用箭头函数返回对象，必须在对象外层加上大括号\nvar getTemplate = id => ({id: id, name: \"Temp\"});\n```\n\n箭头函数也可以与变量解构结合\n\n```javascript\nconst full = ({ first ,last }) => first + ' ' + last;\n// 等同于\nfunction full(person) {\n    return person.first + ' ' + person.last;\n}\n```\n\n使用箭头函数需要注意几个地方：\n\n- 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象；\n- 不可以当做构造函数；（`this`对象的指向是可变的，而在箭头函数中是固定的）\n- 不可以使用`arguments`对象，如果要用，可以使用Rest参数代替；\n- 不可以使用`yield`命令，因此箭头函数不可以用作Generator函数\n\n```javascript\nfunction foo() {\n    setTimeout(() => {\n        console.log('id:', this.id);\n    }, 100);\n}\n\nvar id = 21;\nfoo.call({ id: 42 });\n// id: 42\n```\n\n## 绑定this\n\n箭头函数可以绑定`this`对象，因此大大减少了显式绑定`this`对象的写法（`apply`、`call`、`bind`）。但是见图函数并不适用于任何场合，因此ES7提出了函数绑定运算符。语法为两个并排的冒号：`::`。双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境，绑定到右边的函数上面。\n\n```javascript\nfoo::bar // bar.bind(foo)\n\nfoo::bar(...arguments); // bar.bind(foo, arguments)\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n    return obj::hasOwnProperty(key);\n}\n```\n\n如果双冒号左边为空（对需要绑定的对象为空），则等于将该方法绑定在对象上面。\n\n```javascript\nvar method = obj::obj.foo;\n// 等同于\nvar method = ::obj.foo;\n\nlet log = ::console.log;\n// 等同于\nvar log = console.log.bind(console);\n```\n\n由于双冒号运算符返回的还是原对象，因此可以采用链式写法。\n\n```javascript\nimport { map, takeWhile, forEach } from \"iterlib\";\n\n// 例1\ngetPlayers()\n::map(x => x.character())\n::takeWhile(x => x.strength > 100)\n::forEach(x => console.log(x));\n\n// 例2\nlet { find, html } = jake;\ndocument.querySelectorAll(\"div.myClass\");\n::find(\"p\")\n::html(\"hahahh\");\n```\n\n## 尾调用优化\n\n尾调用是函数式编程中的一个重要概念：就是指某个函数的最后一步调用是另一个函数。例如下面的例子：函数f的最后一步是调用函数g。尾调用优化只在严格模式下才生效。\n\n```javascript\nfunction f(x) {\n    return g(x);\n}\n```\n\n下面三种情况都不属于尾调用：\n\n```javascript\nfunction f(x) {\n    let y = g(x);\n    return y;\n}\n\nfunction f(x) {\n    return g(x) + 1;\n}\n\nfunction f(x) {\n    g(x);\n    return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可：\n\n```javascript\nfunction (x) {\n    if (x > 0) {\n        return m(x);\n    }\n    return n(x);\n}\n```\n\n通常来说：函数调用会在内存中形成一个“调用记录”，也称为调用帧。保存调用位置和内部变量等信息。\n\n由于尾调用是函数最后一步操作，因此不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧即可。\n\n这里有一个前提条件：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾部调用优化”；\n\n```javascript\nfunction f() {\n    let m = 1;\n    let n = 2;\n    return g(m + n);\n}\nf()\n\n// 等同于\nfunction f() {\n    return g(3)\n}\nf();\n\n// 等同于\ng(3)\n```\n\n### 尾递归\n\n基于上述尾部调用优化的特性：因此对于尾递归来说，由于只存在一个调用帧，因此永远也不会发生“栈溢出”错误。（注：将函数的多参数转换为单参数的范式成为”柯里化“）\n\n```javascript\n// 非尾递归写法\nfunction factorial(n) {\n    if (n === 1) return 1;\n    return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n\n// 尾递归写法\nfunction factorial(n, total = 1) {\n    if (n === 1) return total;\n    return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n```\n\n还有斐波那契数列的例子：\n\n```javascript\n// 非尾递归写法\nfunction Fibonacci(n) {\n    if (n <= 1) { return 1 };\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\nFibonacci(10); // 89\nFibonacci(1000); // 运行很慢\n\n// 尾递归写法\nfunction Fibonacci(n, ac1 = 1, ac2 = 1) {\n    if (n <= 1) { return ac2; }\n    return Fibonacci(n - 1. ac2, ac1 + ac2);\n}\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\n```\n\n可以看出“尾部调用优化”对于“尾递归\"的意义重大，所以一些函数式编程语言将其写入了语言规格。换句话来说只要使用尾递归来实现就不会发生栈溢出，从而节省内存。\n\n### 蹦床函数\n\n由于尾部递归只能在严格模式下生效，理由如下：\n\n正常模式下函数有两个变量，可以用于跟踪和记录函数调用：\n\n- `func.arguments`：返回调用时的函数参数；\n- `func.caller`：返回调用当前的函数；\n\n尾部调用发生时，调用栈的记录会被改写，因此上面两个变量就会失真。而在严格模式下会禁用上面两个变量，因此尾部调用只能在严格模式下生效。\n\n那么，如果我现在正常模式下实现尾部递归的写法又该如何做呢？可以将递归转换为循环执行。也就是俗称的“蹦床函数”：如下所示：`sum`函数每执行一次，都会返回自身的另一个版本。\n\n```javascript\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n\nfunction sum(x, y) {\n    if (y > 0) {\n        return sum.bind(null, x + 1, y - 1);\n    } else {\n        return x;\n    }\n}\n\ntrampoline(sum(1, 100000)); // 100001\n```\n\n但是上面的蹦床函数并不是真正的尾调用优化。下面这段代码来自官网教程。细细品位。\n\n```javascript\nfunction tco(f) {\n    var value;\n    var active = false; // 默认情况下该变量不激活\n    var accumulated = [];\n    \n    return function accumulator() {\n        accumulated.push(arguments);\n        if (!active) {\n            active = true; // 进入尾调用函数后激活\n            while(accumulated.length) {\n                value = f.apply(this, accumulated.shift());\n            }\n            active = false; // 调用完毕后关闭\n            return value;\n        }\n    };\n}\n\nvar sum = tco(function (x, y){\n    if (y > 0) {\n        return sum(x + 1, y - 1)\n    } else {\n        return x;\n    }\n});\n\nsum(1, 10000) // 10001\n```\n\n## 函数参数的尾逗号\n\nES7将允许函数的最后一个参数有尾逗号。在此之前，不允许最后一个参数携带逗号;\n\n```javascript\nfunction clownsEveryWhere(\n param1,\n param2,\n) {}\n```\n","source":"_posts/javascript/es6-function-expand.md","raw":"---\ntitle: ES6 函数扩展\ndate: 2022-02-17 15:07:14\nupdated: 2022-02-17 15:07:14\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 函数的扩展\n\n## 函数参数的默认值\n\nES6以前函数参数是不能有默认值的，而ES6中对这个规则进行了修改了，函数参数也可以带默认参数。即直接写在参数定义的后面。\n\n```javascript\nfunction log(x, y = 'World') {\n    console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n这样的写法有两个好处：一个是阅读代码的人可以立刻意识到哪些参数是可以省略的，不需要查看函数体；其次有利于代码将来的优化。即便在未来的版本对外接口中，彻底拿掉这个参数也不会导致原有代码无法运行。\n\n### 结合解构赋值\n\n参数默认值当然可以使用前面章节提到的解构特性进行赋值了。\n\n```javascript\nfunction foo({x, y = 5}) {\n    console.log(x, y);\n}\n\nfoo({}) // undefined, 5\nfoo({x: 1}) // 1, 5\nfoo({x: 1, y: 2}) // 1, 2\nfoo() // Error\n```\n\n### 参数默认值的位置\n\n一般情况下定义了默认值的参数应该是函数的尾部，这样比较容易看出来，如果是非尾部的参数设置默认值，实际上该参数是没法省略的。\n\n```javascript\nfunction (x = 1, y) {\n    return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined]\nf(, 1) // Error\nf(undefined, 1) // [1, 1]\n\nfunction (x, y = 5, z) {\n    return [x, y, z];\n}\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // Error\nf(1, undefinied, 2) // [1, 5, 2]\n```\n\n### length属性\n\n函数的length属性将返回没有指定默认值的参数个数。也就是说：指定了默认值后，length属性将失真；\n\n```javascript\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n```\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再记入后面的参数了。\n\n```javascript\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n```\n\n### 作用域\n\n如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。\n\n```javascript\nvar x = 1;\n\nfunction f(x, y = x) {\n    console.log(y);\n}\n\nf(2) // 2\n```\n\n如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域\n\n```javascript\nlet foo = 'outer';\n\n// func为一个默认匿名函数，返回值为变量foo\nfunction bar(func = x => foo) {\n    let foo = 'inner';\n    console.log(func());\n}\n\nbar(); // outer\n```\n\n### 默认参数的用途一目了然\n\n利用默认参数值，可以指定某一个参数不得省略，一旦省略就抛出一个错误；如果想省略这个参数，只要设置成`undefined`就行了。\n\n```javascript\nfunction throwIfMissing() {\n    throw new Error('Missing parameters');\n}\n\nfunction foo(mustBeProvided = throwIfMissing()) {\n    return mustBeProvided;\n}\n\nfoo(); // Error: Missing Parameters\n```\n\n### rest参数\n\n顾名思义：就是入参的个数是不确定的，跟Java中的多参数语法类似。这里就不再赘述了。\n\n```javascript\nfunction add(...values) {\n    let sum = 0;\n    \n    for (var val of values) {\n        sum += val;\n    }\n    \n    return sum;\n}\n\nadd(1, 2, 3, 4) // 10\n```\n\n## 扩展运算符\n\n扩展运算符为三个点`...`，是将一个数组转化为用逗号分隔的参数序列，是rest参数的逆运算。\n\n```javascript\nconsole.log(...[1, 2, 3]) // 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5\n\n[...document.querySelectorAll('div')] // [<div>, <div>, <div>]\n```\n\n该运算符主要用于函数调用\n\n```javascript\nfunction push(array, ...items) {\n    array.push(...items);\n}\n\nfunction add(x, y) {\n    return x + y;\n}\n\nvar numbers = [4, 38];\nadd(...numbers) // 42\n```\n\n### 扩展运算符的应用\n\n#### （1）合并数组\n\n```javascript\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['e', 'f'];\n\n[...arr1, ...arr2, ...arr3] // ['a', 'b', 'c', 'e', 'f']\n```\n\n#### （2） 与解构赋值结合\n\n```javascript\na = list[0], rest = list.slice(1)\n\n[a, ...rest] = list\n\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest // [2, 3, 4, 5]\n\nconst [first, ...rest] = []\nfirst // undefined\nrest // []\n\nconst [first, ...rest] = ['foo']\nfirst // foo\nrest // []\n```\n\n#### （3）函数返回值\n\nJavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种办法：\n\n```javascript\nvar dateFields = readDateFields(database);\nvar d = new Date(...dateFields);\n```\n\n#### （4）字符串\n\n可以将字符串转换为真正的数组。因为扩展运算符可以很好地识别Unicode字符，因此最好都用扩展运算符；\n\n```javascript\n[...'hello']\n// ['h', 'e', 'l', 'l', 'o']\n```\n\n#### （5）实现了Iterator接口的对象\n\n任何Iterator接口的对象，都可以用扩展运算符转换为真正的数组，之前已经提过了，这里不再赘述\n\n#### （6）Map和Set结构、Generator函数\n\n承接第（5）点，Map和Set也部署了Iterator接口，所以也可以使用扩展运算符，Generator函数运行后返回的是一个遍历器对象，因此也可以使用扩展运算符。\n\n```javascript\nvar go = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...go()] // [1, 2, 3]\n```\n\n## 严格模式\n\n从ES5开始，函数内部可以使用严格模式，在ES2016中做了一点修改。规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。\n\n这样规定的原因是：函数内部的严格模式同时适用于函数体和函数参数。但是函数执行时会先执行函数参数代码，再执行函数体代码。因此只有从函数体代码之中才能知道参数代码是否应该以严格模式执行，但是函数参数代码又要先于函数体执行。所以这就导致了不合理的存在。\n\n```javascript\nfunction doSomething(value = 070) { // value = 070 先执行\n    'use strict'; // 设置了严格模式\n    return value; // 后执行\n}\n// Illegal 'use strict' directive in function with non-simple parameter list\n```\n\n### 但是我想要用严格模式限定时该怎么办呢？\n\n```javascript\n'use strict' // 全局严格模式\n\nfunction doSomething(a, b = a) {}\n\n// 由于函数参数部分会先执行：那很简单，将函数包在一个无参数的立即执行函数中\nconst doSomething = (function(){\n    'use strict';\n    return function(value = 42) {\n        return value;\n    }\n});\n```\n\n## name属性\n\n函数的`name`属性返回的是函数的名称。如果是将匿名函数赋给一个变量，在ES5中会返回空串，但是在ES6中会将变量名作为函数的名称。\n\n```javascript\nfunction foo () {}\nfoo.name // 'foo'\n\nvar func1 = function () {}\n\n// ES5\nfunc1.name // \"\"\n\n// ES6\nfunc1.name // \"func1\"\n```\n\n## 箭头函数\n\nES6中允许使用箭头`=>`来定义函数，定义效果和你使用`function`创建函数是等价的。\n\n```javascript\nvar f = v => v;\n\n// 等同于\n\nvar f = function(v) {\n    return v;\n};\n```\n\n如果箭头函数不需要参数或者需要多个参数，就是用圆括号来代表参数部分。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () {return 5;}\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n```\n\n如果箭头函数的代码块部分超过一条语句，就是用大括号将它们围起来，必须在对象外面加上括号。\n\n```javascript\nvar sum = (num1, num2) => {return num1 + num2;}\n\n//大括号会解释为代码块，所以如果是用箭头函数返回对象，必须在对象外层加上大括号\nvar getTemplate = id => ({id: id, name: \"Temp\"});\n```\n\n箭头函数也可以与变量解构结合\n\n```javascript\nconst full = ({ first ,last }) => first + ' ' + last;\n// 等同于\nfunction full(person) {\n    return person.first + ' ' + person.last;\n}\n```\n\n使用箭头函数需要注意几个地方：\n\n- 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象；\n- 不可以当做构造函数；（`this`对象的指向是可变的，而在箭头函数中是固定的）\n- 不可以使用`arguments`对象，如果要用，可以使用Rest参数代替；\n- 不可以使用`yield`命令，因此箭头函数不可以用作Generator函数\n\n```javascript\nfunction foo() {\n    setTimeout(() => {\n        console.log('id:', this.id);\n    }, 100);\n}\n\nvar id = 21;\nfoo.call({ id: 42 });\n// id: 42\n```\n\n## 绑定this\n\n箭头函数可以绑定`this`对象，因此大大减少了显式绑定`this`对象的写法（`apply`、`call`、`bind`）。但是见图函数并不适用于任何场合，因此ES7提出了函数绑定运算符。语法为两个并排的冒号：`::`。双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境，绑定到右边的函数上面。\n\n```javascript\nfoo::bar // bar.bind(foo)\n\nfoo::bar(...arguments); // bar.bind(foo, arguments)\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n    return obj::hasOwnProperty(key);\n}\n```\n\n如果双冒号左边为空（对需要绑定的对象为空），则等于将该方法绑定在对象上面。\n\n```javascript\nvar method = obj::obj.foo;\n// 等同于\nvar method = ::obj.foo;\n\nlet log = ::console.log;\n// 等同于\nvar log = console.log.bind(console);\n```\n\n由于双冒号运算符返回的还是原对象，因此可以采用链式写法。\n\n```javascript\nimport { map, takeWhile, forEach } from \"iterlib\";\n\n// 例1\ngetPlayers()\n::map(x => x.character())\n::takeWhile(x => x.strength > 100)\n::forEach(x => console.log(x));\n\n// 例2\nlet { find, html } = jake;\ndocument.querySelectorAll(\"div.myClass\");\n::find(\"p\")\n::html(\"hahahh\");\n```\n\n## 尾调用优化\n\n尾调用是函数式编程中的一个重要概念：就是指某个函数的最后一步调用是另一个函数。例如下面的例子：函数f的最后一步是调用函数g。尾调用优化只在严格模式下才生效。\n\n```javascript\nfunction f(x) {\n    return g(x);\n}\n```\n\n下面三种情况都不属于尾调用：\n\n```javascript\nfunction f(x) {\n    let y = g(x);\n    return y;\n}\n\nfunction f(x) {\n    return g(x) + 1;\n}\n\nfunction f(x) {\n    g(x);\n    return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可：\n\n```javascript\nfunction (x) {\n    if (x > 0) {\n        return m(x);\n    }\n    return n(x);\n}\n```\n\n通常来说：函数调用会在内存中形成一个“调用记录”，也称为调用帧。保存调用位置和内部变量等信息。\n\n由于尾调用是函数最后一步操作，因此不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧即可。\n\n这里有一个前提条件：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾部调用优化”；\n\n```javascript\nfunction f() {\n    let m = 1;\n    let n = 2;\n    return g(m + n);\n}\nf()\n\n// 等同于\nfunction f() {\n    return g(3)\n}\nf();\n\n// 等同于\ng(3)\n```\n\n### 尾递归\n\n基于上述尾部调用优化的特性：因此对于尾递归来说，由于只存在一个调用帧，因此永远也不会发生“栈溢出”错误。（注：将函数的多参数转换为单参数的范式成为”柯里化“）\n\n```javascript\n// 非尾递归写法\nfunction factorial(n) {\n    if (n === 1) return 1;\n    return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n\n// 尾递归写法\nfunction factorial(n, total = 1) {\n    if (n === 1) return total;\n    return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n```\n\n还有斐波那契数列的例子：\n\n```javascript\n// 非尾递归写法\nfunction Fibonacci(n) {\n    if (n <= 1) { return 1 };\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\nFibonacci(10); // 89\nFibonacci(1000); // 运行很慢\n\n// 尾递归写法\nfunction Fibonacci(n, ac1 = 1, ac2 = 1) {\n    if (n <= 1) { return ac2; }\n    return Fibonacci(n - 1. ac2, ac1 + ac2);\n}\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\n```\n\n可以看出“尾部调用优化”对于“尾递归\"的意义重大，所以一些函数式编程语言将其写入了语言规格。换句话来说只要使用尾递归来实现就不会发生栈溢出，从而节省内存。\n\n### 蹦床函数\n\n由于尾部递归只能在严格模式下生效，理由如下：\n\n正常模式下函数有两个变量，可以用于跟踪和记录函数调用：\n\n- `func.arguments`：返回调用时的函数参数；\n- `func.caller`：返回调用当前的函数；\n\n尾部调用发生时，调用栈的记录会被改写，因此上面两个变量就会失真。而在严格模式下会禁用上面两个变量，因此尾部调用只能在严格模式下生效。\n\n那么，如果我现在正常模式下实现尾部递归的写法又该如何做呢？可以将递归转换为循环执行。也就是俗称的“蹦床函数”：如下所示：`sum`函数每执行一次，都会返回自身的另一个版本。\n\n```javascript\nfunction trampoline(f) {\n    while (f && f instanceof Function) {\n        f = f();\n    }\n    return f;\n}\n\nfunction sum(x, y) {\n    if (y > 0) {\n        return sum.bind(null, x + 1, y - 1);\n    } else {\n        return x;\n    }\n}\n\ntrampoline(sum(1, 100000)); // 100001\n```\n\n但是上面的蹦床函数并不是真正的尾调用优化。下面这段代码来自官网教程。细细品位。\n\n```javascript\nfunction tco(f) {\n    var value;\n    var active = false; // 默认情况下该变量不激活\n    var accumulated = [];\n    \n    return function accumulator() {\n        accumulated.push(arguments);\n        if (!active) {\n            active = true; // 进入尾调用函数后激活\n            while(accumulated.length) {\n                value = f.apply(this, accumulated.shift());\n            }\n            active = false; // 调用完毕后关闭\n            return value;\n        }\n    };\n}\n\nvar sum = tco(function (x, y){\n    if (y > 0) {\n        return sum(x + 1, y - 1)\n    } else {\n        return x;\n    }\n});\n\nsum(1, 10000) // 10001\n```\n\n## 函数参数的尾逗号\n\nES7将允许函数的最后一个参数有尾逗号。在此之前，不允许最后一个参数携带逗号;\n\n```javascript\nfunction clownsEveryWhere(\n param1,\n param2,\n) {}\n```\n","slug":"javascript/es6-function-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2w000y2y617s926vql","content":"<h1 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h1><h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><p>ES6以前函数参数是不能有默认值的，而ES6中对这个规则进行了修改了，函数参数也可以带默认参数。即直接写在参数定义的后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">x, y = <span class=\"hljs-string\">&#x27;World&#x27;</span></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y);<br>&#125;<br><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>) <span class=\"hljs-comment\">// Hello World</span><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;China&#x27;</span>) <span class=\"hljs-comment\">// Hello China</span><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n<p>这样的写法有两个好处：一个是阅读代码的人可以立刻意识到哪些参数是可以省略的，不需要查看函数体；其次有利于代码将来的优化。即便在未来的版本对外接口中，彻底拿掉这个参数也不会导致原有代码无法运行。</p>\n<h3 id=\"结合解构赋值\"><a href=\"#结合解构赋值\" class=\"headerlink\" title=\"结合解构赋值\"></a>结合解构赋值</h3><p>参数默认值当然可以使用前面章节提到的解构特性进行赋值了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">&#123;x, y = <span class=\"hljs-number\">5</span>&#125;</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y);<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(&#123;&#125;) <span class=\"hljs-comment\">// undefined, 5</span><br><span class=\"hljs-title function_\">foo</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// 1, 5</span><br><span class=\"hljs-title function_\">foo</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>&#125;) <span class=\"hljs-comment\">// 1, 2</span><br><span class=\"hljs-title function_\">foo</span>() <span class=\"hljs-comment\">// Error</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"参数默认值的位置\"><a href=\"#参数默认值的位置\" class=\"headerlink\" title=\"参数默认值的位置\"></a>参数默认值的位置</h3><p>一般情况下定义了默认值的参数应该是函数的尾部，这样比较容易看出来，如果是非尾部的参数设置默认值，实际上该参数是没法省略的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x = <span class=\"hljs-number\">1</span>, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>() <span class=\"hljs-comment\">// [1, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [2, undefined]</span><br><span class=\"hljs-title function_\">f</span>(, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Error</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [1, 1]</span><br><br><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y = <span class=\"hljs-number\">5</span>, z</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [x, y, z];<br>&#125;<br><span class=\"hljs-title function_\">f</span>() <span class=\"hljs-comment\">// [undefined, 5, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [1, 5, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, ,<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// Error</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, undefinied, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [1, 5, 2]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"length属性\"><a href=\"#length属性\" class=\"headerlink\" title=\"length属性\"></a>length属性</h3><p>函数的length属性将返回没有指定默认值的参数个数。也就是说：指定了默认值后，length属性将失真；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 1</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a = <span class=\"hljs-number\">5</span></span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 0</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b, c = <span class=\"hljs-number\">5</span></span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<p>如果设置了默认值的参数不是尾参数，那么length属性也不再记入后面的参数了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a = <span class=\"hljs-number\">0</span>, b, c</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 0</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b = <span class=\"hljs-number\">1</span>, c</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x, y = x</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(y);<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<p>如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&#x27;outer&#x27;</span>;<br><br><span class=\"hljs-comment\">// func为一个默认匿名函数，返回值为变量foo</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\">func = x =&gt; foo</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&#x27;inner&#x27;</span>;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">func</span>());<br>&#125;<br><br><span class=\"hljs-title function_\">bar</span>(); <span class=\"hljs-comment\">// outer</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"默认参数的用途一目了然\"><a href=\"#默认参数的用途一目了然\" class=\"headerlink\" title=\"默认参数的用途一目了然\"></a>默认参数的用途一目了然</h3><p>利用默认参数值，可以指定某一个参数不得省略，一旦省略就抛出一个错误；如果想省略这个参数，只要设置成<code>undefined</code>就行了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throwIfMissing</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Missing parameters&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">mustBeProvided = throwIfMissing()</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> mustBeProvided;<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">// Error: Missing Parameters</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h3><p>顾名思义：就是入参的个数是不确定的，跟Java中的多参数语法类似。这里就不再赘述了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">...values</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> val <span class=\"hljs-keyword\">of</span> values) &#123;<br>        sum += val;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 10</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><p>扩展运算符为三个点<code>...</code>，是将一个数组转化为用逗号分隔的参数序列，是rest参数的逆运算。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(...[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]) <span class=\"hljs-comment\">// 1 2 3</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>, ...[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>], <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 1 2 3 4 5</span><br><br>[...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)] <span class=\"hljs-comment\">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></code></pre></td></tr></table></figure>\n<p>该运算符主要用于函数调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-params\">array, ...items</span>) &#123;<br>    array.<span class=\"hljs-title function_\">push</span>(...items);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">38</span>];<br><span class=\"hljs-title function_\">add</span>(...numbers) <span class=\"hljs-comment\">// 42</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符的应用\"><a href=\"#扩展运算符的应用\" class=\"headerlink\" title=\"扩展运算符的应用\"></a>扩展运算符的应用</h3><h4 id=\"（1）合并数组\"><a href=\"#（1）合并数组\" class=\"headerlink\" title=\"（1）合并数组\"></a>（1）合并数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> arr3 = [<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>];<br><br>[...arr1, ...arr2, ...arr3] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（2）-与解构赋值结合\"><a href=\"#（2）-与解构赋值结合\" class=\"headerlink\" title=\"（2） 与解构赋值结合\"></a>（2） 与解构赋值结合</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = list[<span class=\"hljs-number\">0</span>], rest = list.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)<br><br>[a, ...rest] = list<br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br>first <span class=\"hljs-comment\">// 1</span><br>rest <span class=\"hljs-comment\">// [2, 3, 4, 5]</span><br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = []<br>first <span class=\"hljs-comment\">// undefined</span><br>rest <span class=\"hljs-comment\">// []</span><br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = [<span class=\"hljs-string\">&#x27;foo&#x27;</span>]<br>first <span class=\"hljs-comment\">// foo</span><br>rest <span class=\"hljs-comment\">// []</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（3）函数返回值\"><a href=\"#（3）函数返回值\" class=\"headerlink\" title=\"（3）函数返回值\"></a>（3）函数返回值</h4><p>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种办法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> dateFields = <span class=\"hljs-title function_\">readDateFields</span>(database);<br><span class=\"hljs-keyword\">var</span> d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(...dateFields);<br></code></pre></td></tr></table></figure>\n<h4 id=\"（4）字符串\"><a href=\"#（4）字符串\" class=\"headerlink\" title=\"（4）字符串\"></a>（4）字符串</h4><p>可以将字符串转换为真正的数组。因为扩展运算符可以很好地识别Unicode字符，因此最好都用扩展运算符；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[...<span class=\"hljs-string\">&#x27;hello&#x27;</span>]<br><span class=\"hljs-comment\">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（5）实现了Iterator接口的对象\"><a href=\"#（5）实现了Iterator接口的对象\" class=\"headerlink\" title=\"（5）实现了Iterator接口的对象\"></a>（5）实现了Iterator接口的对象</h4><p>任何Iterator接口的对象，都可以用扩展运算符转换为真正的数组，之前已经提过了，这里不再赘述</p>\n<h4 id=\"（6）Map和Set结构、Generator函数\"><a href=\"#（6）Map和Set结构、Generator函数\" class=\"headerlink\" title=\"（6）Map和Set结构、Generator函数\"></a>（6）Map和Set结构、Generator函数</h4><p>承接第（5）点，Map和Set也部署了Iterator接口，所以也可以使用扩展运算符，Generator函数运行后返回的是一个遍历器对象，因此也可以使用扩展运算符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> go = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...<span class=\"hljs-title function_\">go</span>()] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>从ES5开始，函数内部可以使用严格模式，在ES2016中做了一点修改。规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。</p>\n<p>这样规定的原因是：函数内部的严格模式同时适用于函数体和函数参数。但是函数执行时会先执行函数参数代码，再执行函数体代码。因此只有从函数体代码之中才能知道参数代码是否应该以严格模式执行，但是函数参数代码又要先于函数体执行。所以这就导致了不合理的存在。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\">value = <span class=\"hljs-number\">070</span></span>) &#123; <span class=\"hljs-comment\">// value = 070 先执行</span><br>    <span class=\"hljs-string\">&#x27;use strict&#x27;</span>; <span class=\"hljs-comment\">// 设置了严格模式</span><br>    <span class=\"hljs-keyword\">return</span> value; <span class=\"hljs-comment\">// 后执行</span><br>&#125;<br><span class=\"hljs-comment\">// Illegal &#x27;use strict&#x27; directive in function with non-simple parameter list</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"但是我想要用严格模式限定时该怎么办呢？\"><a href=\"#但是我想要用严格模式限定时该怎么办呢？\" class=\"headerlink\" title=\"但是我想要用严格模式限定时该怎么办呢？\"></a>但是我想要用严格模式限定时该怎么办呢？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-meta\">&#x27;use strict&#x27;</span> <span class=\"hljs-comment\">// 全局严格模式</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\">a, b = a</span>) &#123;&#125;<br><br><span class=\"hljs-comment\">// 由于函数参数部分会先执行：那很简单，将函数包在一个无参数的立即执行函数中</span><br><span class=\"hljs-keyword\">const</span> doSomething = (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-string\">&#x27;use strict&#x27;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value = <span class=\"hljs-number\">42</span></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h2><p>函数的<code>name</code>属性返回的是函数的名称。如果是将匿名函数赋给一个变量，在ES5中会返回空串，但是在ES6中会将变量名作为函数的名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;&#125;<br>foo.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &#x27;foo&#x27;</span><br><br><span class=\"hljs-keyword\">var</span> func1 = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><br><span class=\"hljs-comment\">// ES5</span><br>func1.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &quot;&quot;</span><br><br><span class=\"hljs-comment\">// ES6</span><br>func1.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &quot;func1&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6中允许使用箭头<code>=&gt;</code>来定义函数，定义效果和你使用<code>function</code>创建函数是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">f</span> = v =&gt; v;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> v;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>如果箭头函数不需要参数或者需要多个参数，就是用圆括号来代表参数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>;&#125;<br><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">num1, num2</span>) =&gt; num1 + num2;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">num1, num2</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> num1 + num2;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果箭头函数的代码块部分超过一条语句，就是用大括号将它们围起来，必须在对象外面加上括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">num1, num2</span>) =&gt; &#123;<span class=\"hljs-keyword\">return</span> num1 + num2;&#125;<br><br><span class=\"hljs-comment\">//大括号会解释为代码块，所以如果是用箭头函数返回对象，必须在对象外层加上大括号</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">getTemplate</span> = id =&gt; (&#123;<span class=\"hljs-attr\">id</span>: id, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Temp&quot;</span>&#125;);<br></code></pre></td></tr></table></figure>\n<p>箭头函数也可以与变量解构结合</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">full</span> = (<span class=\"hljs-params\">&#123; first ,last &#125;</span>) =&gt; first + <span class=\"hljs-string\">&#x27; &#x27;</span> + last;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">full</span>(<span class=\"hljs-params\">person</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> person.<span class=\"hljs-property\">first</span> + <span class=\"hljs-string\">&#x27; &#x27;</span> + person.<span class=\"hljs-property\">last</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用箭头函数需要注意几个地方：</p>\n<ul>\n<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象；</li>\n<li>不可以当做构造函数；（<code>this</code>对象的指向是可变的，而在箭头函数中是固定的）</li>\n<li>不可以使用<code>arguments</code>对象，如果要用，可以使用Rest参数代替；</li>\n<li>不可以使用<code>yield</code>命令，因此箭头函数不可以用作Generator函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;id:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>);<br>    &#125;, <span class=\"hljs-number\">100</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-number\">21</span>;<br>foo.<span class=\"hljs-title function_\">call</span>(&#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">42</span> &#125;);<br><span class=\"hljs-comment\">// id: 42</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"绑定this\"><a href=\"#绑定this\" class=\"headerlink\" title=\"绑定this\"></a>绑定this</h2><p>箭头函数可以绑定<code>this</code>对象，因此大大减少了显式绑定<code>this</code>对象的写法（<code>apply</code>、<code>call</code>、<code>bind</code>）。但是见图函数并不适用于任何场合，因此ES7提出了函数绑定运算符。语法为两个并排的冒号：<code>::</code>。双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境，绑定到右边的函数上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">foo</span>::bar <span class=\"hljs-comment\">// bar.bind(foo)</span><br><br><span class=\"hljs-attr\">foo</span>::<span class=\"hljs-title function_\">bar</span>(...<span class=\"hljs-variable language_\">arguments</span>); <span class=\"hljs-comment\">// bar.bind(foo, arguments)</span><br><br><span class=\"hljs-keyword\">const</span> hasOwnProperty = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hasOwnProperty</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hasOwn</span>(<span class=\"hljs-params\">obj, key</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-attr\">obj</span>::<span class=\"hljs-title function_\">hasOwnProperty</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果双冒号左边为空（对需要绑定的对象为空），则等于将该方法绑定在对象上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> method = <span class=\"hljs-attr\">obj</span>::obj.<span class=\"hljs-property\">foo</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> method = ::obj.<span class=\"hljs-property\">foo</span>;<br><br><span class=\"hljs-keyword\">let</span> log = ::<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> log = <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">console</span>);<br></code></pre></td></tr></table></figure>\n<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; map, takeWhile, forEach &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;iterlib&quot;</span>;<br><br><span class=\"hljs-comment\">// 例1</span><br><span class=\"hljs-title function_\">getPlayers</span>()<br>::<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-title function_\">character</span>())<br>::<span class=\"hljs-title function_\">takeWhile</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-property\">strength</span> &gt; <span class=\"hljs-number\">100</span>)<br>::<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x));<br><br><span class=\"hljs-comment\">// 例2</span><br><span class=\"hljs-keyword\">let</span> &#123; find, html &#125; = jake;<br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&quot;div.myClass&quot;</span>);<br>::<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-string\">&quot;p&quot;</span>)<br>::<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-string\">&quot;hahahh&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><p>尾调用是函数式编程中的一个重要概念：就是指某个函数的最后一步调用是另一个函数。例如下面的例子：函数f的最后一步是调用函数g。尾调用优化只在严格模式下才生效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>下面三种情况都不属于尾调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-title function_\">g</span>(x);<br>    <span class=\"hljs-keyword\">return</span> y;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(x) + <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-title function_\">g</span>(x);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">m</span>(x);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">n</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通常来说：函数调用会在内存中形成一个“调用记录”，也称为调用帧。保存调用位置和内部变量等信息。</p>\n<p>由于尾调用是函数最后一步操作，因此不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧即可。</p>\n<p>这里有一个前提条件：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾部调用优化”；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> m = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">let</span> n = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(m + n);<br>&#125;<br><span class=\"hljs-title function_\">f</span>()<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-number\">3</span>)<br>&#125;<br><span class=\"hljs-title function_\">f</span>();<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-title function_\">g</span>(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>基于上述尾部调用优化的特性：因此对于尾递归来说，由于只存在一个调用帧，因此永远也不会发生“栈溢出”错误。（注：将函数的多参数转换为单参数的范式成为”柯里化“）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 非尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> n * <span class=\"hljs-title function_\">factorial</span>(n - <span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span><br><br><span class=\"hljs-comment\">// 尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n, total = <span class=\"hljs-number\">1</span></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> total;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">factorial</span>(n - <span class=\"hljs-number\">1</span>, n * total);<br>&#125;<br><br><span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span><br></code></pre></td></tr></table></figure>\n<p>还有斐波那契数列的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 非尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fibonacci</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> &#125;;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">1</span>) + <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">2</span>);<br>&#125;<br><span class=\"hljs-title class_\">Fibonacci</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 89</span><br><span class=\"hljs-title class_\">Fibonacci</span>(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 运行很慢</span><br><br><span class=\"hljs-comment\">// 尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fibonacci</span>(<span class=\"hljs-params\">n, ac1 = <span class=\"hljs-number\">1</span>, ac2 = <span class=\"hljs-number\">1</span></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-keyword\">return</span> ac2; &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">1.</span> ac2, ac1 + ac2);<br>&#125;<br><br><span class=\"hljs-title class_\">Fibonacci2</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 573147844013817200000</span><br><span class=\"hljs-title class_\">Fibonacci2</span>(<span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 7.0330367711422765e+208</span><br></code></pre></td></tr></table></figure>\n<p>可以看出“尾部调用优化”对于“尾递归”的意义重大，所以一些函数式编程语言将其写入了语言规格。换句话来说只要使用尾递归来实现就不会发生栈溢出，从而节省内存。</p>\n<h3 id=\"蹦床函数\"><a href=\"#蹦床函数\" class=\"headerlink\" title=\"蹦床函数\"></a>蹦床函数</h3><p>由于尾部递归只能在严格模式下生效，理由如下：</p>\n<p>正常模式下函数有两个变量，可以用于跟踪和记录函数调用：</p>\n<ul>\n<li><code>func.arguments</code>：返回调用时的函数参数；</li>\n<li><code>func.caller</code>：返回调用当前的函数；</li>\n</ul>\n<p>尾部调用发生时，调用栈的记录会被改写，因此上面两个变量就会失真。而在严格模式下会禁用上面两个变量，因此尾部调用只能在严格模式下生效。</p>\n<p>那么，如果我现在正常模式下实现尾部递归的写法又该如何做呢？可以将递归转换为循环执行。也就是俗称的“蹦床函数”：如下所示：<code>sum</code>函数每执行一次，都会返回自身的另一个版本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trampoline</span>(<span class=\"hljs-params\">f</span>) &#123;<br>    <span class=\"hljs-keyword\">while</span> (f &amp;&amp; f <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Function</span>) &#123;<br>        f = <span class=\"hljs-title function_\">f</span>();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> f;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> sum.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">trampoline</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">100000</span>)); <span class=\"hljs-comment\">// 100001</span><br></code></pre></td></tr></table></figure>\n<p>但是上面的蹦床函数并不是真正的尾调用优化。下面这段代码来自官网教程。细细品位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">tco</span>(<span class=\"hljs-params\">f</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> value;<br>    <span class=\"hljs-keyword\">var</span> active = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 默认情况下该变量不激活</span><br>    <span class=\"hljs-keyword\">var</span> accumulated = [];<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">accumulator</span>(<span class=\"hljs-params\"></span>) &#123;<br>        accumulated.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>        <span class=\"hljs-keyword\">if</span> (!active) &#123;<br>            active = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 进入尾调用函数后激活</span><br>            <span class=\"hljs-keyword\">while</span>(accumulated.<span class=\"hljs-property\">length</span>) &#123;<br>                value = f.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, accumulated.<span class=\"hljs-title function_\">shift</span>());<br>            &#125;<br>            active = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 调用完毕后关闭</span><br>            <span class=\"hljs-keyword\">return</span> value;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-title function_\">tco</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">sum</span>(x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10000</span>) <span class=\"hljs-comment\">// 10001</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数参数的尾逗号\"><a href=\"#函数参数的尾逗号\" class=\"headerlink\" title=\"函数参数的尾逗号\"></a>函数参数的尾逗号</h2><p>ES7将允许函数的最后一个参数有尾逗号。在此之前，不允许最后一个参数携带逗号;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clownsEveryWhere</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\"> param1,</span><br><span class=\"hljs-params\"> param2,</span><br><span class=\"hljs-params\"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":8590,"excerpt":"","more":"<h1 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h1><h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><p>ES6以前函数参数是不能有默认值的，而ES6中对这个规则进行了修改了，函数参数也可以带默认参数。即直接写在参数定义的后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">x, y = <span class=\"hljs-string\">&#x27;World&#x27;</span></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y);<br>&#125;<br><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>) <span class=\"hljs-comment\">// Hello World</span><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;China&#x27;</span>) <span class=\"hljs-comment\">// Hello China</span><br><span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n<p>这样的写法有两个好处：一个是阅读代码的人可以立刻意识到哪些参数是可以省略的，不需要查看函数体；其次有利于代码将来的优化。即便在未来的版本对外接口中，彻底拿掉这个参数也不会导致原有代码无法运行。</p>\n<h3 id=\"结合解构赋值\"><a href=\"#结合解构赋值\" class=\"headerlink\" title=\"结合解构赋值\"></a>结合解构赋值</h3><p>参数默认值当然可以使用前面章节提到的解构特性进行赋值了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">&#123;x, y = <span class=\"hljs-number\">5</span>&#125;</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y);<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(&#123;&#125;) <span class=\"hljs-comment\">// undefined, 5</span><br><span class=\"hljs-title function_\">foo</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// 1, 5</span><br><span class=\"hljs-title function_\">foo</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>&#125;) <span class=\"hljs-comment\">// 1, 2</span><br><span class=\"hljs-title function_\">foo</span>() <span class=\"hljs-comment\">// Error</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"参数默认值的位置\"><a href=\"#参数默认值的位置\" class=\"headerlink\" title=\"参数默认值的位置\"></a>参数默认值的位置</h3><p>一般情况下定义了默认值的参数应该是函数的尾部，这样比较容易看出来，如果是非尾部的参数设置默认值，实际上该参数是没法省略的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x = <span class=\"hljs-number\">1</span>, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>() <span class=\"hljs-comment\">// [1, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [2, undefined]</span><br><span class=\"hljs-title function_\">f</span>(, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Error</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [1, 1]</span><br><br><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y = <span class=\"hljs-number\">5</span>, z</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [x, y, z];<br>&#125;<br><span class=\"hljs-title function_\">f</span>() <span class=\"hljs-comment\">// [undefined, 5, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [1, 5, undefined]</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, ,<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// Error</span><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, undefinied, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [1, 5, 2]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"length属性\"><a href=\"#length属性\" class=\"headerlink\" title=\"length属性\"></a>length属性</h3><p>函数的length属性将返回没有指定默认值的参数个数。也就是说：指定了默认值后，length属性将失真；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 1</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a = <span class=\"hljs-number\">5</span></span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 0</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b, c = <span class=\"hljs-number\">5</span></span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<p>如果设置了默认值的参数不是尾参数，那么length属性也不再记入后面的参数了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a = <span class=\"hljs-number\">0</span>, b, c</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 0</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b = <span class=\"hljs-number\">1</span>, c</span>) &#123;&#125;).<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>如果参数默认值是一个变量，则该变量所处的作用域与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x, y = x</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(y);<br>&#125;<br><br><span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<p>如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&#x27;outer&#x27;</span>;<br><br><span class=\"hljs-comment\">// func为一个默认匿名函数，返回值为变量foo</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\">func = x =&gt; foo</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&#x27;inner&#x27;</span>;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">func</span>());<br>&#125;<br><br><span class=\"hljs-title function_\">bar</span>(); <span class=\"hljs-comment\">// outer</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"默认参数的用途一目了然\"><a href=\"#默认参数的用途一目了然\" class=\"headerlink\" title=\"默认参数的用途一目了然\"></a>默认参数的用途一目了然</h3><p>利用默认参数值，可以指定某一个参数不得省略，一旦省略就抛出一个错误；如果想省略这个参数，只要设置成<code>undefined</code>就行了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throwIfMissing</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Missing parameters&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">mustBeProvided = throwIfMissing()</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> mustBeProvided;<br>&#125;<br><br><span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">// Error: Missing Parameters</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h3><p>顾名思义：就是入参的个数是不确定的，跟Java中的多参数语法类似。这里就不再赘述了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">...values</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> val <span class=\"hljs-keyword\">of</span> values) &#123;<br>        sum += val;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 10</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><p>扩展运算符为三个点<code>...</code>，是将一个数组转化为用逗号分隔的参数序列，是rest参数的逆运算。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(...[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]) <span class=\"hljs-comment\">// 1 2 3</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>, ...[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>], <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 1 2 3 4 5</span><br><br>[...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>)] <span class=\"hljs-comment\">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></code></pre></td></tr></table></figure>\n<p>该运算符主要用于函数调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-params\">array, ...items</span>) &#123;<br>    array.<span class=\"hljs-title function_\">push</span>(...items);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">38</span>];<br><span class=\"hljs-title function_\">add</span>(...numbers) <span class=\"hljs-comment\">// 42</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符的应用\"><a href=\"#扩展运算符的应用\" class=\"headerlink\" title=\"扩展运算符的应用\"></a>扩展运算符的应用</h3><h4 id=\"（1）合并数组\"><a href=\"#（1）合并数组\" class=\"headerlink\" title=\"（1）合并数组\"></a>（1）合并数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> arr3 = [<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>];<br><br>[...arr1, ...arr2, ...arr3] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（2）-与解构赋值结合\"><a href=\"#（2）-与解构赋值结合\" class=\"headerlink\" title=\"（2） 与解构赋值结合\"></a>（2） 与解构赋值结合</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = list[<span class=\"hljs-number\">0</span>], rest = list.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)<br><br>[a, ...rest] = list<br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br>first <span class=\"hljs-comment\">// 1</span><br>rest <span class=\"hljs-comment\">// [2, 3, 4, 5]</span><br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = []<br>first <span class=\"hljs-comment\">// undefined</span><br>rest <span class=\"hljs-comment\">// []</span><br><br><span class=\"hljs-keyword\">const</span> [first, ...rest] = [<span class=\"hljs-string\">&#x27;foo&#x27;</span>]<br>first <span class=\"hljs-comment\">// foo</span><br>rest <span class=\"hljs-comment\">// []</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（3）函数返回值\"><a href=\"#（3）函数返回值\" class=\"headerlink\" title=\"（3）函数返回值\"></a>（3）函数返回值</h4><p>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种办法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> dateFields = <span class=\"hljs-title function_\">readDateFields</span>(database);<br><span class=\"hljs-keyword\">var</span> d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(...dateFields);<br></code></pre></td></tr></table></figure>\n<h4 id=\"（4）字符串\"><a href=\"#（4）字符串\" class=\"headerlink\" title=\"（4）字符串\"></a>（4）字符串</h4><p>可以将字符串转换为真正的数组。因为扩展运算符可以很好地识别Unicode字符，因此最好都用扩展运算符；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[...<span class=\"hljs-string\">&#x27;hello&#x27;</span>]<br><span class=\"hljs-comment\">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"（5）实现了Iterator接口的对象\"><a href=\"#（5）实现了Iterator接口的对象\" class=\"headerlink\" title=\"（5）实现了Iterator接口的对象\"></a>（5）实现了Iterator接口的对象</h4><p>任何Iterator接口的对象，都可以用扩展运算符转换为真正的数组，之前已经提过了，这里不再赘述</p>\n<h4 id=\"（6）Map和Set结构、Generator函数\"><a href=\"#（6）Map和Set结构、Generator函数\" class=\"headerlink\" title=\"（6）Map和Set结构、Generator函数\"></a>（6）Map和Set结构、Generator函数</h4><p>承接第（5）点，Map和Set也部署了Iterator接口，所以也可以使用扩展运算符，Generator函数运行后返回的是一个遍历器对象，因此也可以使用扩展运算符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> go = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...<span class=\"hljs-title function_\">go</span>()] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>从ES5开始，函数内部可以使用严格模式，在ES2016中做了一点修改。规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式。</p>\n<p>这样规定的原因是：函数内部的严格模式同时适用于函数体和函数参数。但是函数执行时会先执行函数参数代码，再执行函数体代码。因此只有从函数体代码之中才能知道参数代码是否应该以严格模式执行，但是函数参数代码又要先于函数体执行。所以这就导致了不合理的存在。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\">value = <span class=\"hljs-number\">070</span></span>) &#123; <span class=\"hljs-comment\">// value = 070 先执行</span><br>    <span class=\"hljs-string\">&#x27;use strict&#x27;</span>; <span class=\"hljs-comment\">// 设置了严格模式</span><br>    <span class=\"hljs-keyword\">return</span> value; <span class=\"hljs-comment\">// 后执行</span><br>&#125;<br><span class=\"hljs-comment\">// Illegal &#x27;use strict&#x27; directive in function with non-simple parameter list</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"但是我想要用严格模式限定时该怎么办呢？\"><a href=\"#但是我想要用严格模式限定时该怎么办呢？\" class=\"headerlink\" title=\"但是我想要用严格模式限定时该怎么办呢？\"></a>但是我想要用严格模式限定时该怎么办呢？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-meta\">&#x27;use strict&#x27;</span> <span class=\"hljs-comment\">// 全局严格模式</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\">a, b = a</span>) &#123;&#125;<br><br><span class=\"hljs-comment\">// 由于函数参数部分会先执行：那很简单，将函数包在一个无参数的立即执行函数中</span><br><span class=\"hljs-keyword\">const</span> doSomething = (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-string\">&#x27;use strict&#x27;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value = <span class=\"hljs-number\">42</span></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h2><p>函数的<code>name</code>属性返回的是函数的名称。如果是将匿名函数赋给一个变量，在ES5中会返回空串，但是在ES6中会将变量名作为函数的名称。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span> () &#123;&#125;<br>foo.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &#x27;foo&#x27;</span><br><br><span class=\"hljs-keyword\">var</span> func1 = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><br><span class=\"hljs-comment\">// ES5</span><br>func1.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &quot;&quot;</span><br><br><span class=\"hljs-comment\">// ES6</span><br>func1.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// &quot;func1&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6中允许使用箭头<code>=&gt;</code>来定义函数，定义效果和你使用<code>function</code>创建函数是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">f</span> = v =&gt; v;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> v;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>如果箭头函数不需要参数或者需要多个参数，就是用圆括号来代表参数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>;&#125;<br><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">num1, num2</span>) =&gt; num1 + num2;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">num1, num2</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> num1 + num2;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果箭头函数的代码块部分超过一条语句，就是用大括号将它们围起来，必须在对象外面加上括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">num1, num2</span>) =&gt; &#123;<span class=\"hljs-keyword\">return</span> num1 + num2;&#125;<br><br><span class=\"hljs-comment\">//大括号会解释为代码块，所以如果是用箭头函数返回对象，必须在对象外层加上大括号</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">getTemplate</span> = id =&gt; (&#123;<span class=\"hljs-attr\">id</span>: id, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Temp&quot;</span>&#125;);<br></code></pre></td></tr></table></figure>\n<p>箭头函数也可以与变量解构结合</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">full</span> = (<span class=\"hljs-params\">&#123; first ,last &#125;</span>) =&gt; first + <span class=\"hljs-string\">&#x27; &#x27;</span> + last;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">full</span>(<span class=\"hljs-params\">person</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> person.<span class=\"hljs-property\">first</span> + <span class=\"hljs-string\">&#x27; &#x27;</span> + person.<span class=\"hljs-property\">last</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用箭头函数需要注意几个地方：</p>\n<ul>\n<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象；</li>\n<li>不可以当做构造函数；（<code>this</code>对象的指向是可变的，而在箭头函数中是固定的）</li>\n<li>不可以使用<code>arguments</code>对象，如果要用，可以使用Rest参数代替；</li>\n<li>不可以使用<code>yield</code>命令，因此箭头函数不可以用作Generator函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;id:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>);<br>    &#125;, <span class=\"hljs-number\">100</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-number\">21</span>;<br>foo.<span class=\"hljs-title function_\">call</span>(&#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">42</span> &#125;);<br><span class=\"hljs-comment\">// id: 42</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"绑定this\"><a href=\"#绑定this\" class=\"headerlink\" title=\"绑定this\"></a>绑定this</h2><p>箭头函数可以绑定<code>this</code>对象，因此大大减少了显式绑定<code>this</code>对象的写法（<code>apply</code>、<code>call</code>、<code>bind</code>）。但是见图函数并不适用于任何场合，因此ES7提出了函数绑定运算符。语法为两个并排的冒号：<code>::</code>。双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境，绑定到右边的函数上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">foo</span>::bar <span class=\"hljs-comment\">// bar.bind(foo)</span><br><br><span class=\"hljs-attr\">foo</span>::<span class=\"hljs-title function_\">bar</span>(...<span class=\"hljs-variable language_\">arguments</span>); <span class=\"hljs-comment\">// bar.bind(foo, arguments)</span><br><br><span class=\"hljs-keyword\">const</span> hasOwnProperty = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hasOwnProperty</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hasOwn</span>(<span class=\"hljs-params\">obj, key</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-attr\">obj</span>::<span class=\"hljs-title function_\">hasOwnProperty</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果双冒号左边为空（对需要绑定的对象为空），则等于将该方法绑定在对象上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> method = <span class=\"hljs-attr\">obj</span>::obj.<span class=\"hljs-property\">foo</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> method = ::obj.<span class=\"hljs-property\">foo</span>;<br><br><span class=\"hljs-keyword\">let</span> log = ::<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> log = <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">console</span>);<br></code></pre></td></tr></table></figure>\n<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; map, takeWhile, forEach &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;iterlib&quot;</span>;<br><br><span class=\"hljs-comment\">// 例1</span><br><span class=\"hljs-title function_\">getPlayers</span>()<br>::<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-title function_\">character</span>())<br>::<span class=\"hljs-title function_\">takeWhile</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-property\">strength</span> &gt; <span class=\"hljs-number\">100</span>)<br>::<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x));<br><br><span class=\"hljs-comment\">// 例2</span><br><span class=\"hljs-keyword\">let</span> &#123; find, html &#125; = jake;<br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&quot;div.myClass&quot;</span>);<br>::<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-string\">&quot;p&quot;</span>)<br>::<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-string\">&quot;hahahh&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><p>尾调用是函数式编程中的一个重要概念：就是指某个函数的最后一步调用是另一个函数。例如下面的例子：函数f的最后一步是调用函数g。尾调用优化只在严格模式下才生效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>下面三种情况都不属于尾调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-title function_\">g</span>(x);<br>    <span class=\"hljs-keyword\">return</span> y;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(x) + <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-title function_\">g</span>(x);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">m</span>(x);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">n</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通常来说：函数调用会在内存中形成一个“调用记录”，也称为调用帧。保存调用位置和内部变量等信息。</p>\n<p>由于尾调用是函数最后一步操作，因此不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧即可。</p>\n<p>这里有一个前提条件：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾部调用优化”；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> m = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">let</span> n = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(m + n);<br>&#125;<br><span class=\"hljs-title function_\">f</span>()<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-number\">3</span>)<br>&#125;<br><span class=\"hljs-title function_\">f</span>();<br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-title function_\">g</span>(<span class=\"hljs-number\">3</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>基于上述尾部调用优化的特性：因此对于尾递归来说，由于只存在一个调用帧，因此永远也不会发生“栈溢出”错误。（注：将函数的多参数转换为单参数的范式成为”柯里化“）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 非尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> n * <span class=\"hljs-title function_\">factorial</span>(n - <span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span><br><br><span class=\"hljs-comment\">// 尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n, total = <span class=\"hljs-number\">1</span></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> total;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">factorial</span>(n - <span class=\"hljs-number\">1</span>, n * total);<br>&#125;<br><br><span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// 120</span><br></code></pre></td></tr></table></figure>\n<p>还有斐波那契数列的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 非尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fibonacci</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> &#125;;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">1</span>) + <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">2</span>);<br>&#125;<br><span class=\"hljs-title class_\">Fibonacci</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 89</span><br><span class=\"hljs-title class_\">Fibonacci</span>(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 运行很慢</span><br><br><span class=\"hljs-comment\">// 尾递归写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fibonacci</span>(<span class=\"hljs-params\">n, ac1 = <span class=\"hljs-number\">1</span>, ac2 = <span class=\"hljs-number\">1</span></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-keyword\">return</span> ac2; &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Fibonacci</span>(n - <span class=\"hljs-number\">1.</span> ac2, ac1 + ac2);<br>&#125;<br><br><span class=\"hljs-title class_\">Fibonacci2</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-comment\">// 573147844013817200000</span><br><span class=\"hljs-title class_\">Fibonacci2</span>(<span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 7.0330367711422765e+208</span><br></code></pre></td></tr></table></figure>\n<p>可以看出“尾部调用优化”对于“尾递归”的意义重大，所以一些函数式编程语言将其写入了语言规格。换句话来说只要使用尾递归来实现就不会发生栈溢出，从而节省内存。</p>\n<h3 id=\"蹦床函数\"><a href=\"#蹦床函数\" class=\"headerlink\" title=\"蹦床函数\"></a>蹦床函数</h3><p>由于尾部递归只能在严格模式下生效，理由如下：</p>\n<p>正常模式下函数有两个变量，可以用于跟踪和记录函数调用：</p>\n<ul>\n<li><code>func.arguments</code>：返回调用时的函数参数；</li>\n<li><code>func.caller</code>：返回调用当前的函数；</li>\n</ul>\n<p>尾部调用发生时，调用栈的记录会被改写，因此上面两个变量就会失真。而在严格模式下会禁用上面两个变量，因此尾部调用只能在严格模式下生效。</p>\n<p>那么，如果我现在正常模式下实现尾部递归的写法又该如何做呢？可以将递归转换为循环执行。也就是俗称的“蹦床函数”：如下所示：<code>sum</code>函数每执行一次，都会返回自身的另一个版本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trampoline</span>(<span class=\"hljs-params\">f</span>) &#123;<br>    <span class=\"hljs-keyword\">while</span> (f &amp;&amp; f <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Function</span>) &#123;<br>        f = <span class=\"hljs-title function_\">f</span>();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> f;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> sum.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">trampoline</span>(<span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">100000</span>)); <span class=\"hljs-comment\">// 100001</span><br></code></pre></td></tr></table></figure>\n<p>但是上面的蹦床函数并不是真正的尾调用优化。下面这段代码来自官网教程。细细品位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">tco</span>(<span class=\"hljs-params\">f</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> value;<br>    <span class=\"hljs-keyword\">var</span> active = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 默认情况下该变量不激活</span><br>    <span class=\"hljs-keyword\">var</span> accumulated = [];<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">accumulator</span>(<span class=\"hljs-params\"></span>) &#123;<br>        accumulated.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>        <span class=\"hljs-keyword\">if</span> (!active) &#123;<br>            active = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 进入尾调用函数后激活</span><br>            <span class=\"hljs-keyword\">while</span>(accumulated.<span class=\"hljs-property\">length</span>) &#123;<br>                value = f.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, accumulated.<span class=\"hljs-title function_\">shift</span>());<br>            &#125;<br>            active = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 调用完毕后关闭</span><br>            <span class=\"hljs-keyword\">return</span> value;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> sum = <span class=\"hljs-title function_\">tco</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">sum</span>(x + <span class=\"hljs-number\">1</span>, y - <span class=\"hljs-number\">1</span>)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10000</span>) <span class=\"hljs-comment\">// 10001</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数参数的尾逗号\"><a href=\"#函数参数的尾逗号\" class=\"headerlink\" title=\"函数参数的尾逗号\"></a>函数参数的尾逗号</h2><p>ES7将允许函数的最后一个参数有尾逗号。在此之前，不允许最后一个参数携带逗号;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clownsEveryWhere</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\"> param1,</span><br><span class=\"hljs-params\"> param2,</span><br><span class=\"hljs-params\"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 Generator函数","date":"2022-02-17T14:20:37.000Z","updated":"2022-02-17T14:20:37.000Z","_content":"\n# Generator函数\n\n## 基本概念\n\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\nGenerator函数有多种理解角度：从语法上：可以将其理解成状态机，封装了多个内部状态；其次：执行Generator函数会返回一个遍历器对象。\n\n形式上，Generator函数是个普通函数，但是有两个特征。一是`function`关键字和函数名之间多了一个星号；二是函数体内部使用了`yield`语句，定义了不同的内部状态。\n\n```javascript\nfunction* hello() {\n    yield 'hello';\n    yield 'world';\n    return 'ending';\n}\n\nvar hello = hello();\nhello.next() // hello - 1\nhello.next() // world - 2\nhello.next() // ending - 3\nhello.next() //undefined - 4\n```\n\n## yield语句\n\n可以看出，只有显式调用next()方法才会继续遍历到下一个状态，所以其实提供了一种可以暂停执行的函数。其中yield就是暂停标识。如果Generator函数不使用yield语句，这时就变成了一个单纯地暂缓执行函数。注意：yield不能用在普通函数中。\n\n```javascript\nfunction* f() {\n    console.log('Executed!');\n}\n\nvar generator = f();\nsetTimeout(function() {\n    generator.next();\n}, 2000);\n```\n\n## 与Iterator接口的关系\n\n由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable] // [1, 2, 3]\n```\n\n## next()方法的参数\n\n`yield`语句本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。\n\n```javascript\nfunction* f() {\n    for (var i = 0; true; i++) {\n        var reset = yield i;\n        if (reset) {i = -1;}\n    }\n}\n\nvar g = f();\n\ng.next()\ng.next()\ng.next(true)\n```\n\n上面这个例子有一个很有意思的特性：可以通过在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而来调整函数的行为。\n\n## for...of循环\n\n`for...of`循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。\n\n```javascript\nfunction* foo() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n    yield 5;\n    return 6;\n}\n\nfor (let v of foo()) {\n    console.log(v);\n}\n// 1 2 3 4 5\n```\n\n需要注意的是：一旦next方法的返回对象的done属性为true，for...of循环就会终止，且不包含该返回对象。下面再举一个解斐波那契数列的例子。\n\n```javascript\nfunction* fibonacci() {\n    let [prev, curr] = [0, 1];\n    for (;;) { // 内部自动会取下一个yield语句\n        [prev, curr] = [curr, prev + curr];\n        yield curr;\n    }\n}\n\nfor (let n of fibonacci()) {\n    if (n > 1000) break;\n    console.log(n);\n}\n```\n\n利用`for...of`循环可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用`for...of`循环，通过Generator函数为它加上这个接口，就可以使用了。\n\n```javascript\nfunction* objectEntries() {\n    let propKeys = Reflect.ownKeys(obj);\n    \n    for (let propKey of propKeys) {\n        yield [propKey, obj[propKey]];\n    }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n    console.log(`${key}: ${value}`);\n}\n\n// 另一种写法是将Generator函数加入到Symbol.iterator属性中.\njane[Symbol.iterator] = objectEntries;\n```\n\n## Generator.prototype.throw()\n\nGenerator函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。切记：不要混淆遍历器对象的throw方法和全局throw命令。因此：如果Generator函数内部没有部署`try...catch`代码块，那么`throw`方法抛出的错误，将被外部`try...catch`代码块捕获。\n\n```javascript\nvar g = function* () {\n    try {\n        yield;\n    } catch (e) {\n        console.log('Inner catch', e);\n    }\n};\n\nvar i = g();\ni.next();\ni.throw(new Error('Error occurs!'));\n```\n\n如果Generator函数内部和外部都没有部署`try...catch`代码块，那么程序将直接报错并且中断运行。\n\n```javascript\nvar gen = function* gen() {\n    yield console.log('hello');\n    yield console.log('world');\n}\n\nvar g = gen();\ng.next();\ng.throw();\n```\n\n如果Generator函数内部部署了`try-...catch`代码块，就不会影响下一次yield语句的执行。throw方法在被捕获以后会顺带执行下一条yield语句。\n\n```javascript\nvar gen = function* gen() {\n    try {\n        yield console.log('a');\n    } catch (e) {\n        // ...\n    }\n    yield console.log('b');\n    yield console.log('c');\n}\n\nvar g = gen();\ng.next();\ng.throw();\ng.next();\n```\n\n## Generator.prototype.return()\n\nGenerator函数的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。\n\n```javascript\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nvar g = gen();\n\ng.next(); // {value:1, done: false}\ng.return('foo'); // {value: 'foo', done: true}\ng.next(); // {value: undefined, done: true}\n```\n\n如果`return`方法调用时，不提供参数，则返回的`value`值为`undefined`;\n\n```javascript\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nvar g = gen();\n\ng.next(); // {value: 1, done: false}\ng.return(); // {value: undefined, done: true}\n```\n\n如果Generator函数内部有`try...finally`代码块，那么`return`方法将会推迟到`finally`代码块执行完再执行。\n\n```javascript\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers()\ng.next() // { done: false, value: 1 }\ng.next() // { done: false, value: 2 }\ng.return(7) // { done: false, value: 4 }\ng.next() // { done: false, value: 5 }\ng.next() // { done: true, value: 7 }\n```\n\n## yield* 语句\n\n该语句是用来在一个Generator函数中执行另外一个Generator函数的。从语法的角度上看：如果yield语句后面跟着一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。\n\n```javascript\nfunction* bar() {\n    yield 'x';\n    yield* foo();\n    yield 'y';\n}\n\nfunction* foo() {\n    yield 'a';\n    yield 'b';\n}\n```\n\n## Generator函数的this\n\nGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的`prototype`对象上的方法。\n\n```javascript\nfunction* g() {}\n\ng.prototype.hello = function() {\n    return 'hi!';\n};\n\nlet obj = g();\n\nobj instanceof g;\nobj.hello(); // 'hi!'\n```\n\n默认情况下，Generator函数是不可以使用new关键字生成的，但是我们可以用下面这种方式来生成一个空的Generator实例。\n\n```javascript\nfunction* F() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar obj = {};\nvar f = F.call(F.prototype);\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n\n```\n\n再将F改造成构造函数，就可以使用new命令来创建对象了；\n\n```javascript\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n```\n\n## Generator函数的应用\n\n### （1）异步操作的同步化表达\n\n基于Generator函数暂停执行的效果，意味着可以把异步写到yield语句中。等到next方法时再往后执行。这实际上等同于不需要再写回调函数了，因为异步操作的后续可以放在yield语句的下面。具体例子前面已经有涉及到了，所以这里就不再演示了。\n\n### （2）控制流管理\n\n如果一个多步操作非常耗时，可以使用Generator函数进一步改善代码的运作流程。不过这种写法只适合同步操作。\n\n```javascript\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n\nscheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) {\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) {\n    task.value = taskObj.value\n    scheduler(task);\n  }\n}\n```\n\n### （3）部署Iterator接口\n\n利用Generator函数的特性，可以在任意对象上部署Iterator接口。\n\n```javascript\nfunction* iterEntries(obj) {\n  let keys = Object.keys(obj);\n  for (let i=0; i < keys.length; i++) {\n    let key = keys[i];\n    yield [key, obj[key]];\n  }\n}\n\nlet myObj = { foo: 3, bar: 7 };\n\nfor (let [key, value] of iterEntries(myObj)) {\n  console.log(key, value);\n}\n\n// foo 3\n// bar 7\n```\n\n### （4）作为数据结构\n\nGenerator可以看作数据结构，更确切的说是一种数组结构，因为Generator函数可以返回一系列的值。这意味着它可以对任意表达式，提供类似数组的接口。\n\n```javascript\nfunction *doStuff() {\n  yield fs.readFile.bind(null, 'hello.txt');\n  yield fs.readFile.bind(null, 'world.txt');\n  yield fs.readFile.bind(null, 'and-such.txt');\n}\n```\n","source":"_posts/javascript/es6-generator-function.md","raw":"---\ntitle: ES6 Generator函数\ndate: 2022-02-17 22:20:37\nupdated: 2022-02-17 22:20:37\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Generator函数\n\n## 基本概念\n\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\nGenerator函数有多种理解角度：从语法上：可以将其理解成状态机，封装了多个内部状态；其次：执行Generator函数会返回一个遍历器对象。\n\n形式上，Generator函数是个普通函数，但是有两个特征。一是`function`关键字和函数名之间多了一个星号；二是函数体内部使用了`yield`语句，定义了不同的内部状态。\n\n```javascript\nfunction* hello() {\n    yield 'hello';\n    yield 'world';\n    return 'ending';\n}\n\nvar hello = hello();\nhello.next() // hello - 1\nhello.next() // world - 2\nhello.next() // ending - 3\nhello.next() //undefined - 4\n```\n\n## yield语句\n\n可以看出，只有显式调用next()方法才会继续遍历到下一个状态，所以其实提供了一种可以暂停执行的函数。其中yield就是暂停标识。如果Generator函数不使用yield语句，这时就变成了一个单纯地暂缓执行函数。注意：yield不能用在普通函数中。\n\n```javascript\nfunction* f() {\n    console.log('Executed!');\n}\n\nvar generator = f();\nsetTimeout(function() {\n    generator.next();\n}, 2000);\n```\n\n## 与Iterator接口的关系\n\n由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable] // [1, 2, 3]\n```\n\n## next()方法的参数\n\n`yield`语句本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。\n\n```javascript\nfunction* f() {\n    for (var i = 0; true; i++) {\n        var reset = yield i;\n        if (reset) {i = -1;}\n    }\n}\n\nvar g = f();\n\ng.next()\ng.next()\ng.next(true)\n```\n\n上面这个例子有一个很有意思的特性：可以通过在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而来调整函数的行为。\n\n## for...of循环\n\n`for...of`循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。\n\n```javascript\nfunction* foo() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n    yield 5;\n    return 6;\n}\n\nfor (let v of foo()) {\n    console.log(v);\n}\n// 1 2 3 4 5\n```\n\n需要注意的是：一旦next方法的返回对象的done属性为true，for...of循环就会终止，且不包含该返回对象。下面再举一个解斐波那契数列的例子。\n\n```javascript\nfunction* fibonacci() {\n    let [prev, curr] = [0, 1];\n    for (;;) { // 内部自动会取下一个yield语句\n        [prev, curr] = [curr, prev + curr];\n        yield curr;\n    }\n}\n\nfor (let n of fibonacci()) {\n    if (n > 1000) break;\n    console.log(n);\n}\n```\n\n利用`for...of`循环可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用`for...of`循环，通过Generator函数为它加上这个接口，就可以使用了。\n\n```javascript\nfunction* objectEntries() {\n    let propKeys = Reflect.ownKeys(obj);\n    \n    for (let propKey of propKeys) {\n        yield [propKey, obj[propKey]];\n    }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n    console.log(`${key}: ${value}`);\n}\n\n// 另一种写法是将Generator函数加入到Symbol.iterator属性中.\njane[Symbol.iterator] = objectEntries;\n```\n\n## Generator.prototype.throw()\n\nGenerator函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。切记：不要混淆遍历器对象的throw方法和全局throw命令。因此：如果Generator函数内部没有部署`try...catch`代码块，那么`throw`方法抛出的错误，将被外部`try...catch`代码块捕获。\n\n```javascript\nvar g = function* () {\n    try {\n        yield;\n    } catch (e) {\n        console.log('Inner catch', e);\n    }\n};\n\nvar i = g();\ni.next();\ni.throw(new Error('Error occurs!'));\n```\n\n如果Generator函数内部和外部都没有部署`try...catch`代码块，那么程序将直接报错并且中断运行。\n\n```javascript\nvar gen = function* gen() {\n    yield console.log('hello');\n    yield console.log('world');\n}\n\nvar g = gen();\ng.next();\ng.throw();\n```\n\n如果Generator函数内部部署了`try-...catch`代码块，就不会影响下一次yield语句的执行。throw方法在被捕获以后会顺带执行下一条yield语句。\n\n```javascript\nvar gen = function* gen() {\n    try {\n        yield console.log('a');\n    } catch (e) {\n        // ...\n    }\n    yield console.log('b');\n    yield console.log('c');\n}\n\nvar g = gen();\ng.next();\ng.throw();\ng.next();\n```\n\n## Generator.prototype.return()\n\nGenerator函数的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。\n\n```javascript\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nvar g = gen();\n\ng.next(); // {value:1, done: false}\ng.return('foo'); // {value: 'foo', done: true}\ng.next(); // {value: undefined, done: true}\n```\n\n如果`return`方法调用时，不提供参数，则返回的`value`值为`undefined`;\n\n```javascript\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nvar g = gen();\n\ng.next(); // {value: 1, done: false}\ng.return(); // {value: undefined, done: true}\n```\n\n如果Generator函数内部有`try...finally`代码块，那么`return`方法将会推迟到`finally`代码块执行完再执行。\n\n```javascript\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers()\ng.next() // { done: false, value: 1 }\ng.next() // { done: false, value: 2 }\ng.return(7) // { done: false, value: 4 }\ng.next() // { done: false, value: 5 }\ng.next() // { done: true, value: 7 }\n```\n\n## yield* 语句\n\n该语句是用来在一个Generator函数中执行另外一个Generator函数的。从语法的角度上看：如果yield语句后面跟着一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。\n\n```javascript\nfunction* bar() {\n    yield 'x';\n    yield* foo();\n    yield 'y';\n}\n\nfunction* foo() {\n    yield 'a';\n    yield 'b';\n}\n```\n\n## Generator函数的this\n\nGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的`prototype`对象上的方法。\n\n```javascript\nfunction* g() {}\n\ng.prototype.hello = function() {\n    return 'hi!';\n};\n\nlet obj = g();\n\nobj instanceof g;\nobj.hello(); // 'hi!'\n```\n\n默认情况下，Generator函数是不可以使用new关键字生成的，但是我们可以用下面这种方式来生成一个空的Generator实例。\n\n```javascript\nfunction* F() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar obj = {};\nvar f = F.call(F.prototype);\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n\n```\n\n再将F改造成构造函数，就可以使用new命令来创建对象了；\n\n```javascript\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n```\n\n## Generator函数的应用\n\n### （1）异步操作的同步化表达\n\n基于Generator函数暂停执行的效果，意味着可以把异步写到yield语句中。等到next方法时再往后执行。这实际上等同于不需要再写回调函数了，因为异步操作的后续可以放在yield语句的下面。具体例子前面已经有涉及到了，所以这里就不再演示了。\n\n### （2）控制流管理\n\n如果一个多步操作非常耗时，可以使用Generator函数进一步改善代码的运作流程。不过这种写法只适合同步操作。\n\n```javascript\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n\nscheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) {\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) {\n    task.value = taskObj.value\n    scheduler(task);\n  }\n}\n```\n\n### （3）部署Iterator接口\n\n利用Generator函数的特性，可以在任意对象上部署Iterator接口。\n\n```javascript\nfunction* iterEntries(obj) {\n  let keys = Object.keys(obj);\n  for (let i=0; i < keys.length; i++) {\n    let key = keys[i];\n    yield [key, obj[key]];\n  }\n}\n\nlet myObj = { foo: 3, bar: 7 };\n\nfor (let [key, value] of iterEntries(myObj)) {\n  console.log(key, value);\n}\n\n// foo 3\n// bar 7\n```\n\n### （4）作为数据结构\n\nGenerator可以看作数据结构，更确切的说是一种数组结构，因为Generator函数可以返回一系列的值。这意味着它可以对任意表达式，提供类似数组的接口。\n\n```javascript\nfunction *doStuff() {\n  yield fs.readFile.bind(null, 'hello.txt');\n  yield fs.readFile.bind(null, 'world.txt');\n  yield fs.readFile.bind(null, 'and-such.txt');\n}\n```\n","slug":"javascript/es6-generator-function","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2x00112y615f20fd98","content":"<h1 id=\"Generator函数\"><a href=\"#Generator函数\" class=\"headerlink\" title=\"Generator函数\"></a>Generator函数</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>\n<p>Generator函数有多种理解角度：从语法上：可以将其理解成状态机，封装了多个内部状态；其次：执行Generator函数会返回一个遍历器对象。</p>\n<p>形式上，Generator函数是个普通函数，但是有两个特征。一是<code>function</code>关键字和函数名之间多了一个星号；二是函数体内部使用了<code>yield</code>语句，定义了不同的内部状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">hello</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;world&#x27;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;ending&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> hello = <span class=\"hljs-title function_\">hello</span>();<br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// hello - 1</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// world - 2</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// ending - 3</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">//undefined - 4</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"yield语句\"><a href=\"#yield语句\" class=\"headerlink\" title=\"yield语句\"></a>yield语句</h2><p>可以看出，只有显式调用next()方法才会继续遍历到下一个状态，所以其实提供了一种可以暂停执行的函数。其中yield就是暂停标识。如果Generator函数不使用yield语句，这时就变成了一个单纯地暂缓执行函数。注意：yield不能用在普通函数中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Executed!&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> generator = <span class=\"hljs-title function_\">f</span>();<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    generator.<span class=\"hljs-title function_\">next</span>();<br>&#125;, <span class=\"hljs-number\">2000</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"与Iterator接口的关系\"><a href=\"#与Iterator接口的关系\" class=\"headerlink\" title=\"与Iterator接口的关系\"></a>与Iterator接口的关系</h2><p>由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"next-方法的参数\"><a href=\"#next-方法的参数\" class=\"headerlink\" title=\"next()方法的参数\"></a>next()方法的参数</h2><p><code>yield</code>语句本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; <span class=\"hljs-literal\">true</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">var</span> reset = <span class=\"hljs-keyword\">yield</span> i;<br>        <span class=\"hljs-keyword\">if</span> (reset) &#123;i = -<span class=\"hljs-number\">1</span>;&#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">f</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>()<br>g.<span class=\"hljs-title function_\">next</span>()<br>g.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-literal\">true</span>)<br></code></pre></td></tr></table></figure>\n<p>上面这个例子有一个很有意思的特性：可以通过在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而来调整函数的行为。</p>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p><code>for...of</code>循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">6</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">foo</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br><span class=\"hljs-comment\">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure>\n<p>需要注意的是：一旦next方法的返回对象的done属性为true，for…of循环就会终止，且不包含该返回对象。下面再举一个解斐波那契数列的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibonacci</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> [prev, curr] = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123; <span class=\"hljs-comment\">// 内部自动会取下一个yield语句</span><br>        [prev, curr] = [curr, prev + curr];<br>        <span class=\"hljs-keyword\">yield</span> curr;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> n <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">fibonacci</span>()) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &gt; <span class=\"hljs-number\">1000</span>) <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>利用<code>for...of</code>循环可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用<code>for...of</code>循环，通过Generator函数为它加上这个接口，就可以使用了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">objectEntries</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> propKeys = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(obj);<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> propKey <span class=\"hljs-keyword\">of</span> propKeys) &#123;<br>        <span class=\"hljs-keyword\">yield</span> [propKey, obj[propKey]];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> jane = &#123; <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;Jane&#x27;</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">objectEntries</span>(jane)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法是将Generator函数加入到Symbol.iterator属性中.</span><br>jane[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = objectEntries;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-throw\"><a href=\"#Generator-prototype-throw\" class=\"headerlink\" title=\"Generator.prototype.throw()\"></a>Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。切记：不要混淆遍历器对象的throw方法和全局throw命令。因此：如果Generator函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">yield</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Inner catch&#x27;</span>, e);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-title function_\">g</span>();<br>i.<span class=\"hljs-title function_\">next</span>();<br>i.<span class=\"hljs-keyword\">throw</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Error occurs!&#x27;</span>));<br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部和外部都没有部署<code>try...catch</code>代码块，那么程序将直接报错并且中断运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;world&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br>g.<span class=\"hljs-keyword\">throw</span>();<br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部部署了<code>try-...catch</code>代码块，就不会影响下一次yield语句的执行。throw方法在被捕获以后会顺带执行下一条yield语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br>g.<span class=\"hljs-keyword\">throw</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-return\"><a href=\"#Generator-prototype-return\" class=\"headerlink\" title=\"Generator.prototype.return()\"></a>Generator.prototype.return()</h2><p>Generator函数的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value:1, done: false&#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>); <span class=\"hljs-comment\">// &#123;value: &#x27;foo&#x27;, done: true&#125;</span><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>return</code>方法调用时，不提供参数，则返回的<code>value</code>值为<code>undefined</code>;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value: 1, done: false&#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(); <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部有<code>try...finally</code>代码块，那么<code>return</code>方法将会推迟到<code>finally</code>代码块执行完再执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* numbers () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>  &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">6</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">numbers</span>()<br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 1 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 2 &#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-number\">7</span>) <span class=\"hljs-comment\">// &#123; done: false, value: 4 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 5 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: true, value: 7 &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"yield-语句\"><a href=\"#yield-语句\" class=\"headerlink\" title=\"yield* 语句\"></a>yield* 语句</h2><p>该语句是用来在一个Generator函数中执行另外一个Generator函数的。从语法的角度上看：如果yield语句后面跟着一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;x&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-title function_\">foo</span>();<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;y&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;b&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator函数的this\"><a href=\"#Generator函数的this\" class=\"headerlink\" title=\"Generator函数的this\"></a>Generator函数的this</h2><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><br>g.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hello</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hi!&#x27;</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-title function_\">g</span>();<br><br>obj <span class=\"hljs-keyword\">instanceof</span> g;<br>obj.<span class=\"hljs-title function_\">hello</span>(); <span class=\"hljs-comment\">// &#x27;hi!&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>默认情况下，Generator函数是不可以使用new关键字生成的，但是我们可以用下面这种方式来生成一个空的Generator实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span> = <span class=\"hljs-number\">3</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> f = F.<span class=\"hljs-title function_\">call</span>(F.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 2, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 3, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: undefined, done: true&#125;</span><br><br>obj.<span class=\"hljs-property\">a</span> <span class=\"hljs-comment\">// 1</span><br>obj.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br>obj.<span class=\"hljs-property\">c</span> <span class=\"hljs-comment\">// 3</span><br><br></code></pre></td></tr></table></figure>\n<p>再将F改造成构造函数，就可以使用new命令来创建对象了；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span> = <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> gen.<span class=\"hljs-title function_\">call</span>(gen.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 2, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 3, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: undefined, done: true&#125;</span><br><br>f.<span class=\"hljs-property\">a</span> <span class=\"hljs-comment\">// 1</span><br>f.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br>f.<span class=\"hljs-property\">c</span> <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator函数的应用\"><a href=\"#Generator函数的应用\" class=\"headerlink\" title=\"Generator函数的应用\"></a>Generator函数的应用</h2><h3 id=\"（1）异步操作的同步化表达\"><a href=\"#（1）异步操作的同步化表达\" class=\"headerlink\" title=\"（1）异步操作的同步化表达\"></a>（1）异步操作的同步化表达</h3><p>基于Generator函数暂停执行的效果，意味着可以把异步写到yield语句中。等到next方法时再往后执行。这实际上等同于不需要再写回调函数了，因为异步操作的后续可以放在yield语句的下面。具体例子前面已经有涉及到了，所以这里就不再演示了。</p>\n<h3 id=\"（2）控制流管理\"><a href=\"#（2）控制流管理\" class=\"headerlink\" title=\"（2）控制流管理\"></a>（2）控制流管理</h3><p>如果一个多步操作非常耗时，可以使用Generator函数进一步改善代码的运作流程。不过这种写法只适合同步操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">longRunningTask</span>(<span class=\"hljs-params\">value1</span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> value2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step1</span>(value1);<br>    <span class=\"hljs-keyword\">var</span> value3 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step2</span>(value2);<br>    <span class=\"hljs-keyword\">var</span> value4 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step3</span>(value3);<br>    <span class=\"hljs-keyword\">var</span> value5 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step4</span>(value4);<br>    <span class=\"hljs-comment\">// Do something with value4</span><br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-comment\">// Handle any error from step1 through step4</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">scheduler</span>(<span class=\"hljs-title function_\">longRunningTask</span>(initialValue));<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">scheduler</span>(<span class=\"hljs-params\">task</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> taskObj = task.<span class=\"hljs-title function_\">next</span>(task.<span class=\"hljs-property\">value</span>);<br>  <span class=\"hljs-comment\">// 如果Generator函数未结束，就继续调用</span><br>  <span class=\"hljs-keyword\">if</span> (!taskObj.<span class=\"hljs-property\">done</span>) &#123;<br>    task.<span class=\"hljs-property\">value</span> = taskObj.<span class=\"hljs-property\">value</span><br>    <span class=\"hljs-title function_\">scheduler</span>(task);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（3）部署Iterator接口\"><a href=\"#（3）部署Iterator接口\" class=\"headerlink\" title=\"（3）部署Iterator接口\"></a>（3）部署Iterator接口</h3><p>利用Generator函数的特性，可以在任意对象上部署Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">iterEntries</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> keys = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj);<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i &lt; keys.<span class=\"hljs-property\">length</span>; i++) &#123;<br>    <span class=\"hljs-keyword\">let</span> key = keys[i];<br>    <span class=\"hljs-keyword\">yield</span> [key, obj[key]];<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myObj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">7</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">iterEntries</span>(myObj)) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value);<br>&#125;<br><br><span class=\"hljs-comment\">// foo 3</span><br><span class=\"hljs-comment\">// bar 7</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）作为数据结构\"><a href=\"#（4）作为数据结构\" class=\"headerlink\" title=\"（4）作为数据结构\"></a>（4）作为数据结构</h3><p>Generator可以看作数据结构，更确切的说是一种数组结构，因为Generator函数可以返回一系列的值。这意味着它可以对任意表达式，提供类似数组的接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title function_\">doStuff</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;hello.txt&#x27;</span>);<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;world.txt&#x27;</span>);<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;and-such.txt&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":6562,"excerpt":"","more":"<h1 id=\"Generator函数\"><a href=\"#Generator函数\" class=\"headerlink\" title=\"Generator函数\"></a>Generator函数</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>\n<p>Generator函数有多种理解角度：从语法上：可以将其理解成状态机，封装了多个内部状态；其次：执行Generator函数会返回一个遍历器对象。</p>\n<p>形式上，Generator函数是个普通函数，但是有两个特征。一是<code>function</code>关键字和函数名之间多了一个星号；二是函数体内部使用了<code>yield</code>语句，定义了不同的内部状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">hello</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;world&#x27;</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;ending&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> hello = <span class=\"hljs-title function_\">hello</span>();<br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// hello - 1</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// world - 2</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// ending - 3</span><br>hello.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">//undefined - 4</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"yield语句\"><a href=\"#yield语句\" class=\"headerlink\" title=\"yield语句\"></a>yield语句</h2><p>可以看出，只有显式调用next()方法才会继续遍历到下一个状态，所以其实提供了一种可以暂停执行的函数。其中yield就是暂停标识。如果Generator函数不使用yield语句，这时就变成了一个单纯地暂缓执行函数。注意：yield不能用在普通函数中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Executed!&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> generator = <span class=\"hljs-title function_\">f</span>();<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    generator.<span class=\"hljs-title function_\">next</span>();<br>&#125;, <span class=\"hljs-number\">2000</span>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"与Iterator接口的关系\"><a href=\"#与Iterator接口的关系\" class=\"headerlink\" title=\"与Iterator接口的关系\"></a>与Iterator接口的关系</h2><p>由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"next-方法的参数\"><a href=\"#next-方法的参数\" class=\"headerlink\" title=\"next()方法的参数\"></a>next()方法的参数</h2><p><code>yield</code>语句本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; <span class=\"hljs-literal\">true</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">var</span> reset = <span class=\"hljs-keyword\">yield</span> i;<br>        <span class=\"hljs-keyword\">if</span> (reset) &#123;i = -<span class=\"hljs-number\">1</span>;&#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">f</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>()<br>g.<span class=\"hljs-title function_\">next</span>()<br>g.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-literal\">true</span>)<br></code></pre></td></tr></table></figure>\n<p>上面这个例子有一个很有意思的特性：可以通过在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而来调整函数的行为。</p>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p><code>for...of</code>循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">6</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">foo</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br><span class=\"hljs-comment\">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure>\n<p>需要注意的是：一旦next方法的返回对象的done属性为true，for…of循环就会终止，且不包含该返回对象。下面再举一个解斐波那契数列的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibonacci</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> [prev, curr] = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123; <span class=\"hljs-comment\">// 内部自动会取下一个yield语句</span><br>        [prev, curr] = [curr, prev + curr];<br>        <span class=\"hljs-keyword\">yield</span> curr;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> n <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">fibonacci</span>()) &#123;<br>    <span class=\"hljs-keyword\">if</span> (n &gt; <span class=\"hljs-number\">1000</span>) <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>利用<code>for...of</code>循环可以写出遍历任意对象的方法。原生的JavaScript对象没有遍历接口，无法使用<code>for...of</code>循环，通过Generator函数为它加上这个接口，就可以使用了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">objectEntries</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> propKeys = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(obj);<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> propKey <span class=\"hljs-keyword\">of</span> propKeys) &#123;<br>        <span class=\"hljs-keyword\">yield</span> [propKey, obj[propKey]];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> jane = &#123; <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;Jane&#x27;</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">objectEntries</span>(jane)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 另一种写法是将Generator函数加入到Symbol.iterator属性中.</span><br>jane[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = objectEntries;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-throw\"><a href=\"#Generator-prototype-throw\" class=\"headerlink\" title=\"Generator.prototype.throw()\"></a>Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。切记：不要混淆遍历器对象的throw方法和全局throw命令。因此：如果Generator函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">yield</span>;<br>    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Inner catch&#x27;</span>, e);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-title function_\">g</span>();<br>i.<span class=\"hljs-title function_\">next</span>();<br>i.<span class=\"hljs-keyword\">throw</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Error occurs!&#x27;</span>));<br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部和外部都没有部署<code>try...catch</code>代码块，那么程序将直接报错并且中断运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;world&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br>g.<span class=\"hljs-keyword\">throw</span>();<br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部部署了<code>try-...catch</code>代码块，就不会影响下一次yield语句的执行。throw方法在被捕获以后会顺带执行下一条yield语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> gen = <span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>        <span class=\"hljs-comment\">// ...</span><br>    &#125;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br>g.<span class=\"hljs-keyword\">throw</span>();<br>g.<span class=\"hljs-title function_\">next</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator-prototype-return\"><a href=\"#Generator-prototype-return\" class=\"headerlink\" title=\"Generator.prototype.return()\"></a>Generator.prototype.return()</h2><p>Generator函数的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value:1, done: false&#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>); <span class=\"hljs-comment\">// &#123;value: &#x27;foo&#x27;, done: true&#125;</span><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>return</code>方法调用时，不提供参数，则返回的<code>value</code>值为<code>undefined</code>;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">gen</span>();<br><br>g.<span class=\"hljs-title function_\">next</span>(); <span class=\"hljs-comment\">// &#123;value: 1, done: false&#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(); <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果Generator函数内部有<code>try...finally</code>代码块，那么<code>return</code>方法将会推迟到<code>finally</code>代码块执行完再执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* numbers () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>  &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">6</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-title function_\">numbers</span>()<br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 1 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 2 &#125;</span><br>g.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-number\">7</span>) <span class=\"hljs-comment\">// &#123; done: false, value: 4 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: false, value: 5 &#125;</span><br>g.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; done: true, value: 7 &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"yield-语句\"><a href=\"#yield-语句\" class=\"headerlink\" title=\"yield* 语句\"></a>yield* 语句</h2><p>该语句是用来在一个Generator函数中执行另外一个Generator函数的。从语法的角度上看：如果yield语句后面跟着一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;x&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-title function_\">foo</span>();<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;y&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;b&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator函数的this\"><a href=\"#Generator函数的this\" class=\"headerlink\" title=\"Generator函数的this\"></a>Generator函数的this</h2><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><br>g.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hello</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hi!&#x27;</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-title function_\">g</span>();<br><br>obj <span class=\"hljs-keyword\">instanceof</span> g;<br>obj.<span class=\"hljs-title function_\">hello</span>(); <span class=\"hljs-comment\">// &#x27;hi!&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>默认情况下，Generator函数是不可以使用new关键字生成的，但是我们可以用下面这种方式来生成一个空的Generator实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span> = <span class=\"hljs-number\">3</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> obj = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> f = F.<span class=\"hljs-title function_\">call</span>(F.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 2, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 3, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: undefined, done: true&#125;</span><br><br>obj.<span class=\"hljs-property\">a</span> <span class=\"hljs-comment\">// 1</span><br>obj.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br>obj.<span class=\"hljs-property\">c</span> <span class=\"hljs-comment\">// 3</span><br><br></code></pre></td></tr></table></figure>\n<p>再将F改造成构造函数，就可以使用new命令来创建对象了；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span> = <span class=\"hljs-number\">3</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> gen.<span class=\"hljs-title function_\">call</span>(gen.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">F</span>();<br><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 2, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: 3, done: false&#125;</span><br>f.<span class=\"hljs-title function_\">next</span>();  <span class=\"hljs-comment\">// Object &#123;value: undefined, done: true&#125;</span><br><br>f.<span class=\"hljs-property\">a</span> <span class=\"hljs-comment\">// 1</span><br>f.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br>f.<span class=\"hljs-property\">c</span> <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Generator函数的应用\"><a href=\"#Generator函数的应用\" class=\"headerlink\" title=\"Generator函数的应用\"></a>Generator函数的应用</h2><h3 id=\"（1）异步操作的同步化表达\"><a href=\"#（1）异步操作的同步化表达\" class=\"headerlink\" title=\"（1）异步操作的同步化表达\"></a>（1）异步操作的同步化表达</h3><p>基于Generator函数暂停执行的效果，意味着可以把异步写到yield语句中。等到next方法时再往后执行。这实际上等同于不需要再写回调函数了，因为异步操作的后续可以放在yield语句的下面。具体例子前面已经有涉及到了，所以这里就不再演示了。</p>\n<h3 id=\"（2）控制流管理\"><a href=\"#（2）控制流管理\" class=\"headerlink\" title=\"（2）控制流管理\"></a>（2）控制流管理</h3><p>如果一个多步操作非常耗时，可以使用Generator函数进一步改善代码的运作流程。不过这种写法只适合同步操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">longRunningTask</span>(<span class=\"hljs-params\">value1</span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> value2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step1</span>(value1);<br>    <span class=\"hljs-keyword\">var</span> value3 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step2</span>(value2);<br>    <span class=\"hljs-keyword\">var</span> value4 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step3</span>(value3);<br>    <span class=\"hljs-keyword\">var</span> value5 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">step4</span>(value4);<br>    <span class=\"hljs-comment\">// Do something with value4</span><br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-comment\">// Handle any error from step1 through step4</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">scheduler</span>(<span class=\"hljs-title function_\">longRunningTask</span>(initialValue));<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">scheduler</span>(<span class=\"hljs-params\">task</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> taskObj = task.<span class=\"hljs-title function_\">next</span>(task.<span class=\"hljs-property\">value</span>);<br>  <span class=\"hljs-comment\">// 如果Generator函数未结束，就继续调用</span><br>  <span class=\"hljs-keyword\">if</span> (!taskObj.<span class=\"hljs-property\">done</span>) &#123;<br>    task.<span class=\"hljs-property\">value</span> = taskObj.<span class=\"hljs-property\">value</span><br>    <span class=\"hljs-title function_\">scheduler</span>(task);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（3）部署Iterator接口\"><a href=\"#（3）部署Iterator接口\" class=\"headerlink\" title=\"（3）部署Iterator接口\"></a>（3）部署Iterator接口</h3><p>利用Generator函数的特性，可以在任意对象上部署Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">iterEntries</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> keys = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj);<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i &lt; keys.<span class=\"hljs-property\">length</span>; i++) &#123;<br>    <span class=\"hljs-keyword\">let</span> key = keys[i];<br>    <span class=\"hljs-keyword\">yield</span> [key, obj[key]];<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myObj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">7</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">iterEntries</span>(myObj)) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value);<br>&#125;<br><br><span class=\"hljs-comment\">// foo 3</span><br><span class=\"hljs-comment\">// bar 7</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）作为数据结构\"><a href=\"#（4）作为数据结构\" class=\"headerlink\" title=\"（4）作为数据结构\"></a>（4）作为数据结构</h3><p>Generator可以看作数据结构，更确切的说是一种数组结构，因为Generator函数可以返回一系列的值。这意味着它可以对任意表达式，提供类似数组的接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title function_\">doStuff</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;hello.txt&#x27;</span>);<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;world.txt&#x27;</span>);<br>  <span class=\"hljs-keyword\">yield</span> fs.<span class=\"hljs-property\">readFile</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&#x27;and-such.txt&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"初识 ES6","date":"2022-02-17T02:48:32.000Z","updated":"2022-02-17T02:48:32.000Z","_content":"\n# ES6历史\n\n ES6全程ECMAScript 6.0，也叫ES2015。ECMA是国际标准化组织，推出这个标准是为了希望此种编程语言能够成为国际标准。因此我们常说的JavaScript实际上是ES的一种实现形式，而ES是JavaScript的规范草案。很多人在一开始学习JavaScript的时候一看到Java就会把它和Sun（Oracle）公司的框架联结起来，实际上两者并没有什么关系。\n\n# 查看Node支持的ES特性\n\n打开终端，前提是需要装好node（为了方便切换node版本你可以安装NVM），然后在控制台输入下列语句：(不同版本的node显示的结果不相同)\n\n```shell\n$ node --v8-options | grep harmony\n\n--es-staging (enable test-worthy harmony features (for internal use only))\n  --harmony (enable all completed harmony features)\n  --harmony-shipping (enable all shipped harmony features)\n  --harmony-private-methods (enable \"harmony private methods in class literals\" (in progress))\n  --harmony-regexp-sequence (enable \"RegExp Unicode sequence properties\" (in progress))\n  --harmony-weak-refs (enable \"harmony weak references\" (in progress))\n  --harmony-intl-dateformat-quarter (enable \"Add quarter option to DateTimeFormat\" (in progress))\n  --harmony-intl-add-calendar-numbering-system (enable \"Add calendar and numberingSystem to DateTimeFormat\")\n  --harmony-intl-dateformat-day-period (enable \"Add dayPeriod option to DateTimeFormat\")\n```\n\n# 使用Babel完成ES6解码\n\n 因为ES6草案还在不断完善，而且由于不同平台环境的差异，导致支持ES6的情况都不相同。这个时候Babel可以将我们旧的ES5语法转换成ES6语法，这样在写程序的时候就不用关心底层的环境了。\n\n```javascript\n// 转码前语法\ninput.map(item => item + 1);\n\n// 转码后\ninput.map(function (item){\n  return item + 1;\n});\n```\n\n## 配置Babel\n\n核心文件就是.babelrc文件，一般在引入Babel后都可以看到这个文件，细则可以去看Babel的官方文档，这里就不扯了。\n","source":"_posts/javascript/es6-getting-started.md","raw":"---\ntitle: 初识 ES6\ndate: 2022-02-17 10:48:32\nupdated: 2022-02-17 10:48:32\ntags: ES6基础\ncategories: JavaScript\n---\n\n# ES6历史\n\n ES6全程ECMAScript 6.0，也叫ES2015。ECMA是国际标准化组织，推出这个标准是为了希望此种编程语言能够成为国际标准。因此我们常说的JavaScript实际上是ES的一种实现形式，而ES是JavaScript的规范草案。很多人在一开始学习JavaScript的时候一看到Java就会把它和Sun（Oracle）公司的框架联结起来，实际上两者并没有什么关系。\n\n# 查看Node支持的ES特性\n\n打开终端，前提是需要装好node（为了方便切换node版本你可以安装NVM），然后在控制台输入下列语句：(不同版本的node显示的结果不相同)\n\n```shell\n$ node --v8-options | grep harmony\n\n--es-staging (enable test-worthy harmony features (for internal use only))\n  --harmony (enable all completed harmony features)\n  --harmony-shipping (enable all shipped harmony features)\n  --harmony-private-methods (enable \"harmony private methods in class literals\" (in progress))\n  --harmony-regexp-sequence (enable \"RegExp Unicode sequence properties\" (in progress))\n  --harmony-weak-refs (enable \"harmony weak references\" (in progress))\n  --harmony-intl-dateformat-quarter (enable \"Add quarter option to DateTimeFormat\" (in progress))\n  --harmony-intl-add-calendar-numbering-system (enable \"Add calendar and numberingSystem to DateTimeFormat\")\n  --harmony-intl-dateformat-day-period (enable \"Add dayPeriod option to DateTimeFormat\")\n```\n\n# 使用Babel完成ES6解码\n\n 因为ES6草案还在不断完善，而且由于不同平台环境的差异，导致支持ES6的情况都不相同。这个时候Babel可以将我们旧的ES5语法转换成ES6语法，这样在写程序的时候就不用关心底层的环境了。\n\n```javascript\n// 转码前语法\ninput.map(item => item + 1);\n\n// 转码后\ninput.map(function (item){\n  return item + 1;\n});\n```\n\n## 配置Babel\n\n核心文件就是.babelrc文件，一般在引入Babel后都可以看到这个文件，细则可以去看Babel的官方文档，这里就不扯了。\n","slug":"javascript/es6-getting-started","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl2z00152y616npratl2","content":"<h1 id=\"ES6历史\"><a href=\"#ES6历史\" class=\"headerlink\" title=\"ES6历史\"></a>ES6历史</h1><p> ES6全程ECMAScript 6.0，也叫ES2015。ECMA是国际标准化组织，推出这个标准是为了希望此种编程语言能够成为国际标准。因此我们常说的JavaScript实际上是ES的一种实现形式，而ES是JavaScript的规范草案。很多人在一开始学习JavaScript的时候一看到Java就会把它和Sun（Oracle）公司的框架联结起来，实际上两者并没有什么关系。</p>\n<h1 id=\"查看Node支持的ES特性\"><a href=\"#查看Node支持的ES特性\" class=\"headerlink\" title=\"查看Node支持的ES特性\"></a>查看Node支持的ES特性</h1><p>打开终端，前提是需要装好node（为了方便切换node版本你可以安装NVM），然后在控制台输入下列语句：(不同版本的node显示的结果不相同)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">node --v8-options | grep harmony</span><br><br>--es-staging (enable test-worthy harmony features (for internal use only))<br>  --harmony (enable all completed harmony features)<br>  --harmony-shipping (enable all shipped harmony features)<br>  --harmony-private-methods (enable &quot;harmony private methods in class literals&quot; (in progress))<br>  --harmony-regexp-sequence (enable &quot;RegExp Unicode sequence properties&quot; (in progress))<br>  --harmony-weak-refs (enable &quot;harmony weak references&quot; (in progress))<br>  --harmony-intl-dateformat-quarter (enable &quot;Add quarter option to DateTimeFormat&quot; (in progress))<br>  --harmony-intl-add-calendar-numbering-system (enable &quot;Add calendar and numberingSystem to DateTimeFormat&quot;)<br>  --harmony-intl-dateformat-day-period (enable &quot;Add dayPeriod option to DateTimeFormat&quot;)<br></code></pre></td></tr></table></figure>\n<h1 id=\"使用Babel完成ES6解码\"><a href=\"#使用Babel完成ES6解码\" class=\"headerlink\" title=\"使用Babel完成ES6解码\"></a>使用Babel完成ES6解码</h1><p> 因为ES6草案还在不断完善，而且由于不同平台环境的差异，导致支持ES6的情况都不相同。这个时候Babel可以将我们旧的ES5语法转换成ES6语法，这样在写程序的时候就不用关心底层的环境了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 转码前语法</span><br>input.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-comment\">// 转码后</span><br>input.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>)&#123;<br>  <span class=\"hljs-keyword\">return</span> item + <span class=\"hljs-number\">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置Babel\"><a href=\"#配置Babel\" class=\"headerlink\" title=\"配置Babel\"></a>配置Babel</h2><p>核心文件就是.babelrc文件，一般在引入Babel后都可以看到这个文件，细则可以去看Babel的官方文档，这里就不扯了。</p>\n","site":{"data":{}},"wordcount":1301,"excerpt":"","more":"<h1 id=\"ES6历史\"><a href=\"#ES6历史\" class=\"headerlink\" title=\"ES6历史\"></a>ES6历史</h1><p> ES6全程ECMAScript 6.0，也叫ES2015。ECMA是国际标准化组织，推出这个标准是为了希望此种编程语言能够成为国际标准。因此我们常说的JavaScript实际上是ES的一种实现形式，而ES是JavaScript的规范草案。很多人在一开始学习JavaScript的时候一看到Java就会把它和Sun（Oracle）公司的框架联结起来，实际上两者并没有什么关系。</p>\n<h1 id=\"查看Node支持的ES特性\"><a href=\"#查看Node支持的ES特性\" class=\"headerlink\" title=\"查看Node支持的ES特性\"></a>查看Node支持的ES特性</h1><p>打开终端，前提是需要装好node（为了方便切换node版本你可以安装NVM），然后在控制台输入下列语句：(不同版本的node显示的结果不相同)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">node --v8-options | grep harmony</span><br><br>--es-staging (enable test-worthy harmony features (for internal use only))<br>  --harmony (enable all completed harmony features)<br>  --harmony-shipping (enable all shipped harmony features)<br>  --harmony-private-methods (enable &quot;harmony private methods in class literals&quot; (in progress))<br>  --harmony-regexp-sequence (enable &quot;RegExp Unicode sequence properties&quot; (in progress))<br>  --harmony-weak-refs (enable &quot;harmony weak references&quot; (in progress))<br>  --harmony-intl-dateformat-quarter (enable &quot;Add quarter option to DateTimeFormat&quot; (in progress))<br>  --harmony-intl-add-calendar-numbering-system (enable &quot;Add calendar and numberingSystem to DateTimeFormat&quot;)<br>  --harmony-intl-dateformat-day-period (enable &quot;Add dayPeriod option to DateTimeFormat&quot;)<br></code></pre></td></tr></table></figure>\n<h1 id=\"使用Babel完成ES6解码\"><a href=\"#使用Babel完成ES6解码\" class=\"headerlink\" title=\"使用Babel完成ES6解码\"></a>使用Babel完成ES6解码</h1><p> 因为ES6草案还在不断完善，而且由于不同平台环境的差异，导致支持ES6的情况都不相同。这个时候Babel可以将我们旧的ES5语法转换成ES6语法，这样在写程序的时候就不用关心底层的环境了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 转码前语法</span><br>input.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-comment\">// 转码后</span><br>input.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>)&#123;<br>  <span class=\"hljs-keyword\">return</span> item + <span class=\"hljs-number\">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置Babel\"><a href=\"#配置Babel\" class=\"headerlink\" title=\"配置Babel\"></a>配置Babel</h2><p>核心文件就是.babelrc文件，一般在引入Babel后都可以看到这个文件，细则可以去看Babel的官方文档，这里就不扯了。</p>\n"},{"title":"ES6 迭代","date":"2022-02-17T07:27:58.000Z","updated":"2022-02-17T07:27:58.000Z","_content":"\n# Iterator和for...of循环\n\n## Iterator\n\n### 基本概念\n\n遍历器是是一种机制：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。\n\n### 数据结构的默认Iterator接口\n\n目的在于为所有数据结构，提供一种统一的访问机制，即`for...of`循环。因此一种数据结构只要部署了Iterator接口，我们就可以成为该数据结构是可遍历的。\n\nES6规定：默认的Iterator接口部署在数据结构的`Symbol.iterator`属性，也就是说：一个数据结构只要具有该属性，就可以认为是可遍历的。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。例子如下：\n\n```javascript\nconst obj = {\n    [Symbol.iterator] : function() {\n        return {\n            next: function() {\n                return {\n                    value: 1,\n                    done: true\n                };\n            }\n        };\n    }\n};\n\n// obj对象是可遍历的，因为具有Symbol.iterator属性。\n```\n\n一个对象如果想要在`for...of`循环上调用Iterator接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法。\n\n```javascript\nclass RangeIterator {\n    constructor(start, stop) {\n        this.value = start;\n        this.stop = stop;\n    }\n\n    [Symbol.iterator]() { return this; }\n\n    next() {\n        var value = this.value;\n        if (value < this.stop) {\n            this.value ++;\n            return {done: false, value: value};\n        } else {\n            return {done: true, value: undefined};\n        }\n    }\n}\n\nfunction range(start ,stop) {\n    return new RangeIterator(start, stop);\n}\n\nfor (var value of range(0, 3)) {\n    console.log(value);\n}\n// 0\n// 1\n// 2\n```\n\n## 调用Iterator接口的场合\n\n### （1）解构赋值\n\n对数组和Set结构进行解构赋值时，会默认调用`Symbol.iterator`方法。\n\n```javascript\nlet set = new Set().add('a').add('b').add('c');\n\nlet [x, y] = set;\n\nlet [first, ...rest] = set;\n```\n\n### （2）扩展运算符\n\n扩展运算符默认也会调用`Symbol.iterator`接口，前面章节已经有很多例子，这里就不再展示了。\n\n### （3）yield*\n\nyield* 后面跟的也是一个可遍历结构，它会调用该结构的遍历器接口\n\n```javascript\nlet generator = function* () {\n    yield 1;\n    yield* [2, 3, 4];\n    yield 5;\n};\n\nvar iterator = generator();\n\niterator.next()\n{ value: 1, done: false }\n\niterator.next()\n{ value: 2, done: false }\n\niterator.next()\n{ value: 3, done: false }\n\niterator.next()\n{ value: 4, done: false }\n\niterator.next()\n{ value: 5, done: false }\n\niterator.next()\n{ value: undefined, done: true }\n```\n\n### （4）其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都是调用了遍历器接口的。\n\n## 字符串的Iterator接口\n\n字符串是一个类似数组的对象，也原生具有Iterator接口。\n\n```javascript\nvar someString = \"hi\";\ntypeof someString[Symbol.iterator]\n// \"function\"\n\nvar iterator = someString[Symbol.iterator]();\n\niterator.next()  // { value: \"h\", done: false }\niterator.next()  // { value: \"i\", done: false }\niterator.next()  // { value: undefined, done: true }\n```\n\n## Iterator接口与Generator函数\n\n```javascript\nvar myIterable = {};\n\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n[...myIterable] // [1, 2, 3]\n\n// 或者采用下面的简洁写法\n\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n\nfor (let x of obj) {\n  console.log(x);\n}\n// hello\n// world\n```\n\n## 遍历器对象的return()，throw()\n\n遍历器除了有`next`方法以外，还可以拥有`return`和`throw`方法。其中`next`方法是必须部署的，而`return`和`throw`却是可选的。\n\n`return`方法的使用场景是：如果一个对象要在完成遍历前，需要清理或者释放资源，就需要部署。\n\n`throw`方法主要结合Generator函数使用。这里不做过多解释。\n\n```javascript\nfunction readLinesSync(file) {\n  return {\n    next() {\n      if (file.isAtEndOfFile()) {\n        file.close();\n        return { done: true };\n      }\n    },\n    return() {\n      file.close();\n      return { done: true };\n    },\n  };\n}\n```\n\n## for...of循环\n\n一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有iterator接口，就可以使用`for...of`循环遍历。也就是说`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。\n\n### 数组\n\n数组具备iterator接口，可以通过下面的代码证明：\n\n```javascript\nconst arr = ['red', 'gree', 'blue'];\n\nfor (let v of arr) {\n    console.log(v);\n}\n\nconst obj = {};\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n\nfor (let v of obj) {\n    console.log(v);\n}\n```\n\n### Set和Map结构\n\nSet和Map结构也原生具有Iterator接口，可以直接使用`for...of`循环。前面有例子演示过，不再赘述。\n\n### 类似数组的对象\n\n类似数组的对象，包括：DON NodeList对象，arguments对象。都可以使用`for...of`来循环遍历。\n\n```javascript\n// 字符串\nlet str = \"hello\";\n\nfor (let s of str) {\n  console.log(s); // h e l l o\n}\n\n// DOM NodeList对象\nlet paras = document.querySelectorAll(\"p\");\n\nfor (let p of paras) {\n  p.classList.add(\"test\");\n}\n\n// arguments对象\nfunction printArgs() {\n  for (let x of arguments) {\n    console.log(x);\n  }\n}\nprintArgs('a', 'b');\n// 'a'\n// 'b'\n```\n\n### 对象\n\n对于普通对象，`for...of`不能直接使用，会报错；必须部署了iterator接口后才能使用。但是即便是这样：`for...of`依旧可以用来遍历键名。\n\n```javascript\nvar es6 = {\n  edition: 6,\n  committee: \"TC39\",\n  standard: \"ECMA-262\"\n};\n\nfor (let e in es6) {\n  console.log(e);\n}\n// edition\n// committee\n// standard\n\nfor (let e of es6) {\n  console.log(e);\n}\n// TypeError: es6 is not iterable\n```\n\n## `for...in`循环的缺点\n\n`for...in`循环也是有缺点的：\n\n- 数组的键名是数字，但是`for...in`循环是字符串作为键名的；\n- 除了循环数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；\n- 某些情况下，`for...in`循环会以任何顺序遍历键名；\n\n## `for...of`循环的优点\n\n- 有着和for...in循环一样简洁的语法，但是没有for...in那些缺点；\n- 不同于forEach方法，可以结合return, continue和break使用；\n- 提供了遍历所有数据结构的统一操作接口；\n","source":"_posts/javascript/es6-iterator.md","raw":"---\ntitle: ES6 迭代\ndate: 2022-02-17 15:27:58\nupdated: 2022-02-17 15:27:58\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Iterator和for...of循环\n\n## Iterator\n\n### 基本概念\n\n遍历器是是一种机制：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。\n\n### 数据结构的默认Iterator接口\n\n目的在于为所有数据结构，提供一种统一的访问机制，即`for...of`循环。因此一种数据结构只要部署了Iterator接口，我们就可以成为该数据结构是可遍历的。\n\nES6规定：默认的Iterator接口部署在数据结构的`Symbol.iterator`属性，也就是说：一个数据结构只要具有该属性，就可以认为是可遍历的。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。例子如下：\n\n```javascript\nconst obj = {\n    [Symbol.iterator] : function() {\n        return {\n            next: function() {\n                return {\n                    value: 1,\n                    done: true\n                };\n            }\n        };\n    }\n};\n\n// obj对象是可遍历的，因为具有Symbol.iterator属性。\n```\n\n一个对象如果想要在`for...of`循环上调用Iterator接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法。\n\n```javascript\nclass RangeIterator {\n    constructor(start, stop) {\n        this.value = start;\n        this.stop = stop;\n    }\n\n    [Symbol.iterator]() { return this; }\n\n    next() {\n        var value = this.value;\n        if (value < this.stop) {\n            this.value ++;\n            return {done: false, value: value};\n        } else {\n            return {done: true, value: undefined};\n        }\n    }\n}\n\nfunction range(start ,stop) {\n    return new RangeIterator(start, stop);\n}\n\nfor (var value of range(0, 3)) {\n    console.log(value);\n}\n// 0\n// 1\n// 2\n```\n\n## 调用Iterator接口的场合\n\n### （1）解构赋值\n\n对数组和Set结构进行解构赋值时，会默认调用`Symbol.iterator`方法。\n\n```javascript\nlet set = new Set().add('a').add('b').add('c');\n\nlet [x, y] = set;\n\nlet [first, ...rest] = set;\n```\n\n### （2）扩展运算符\n\n扩展运算符默认也会调用`Symbol.iterator`接口，前面章节已经有很多例子，这里就不再展示了。\n\n### （3）yield*\n\nyield* 后面跟的也是一个可遍历结构，它会调用该结构的遍历器接口\n\n```javascript\nlet generator = function* () {\n    yield 1;\n    yield* [2, 3, 4];\n    yield 5;\n};\n\nvar iterator = generator();\n\niterator.next()\n{ value: 1, done: false }\n\niterator.next()\n{ value: 2, done: false }\n\niterator.next()\n{ value: 3, done: false }\n\niterator.next()\n{ value: 4, done: false }\n\niterator.next()\n{ value: 5, done: false }\n\niterator.next()\n{ value: undefined, done: true }\n```\n\n### （4）其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都是调用了遍历器接口的。\n\n## 字符串的Iterator接口\n\n字符串是一个类似数组的对象，也原生具有Iterator接口。\n\n```javascript\nvar someString = \"hi\";\ntypeof someString[Symbol.iterator]\n// \"function\"\n\nvar iterator = someString[Symbol.iterator]();\n\niterator.next()  // { value: \"h\", done: false }\niterator.next()  // { value: \"i\", done: false }\niterator.next()  // { value: undefined, done: true }\n```\n\n## Iterator接口与Generator函数\n\n```javascript\nvar myIterable = {};\n\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n[...myIterable] // [1, 2, 3]\n\n// 或者采用下面的简洁写法\n\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n\nfor (let x of obj) {\n  console.log(x);\n}\n// hello\n// world\n```\n\n## 遍历器对象的return()，throw()\n\n遍历器除了有`next`方法以外，还可以拥有`return`和`throw`方法。其中`next`方法是必须部署的，而`return`和`throw`却是可选的。\n\n`return`方法的使用场景是：如果一个对象要在完成遍历前，需要清理或者释放资源，就需要部署。\n\n`throw`方法主要结合Generator函数使用。这里不做过多解释。\n\n```javascript\nfunction readLinesSync(file) {\n  return {\n    next() {\n      if (file.isAtEndOfFile()) {\n        file.close();\n        return { done: true };\n      }\n    },\n    return() {\n      file.close();\n      return { done: true };\n    },\n  };\n}\n```\n\n## for...of循环\n\n一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有iterator接口，就可以使用`for...of`循环遍历。也就是说`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。\n\n### 数组\n\n数组具备iterator接口，可以通过下面的代码证明：\n\n```javascript\nconst arr = ['red', 'gree', 'blue'];\n\nfor (let v of arr) {\n    console.log(v);\n}\n\nconst obj = {};\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n\nfor (let v of obj) {\n    console.log(v);\n}\n```\n\n### Set和Map结构\n\nSet和Map结构也原生具有Iterator接口，可以直接使用`for...of`循环。前面有例子演示过，不再赘述。\n\n### 类似数组的对象\n\n类似数组的对象，包括：DON NodeList对象，arguments对象。都可以使用`for...of`来循环遍历。\n\n```javascript\n// 字符串\nlet str = \"hello\";\n\nfor (let s of str) {\n  console.log(s); // h e l l o\n}\n\n// DOM NodeList对象\nlet paras = document.querySelectorAll(\"p\");\n\nfor (let p of paras) {\n  p.classList.add(\"test\");\n}\n\n// arguments对象\nfunction printArgs() {\n  for (let x of arguments) {\n    console.log(x);\n  }\n}\nprintArgs('a', 'b');\n// 'a'\n// 'b'\n```\n\n### 对象\n\n对于普通对象，`for...of`不能直接使用，会报错；必须部署了iterator接口后才能使用。但是即便是这样：`for...of`依旧可以用来遍历键名。\n\n```javascript\nvar es6 = {\n  edition: 6,\n  committee: \"TC39\",\n  standard: \"ECMA-262\"\n};\n\nfor (let e in es6) {\n  console.log(e);\n}\n// edition\n// committee\n// standard\n\nfor (let e of es6) {\n  console.log(e);\n}\n// TypeError: es6 is not iterable\n```\n\n## `for...in`循环的缺点\n\n`for...in`循环也是有缺点的：\n\n- 数组的键名是数字，但是`for...in`循环是字符串作为键名的；\n- 除了循环数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；\n- 某些情况下，`for...in`循环会以任何顺序遍历键名；\n\n## `for...of`循环的优点\n\n- 有着和for...in循环一样简洁的语法，但是没有for...in那些缺点；\n- 不同于forEach方法，可以结合return, continue和break使用；\n- 提供了遍历所有数据结构的统一操作接口；\n","slug":"javascript/es6-iterator","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3100172y61bvpa4k6u","content":"<h1 id=\"Iterator和for…of循环\"><a href=\"#Iterator和for…of循环\" class=\"headerlink\" title=\"Iterator和for…of循环\"></a>Iterator和for…of循环</h1><h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>遍历器是是一种机制：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。</p>\n<h3 id=\"数据结构的默认Iterator接口\"><a href=\"#数据结构的默认Iterator接口\" class=\"headerlink\" title=\"数据结构的默认Iterator接口\"></a>数据结构的默认Iterator接口</h3><p>目的在于为所有数据结构，提供一种统一的访问机制，即<code>for...of</code>循环。因此一种数据结构只要部署了Iterator接口，我们就可以成为该数据结构是可遍历的。</p>\n<p>ES6规定：默认的Iterator接口部署在数据结构的<code>Symbol.iterator</code>属性，也就是说：一个数据结构只要具有该属性，就可以认为是可遍历的。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] : <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<br>            <span class=\"hljs-attr\">next</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>                <span class=\"hljs-keyword\">return</span> &#123;<br>                    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>,<br>                    <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span><br>                &#125;;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// obj对象是可遍历的，因为具有Symbol.iterator属性。</span><br></code></pre></td></tr></table></figure>\n<p>一个对象如果想要在<code>for...of</code>循环上调用Iterator接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RangeIterator</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">start, stop</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = start;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span> = stop;<br>    &#125;<br><br>    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>; &#125;<br><br>    <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>;<br>        <span class=\"hljs-keyword\">if</span> (value &lt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span>) &#123;<br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> ++;<br>            <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">value</span>: value&#125;;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-params\">start ,stop</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeIterator</span>(start, stop);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> value <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"调用Iterator接口的场合\"><a href=\"#调用Iterator接口的场合\" class=\"headerlink\" title=\"调用Iterator接口的场合\"></a>调用Iterator接口的场合</h2><h3 id=\"（1）解构赋值\"><a href=\"#（1）解构赋值\" class=\"headerlink\" title=\"（1）解构赋值\"></a>（1）解构赋值</h3><p>对数组和Set结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>().<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br><br><span class=\"hljs-keyword\">let</span> [x, y] = set;<br><br><span class=\"hljs-keyword\">let</span> [first, ...rest] = set;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（2）扩展运算符\"><a href=\"#（2）扩展运算符\" class=\"headerlink\" title=\"（2）扩展运算符\"></a>（2）扩展运算符</h3><p>扩展运算符默认也会调用<code>Symbol.iterator</code>接口，前面章节已经有很多例子，这里就不再展示了。</p>\n<h3 id=\"（3）yield\"><a href=\"#（3）yield\" class=\"headerlink\" title=\"（3）yield*\"></a>（3）yield*</h3><p>yield* 后面跟的也是一个可遍历结构，它会调用该结构的遍历器接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> generator = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span>* [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> iterator = <span class=\"hljs-title function_\">generator</span>();<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）其他场合\"><a href=\"#（4）其他场合\" class=\"headerlink\" title=\"（4）其他场合\"></a>（4）其他场合</h3><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都是调用了遍历器接口的。</p>\n<h2 id=\"字符串的Iterator接口\"><a href=\"#字符串的Iterator接口\" class=\"headerlink\" title=\"字符串的Iterator接口\"></a>字符串的Iterator接口</h2><p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> someString = <span class=\"hljs-string\">&quot;hi&quot;</span>;<br><span class=\"hljs-keyword\">typeof</span> someString[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]<br><span class=\"hljs-comment\">// &quot;function&quot;</span><br><br><span class=\"hljs-keyword\">var</span> iterator = someString[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: &quot;h&quot;, done: false &#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: &quot;i&quot;, done: false &#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Iterator接口与Generator函数\"><a href=\"#Iterator接口与Generator函数\" class=\"headerlink\" title=\"Iterator接口与Generator函数\"></a>Iterator接口与Generator函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br><br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br><br><span class=\"hljs-comment\">// 或者采用下面的简洁写法</span><br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>  * [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;world&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> obj) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br><span class=\"hljs-comment\">// hello</span><br><span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"遍历器对象的return-，throw\"><a href=\"#遍历器对象的return-，throw\" class=\"headerlink\" title=\"遍历器对象的return()，throw()\"></a>遍历器对象的return()，throw()</h2><p>遍历器除了有<code>next</code>方法以外，还可以拥有<code>return</code>和<code>throw</code>方法。其中<code>next</code>方法是必须部署的，而<code>return</code>和<code>throw</code>却是可选的。</p>\n<p><code>return</code>方法的使用场景是：如果一个对象要在完成遍历前，需要清理或者释放资源，就需要部署。</p>\n<p><code>throw</code>方法主要结合Generator函数使用。这里不做过多解释。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">readLinesSync</span>(<span class=\"hljs-params\">file</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-keyword\">if</span> (file.<span class=\"hljs-title function_\">isAtEndOfFile</span>()) &#123;<br>        file.<span class=\"hljs-title function_\">close</span>();<br>        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>      &#125;<br>    &#125;,<br>    <span class=\"hljs-keyword\">return</span>() &#123;<br>      file.<span class=\"hljs-title function_\">close</span>();<br>      <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>    &#125;,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有iterator接口，就可以使用<code>for...of</code>循环遍历。也就是说<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组具备iterator接口，可以通过下面的代码证明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;gree&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> arr) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;;<br>obj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = arr[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>].<span class=\"hljs-title function_\">bind</span>(arr);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> obj) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Set和Map结构\"><a href=\"#Set和Map结构\" class=\"headerlink\" title=\"Set和Map结构\"></a>Set和Map结构</h3><p>Set和Map结构也原生具有Iterator接口，可以直接使用<code>for...of</code>循环。前面有例子演示过，不再赘述。</p>\n<h3 id=\"类似数组的对象\"><a href=\"#类似数组的对象\" class=\"headerlink\" title=\"类似数组的对象\"></a>类似数组的对象</h3><p>类似数组的对象，包括：DON NodeList对象，arguments对象。都可以使用<code>for...of</code>来循环遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 字符串</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> s <span class=\"hljs-keyword\">of</span> str) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s); <span class=\"hljs-comment\">// h e l l o</span><br>&#125;<br><br><span class=\"hljs-comment\">// DOM NodeList对象</span><br><span class=\"hljs-keyword\">let</span> paras = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&quot;p&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> paras) &#123;<br>  p.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&quot;test&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// arguments对象</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printArgs</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable language_\">arguments</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>  &#125;<br>&#125;<br><span class=\"hljs-title function_\">printArgs</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>);<br><span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对于普通对象，<code>for...of</code>不能直接使用，会报错；必须部署了iterator接口后才能使用。但是即便是这样：<code>for...of</code>依旧可以用来遍历键名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> es6 = &#123;<br>  <span class=\"hljs-attr\">edition</span>: <span class=\"hljs-number\">6</span>,<br>  <span class=\"hljs-attr\">committee</span>: <span class=\"hljs-string\">&quot;TC39&quot;</span>,<br>  <span class=\"hljs-attr\">standard</span>: <span class=\"hljs-string\">&quot;ECMA-262&quot;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> e <span class=\"hljs-keyword\">in</span> es6) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);<br>&#125;<br><span class=\"hljs-comment\">// edition</span><br><span class=\"hljs-comment\">// committee</span><br><span class=\"hljs-comment\">// standard</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> e <span class=\"hljs-keyword\">of</span> es6) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);<br>&#125;<br><span class=\"hljs-comment\">// TypeError: es6 is not iterable</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"for-in循环的缺点\"><a href=\"#for-in循环的缺点\" class=\"headerlink\" title=\"for...in循环的缺点\"></a><code>for...in</code>循环的缺点</h2><p><code>for...in</code>循环也是有缺点的：</p>\n<ul>\n<li>数组的键名是数字，但是<code>for...in</code>循环是字符串作为键名的；</li>\n<li>除了循环数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；</li>\n<li>某些情况下，<code>for...in</code>循环会以任何顺序遍历键名；</li>\n</ul>\n<h2 id=\"for-of循环的优点\"><a href=\"#for-of循环的优点\" class=\"headerlink\" title=\"for...of循环的优点\"></a><code>for...of</code>循环的优点</h2><ul>\n<li>有着和for…in循环一样简洁的语法，但是没有for…in那些缺点；</li>\n<li>不同于forEach方法，可以结合return, continue和break使用；</li>\n<li>提供了遍历所有数据结构的统一操作接口；</li>\n</ul>\n","site":{"data":{}},"wordcount":4395,"excerpt":"","more":"<h1 id=\"Iterator和for…of循环\"><a href=\"#Iterator和for…of循环\" class=\"headerlink\" title=\"Iterator和for…of循环\"></a>Iterator和for…of循环</h1><h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>遍历器是是一种机制：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。</p>\n<h3 id=\"数据结构的默认Iterator接口\"><a href=\"#数据结构的默认Iterator接口\" class=\"headerlink\" title=\"数据结构的默认Iterator接口\"></a>数据结构的默认Iterator接口</h3><p>目的在于为所有数据结构，提供一种统一的访问机制，即<code>for...of</code>循环。因此一种数据结构只要部署了Iterator接口，我们就可以成为该数据结构是可遍历的。</p>\n<p>ES6规定：默认的Iterator接口部署在数据结构的<code>Symbol.iterator</code>属性，也就是说：一个数据结构只要具有该属性，就可以认为是可遍历的。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] : <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<br>            <span class=\"hljs-attr\">next</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>                <span class=\"hljs-keyword\">return</span> &#123;<br>                    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>,<br>                    <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span><br>                &#125;;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// obj对象是可遍历的，因为具有Symbol.iterator属性。</span><br></code></pre></td></tr></table></figure>\n<p>一个对象如果想要在<code>for...of</code>循环上调用Iterator接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RangeIterator</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">start, stop</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = start;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span> = stop;<br>    &#125;<br><br>    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>; &#125;<br><br>    <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>;<br>        <span class=\"hljs-keyword\">if</span> (value &lt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span>) &#123;<br>            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> ++;<br>            <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">value</span>: value&#125;;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-params\">start ,stop</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeIterator</span>(start, stop);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> value <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"调用Iterator接口的场合\"><a href=\"#调用Iterator接口的场合\" class=\"headerlink\" title=\"调用Iterator接口的场合\"></a>调用Iterator接口的场合</h2><h3 id=\"（1）解构赋值\"><a href=\"#（1）解构赋值\" class=\"headerlink\" title=\"（1）解构赋值\"></a>（1）解构赋值</h3><p>对数组和Set结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>().<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);<br><br><span class=\"hljs-keyword\">let</span> [x, y] = set;<br><br><span class=\"hljs-keyword\">let</span> [first, ...rest] = set;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（2）扩展运算符\"><a href=\"#（2）扩展运算符\" class=\"headerlink\" title=\"（2）扩展运算符\"></a>（2）扩展运算符</h3><p>扩展运算符默认也会调用<code>Symbol.iterator</code>接口，前面章节已经有很多例子，这里就不再展示了。</p>\n<h3 id=\"（3）yield\"><a href=\"#（3）yield\" class=\"headerlink\" title=\"（3）yield*\"></a>（3）yield*</h3><p>yield* 后面跟的也是一个可遍历结构，它会调用该结构的遍历器接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> generator = <span class=\"hljs-keyword\">function</span>* () &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">yield</span>* [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">5</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> iterator = <span class=\"hljs-title function_\">generator</span>();<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span> &#125;<br><br>iterator.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>)<br>&#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）其他场合\"><a href=\"#（4）其他场合\" class=\"headerlink\" title=\"（4）其他场合\"></a>（4）其他场合</h3><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都是调用了遍历器接口的。</p>\n<h2 id=\"字符串的Iterator接口\"><a href=\"#字符串的Iterator接口\" class=\"headerlink\" title=\"字符串的Iterator接口\"></a>字符串的Iterator接口</h2><p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> someString = <span class=\"hljs-string\">&quot;hi&quot;</span>;<br><span class=\"hljs-keyword\">typeof</span> someString[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]<br><span class=\"hljs-comment\">// &quot;function&quot;</span><br><br><span class=\"hljs-keyword\">var</span> iterator = someString[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: &quot;h&quot;, done: false &#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: &quot;i&quot;, done: false &#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Iterator接口与Generator函数\"><a href=\"#Iterator接口与Generator函数\" class=\"headerlink\" title=\"Iterator接口与Generator函数\"></a>Iterator接口与Generator函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br><br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br><br><span class=\"hljs-comment\">// 或者采用下面的简洁写法</span><br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>  * [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]() &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&#x27;world&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> obj) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br><span class=\"hljs-comment\">// hello</span><br><span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"遍历器对象的return-，throw\"><a href=\"#遍历器对象的return-，throw\" class=\"headerlink\" title=\"遍历器对象的return()，throw()\"></a>遍历器对象的return()，throw()</h2><p>遍历器除了有<code>next</code>方法以外，还可以拥有<code>return</code>和<code>throw</code>方法。其中<code>next</code>方法是必须部署的，而<code>return</code>和<code>throw</code>却是可选的。</p>\n<p><code>return</code>方法的使用场景是：如果一个对象要在完成遍历前，需要清理或者释放资源，就需要部署。</p>\n<p><code>throw</code>方法主要结合Generator函数使用。这里不做过多解释。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">readLinesSync</span>(<span class=\"hljs-params\">file</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-keyword\">if</span> (file.<span class=\"hljs-title function_\">isAtEndOfFile</span>()) &#123;<br>        file.<span class=\"hljs-title function_\">close</span>();<br>        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>      &#125;<br>    &#125;,<br>    <span class=\"hljs-keyword\">return</span>() &#123;<br>      file.<span class=\"hljs-title function_\">close</span>();<br>      <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>    &#125;,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"for…of循环\"><a href=\"#for…of循环\" class=\"headerlink\" title=\"for…of循环\"></a>for…of循环</h2><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有iterator接口，就可以使用<code>for...of</code>循环遍历。也就是说<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组具备iterator接口，可以通过下面的代码证明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;gree&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> arr) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;;<br>obj[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = arr[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>].<span class=\"hljs-title function_\">bind</span>(arr);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> v <span class=\"hljs-keyword\">of</span> obj) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Set和Map结构\"><a href=\"#Set和Map结构\" class=\"headerlink\" title=\"Set和Map结构\"></a>Set和Map结构</h3><p>Set和Map结构也原生具有Iterator接口，可以直接使用<code>for...of</code>循环。前面有例子演示过，不再赘述。</p>\n<h3 id=\"类似数组的对象\"><a href=\"#类似数组的对象\" class=\"headerlink\" title=\"类似数组的对象\"></a>类似数组的对象</h3><p>类似数组的对象，包括：DON NodeList对象，arguments对象。都可以使用<code>for...of</code>来循环遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 字符串</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> s <span class=\"hljs-keyword\">of</span> str) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s); <span class=\"hljs-comment\">// h e l l o</span><br>&#125;<br><br><span class=\"hljs-comment\">// DOM NodeList对象</span><br><span class=\"hljs-keyword\">let</span> paras = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&quot;p&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> p <span class=\"hljs-keyword\">of</span> paras) &#123;<br>  p.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&quot;test&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// arguments对象</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printArgs</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable language_\">arguments</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>  &#125;<br>&#125;<br><span class=\"hljs-title function_\">printArgs</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>);<br><span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-comment\">// &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对于普通对象，<code>for...of</code>不能直接使用，会报错；必须部署了iterator接口后才能使用。但是即便是这样：<code>for...of</code>依旧可以用来遍历键名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> es6 = &#123;<br>  <span class=\"hljs-attr\">edition</span>: <span class=\"hljs-number\">6</span>,<br>  <span class=\"hljs-attr\">committee</span>: <span class=\"hljs-string\">&quot;TC39&quot;</span>,<br>  <span class=\"hljs-attr\">standard</span>: <span class=\"hljs-string\">&quot;ECMA-262&quot;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> e <span class=\"hljs-keyword\">in</span> es6) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);<br>&#125;<br><span class=\"hljs-comment\">// edition</span><br><span class=\"hljs-comment\">// committee</span><br><span class=\"hljs-comment\">// standard</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> e <span class=\"hljs-keyword\">of</span> es6) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);<br>&#125;<br><span class=\"hljs-comment\">// TypeError: es6 is not iterable</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"for-in循环的缺点\"><a href=\"#for-in循环的缺点\" class=\"headerlink\" title=\"for...in循环的缺点\"></a><code>for...in</code>循环的缺点</h2><p><code>for...in</code>循环也是有缺点的：</p>\n<ul>\n<li>数组的键名是数字，但是<code>for...in</code>循环是字符串作为键名的；</li>\n<li>除了循环数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；</li>\n<li>某些情况下，<code>for...in</code>循环会以任何顺序遍历键名；</li>\n</ul>\n<h2 id=\"for-of循环的优点\"><a href=\"#for-of循环的优点\" class=\"headerlink\" title=\"for...of循环的优点\"></a><code>for...of</code>循环的优点</h2><ul>\n<li>有着和for…in循环一样简洁的语法，但是没有for…in那些缺点；</li>\n<li>不同于forEach方法，可以结合return, continue和break使用；</li>\n<li>提供了遍历所有数据结构的统一操作接口；</li>\n</ul>\n"},{"title":"ES6 let和const的区别","date":"2022-02-17T02:50:28.000Z","updated":"2022-02-17T02:50:28.000Z","_content":"\n# let和const命令\n\n## 基本用法\n\n跟`var`的用法类似，都是用于定义变量，但是与`var`不同的是：`let`声明的变量仅在定义的区域起作用。如果你在IDE中使用`let`关键字必须先声明再使用，否则会直接报错无法通过ESLint编译。\n\n```javascript\n{\n  let a = 123; // 变量a仅在这个代码区块有效\n  var b = 'hello';\n}\n\na // Undefined\nb // hello\n```\n\n## 这有什么好处？\n\n由于`let`声明的变量不会被覆盖，因此很适合在迭代器中做指针，看看下面这两段程序的结果会怎么样？\n\n使用`var`做循环指针：每次迭代过程中指针`i`的值都会被覆盖\n\n```javascript\nvar a = [];\n\nfor (var i = 0; i < 10; i++) {\n  a[i] = function() {\n    console.log(i);\n  };\n}\n\na[6](); // 10\n```\n\n使用`let`做循环指针：每次迭代过程中指针`i`的值都会指向当前值\n\n```javascript\nvar a = [];\n\nfor (let i = 0; i < 10; i++) {\n  a[i] = function() {\n    cosole.log(i);\n  };\n}\n\na[6](); // 6\n```\n\n## 暂时性死区（Temporary Dead Zone）\n\n只要块级作用域内存在`let`关键字，那么所声明的变量就与作用域牢牢地绑定在了一块。\n\n```javascript\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // 由于块区存在let绑定变量，因此这里报错显示变量未定义\n  let tmp;\n}\n```\n\n## 块级作用域\n\nES6中规定在块级作用域定义的变量只在所在块内才有效。块级可以嵌套。内层和外层可以定义同名的变量；\n\n```javascript\n{\n  let name = 'hello' // 因为处在不同的块，所以不会报错\n  {\n    let name = 'world' // 内层定义跟外层不冲突\n  }\n}\n```\n\n## DO表达式\n\n将块级作用域转换为表达式，这样就可以取到返回值，使用如下：如果不使用do表达式那么块内变量t在外层将无法取到；\n\n```javascript\nlet x = do {\n  let t = f();\n  t * t + 1;\n}\n```\n\n## 冻结对象\n\n使用`const`关键字定义的变量跟`let`一样需要先定义再使用。但是常量并不意味着变量不能修改。看看下面的程序。\n\n```javascript\nconst a = [];\n\na.push('Hello');\na // Hello\n\na.length = 0;\na // []\n\na = ['David'] // TypeError: Assignment to constant variable\n```\n\n如果需要冻结一个对象，可以使用`Object.freeze(obj)`，除了冻结对象，还需要冻结其属性。代码如下：\n\n```javascript\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach((key, value) => {\n    if (typeof obj[key] === 'object') {\n      constantize(obj[key]);\n    }\n  });\n};\n```\n","source":"_posts/javascript/es6-let-const.md","raw":"---\ntitle: ES6 let和const的区别\ndate: 2022-02-17 10:50:28\nupdated: 2022-02-17 10:50:28\ntags:\ncategories:\n---\n\n# let和const命令\n\n## 基本用法\n\n跟`var`的用法类似，都是用于定义变量，但是与`var`不同的是：`let`声明的变量仅在定义的区域起作用。如果你在IDE中使用`let`关键字必须先声明再使用，否则会直接报错无法通过ESLint编译。\n\n```javascript\n{\n  let a = 123; // 变量a仅在这个代码区块有效\n  var b = 'hello';\n}\n\na // Undefined\nb // hello\n```\n\n## 这有什么好处？\n\n由于`let`声明的变量不会被覆盖，因此很适合在迭代器中做指针，看看下面这两段程序的结果会怎么样？\n\n使用`var`做循环指针：每次迭代过程中指针`i`的值都会被覆盖\n\n```javascript\nvar a = [];\n\nfor (var i = 0; i < 10; i++) {\n  a[i] = function() {\n    console.log(i);\n  };\n}\n\na[6](); // 10\n```\n\n使用`let`做循环指针：每次迭代过程中指针`i`的值都会指向当前值\n\n```javascript\nvar a = [];\n\nfor (let i = 0; i < 10; i++) {\n  a[i] = function() {\n    cosole.log(i);\n  };\n}\n\na[6](); // 6\n```\n\n## 暂时性死区（Temporary Dead Zone）\n\n只要块级作用域内存在`let`关键字，那么所声明的变量就与作用域牢牢地绑定在了一块。\n\n```javascript\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // 由于块区存在let绑定变量，因此这里报错显示变量未定义\n  let tmp;\n}\n```\n\n## 块级作用域\n\nES6中规定在块级作用域定义的变量只在所在块内才有效。块级可以嵌套。内层和外层可以定义同名的变量；\n\n```javascript\n{\n  let name = 'hello' // 因为处在不同的块，所以不会报错\n  {\n    let name = 'world' // 内层定义跟外层不冲突\n  }\n}\n```\n\n## DO表达式\n\n将块级作用域转换为表达式，这样就可以取到返回值，使用如下：如果不使用do表达式那么块内变量t在外层将无法取到；\n\n```javascript\nlet x = do {\n  let t = f();\n  t * t + 1;\n}\n```\n\n## 冻结对象\n\n使用`const`关键字定义的变量跟`let`一样需要先定义再使用。但是常量并不意味着变量不能修改。看看下面的程序。\n\n```javascript\nconst a = [];\n\na.push('Hello');\na // Hello\n\na.length = 0;\na // []\n\na = ['David'] // TypeError: Assignment to constant variable\n```\n\n如果需要冻结一个对象，可以使用`Object.freeze(obj)`，除了冻结对象，还需要冻结其属性。代码如下：\n\n```javascript\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach((key, value) => {\n    if (typeof obj[key] === 'object') {\n      constantize(obj[key]);\n    }\n  });\n};\n```\n","slug":"javascript/es6-let-const","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl32001c2y6187922h1c","content":"<h1 id=\"let和const命令\"><a href=\"#let和const命令\" class=\"headerlink\" title=\"let和const命令\"></a>let和const命令</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>跟<code>var</code>的用法类似，都是用于定义变量，但是与<code>var</code>不同的是：<code>let</code>声明的变量仅在定义的区域起作用。如果你在IDE中使用<code>let</code>关键字必须先声明再使用，否则会直接报错无法通过ESLint编译。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 变量a仅在这个代码区块有效</span><br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>&#125;<br><br>a <span class=\"hljs-comment\">// Undefined</span><br>b <span class=\"hljs-comment\">// hello</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"这有什么好处？\"><a href=\"#这有什么好处？\" class=\"headerlink\" title=\"这有什么好处？\"></a>这有什么好处？</h2><p>由于<code>let</code>声明的变量不会被覆盖，因此很适合在迭代器中做指针，看看下面这两段程序的结果会怎么样？</p>\n<p>使用<code>var</code>做循环指针：每次迭代过程中指针<code>i</code>的值都会被覆盖</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  a[i] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>  &#125;;<br>&#125;<br><br>a[<span class=\"hljs-number\">6</span>](); <span class=\"hljs-comment\">// 10</span><br></code></pre></td></tr></table></figure>\n<p>使用<code>let</code>做循环指针：每次迭代过程中指针<code>i</code>的值都会指向当前值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  a[i] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    cosole.<span class=\"hljs-title function_\">log</span>(i);<br>  &#125;;<br>&#125;<br><br>a[<span class=\"hljs-number\">6</span>](); <span class=\"hljs-comment\">// 6</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"暂时性死区（Temporary-Dead-Zone）\"><a href=\"#暂时性死区（Temporary-Dead-Zone）\" class=\"headerlink\" title=\"暂时性死区（Temporary Dead Zone）\"></a>暂时性死区（Temporary Dead Zone）</h2><p>只要块级作用域内存在<code>let</code>关键字，那么所声明的变量就与作用域牢牢地绑定在了一块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> tmp = <span class=\"hljs-number\">123</span>;<br><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>  tmp = <span class=\"hljs-string\">&#x27;abc&#x27;</span>; <span class=\"hljs-comment\">// 由于块区存在let绑定变量，因此这里报错显示变量未定义</span><br>  <span class=\"hljs-keyword\">let</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>ES6中规定在块级作用域定义的变量只在所在块内才有效。块级可以嵌套。内层和外层可以定义同名的变量；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;hello&#x27;</span> <span class=\"hljs-comment\">// 因为处在不同的块，所以不会报错</span><br>  &#123;<br>    <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;world&#x27;</span> <span class=\"hljs-comment\">// 内层定义跟外层不冲突</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"DO表达式\"><a href=\"#DO表达式\" class=\"headerlink\" title=\"DO表达式\"></a>DO表达式</h2><p>将块级作用域转换为表达式，这样就可以取到返回值，使用如下：如果不使用do表达式那么块内变量t在外层将无法取到；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-keyword\">do</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-title function_\">f</span>();<br>  t * t + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"冻结对象\"><a href=\"#冻结对象\" class=\"headerlink\" title=\"冻结对象\"></a>冻结对象</h2><p>使用<code>const</code>关键字定义的变量跟<code>let</code>一样需要先定义再使用。但是常量并不意味着变量不能修改。看看下面的程序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> a = [];<br><br>a.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);<br>a <span class=\"hljs-comment\">// Hello</span><br><br>a.<span class=\"hljs-property\">length</span> = <span class=\"hljs-number\">0</span>;<br>a <span class=\"hljs-comment\">// []</span><br><br>a = [<span class=\"hljs-string\">&#x27;David&#x27;</span>] <span class=\"hljs-comment\">// TypeError: Assignment to constant variable</span><br></code></pre></td></tr></table></figure>\n<p>如果需要冻结一个对象，可以使用<code>Object.freeze(obj)</code>，除了冻结对象，还需要冻结其属性。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">constantize</span> = (<span class=\"hljs-params\">obj</span>) =&gt; &#123;<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">freeze</span>(obj);<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key, value</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj[key] === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      <span class=\"hljs-title function_\">constantize</span>(obj[key]);<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1371,"excerpt":"","more":"<h1 id=\"let和const命令\"><a href=\"#let和const命令\" class=\"headerlink\" title=\"let和const命令\"></a>let和const命令</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>跟<code>var</code>的用法类似，都是用于定义变量，但是与<code>var</code>不同的是：<code>let</code>声明的变量仅在定义的区域起作用。如果你在IDE中使用<code>let</code>关键字必须先声明再使用，否则会直接报错无法通过ESLint编译。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 变量a仅在这个代码区块有效</span><br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>&#125;<br><br>a <span class=\"hljs-comment\">// Undefined</span><br>b <span class=\"hljs-comment\">// hello</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"这有什么好处？\"><a href=\"#这有什么好处？\" class=\"headerlink\" title=\"这有什么好处？\"></a>这有什么好处？</h2><p>由于<code>let</code>声明的变量不会被覆盖，因此很适合在迭代器中做指针，看看下面这两段程序的结果会怎么样？</p>\n<p>使用<code>var</code>做循环指针：每次迭代过程中指针<code>i</code>的值都会被覆盖</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  a[i] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>  &#125;;<br>&#125;<br><br>a[<span class=\"hljs-number\">6</span>](); <span class=\"hljs-comment\">// 10</span><br></code></pre></td></tr></table></figure>\n<p>使用<code>let</code>做循环指针：每次迭代过程中指针<code>i</code>的值都会指向当前值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [];<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  a[i] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    cosole.<span class=\"hljs-title function_\">log</span>(i);<br>  &#125;;<br>&#125;<br><br>a[<span class=\"hljs-number\">6</span>](); <span class=\"hljs-comment\">// 6</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"暂时性死区（Temporary-Dead-Zone）\"><a href=\"#暂时性死区（Temporary-Dead-Zone）\" class=\"headerlink\" title=\"暂时性死区（Temporary Dead Zone）\"></a>暂时性死区（Temporary Dead Zone）</h2><p>只要块级作用域内存在<code>let</code>关键字，那么所声明的变量就与作用域牢牢地绑定在了一块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> tmp = <span class=\"hljs-number\">123</span>;<br><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>  tmp = <span class=\"hljs-string\">&#x27;abc&#x27;</span>; <span class=\"hljs-comment\">// 由于块区存在let绑定变量，因此这里报错显示变量未定义</span><br>  <span class=\"hljs-keyword\">let</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>ES6中规定在块级作用域定义的变量只在所在块内才有效。块级可以嵌套。内层和外层可以定义同名的变量；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;hello&#x27;</span> <span class=\"hljs-comment\">// 因为处在不同的块，所以不会报错</span><br>  &#123;<br>    <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;world&#x27;</span> <span class=\"hljs-comment\">// 内层定义跟外层不冲突</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"DO表达式\"><a href=\"#DO表达式\" class=\"headerlink\" title=\"DO表达式\"></a>DO表达式</h2><p>将块级作用域转换为表达式，这样就可以取到返回值，使用如下：如果不使用do表达式那么块内变量t在外层将无法取到；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-keyword\">do</span> &#123;<br>  <span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-title function_\">f</span>();<br>  t * t + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"冻结对象\"><a href=\"#冻结对象\" class=\"headerlink\" title=\"冻结对象\"></a>冻结对象</h2><p>使用<code>const</code>关键字定义的变量跟<code>let</code>一样需要先定义再使用。但是常量并不意味着变量不能修改。看看下面的程序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> a = [];<br><br>a.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);<br>a <span class=\"hljs-comment\">// Hello</span><br><br>a.<span class=\"hljs-property\">length</span> = <span class=\"hljs-number\">0</span>;<br>a <span class=\"hljs-comment\">// []</span><br><br>a = [<span class=\"hljs-string\">&#x27;David&#x27;</span>] <span class=\"hljs-comment\">// TypeError: Assignment to constant variable</span><br></code></pre></td></tr></table></figure>\n<p>如果需要冻结一个对象，可以使用<code>Object.freeze(obj)</code>，除了冻结对象，还需要冻结其属性。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title function_\">constantize</span> = (<span class=\"hljs-params\">obj</span>) =&gt; &#123;<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">freeze</span>(obj);<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key, value</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj[key] === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      <span class=\"hljs-title function_\">constantize</span>(obj[key]);<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 数值扩展","date":"2022-02-17T07:05:52.000Z","updated":"2022-02-17T07:05:52.000Z","_content":"\n# 数值扩展\n\n## 二进制和八进制数的表示方法\n\nES6提供了二进制和八进制数值的写法。二进制必须用`0b/0B`表示；八进制必须用`0o/0O`表示。示例如下：\n\n```javascript\n0B11111011 === 503 // true\n0o767 === 503 // true\n```\n\n如果要将二进制/八进制数转换为十进制，需要使用`Number`方法：\n\n```javascript\nNumber('0b111'); // 7\nNumber('0o10'); // 8\n```\n\n## 无穷数表示\n\nES6在原有Number的基础上新增了`Number.isFinite()`和`Number.isNaN()`两个方法。前者用于检查一个数值是否为有限数，后者检验一个数是否为`NaN`。例子如下：\n\n```javascript\nNumber.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\n\nNumber.isNan(NaN) // true\nNumber.isNan(15) // false\nNumber.isNan('15') // false\nNumber.isNan(9/NaN) // true\n```\n\n## `Number.parseInt()`和`Number.parseFloat()`\n\nES6将全局方法`parseInt()`和`parseFloat()`移植到Number对象上面，行为完全保持不变。\n\n```javascript\nNumber.parseInt('12.34'); // 12\nNumber.parseFloat('123.45#'); // 123.45\n```\n\n## `Number.isInteger()`和`Number.EPSILON`\n\n`Number.isInteger()`方法返回一个整型，因为JavaScript内部整数和浮点数使用的是同样的存储方法，因此3.0和3返回的都是整型3。\n\n除此之外，ES6还新增了一个极小的常量`Number.EPSILON`。引入这个量的目的是判断当前浮点数计算的结果是不是我们期望的。由于浮点数计算存在精度误差，因此如果这个误差能够小于`Number.EPSILON`，我们就认为得到了正确结果。例子如下：\n\n```javascript\nfunction withInErrorMargin(left, right) {\n    return Math.abs(left - right) < Number.EPSILON;\n}\n\nwithInErrorMargin(0.1 + 0.2, 0.3) // true\nwithInErrorMargin(0.1 + 0.2, 0.3) // false\n```\n\n## 安全整数和`Number.isSafeInteger()`\n\nJavaScript能够准确地表示的整数范围在 `-2^53` 至 `2^53` 之间（不包括两个端点），因此ES6中引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`两个常量，用来表示这个范围的上下限。\n\n```shell\n> Number.isSafeInteger(9007199254740993);\nfalse\n> Number.isSafeInteger(990);\ntrue\n> Number.isSafeInteger(9007199254740993 - 990);\ntrue\n>\n```\n\n所以在涉及大整型计算的过程中，需要同时校验运算数和运算结果是否为安全整型。例子如下：\n\n```javascript\nfunction trusty(left, right, result) {\n    if (Number.isSafeInteger(left) &&\n       Number.isSafeInteger(right) &&\n       Number.isSafeInteger(result)) {\n        return result;\n    }\n    throw new RangeError('Operation cannot be trusted!');\n}\n\ntrusty(9007199254740993, 990, 9007199254740993 - 990)\n// Operation cannot be trusted!\n\ntrusty(1, 2, 3);\n// 3\n```\n\n## Math对象的扩展\n\n### `Math.trunc()`\n\n该方法用于去除一个数的小数部分，返回整数部分；对于非数值，会先将其转换为数值，再进行比较：\n\n```javascript\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n```\n\n### `Math.sign()`\n\n该方法用来判断一个数到底为正数、负数还是零。\n\n```javascript\nMath.sign(-5); // -1\nMath.sign(5); // +1\nMath.sign(0); // +0\nMath.sign(-0); // -0\nMath.sign(NaN); // NaN\nMath.sign('foo'); // NaN\nMath.sign(); // NaN\n```\n\n### `Math.cbrt()`\n\n该方法用于计算一个数的立方根\n\n```javascript\nMath.cbrt(-1); // -1\nMath.cbrt(0); // 0\nMath.cbrt(1); // 1\nMath.cbrt(2); // 1.2599210498948732\n```\n\n### `Math.clz32()`\n\nJavaScript的整数使用32位二进制形式表示，`Math.clz32`方法返回一个数的32位无符号整数形式有多少个前导0。\n\n```shell\n> Math.clz32(0)\n32\n> Math.clz32(1)\n31\n>\n> Math.clz32(1000)\n22\n> Math.clz32(1000)  \n```\n\n### `Math.imul()`\n\n该方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号数。\n\n```javascript\nMath.imul(2, 4) // 8\nMath.imul(-1, 8) // -8\nMath.imul(-2, 2) // 4\n```\n\n### `Math.fround()`\n\n该方法返回一个数的单精度浮点数形式。对于整数来说该方法没有任何效果，但是对于无法使用64个二进制位精确表示的小数，该方法会返回最接近这个小数的单精度浮点数。\n\n```javascript\nMath.fround(0) // 0\nMath.fround(1) // 1\nMath.fround(1.337) // 1.3370000123977661\nMath.fround(1.5) // 1.5\nMath.fround(NaN) // NaN\n```\n\n### `Math.hypot()`\n\n该方法返回所有参数的平方和的平方根。例如注明的勾股定理（勾三股四弦五）\n\n```javascript\nMath.hypot(3, 4); // 5\nMath.hypot(a, b, c); // sqrt(3^2 + 4^2 + 5^2);\n```\n\n### 对数方法\n\nES6新增了4个对数方法\n\n- Math.expm1(x): 返回`e^x - 1`\n- Math.log1p(x): 返回`1 + x`的自然对数，如果`x`小于-1， 返回`NaN`；\n- Math.log10(): 返回以10为底的x的对数。如果`x`小于0，则返回`NaN`；\n- Math.log2()：返回以2为底的x的对数。如果`x`小于0，则返回`NaN`;\n\n### 三角函数方法\n\nES6新增了6个三角函数方法。\n\n- Math.sinh(x)：返回`x`的双曲正弦\n- Math.cosh(x)：返回`x`的双曲余弦\n- Math.tanh(x)：返回`x`的双曲正切\n- Math.asinh(x)：返回`x`的反双曲正弦\n- Math.acosh(x)：返回`x`的反双曲余弦\n- Math.atanh(x)：返回`x`的反双曲正切\n\n### 指数运算\n\nES7新增了一个指数运算符`**`，目前Babel转码已经支持。这里不再赘述。\n","source":"_posts/javascript/es6-num-expand.md","raw":"---\ntitle: ES6 数值扩展\ndate: 2022-02-17 15:05:52\nupdated: 2022-02-17 15:05:52\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 数值扩展\n\n## 二进制和八进制数的表示方法\n\nES6提供了二进制和八进制数值的写法。二进制必须用`0b/0B`表示；八进制必须用`0o/0O`表示。示例如下：\n\n```javascript\n0B11111011 === 503 // true\n0o767 === 503 // true\n```\n\n如果要将二进制/八进制数转换为十进制，需要使用`Number`方法：\n\n```javascript\nNumber('0b111'); // 7\nNumber('0o10'); // 8\n```\n\n## 无穷数表示\n\nES6在原有Number的基础上新增了`Number.isFinite()`和`Number.isNaN()`两个方法。前者用于检查一个数值是否为有限数，后者检验一个数是否为`NaN`。例子如下：\n\n```javascript\nNumber.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\n\nNumber.isNan(NaN) // true\nNumber.isNan(15) // false\nNumber.isNan('15') // false\nNumber.isNan(9/NaN) // true\n```\n\n## `Number.parseInt()`和`Number.parseFloat()`\n\nES6将全局方法`parseInt()`和`parseFloat()`移植到Number对象上面，行为完全保持不变。\n\n```javascript\nNumber.parseInt('12.34'); // 12\nNumber.parseFloat('123.45#'); // 123.45\n```\n\n## `Number.isInteger()`和`Number.EPSILON`\n\n`Number.isInteger()`方法返回一个整型，因为JavaScript内部整数和浮点数使用的是同样的存储方法，因此3.0和3返回的都是整型3。\n\n除此之外，ES6还新增了一个极小的常量`Number.EPSILON`。引入这个量的目的是判断当前浮点数计算的结果是不是我们期望的。由于浮点数计算存在精度误差，因此如果这个误差能够小于`Number.EPSILON`，我们就认为得到了正确结果。例子如下：\n\n```javascript\nfunction withInErrorMargin(left, right) {\n    return Math.abs(left - right) < Number.EPSILON;\n}\n\nwithInErrorMargin(0.1 + 0.2, 0.3) // true\nwithInErrorMargin(0.1 + 0.2, 0.3) // false\n```\n\n## 安全整数和`Number.isSafeInteger()`\n\nJavaScript能够准确地表示的整数范围在 `-2^53` 至 `2^53` 之间（不包括两个端点），因此ES6中引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`两个常量，用来表示这个范围的上下限。\n\n```shell\n> Number.isSafeInteger(9007199254740993);\nfalse\n> Number.isSafeInteger(990);\ntrue\n> Number.isSafeInteger(9007199254740993 - 990);\ntrue\n>\n```\n\n所以在涉及大整型计算的过程中，需要同时校验运算数和运算结果是否为安全整型。例子如下：\n\n```javascript\nfunction trusty(left, right, result) {\n    if (Number.isSafeInteger(left) &&\n       Number.isSafeInteger(right) &&\n       Number.isSafeInteger(result)) {\n        return result;\n    }\n    throw new RangeError('Operation cannot be trusted!');\n}\n\ntrusty(9007199254740993, 990, 9007199254740993 - 990)\n// Operation cannot be trusted!\n\ntrusty(1, 2, 3);\n// 3\n```\n\n## Math对象的扩展\n\n### `Math.trunc()`\n\n该方法用于去除一个数的小数部分，返回整数部分；对于非数值，会先将其转换为数值，再进行比较：\n\n```javascript\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n```\n\n### `Math.sign()`\n\n该方法用来判断一个数到底为正数、负数还是零。\n\n```javascript\nMath.sign(-5); // -1\nMath.sign(5); // +1\nMath.sign(0); // +0\nMath.sign(-0); // -0\nMath.sign(NaN); // NaN\nMath.sign('foo'); // NaN\nMath.sign(); // NaN\n```\n\n### `Math.cbrt()`\n\n该方法用于计算一个数的立方根\n\n```javascript\nMath.cbrt(-1); // -1\nMath.cbrt(0); // 0\nMath.cbrt(1); // 1\nMath.cbrt(2); // 1.2599210498948732\n```\n\n### `Math.clz32()`\n\nJavaScript的整数使用32位二进制形式表示，`Math.clz32`方法返回一个数的32位无符号整数形式有多少个前导0。\n\n```shell\n> Math.clz32(0)\n32\n> Math.clz32(1)\n31\n>\n> Math.clz32(1000)\n22\n> Math.clz32(1000)  \n```\n\n### `Math.imul()`\n\n该方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号数。\n\n```javascript\nMath.imul(2, 4) // 8\nMath.imul(-1, 8) // -8\nMath.imul(-2, 2) // 4\n```\n\n### `Math.fround()`\n\n该方法返回一个数的单精度浮点数形式。对于整数来说该方法没有任何效果，但是对于无法使用64个二进制位精确表示的小数，该方法会返回最接近这个小数的单精度浮点数。\n\n```javascript\nMath.fround(0) // 0\nMath.fround(1) // 1\nMath.fround(1.337) // 1.3370000123977661\nMath.fround(1.5) // 1.5\nMath.fround(NaN) // NaN\n```\n\n### `Math.hypot()`\n\n该方法返回所有参数的平方和的平方根。例如注明的勾股定理（勾三股四弦五）\n\n```javascript\nMath.hypot(3, 4); // 5\nMath.hypot(a, b, c); // sqrt(3^2 + 4^2 + 5^2);\n```\n\n### 对数方法\n\nES6新增了4个对数方法\n\n- Math.expm1(x): 返回`e^x - 1`\n- Math.log1p(x): 返回`1 + x`的自然对数，如果`x`小于-1， 返回`NaN`；\n- Math.log10(): 返回以10为底的x的对数。如果`x`小于0，则返回`NaN`；\n- Math.log2()：返回以2为底的x的对数。如果`x`小于0，则返回`NaN`;\n\n### 三角函数方法\n\nES6新增了6个三角函数方法。\n\n- Math.sinh(x)：返回`x`的双曲正弦\n- Math.cosh(x)：返回`x`的双曲余弦\n- Math.tanh(x)：返回`x`的双曲正切\n- Math.asinh(x)：返回`x`的反双曲正弦\n- Math.acosh(x)：返回`x`的反双曲余弦\n- Math.atanh(x)：返回`x`的反双曲正切\n\n### 指数运算\n\nES7新增了一个指数运算符`**`，目前Babel转码已经支持。这里不再赘述。\n","slug":"javascript/es6-num-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl33001e2y61a4xw6u2k","content":"<h1 id=\"数值扩展\"><a href=\"#数值扩展\" class=\"headerlink\" title=\"数值扩展\"></a>数值扩展</h1><h2 id=\"二进制和八进制数的表示方法\"><a href=\"#二进制和八进制数的表示方法\" class=\"headerlink\" title=\"二进制和八进制数的表示方法\"></a>二进制和八进制数的表示方法</h2><p>ES6提供了二进制和八进制数值的写法。二进制必须用<code>0b/0B</code>表示；八进制必须用<code>0o/0O</code>表示。示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">0B11111011</span> === <span class=\"hljs-number\">503</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-number\">0o767</span> === <span class=\"hljs-number\">503</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>如果要将二进制/八进制数转换为十进制，需要使用<code>Number</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&#x27;0b111&#x27;</span>); <span class=\"hljs-comment\">// 7</span><br><span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&#x27;0o10&#x27;</span>); <span class=\"hljs-comment\">// 8</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"无穷数表示\"><a href=\"#无穷数表示\" class=\"headerlink\" title=\"无穷数表示\"></a>无穷数表示</h2><p>ES6在原有Number的基础上新增了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。前者用于检查一个数值是否为有限数，后者检验一个数是否为<code>NaN</code>。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-number\">15</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-number\">0.8</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(-<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-number\">15</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-string\">&#x27;15&#x27;</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-number\">9</span>/<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Number-parseInt-和Number-parseFloat\"><a href=\"#Number-parseInt-和Number-parseFloat\" class=\"headerlink\" title=\"Number.parseInt()和Number.parseFloat()\"></a><code>Number.parseInt()</code>和<code>Number.parseFloat()</code></h2><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>移植到Number对象上面，行为完全保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;12.34&#x27;</span>); <span class=\"hljs-comment\">// 12</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">parseFloat</span>(<span class=\"hljs-string\">&#x27;123.45#&#x27;</span>); <span class=\"hljs-comment\">// 123.45</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Number-isInteger-和Number-EPSILON\"><a href=\"#Number-isInteger-和Number-EPSILON\" class=\"headerlink\" title=\"Number.isInteger()和Number.EPSILON\"></a><code>Number.isInteger()</code>和<code>Number.EPSILON</code></h2><p><code>Number.isInteger()</code>方法返回一个整型，因为JavaScript内部整数和浮点数使用的是同样的存储方法，因此3.0和3返回的都是整型3。</p>\n<p>除此之外，ES6还新增了一个极小的常量<code>Number.EPSILON</code>。引入这个量的目的是判断当前浮点数计算的结果是不是我们期望的。由于浮点数计算存在精度误差，因此如果这个误差能够小于<code>Number.EPSILON</code>，我们就认为得到了正确结果。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-params\">left, right</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">abs</span>(left - right) &lt; <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-property\">EPSILON</span>;<br>&#125;<br><br><span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-number\">0.1</span> + <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-number\">0.1</span> + <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"安全整数和Number-isSafeInteger\"><a href=\"#安全整数和Number-isSafeInteger\" class=\"headerlink\" title=\"安全整数和Number.isSafeInteger()\"></a>安全整数和<code>Number.isSafeInteger()</code></h2><p>JavaScript能够准确地表示的整数范围在 <code>-2^53</code> 至 <code>2^53</code> 之间（不包括两个端点），因此ES6中引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>两个常量，用来表示这个范围的上下限。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(9007199254740993);</span><br>false<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(990);</span><br>true<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(9007199254740993 - 990);</span><br>true<br><span class=\"hljs-meta\">&gt;</span><br></code></pre></td></tr></table></figure>\n<p>所以在涉及大整型计算的过程中，需要同时校验运算数和运算结果是否为安全整型。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-params\">left, right, result</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(left) &amp;&amp;<br>       <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(right) &amp;&amp;<br>       <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(result)) &#123;<br>        <span class=\"hljs-keyword\">return</span> result;<br>    &#125;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeError</span>(<span class=\"hljs-string\">&#x27;Operation cannot be trusted!&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-number\">9007199254740993</span>, <span class=\"hljs-number\">990</span>, <span class=\"hljs-number\">9007199254740993</span> - <span class=\"hljs-number\">990</span>)<br><span class=\"hljs-comment\">// Operation cannot be trusted!</span><br><br><span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Math对象的扩展\"><a href=\"#Math对象的扩展\" class=\"headerlink\" title=\"Math对象的扩展\"></a>Math对象的扩展</h2><h3 id=\"Math-trunc\"><a href=\"#Math-trunc\" class=\"headerlink\" title=\"Math.trunc()\"></a><code>Math.trunc()</code></h3><p>该方法用于去除一个数的小数部分，返回整数部分；对于非数值，会先将其转换为数值，再进行比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(<span class=\"hljs-number\">4.1</span>) <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(<span class=\"hljs-number\">4.9</span>) <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">4.1</span>) <span class=\"hljs-comment\">// -4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">4.9</span>) <span class=\"hljs-comment\">// -4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">0.1234</span>) <span class=\"hljs-comment\">// -0</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-sign\"><a href=\"#Math-sign\" class=\"headerlink\" title=\"Math.sign()\"></a><code>Math.sign()</code></h3><p>该方法用来判断一个数到底为正数、负数还是零。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(-<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// +1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// +0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(-<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// NaN</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>); <span class=\"hljs-comment\">// NaN</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(); <span class=\"hljs-comment\">// NaN</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-cbrt\"><a href=\"#Math-cbrt\" class=\"headerlink\" title=\"Math.cbrt()\"></a><code>Math.cbrt()</code></h3><p>该方法用于计算一个数的立方根</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 1.2599210498948732</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-clz32\"><a href=\"#Math-clz32\" class=\"headerlink\" title=\"Math.clz32()\"></a><code>Math.clz32()</code></h3><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式有多少个前导0。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(0)</span><br>32<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(1)</span><br>31<br><span class=\"hljs-meta\">&gt;</span><span class=\"language-bash\"></span><br><span class=\"language-bash\">&gt; Math.clz32(1000)</span><br>22<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(1000)</span>  <br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-imul\"><a href=\"#Math-imul\" class=\"headerlink\" title=\"Math.imul()\"></a><code>Math.imul()</code></h3><p>该方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 8</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>) <span class=\"hljs-comment\">// -8</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(-<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 4</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-fround\"><a href=\"#Math-fround\" class=\"headerlink\" title=\"Math.fround()\"></a><code>Math.fround()</code></h3><p>该方法返回一个数的单精度浮点数形式。对于整数来说该方法没有任何效果，但是对于无法使用64个二进制位精确表示的小数，该方法会返回最接近这个小数的单精度浮点数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1.337</span>) <span class=\"hljs-comment\">// 1.3370000123977661</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1.5</span>) <span class=\"hljs-comment\">// 1.5</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// NaN</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-hypot\"><a href=\"#Math-hypot\" class=\"headerlink\" title=\"Math.hypot()\"></a><code>Math.hypot()</code></h3><p>该方法返回所有参数的平方和的平方根。例如注明的勾股定理（勾三股四弦五）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">hypot</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 5</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">hypot</span>(a, b, c); <span class=\"hljs-comment\">// sqrt(3^2 + 4^2 + 5^2);</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"对数方法\"><a href=\"#对数方法\" class=\"headerlink\" title=\"对数方法\"></a>对数方法</h3><p>ES6新增了4个对数方法</p>\n<ul>\n<li>Math.expm1(x): 返回<code>e^x - 1</code></li>\n<li>Math.log1p(x): 返回<code>1 + x</code>的自然对数，如果<code>x</code>小于-1， 返回<code>NaN</code>；</li>\n<li>Math.log10(): 返回以10为底的x的对数。如果<code>x</code>小于0，则返回<code>NaN</code>；</li>\n<li>Math.log2()：返回以2为底的x的对数。如果<code>x</code>小于0，则返回<code>NaN</code>;</li>\n</ul>\n<h3 id=\"三角函数方法\"><a href=\"#三角函数方法\" class=\"headerlink\" title=\"三角函数方法\"></a>三角函数方法</h3><p>ES6新增了6个三角函数方法。</p>\n<ul>\n<li>Math.sinh(x)：返回<code>x</code>的双曲正弦</li>\n<li>Math.cosh(x)：返回<code>x</code>的双曲余弦</li>\n<li>Math.tanh(x)：返回<code>x</code>的双曲正切</li>\n<li>Math.asinh(x)：返回<code>x</code>的反双曲正弦</li>\n<li>Math.acosh(x)：返回<code>x</code>的反双曲余弦</li>\n<li>Math.atanh(x)：返回<code>x</code>的反双曲正切</li>\n</ul>\n<h3 id=\"指数运算\"><a href=\"#指数运算\" class=\"headerlink\" title=\"指数运算\"></a>指数运算</h3><p>ES7新增了一个指数运算符<code>**</code>，目前Babel转码已经支持。这里不再赘述。</p>\n","site":{"data":{}},"wordcount":3223,"excerpt":"","more":"<h1 id=\"数值扩展\"><a href=\"#数值扩展\" class=\"headerlink\" title=\"数值扩展\"></a>数值扩展</h1><h2 id=\"二进制和八进制数的表示方法\"><a href=\"#二进制和八进制数的表示方法\" class=\"headerlink\" title=\"二进制和八进制数的表示方法\"></a>二进制和八进制数的表示方法</h2><p>ES6提供了二进制和八进制数值的写法。二进制必须用<code>0b/0B</code>表示；八进制必须用<code>0o/0O</code>表示。示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">0B11111011</span> === <span class=\"hljs-number\">503</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-number\">0o767</span> === <span class=\"hljs-number\">503</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>如果要将二进制/八进制数转换为十进制，需要使用<code>Number</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&#x27;0b111&#x27;</span>); <span class=\"hljs-comment\">// 7</span><br><span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&#x27;0o10&#x27;</span>); <span class=\"hljs-comment\">// 8</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"无穷数表示\"><a href=\"#无穷数表示\" class=\"headerlink\" title=\"无穷数表示\"></a>无穷数表示</h2><p>ES6在原有Number的基础上新增了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。前者用于检查一个数值是否为有限数，后者检验一个数是否为<code>NaN</code>。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-number\">15</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-number\">0.8</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">isFinite</span>(-<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-number\">15</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-string\">&#x27;15&#x27;</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isNan</span>(<span class=\"hljs-number\">9</span>/<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Number-parseInt-和Number-parseFloat\"><a href=\"#Number-parseInt-和Number-parseFloat\" class=\"headerlink\" title=\"Number.parseInt()和Number.parseFloat()\"></a><code>Number.parseInt()</code>和<code>Number.parseFloat()</code></h2><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>移植到Number对象上面，行为完全保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;12.34&#x27;</span>); <span class=\"hljs-comment\">// 12</span><br><span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-built_in\">parseFloat</span>(<span class=\"hljs-string\">&#x27;123.45#&#x27;</span>); <span class=\"hljs-comment\">// 123.45</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Number-isInteger-和Number-EPSILON\"><a href=\"#Number-isInteger-和Number-EPSILON\" class=\"headerlink\" title=\"Number.isInteger()和Number.EPSILON\"></a><code>Number.isInteger()</code>和<code>Number.EPSILON</code></h2><p><code>Number.isInteger()</code>方法返回一个整型，因为JavaScript内部整数和浮点数使用的是同样的存储方法，因此3.0和3返回的都是整型3。</p>\n<p>除此之外，ES6还新增了一个极小的常量<code>Number.EPSILON</code>。引入这个量的目的是判断当前浮点数计算的结果是不是我们期望的。由于浮点数计算存在精度误差，因此如果这个误差能够小于<code>Number.EPSILON</code>，我们就认为得到了正确结果。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-params\">left, right</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">abs</span>(left - right) &lt; <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-property\">EPSILON</span>;<br>&#125;<br><br><span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-number\">0.1</span> + <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title function_\">withInErrorMargin</span>(<span class=\"hljs-number\">0.1</span> + <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"安全整数和Number-isSafeInteger\"><a href=\"#安全整数和Number-isSafeInteger\" class=\"headerlink\" title=\"安全整数和Number.isSafeInteger()\"></a>安全整数和<code>Number.isSafeInteger()</code></h2><p>JavaScript能够准确地表示的整数范围在 <code>-2^53</code> 至 <code>2^53</code> 之间（不包括两个端点），因此ES6中引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>两个常量，用来表示这个范围的上下限。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(9007199254740993);</span><br>false<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(990);</span><br>true<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Number.isSafeInteger(9007199254740993 - 990);</span><br>true<br><span class=\"hljs-meta\">&gt;</span><br></code></pre></td></tr></table></figure>\n<p>所以在涉及大整型计算的过程中，需要同时校验运算数和运算结果是否为安全整型。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-params\">left, right, result</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(left) &amp;&amp;<br>       <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(right) &amp;&amp;<br>       <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isSafeInteger</span>(result)) &#123;<br>        <span class=\"hljs-keyword\">return</span> result;<br>    &#125;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeError</span>(<span class=\"hljs-string\">&#x27;Operation cannot be trusted!&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-number\">9007199254740993</span>, <span class=\"hljs-number\">990</span>, <span class=\"hljs-number\">9007199254740993</span> - <span class=\"hljs-number\">990</span>)<br><span class=\"hljs-comment\">// Operation cannot be trusted!</span><br><br><span class=\"hljs-title function_\">trusty</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br><span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Math对象的扩展\"><a href=\"#Math对象的扩展\" class=\"headerlink\" title=\"Math对象的扩展\"></a>Math对象的扩展</h2><h3 id=\"Math-trunc\"><a href=\"#Math-trunc\" class=\"headerlink\" title=\"Math.trunc()\"></a><code>Math.trunc()</code></h3><p>该方法用于去除一个数的小数部分，返回整数部分；对于非数值，会先将其转换为数值，再进行比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(<span class=\"hljs-number\">4.1</span>) <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(<span class=\"hljs-number\">4.9</span>) <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">4.1</span>) <span class=\"hljs-comment\">// -4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">4.9</span>) <span class=\"hljs-comment\">// -4</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">trunc</span>(-<span class=\"hljs-number\">0.1234</span>) <span class=\"hljs-comment\">// -0</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-sign\"><a href=\"#Math-sign\" class=\"headerlink\" title=\"Math.sign()\"></a><code>Math.sign()</code></h3><p>该方法用来判断一个数到底为正数、负数还是零。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(-<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// +1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// +0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(-<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// NaN</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>); <span class=\"hljs-comment\">// NaN</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sign</span>(); <span class=\"hljs-comment\">// NaN</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-cbrt\"><a href=\"#Math-cbrt\" class=\"headerlink\" title=\"Math.cbrt()\"></a><code>Math.cbrt()</code></h3><p>该方法用于计算一个数的立方根</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// -1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cbrt</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 1.2599210498948732</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-clz32\"><a href=\"#Math-clz32\" class=\"headerlink\" title=\"Math.clz32()\"></a><code>Math.clz32()</code></h3><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式有多少个前导0。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(0)</span><br>32<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(1)</span><br>31<br><span class=\"hljs-meta\">&gt;</span><span class=\"language-bash\"></span><br><span class=\"language-bash\">&gt; Math.clz32(1000)</span><br>22<br><span class=\"hljs-meta\">&gt; </span><span class=\"language-bash\">Math.clz32(1000)</span>  <br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-imul\"><a href=\"#Math-imul\" class=\"headerlink\" title=\"Math.imul()\"></a><code>Math.imul()</code></h3><p>该方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 8</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>) <span class=\"hljs-comment\">// -8</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">imul</span>(-<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 4</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-fround\"><a href=\"#Math-fround\" class=\"headerlink\" title=\"Math.fround()\"></a><code>Math.fround()</code></h3><p>该方法返回一个数的单精度浮点数形式。对于整数来说该方法没有任何效果，但是对于无法使用64个二进制位精确表示的小数，该方法会返回最接近这个小数的单精度浮点数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1.337</span>) <span class=\"hljs-comment\">// 1.3370000123977661</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-number\">1.5</span>) <span class=\"hljs-comment\">// 1.5</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">fround</span>(<span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// NaN</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Math-hypot\"><a href=\"#Math-hypot\" class=\"headerlink\" title=\"Math.hypot()\"></a><code>Math.hypot()</code></h3><p>该方法返回所有参数的平方和的平方根。例如注明的勾股定理（勾三股四弦五）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">hypot</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 5</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">hypot</span>(a, b, c); <span class=\"hljs-comment\">// sqrt(3^2 + 4^2 + 5^2);</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"对数方法\"><a href=\"#对数方法\" class=\"headerlink\" title=\"对数方法\"></a>对数方法</h3><p>ES6新增了4个对数方法</p>\n<ul>\n<li>Math.expm1(x): 返回<code>e^x - 1</code></li>\n<li>Math.log1p(x): 返回<code>1 + x</code>的自然对数，如果<code>x</code>小于-1， 返回<code>NaN</code>；</li>\n<li>Math.log10(): 返回以10为底的x的对数。如果<code>x</code>小于0，则返回<code>NaN</code>；</li>\n<li>Math.log2()：返回以2为底的x的对数。如果<code>x</code>小于0，则返回<code>NaN</code>;</li>\n</ul>\n<h3 id=\"三角函数方法\"><a href=\"#三角函数方法\" class=\"headerlink\" title=\"三角函数方法\"></a>三角函数方法</h3><p>ES6新增了6个三角函数方法。</p>\n<ul>\n<li>Math.sinh(x)：返回<code>x</code>的双曲正弦</li>\n<li>Math.cosh(x)：返回<code>x</code>的双曲余弦</li>\n<li>Math.tanh(x)：返回<code>x</code>的双曲正切</li>\n<li>Math.asinh(x)：返回<code>x</code>的反双曲正弦</li>\n<li>Math.acosh(x)：返回<code>x</code>的反双曲余弦</li>\n<li>Math.atanh(x)：返回<code>x</code>的反双曲正切</li>\n</ul>\n<h3 id=\"指数运算\"><a href=\"#指数运算\" class=\"headerlink\" title=\"指数运算\"></a>指数运算</h3><p>ES7新增了一个指数运算符<code>**</code>，目前Babel转码已经支持。这里不再赘述。</p>\n"},{"title":"ES6 对象扩展","date":"2022-02-17T07:08:22.000Z","updated":"2022-02-17T07:08:22.000Z","_content":"\n# 对象扩展\n\n## 属性的简洁表示法\n\nES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更加简洁。\n\n```javascript\nvar foo = 'bar';\nvar baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nvar baz = {foo: foo};\n```\n\n除了属性可以简写，方法也可以简写\n\n```javascript\nvar o = {\n    method() {\n        return \"Hello\";\n    }\n};\n\n// 等同于\n\nvar o = {\n    method: function() {\n        return \"Hello\";\n    }\n};\n```\n\n适用于函数返回值，写起来会非常简洁和方便\n\n```javascript\nfunction getPoint() {\n    var x = 1;\n    var y = 10;\n    return {x, y};\n}\n\ngetPoint() // {x: 1, y: 10}\n```\n\n在使用Common JS中，输出的代码非常适合使用这种简洁写法\n\n```javascript\nvar ms = {};\n\nfunction getItem(key) {\n    return key in ms ? ms[key] : null;\n}\n\nfunction setItem(key, value) {\n    ms[key] = value;\n}\n\nfunction clear() {\n    ms = {};\n}\n\nmodule.exports = { getItem, setItem, clear }\n// 等同于\nmodule.exports = {\n    getItem: getItem,\n    setItem: setItem,\n    clear: clear\n}\n```\n\n## 属性名表达式\n\nJavaScript语言定义对象的属性，有如下种方法。\n\n```javascript\nobj.foo = true; // 直接使用标识符作为属性名\n\nobj['a' + 'bc'] = 123; // 使用表达式作为属性名\n```\n\nES6允许字面量定义对象时，用方法二作为对象的属性名，即将表达式放在括号内\n\n```javascript\nlet propKey = 'foo';\n\nlet obj = {\n    [propKey]: true,\n    ['a' + 'bc']: 123\n}\n```\n\n这里再举一个例子：\n\n```javascript\nvar lastWord = 'last word';\n\nvar a = {\n    'first word': 'hello',\n    [lastWord]: 'world'\n};\n\na['first Word'] // hello\na[lastWord] // World\na['last word'] // World\n```\n\n注意：属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串。因此属性名表达式和简洁表示法不可以同时使用。一定要注意。\n\n## 方法的`name`属性\n\n函数的`name`属性返回函数名。对象方法也是函数，因此也有`name`属性。\n\n```javascript\nvar person = {\n    sayName() {\n        console.log(this.name);\n    },\n    // get为取值函数，存值用set\n    get firstName() {\n        return \"Nicholas\";\n    }\n};\n\nperson.sayName.name // sayName\nperson.firstName.name // get firstName\n```\n\n有两个特例：如果是`bind`函数，函数名返回`bound` + 函数名称；如果是`function`关键字构造的函数（匿名函数），`name`属性值返回`anonymous`。\n\n## `Object.is()`\n\n该方法用来比较两个值是否严格相等，与严格比较运算符`===`的作用一致。不同之处有两个：+0不等于-0；另一个是NaN等于自身。\n\n```javascript\n+0 === -0 // true\nNaN === NaN // false\n\nObject.is(+0, -0); // false\nObject.is(NaN, NaN) // true\n```\n\n## `Object.assign()`\n\n### 基本用法\n\n用于将对象合并，将源对象的所有可枚举属性赋值到目标对象。如果目标对象与源对象由同名属性，或多个源对象由同名属性，则后面的属性会覆盖前面的属性。\n\n```javascript\nvar target = { a: 1 };\n\nvar source1 = { b: 2 };\nvar source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // { a: 1, b: 2, c: 3 }\n```\n\n如果只有一个参数，会直接返回该参数；如果该参数不是对象，会先转换为对象，然后返回。由于`undefined`和`null`无法转换为对象，所以将它们作为参数传入会报错。\n\n```javascript\nvar obj = { a: 1};\nObject.assign(obj) === obj // true\n\ntypeof Object.assign(2) // object\n\nObject.assign(undefined) // error\nObject.assign(null) // error\n```\n\n如果`undefined`和`null`出现在非首参数，首先会尝试着转换为对象，如果转换失败会直接跳过。这意味着只要首参数可以转换为对象，就不会报错。\n\n```javascript\nlet obj = { a: 1};\n\nObject.assign(a, undefined) === obj // true\nObject.assign(a, null) === obj // true\n```\n\n其他类型的值中，只有字符串会以数组的形式拷贝至对象中，其他值都不会产生效果；\n\n```javascript\nvar v1 = 'abc';\nvar v2 = true;\nvar v3 = 10;\n\nvar obj = Object.assign({}, v1, v2, v3);\nconsole.log(obj); // {'0': 'a', '1': 'b', '2': 'c'}\n```\n\n`Object.assign()`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）。\n\n```javascript\nObject.assign({b: 'c'}, Object.defineProperty({}, 'invisible', {\n    \tenumerable: false,\n    \tvalue: 'hello'\n\t})\n)\n// {b: 'c'}\n```\n\n值得注意的是：`Object.assign()`执行的是浅拷贝，而不是深拷贝。如果源对象某个属性的值是对象，那么目标对象拷贝得到的仅仅是这个对象的引用。\n\n```javascript\nvar obj1 = {a: {b: 1}};\nvar obj2 = Object.assign({}, obj1);\n\nobj1.a.b = 2;\nobj2.a.b // 2\n```\n\n### Object.assign()方法有哪些用途呢？\n\n#### 为对象添加属性\n\n```javascript\nclass Point {\n    constructor(x, y) {\n        Object.assign(this, {x, y})\n    }\n}\n```\n\n#### 为对象添加方法\n\n```javascript\nObject.assign(SomeClass.prototype, {\n    someMethod(arg1, arg2) {\n        ...\n    },\n    anotherMethod() {\n        ...\n    }\n});\n        \n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) { ... };\nSomeClass.prototype.anotherMethod = function () { ... };\n```\n\n#### 克隆对象\n\n```javascript\n// 将原始对象拷贝到空对象中\nfunction clone (origin) {\n    return Object.assign({}, origin);\n}\n\n// 将原始对象和其继承的值拷贝到新对象中\nfunction clone (origin) {\n    let originProto = Object.getPrototypeOf(origin);\n    return Object.assign(Object.create(originProto), origin);\n}\n```\n\n#### 合并多个对象\n\n```javascript\n// 将多个对象合并到某个对象\nconst merge = (target, ...source) => Object.assign(target, ...source);\n\n// 合并后返回一个新对象\nconst merge = (...source) => Object.assign({}, ...source);\n```\n\n#### 为属性指定默认值\n\n```javascript\nconst DEFAULTS = {\n    logLevel: 0,\n    outputFormat: 'html'\n};\n\nfunction processContent(options) {\n    options = Object.assign({}, DEFAULTS, options)\n}\n```\n\n## 属性的可枚举性\n\n`Object.getOwnPropertyDescriptor(obj, 'foo')`方法可以获取该属性的描述对象，其中描述对象有一个`enumerable`属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。\n\nES6中有下面4个操作会忽略`enumerable`为false的属性。\n\n- `for ... in` 循环：只遍历对象自身的和继承的可枚举属性；\n- `Object.keys()`：返回对象自身的所有可枚举的属性键名；\n- `JSON.stringify()`：只串行化对象自身的可枚举属性；\n- `Object.assign()`：只拷贝对象自身的可枚举属性；\n\n上面4个操作中，只有`for ... in`会返回继承的属性。实际上引入`enumerable`的最初目的，就是让某些可以规避掉`for...in`的操作。\n\n```javascript\nObject.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable // false\n\nObject.getOwnPropertyDescriptor([], 'length').enumerable // false\n```\n\n另外ES6规定，所有Class的原型方法都是不可枚举的：\n\n```javascript\nObject.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable\n```\n\n## 属性的遍历\n\nES6中一共有5种方法可以遍历对象的属性\n\n#### （1）for...in\n\n遍历对象自身和继承的可枚举属性\n\n#### （2）Object.keys(obj)\n\n返回一个数组，包括对象自身的（不含继承）所有可枚举属性（不包括Symbol属性）\n\n#### （3）Object.getOwnPropertyNames(obj)\n\n返回一个数组，包含对象自身的所有属性（不包括Symbol属性）\n\n#### （4）Object.getOwnPropertySymbols(obj)\n\n返回一个数组，包含对象自身的所有Symbol属性\n\n#### （5）Reflect.ownKeys(obj)\n\n返回一个数组，包含对象自身的所有属性，不管是属性名还是Symbol还是字符串，也不管是否可枚举。\n\n上面5种方法遍历对象属性，都遵循同样的属性遍历的次序规则。\n\n- 首先遍历所有属性名为数值的字符的属性，按照数字排序；\n- 其次遍历所有属性名为字符串的属性，按照生成时间排序；\n- 最后遍历所有属性名为Symbol值得属性，按照生成时间排序；\n\n一句话概括：遍历规则为数值 > 字符串 > Symbol；数值排序规则为数字，剩下两个排序规则为生成顺序；\n\n## `__proto__`属性，`Objects.setPrototypeOf()`, `Object.getPrototypeOf()`\n\n#### `__proto__`属性\n\n用来读取或设置当前对象的`prototype`对象。目前所有浏览器都支持这个特性。\n\n```javascript\nvar obj = {\n    method: function () {...}\n};\nobj.__proto__ = someOtherObj;\n\nvar obj = Object.create(someOtherObj);\nobj.method = function () {...};\n```\n\n这里和Python一样，使用双下划线标注的属性内部属性，而不是一个正式对外的API。因此在正式使用时不建议显示的设置。而是用`Object.setPrototypeOf()`、`Object.getPrototypeOf()`、`Object.create()`代替。\n\n#### `Object.setPrototypeOf()`\n\n用来设置对象的`prototype`对象。是ES6推荐的设置原型对象的方法。\n\n```javascript\nlet proto = {};\nlet obj = { x: 10};\nObject.setPrototypeOf(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nconsole.log(obj.x) // 10\nconsole.log(obj.y) // 20\nconsole.log(obj.z) // 40\n```\n\n#### `Object.getPrototypeOf()`\n\n与上面的set方法相反，用来获取一个对象的prototype对象。\n\n```javascript\nfunction Rectangle () {\n\n}\n\nvar rec = new Rectangle();\n\nObject.getPrototypeOf(rec) === Rectangle.prototype; // true\n\nObject.setPrototypeOf(rec, Object.prototype);\nObject.getPrototypeOf(rec) === Rectangle.prototype; // false\n```\n\n## `Object.values()`, `Object.entries()`\n\n#### `Object.keys()`\n\n返回一个数组，成员是参数对象自身的所有可遍历属性的键名（不含继承）\n\n```javascript\nvar obj = { foo: \"bar\", baz: 42 };\nObject.keys(obj)\n// [\"foo\", \"baz\"]\n```\n\n目前ES7有一个新提案，引入了跟`Object.keys()`配套的`Object.values`和`Object.entries`。\n\n```javascript\nlet { keys, values, entries } = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key  of keys(obj)) {\n    console.log(key);\n}\n// 'a', 'b', 'c'\n\nfor (let value of values(obj)) {\n    console.log(value);\n}\n// 1, 2, 3\n\nfor (let [key, value] of entries(obj)) {\n    console.log([key, value]);\n}\n//['a', 1], ['b', 2], ['c', 3]\n```\n\n#### `Object.values()`\n\n返回一个数组，成员是参数对象自身的（不含继承）所有可遍历（enumerable）属性的键值。\n\n```javascript\nvar obj = { foo: \"bar\", baz: 42 };\nObject.values(obj);\n// ['baz', 42]\n```\n\n#### `Object.entries`\n\n返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。\n\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.entries(obj);\n// [ [ 'foo', 'bar' ], [ 'baz', 42 ] ]\n```\n\n基本用途为遍历对象的属性，也可以将对象转换为Map\n\n```javascript\nlet obj = { one: 1, two: 2 };\nfor (let [k, v] of Object.entries(obj)) {\n    console.log(`${JSON.stringify(k)} : ${JSON.stringify(v)}`)\n}\n// \"one\": 1\n// \"two\": 2\n\n// 另一个用途是将对象转换为Map\nvar obj = { foo: 'bar', baz: 42 };\nvar map = new Map(Object.entries(obj));\nmap // Map {foo: \"bar\", baz: 42 }\n```\n\n## 对象的扩展运算符\n\n之前提到过扩展运算符（`...`），在对象中也有运用。\n\n#### 解构赋值\n\n对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到指定的对象上。所有的键和值，都会拷贝到新对象上。\n\n```javascript\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n```\n\n解构必须是最后一个参数，否则会报错，这和Java是完全一样的。注意一点：解构赋值时浅拷贝，如果一个键的值是复合类型的值（数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n\n```javascript\nlet obj = { a: { b: 1 }};\nlet {...x} = obj;\nobj.a.b = 2;\nx.a.b // 2 (浅拷贝无疑了)\n```\n\n另外解构赋值不会拷贝继承自原型对象的属性。下面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。\n\n解构赋值的一个用处，是扩展某个函数的参数，引入其他操作：\n\n```javascript\nfunction baseFunction ({a, b}) {\n    // ...\n}\n\nfunction wrapperFunction ({x, y, ...restConfig}) {\n    return baseFunction(restConfig);\n}\n```\n\n扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n```javascript\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n```\n\n还可以用于合并两个对象。\n\n```javascript\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = Object.assign({}, a, b);\n```\n\n## `Object.getOwnPropertyDescriptors()`\n\n前面提到了：这个方法是用来返回某个对象属性的描述对象的。ES7有个提案：返回指定对象所有自身属性（非继承性——的描述对象。\n\n```javascript\nconst obj = {\n    foo: 123,\n    get bar() { return 'abc' }\n};\n\nObject.getOwnPropertyDescription(obj)\n\n// 返回结果如下\n{\n  foo: { value: 123, writable: true, enumerable: true, configurable: true },\n  bar: {\n    get: [Function: get bar],\n    set: undefined,\n    enumerable: true,\n    configurable: true\n  }\n}\n```\n\n该方法实现的目的：主要是为了解决`Object.assing()`无法正确拷贝`get`属性和`set`属性的问题。结合`Object.defineProperties`方法就可以实现正确拷贝。\n\n```javascript\nconst source = {\n    set foo (value) {\n        console.log(value);\n    }\n};\n\nconst target2 = {};\nObject.defineProperties(target2, Object.getOwnPropertyDescriptors(source));\nObject.getOwnPropertyDescriptor(target2, 'foo')\n\n// 返回结果\n{                           \n  get: undefined,           \n  set: [Function: set foo], \n  enumerable: true,         \n  configurable: true        \n}                           \n```\n\n将上面两部分代码合并起来，就是这样。是不是突然觉得眼熟悉？（就是React Thunk的使用方法）\n\n```javascript\nconst shallowMerge = (target, source) => Object.defineProperties(\n\ttarget,\n    Object.getOwnPropertyDescriptors(source)\n);\n\n// 浅拷贝对象\nconst clone = Object.create(Object.getPrototypeOf(obj),\n                           Object.getOwnPropertyDescriptors(obj));\nconst shallowClone = (obj) => Object.create(\n\tObject.getPrototypeOf(obj),\n    Object.getOwnPropertyDescriptors(obj)\n);\n```\n","source":"_posts/javascript/es6-object-expand.md","raw":"---\ntitle: ES6 对象扩展\ndate: 2022-02-17 15:08:22\nupdated: 2022-02-17 15:08:22\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 对象扩展\n\n## 属性的简洁表示法\n\nES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更加简洁。\n\n```javascript\nvar foo = 'bar';\nvar baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nvar baz = {foo: foo};\n```\n\n除了属性可以简写，方法也可以简写\n\n```javascript\nvar o = {\n    method() {\n        return \"Hello\";\n    }\n};\n\n// 等同于\n\nvar o = {\n    method: function() {\n        return \"Hello\";\n    }\n};\n```\n\n适用于函数返回值，写起来会非常简洁和方便\n\n```javascript\nfunction getPoint() {\n    var x = 1;\n    var y = 10;\n    return {x, y};\n}\n\ngetPoint() // {x: 1, y: 10}\n```\n\n在使用Common JS中，输出的代码非常适合使用这种简洁写法\n\n```javascript\nvar ms = {};\n\nfunction getItem(key) {\n    return key in ms ? ms[key] : null;\n}\n\nfunction setItem(key, value) {\n    ms[key] = value;\n}\n\nfunction clear() {\n    ms = {};\n}\n\nmodule.exports = { getItem, setItem, clear }\n// 等同于\nmodule.exports = {\n    getItem: getItem,\n    setItem: setItem,\n    clear: clear\n}\n```\n\n## 属性名表达式\n\nJavaScript语言定义对象的属性，有如下种方法。\n\n```javascript\nobj.foo = true; // 直接使用标识符作为属性名\n\nobj['a' + 'bc'] = 123; // 使用表达式作为属性名\n```\n\nES6允许字面量定义对象时，用方法二作为对象的属性名，即将表达式放在括号内\n\n```javascript\nlet propKey = 'foo';\n\nlet obj = {\n    [propKey]: true,\n    ['a' + 'bc']: 123\n}\n```\n\n这里再举一个例子：\n\n```javascript\nvar lastWord = 'last word';\n\nvar a = {\n    'first word': 'hello',\n    [lastWord]: 'world'\n};\n\na['first Word'] // hello\na[lastWord] // World\na['last word'] // World\n```\n\n注意：属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串。因此属性名表达式和简洁表示法不可以同时使用。一定要注意。\n\n## 方法的`name`属性\n\n函数的`name`属性返回函数名。对象方法也是函数，因此也有`name`属性。\n\n```javascript\nvar person = {\n    sayName() {\n        console.log(this.name);\n    },\n    // get为取值函数，存值用set\n    get firstName() {\n        return \"Nicholas\";\n    }\n};\n\nperson.sayName.name // sayName\nperson.firstName.name // get firstName\n```\n\n有两个特例：如果是`bind`函数，函数名返回`bound` + 函数名称；如果是`function`关键字构造的函数（匿名函数），`name`属性值返回`anonymous`。\n\n## `Object.is()`\n\n该方法用来比较两个值是否严格相等，与严格比较运算符`===`的作用一致。不同之处有两个：+0不等于-0；另一个是NaN等于自身。\n\n```javascript\n+0 === -0 // true\nNaN === NaN // false\n\nObject.is(+0, -0); // false\nObject.is(NaN, NaN) // true\n```\n\n## `Object.assign()`\n\n### 基本用法\n\n用于将对象合并，将源对象的所有可枚举属性赋值到目标对象。如果目标对象与源对象由同名属性，或多个源对象由同名属性，则后面的属性会覆盖前面的属性。\n\n```javascript\nvar target = { a: 1 };\n\nvar source1 = { b: 2 };\nvar source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // { a: 1, b: 2, c: 3 }\n```\n\n如果只有一个参数，会直接返回该参数；如果该参数不是对象，会先转换为对象，然后返回。由于`undefined`和`null`无法转换为对象，所以将它们作为参数传入会报错。\n\n```javascript\nvar obj = { a: 1};\nObject.assign(obj) === obj // true\n\ntypeof Object.assign(2) // object\n\nObject.assign(undefined) // error\nObject.assign(null) // error\n```\n\n如果`undefined`和`null`出现在非首参数，首先会尝试着转换为对象，如果转换失败会直接跳过。这意味着只要首参数可以转换为对象，就不会报错。\n\n```javascript\nlet obj = { a: 1};\n\nObject.assign(a, undefined) === obj // true\nObject.assign(a, null) === obj // true\n```\n\n其他类型的值中，只有字符串会以数组的形式拷贝至对象中，其他值都不会产生效果；\n\n```javascript\nvar v1 = 'abc';\nvar v2 = true;\nvar v3 = 10;\n\nvar obj = Object.assign({}, v1, v2, v3);\nconsole.log(obj); // {'0': 'a', '1': 'b', '2': 'c'}\n```\n\n`Object.assign()`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）。\n\n```javascript\nObject.assign({b: 'c'}, Object.defineProperty({}, 'invisible', {\n    \tenumerable: false,\n    \tvalue: 'hello'\n\t})\n)\n// {b: 'c'}\n```\n\n值得注意的是：`Object.assign()`执行的是浅拷贝，而不是深拷贝。如果源对象某个属性的值是对象，那么目标对象拷贝得到的仅仅是这个对象的引用。\n\n```javascript\nvar obj1 = {a: {b: 1}};\nvar obj2 = Object.assign({}, obj1);\n\nobj1.a.b = 2;\nobj2.a.b // 2\n```\n\n### Object.assign()方法有哪些用途呢？\n\n#### 为对象添加属性\n\n```javascript\nclass Point {\n    constructor(x, y) {\n        Object.assign(this, {x, y})\n    }\n}\n```\n\n#### 为对象添加方法\n\n```javascript\nObject.assign(SomeClass.prototype, {\n    someMethod(arg1, arg2) {\n        ...\n    },\n    anotherMethod() {\n        ...\n    }\n});\n        \n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) { ... };\nSomeClass.prototype.anotherMethod = function () { ... };\n```\n\n#### 克隆对象\n\n```javascript\n// 将原始对象拷贝到空对象中\nfunction clone (origin) {\n    return Object.assign({}, origin);\n}\n\n// 将原始对象和其继承的值拷贝到新对象中\nfunction clone (origin) {\n    let originProto = Object.getPrototypeOf(origin);\n    return Object.assign(Object.create(originProto), origin);\n}\n```\n\n#### 合并多个对象\n\n```javascript\n// 将多个对象合并到某个对象\nconst merge = (target, ...source) => Object.assign(target, ...source);\n\n// 合并后返回一个新对象\nconst merge = (...source) => Object.assign({}, ...source);\n```\n\n#### 为属性指定默认值\n\n```javascript\nconst DEFAULTS = {\n    logLevel: 0,\n    outputFormat: 'html'\n};\n\nfunction processContent(options) {\n    options = Object.assign({}, DEFAULTS, options)\n}\n```\n\n## 属性的可枚举性\n\n`Object.getOwnPropertyDescriptor(obj, 'foo')`方法可以获取该属性的描述对象，其中描述对象有一个`enumerable`属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。\n\nES6中有下面4个操作会忽略`enumerable`为false的属性。\n\n- `for ... in` 循环：只遍历对象自身的和继承的可枚举属性；\n- `Object.keys()`：返回对象自身的所有可枚举的属性键名；\n- `JSON.stringify()`：只串行化对象自身的可枚举属性；\n- `Object.assign()`：只拷贝对象自身的可枚举属性；\n\n上面4个操作中，只有`for ... in`会返回继承的属性。实际上引入`enumerable`的最初目的，就是让某些可以规避掉`for...in`的操作。\n\n```javascript\nObject.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable // false\n\nObject.getOwnPropertyDescriptor([], 'length').enumerable // false\n```\n\n另外ES6规定，所有Class的原型方法都是不可枚举的：\n\n```javascript\nObject.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable\n```\n\n## 属性的遍历\n\nES6中一共有5种方法可以遍历对象的属性\n\n#### （1）for...in\n\n遍历对象自身和继承的可枚举属性\n\n#### （2）Object.keys(obj)\n\n返回一个数组，包括对象自身的（不含继承）所有可枚举属性（不包括Symbol属性）\n\n#### （3）Object.getOwnPropertyNames(obj)\n\n返回一个数组，包含对象自身的所有属性（不包括Symbol属性）\n\n#### （4）Object.getOwnPropertySymbols(obj)\n\n返回一个数组，包含对象自身的所有Symbol属性\n\n#### （5）Reflect.ownKeys(obj)\n\n返回一个数组，包含对象自身的所有属性，不管是属性名还是Symbol还是字符串，也不管是否可枚举。\n\n上面5种方法遍历对象属性，都遵循同样的属性遍历的次序规则。\n\n- 首先遍历所有属性名为数值的字符的属性，按照数字排序；\n- 其次遍历所有属性名为字符串的属性，按照生成时间排序；\n- 最后遍历所有属性名为Symbol值得属性，按照生成时间排序；\n\n一句话概括：遍历规则为数值 > 字符串 > Symbol；数值排序规则为数字，剩下两个排序规则为生成顺序；\n\n## `__proto__`属性，`Objects.setPrototypeOf()`, `Object.getPrototypeOf()`\n\n#### `__proto__`属性\n\n用来读取或设置当前对象的`prototype`对象。目前所有浏览器都支持这个特性。\n\n```javascript\nvar obj = {\n    method: function () {...}\n};\nobj.__proto__ = someOtherObj;\n\nvar obj = Object.create(someOtherObj);\nobj.method = function () {...};\n```\n\n这里和Python一样，使用双下划线标注的属性内部属性，而不是一个正式对外的API。因此在正式使用时不建议显示的设置。而是用`Object.setPrototypeOf()`、`Object.getPrototypeOf()`、`Object.create()`代替。\n\n#### `Object.setPrototypeOf()`\n\n用来设置对象的`prototype`对象。是ES6推荐的设置原型对象的方法。\n\n```javascript\nlet proto = {};\nlet obj = { x: 10};\nObject.setPrototypeOf(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nconsole.log(obj.x) // 10\nconsole.log(obj.y) // 20\nconsole.log(obj.z) // 40\n```\n\n#### `Object.getPrototypeOf()`\n\n与上面的set方法相反，用来获取一个对象的prototype对象。\n\n```javascript\nfunction Rectangle () {\n\n}\n\nvar rec = new Rectangle();\n\nObject.getPrototypeOf(rec) === Rectangle.prototype; // true\n\nObject.setPrototypeOf(rec, Object.prototype);\nObject.getPrototypeOf(rec) === Rectangle.prototype; // false\n```\n\n## `Object.values()`, `Object.entries()`\n\n#### `Object.keys()`\n\n返回一个数组，成员是参数对象自身的所有可遍历属性的键名（不含继承）\n\n```javascript\nvar obj = { foo: \"bar\", baz: 42 };\nObject.keys(obj)\n// [\"foo\", \"baz\"]\n```\n\n目前ES7有一个新提案，引入了跟`Object.keys()`配套的`Object.values`和`Object.entries`。\n\n```javascript\nlet { keys, values, entries } = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key  of keys(obj)) {\n    console.log(key);\n}\n// 'a', 'b', 'c'\n\nfor (let value of values(obj)) {\n    console.log(value);\n}\n// 1, 2, 3\n\nfor (let [key, value] of entries(obj)) {\n    console.log([key, value]);\n}\n//['a', 1], ['b', 2], ['c', 3]\n```\n\n#### `Object.values()`\n\n返回一个数组，成员是参数对象自身的（不含继承）所有可遍历（enumerable）属性的键值。\n\n```javascript\nvar obj = { foo: \"bar\", baz: 42 };\nObject.values(obj);\n// ['baz', 42]\n```\n\n#### `Object.entries`\n\n返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。\n\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.entries(obj);\n// [ [ 'foo', 'bar' ], [ 'baz', 42 ] ]\n```\n\n基本用途为遍历对象的属性，也可以将对象转换为Map\n\n```javascript\nlet obj = { one: 1, two: 2 };\nfor (let [k, v] of Object.entries(obj)) {\n    console.log(`${JSON.stringify(k)} : ${JSON.stringify(v)}`)\n}\n// \"one\": 1\n// \"two\": 2\n\n// 另一个用途是将对象转换为Map\nvar obj = { foo: 'bar', baz: 42 };\nvar map = new Map(Object.entries(obj));\nmap // Map {foo: \"bar\", baz: 42 }\n```\n\n## 对象的扩展运算符\n\n之前提到过扩展运算符（`...`），在对象中也有运用。\n\n#### 解构赋值\n\n对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到指定的对象上。所有的键和值，都会拷贝到新对象上。\n\n```javascript\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n```\n\n解构必须是最后一个参数，否则会报错，这和Java是完全一样的。注意一点：解构赋值时浅拷贝，如果一个键的值是复合类型的值（数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n\n```javascript\nlet obj = { a: { b: 1 }};\nlet {...x} = obj;\nobj.a.b = 2;\nx.a.b // 2 (浅拷贝无疑了)\n```\n\n另外解构赋值不会拷贝继承自原型对象的属性。下面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。\n\n解构赋值的一个用处，是扩展某个函数的参数，引入其他操作：\n\n```javascript\nfunction baseFunction ({a, b}) {\n    // ...\n}\n\nfunction wrapperFunction ({x, y, ...restConfig}) {\n    return baseFunction(restConfig);\n}\n```\n\n扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n```javascript\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n```\n\n还可以用于合并两个对象。\n\n```javascript\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = Object.assign({}, a, b);\n```\n\n## `Object.getOwnPropertyDescriptors()`\n\n前面提到了：这个方法是用来返回某个对象属性的描述对象的。ES7有个提案：返回指定对象所有自身属性（非继承性——的描述对象。\n\n```javascript\nconst obj = {\n    foo: 123,\n    get bar() { return 'abc' }\n};\n\nObject.getOwnPropertyDescription(obj)\n\n// 返回结果如下\n{\n  foo: { value: 123, writable: true, enumerable: true, configurable: true },\n  bar: {\n    get: [Function: get bar],\n    set: undefined,\n    enumerable: true,\n    configurable: true\n  }\n}\n```\n\n该方法实现的目的：主要是为了解决`Object.assing()`无法正确拷贝`get`属性和`set`属性的问题。结合`Object.defineProperties`方法就可以实现正确拷贝。\n\n```javascript\nconst source = {\n    set foo (value) {\n        console.log(value);\n    }\n};\n\nconst target2 = {};\nObject.defineProperties(target2, Object.getOwnPropertyDescriptors(source));\nObject.getOwnPropertyDescriptor(target2, 'foo')\n\n// 返回结果\n{                           \n  get: undefined,           \n  set: [Function: set foo], \n  enumerable: true,         \n  configurable: true        \n}                           \n```\n\n将上面两部分代码合并起来，就是这样。是不是突然觉得眼熟悉？（就是React Thunk的使用方法）\n\n```javascript\nconst shallowMerge = (target, source) => Object.defineProperties(\n\ttarget,\n    Object.getOwnPropertyDescriptors(source)\n);\n\n// 浅拷贝对象\nconst clone = Object.create(Object.getPrototypeOf(obj),\n                           Object.getOwnPropertyDescriptors(obj));\nconst shallowClone = (obj) => Object.create(\n\tObject.getPrototypeOf(obj),\n    Object.getOwnPropertyDescriptors(obj)\n);\n```\n","slug":"javascript/es6-object-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl34001j2y618ip0d92n","content":"<h1 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h1><h2 id=\"属性的简洁表示法\"><a href=\"#属性的简洁表示法\" class=\"headerlink\" title=\"属性的简洁表示法\"></a>属性的简洁表示法</h2><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更加简洁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> baz = &#123;foo&#125;;<br>baz <span class=\"hljs-comment\">// &#123;foo: &quot;bar&quot;&#125;</span><br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> baz = &#123;<span class=\"hljs-attr\">foo</span>: foo&#125;;<br></code></pre></td></tr></table></figure>\n<p>除了属性可以简写，方法也可以简写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> o = &#123;<br>    <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-keyword\">var</span> o = &#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>适用于函数返回值，写起来会非常简洁和方便</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPoint</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">return</span> &#123;x, y&#125;;<br>&#125;<br><br><span class=\"hljs-title function_\">getPoint</span>() <span class=\"hljs-comment\">// &#123;x: 1, y: 10&#125;</span><br></code></pre></td></tr></table></figure>\n<p>在使用Common JS中，输出的代码非常适合使用这种简洁写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> ms = &#123;&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-params\">key</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> key <span class=\"hljs-keyword\">in</span> ms ? ms[key] : <span class=\"hljs-literal\">null</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setItem</span>(<span class=\"hljs-params\">key, value</span>) &#123;<br>    ms[key] = value;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clear</span>(<span class=\"hljs-params\"></span>) &#123;<br>    ms = &#123;&#125;;<br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123; getItem, setItem, clear &#125;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>    <span class=\"hljs-attr\">getItem</span>: getItem,<br>    <span class=\"hljs-attr\">setItem</span>: setItem,<br>    <span class=\"hljs-attr\">clear</span>: clear<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"属性名表达式\"><a href=\"#属性名表达式\" class=\"headerlink\" title=\"属性名表达式\"></a>属性名表达式</h2><p>JavaScript语言定义对象的属性，有如下种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 直接使用标识符作为属性名</span><br><br>obj[<span class=\"hljs-string\">&#x27;a&#x27;</span> + <span class=\"hljs-string\">&#x27;bc&#x27;</span>] = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 使用表达式作为属性名</span><br></code></pre></td></tr></table></figure>\n<p>ES6允许字面量定义对象时，用方法二作为对象的属性名，即将表达式放在括号内</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> propKey = <span class=\"hljs-string\">&#x27;foo&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>    [propKey]: <span class=\"hljs-literal\">true</span>,<br>    [<span class=\"hljs-string\">&#x27;a&#x27;</span> + <span class=\"hljs-string\">&#x27;bc&#x27;</span>]: <span class=\"hljs-number\">123</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> lastWord = <span class=\"hljs-string\">&#x27;last word&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;<br>    <span class=\"hljs-string\">&#x27;first word&#x27;</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>,<br>    [lastWord]: <span class=\"hljs-string\">&#x27;world&#x27;</span><br>&#125;;<br><br>a[<span class=\"hljs-string\">&#x27;first Word&#x27;</span>] <span class=\"hljs-comment\">// hello</span><br>a[lastWord] <span class=\"hljs-comment\">// World</span><br>a[<span class=\"hljs-string\">&#x27;last word&#x27;</span>] <span class=\"hljs-comment\">// World</span><br></code></pre></td></tr></table></figure>\n<p>注意：属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串。因此属性名表达式和简洁表示法不可以同时使用。一定要注意。</p>\n<h2 id=\"方法的name属性\"><a href=\"#方法的name属性\" class=\"headerlink\" title=\"方法的name属性\"></a>方法的<code>name</code>属性</h2><p>函数的<code>name</code>属性返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-title function_\">sayName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;,<br>    <span class=\"hljs-comment\">// get为取值函数，存值用set</span><br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">firstName</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Nicholas&quot;</span>;<br>    &#125;<br>&#125;;<br><br>person.<span class=\"hljs-property\">sayName</span>.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// sayName</span><br>person.<span class=\"hljs-property\">firstName</span>.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// get firstName</span><br></code></pre></td></tr></table></figure>\n<p>有两个特例：如果是<code>bind</code>函数，函数名返回<code>bound</code> + 函数名称；如果是<code>function</code>关键字构造的函数（匿名函数），<code>name</code>属性值返回<code>anonymous</code>。</p>\n<h2 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a><code>Object.is()</code></h2><p>该方法用来比较两个值是否严格相等，与严格比较运算符<code>===</code>的作用一致。不同之处有两个：+0不等于-0；另一个是NaN等于自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">+<span class=\"hljs-number\">0</span> === -<span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">NaN</span> === <span class=\"hljs-title class_\">NaN</span> <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(+<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(<span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a><code>Object.assign()</code></h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>用于将对象合并，将源对象的所有可枚举属性赋值到目标对象。如果目标对象与源对象由同名属性，或多个源对象由同名属性，则后面的属性会覆盖前面的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;;<br><br><span class=\"hljs-keyword\">var</span> source1 = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">var</span> source2 = &#123; <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, source1, source2);<br>target <span class=\"hljs-comment\">// &#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果只有一个参数，会直接返回该参数；如果该参数不是对象，会先转换为对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转换为对象，所以将它们作为参数传入会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(obj) === obj <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// object</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// error</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// error</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>undefined</code>和<code>null</code>出现在非首参数，首先会尝试着转换为对象，如果转换失败会直接跳过。这意味着只要首参数可以转换为对象，就不会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, <span class=\"hljs-literal\">undefined</span>) === obj <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, <span class=\"hljs-literal\">null</span>) === obj <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>其他类型的值中，只有字符串会以数组的形式拷贝至对象中，其他值都不会产生效果；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> v1 = <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> v2 = <span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">var</span> v3 = <span class=\"hljs-number\">10</span>;<br><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, v1, v2, v3);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj); <span class=\"hljs-comment\">// &#123;&#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n<p><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>&#125;, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(&#123;&#125;, <span class=\"hljs-string\">&#x27;invisible&#x27;</span>, &#123;<br>    \t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span>,<br>    \t<span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span><br>\t&#125;)<br>)<br><span class=\"hljs-comment\">// &#123;b: &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n<p>值得注意的是：<code>Object.assign()</code>执行的是浅拷贝，而不是深拷贝。如果源对象某个属性的值是对象，那么目标对象拷贝得到的仅仅是这个对象的引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<span class=\"hljs-attr\">a</span>: &#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>&#125;&#125;;<br><span class=\"hljs-keyword\">var</span> obj2 = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, obj1);<br><br>obj1.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>obj2.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Object-assign-方法有哪些用途呢？\"><a href=\"#Object-assign-方法有哪些用途呢？\" class=\"headerlink\" title=\"Object.assign()方法有哪些用途呢？\"></a>Object.assign()方法有哪些用途呢？</h3><h4 id=\"为对象添加属性\"><a href=\"#为对象添加属性\" class=\"headerlink\" title=\"为对象添加属性\"></a>为对象添加属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-variable language_\">this</span>, &#123;x, y&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"为对象添加方法\"><a href=\"#为对象添加方法\" class=\"headerlink\" title=\"为对象添加方法\"></a>为对象添加方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, &#123;<br>    <span class=\"hljs-title function_\">someMethod</span>(<span class=\"hljs-params\">arg1, arg2</span>) &#123;<br>        ...<br>    &#125;,<br>    <span class=\"hljs-title function_\">anotherMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>        ...<br>    &#125;<br>&#125;);<br>        <br><span class=\"hljs-comment\">// 等同于下面的写法</span><br><span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">someMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arg1, arg2</span>) &#123; ... &#125;;<br><span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">anotherMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; ... &#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"克隆对象\"><a href=\"#克隆对象\" class=\"headerlink\" title=\"克隆对象\"></a>克隆对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 将原始对象拷贝到空对象中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone</span> (origin) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, origin);<br>&#125;<br><br><span class=\"hljs-comment\">// 将原始对象和其继承的值拷贝到新对象中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone</span> (origin) &#123;<br>    <span class=\"hljs-keyword\">let</span> originProto = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(origin);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(originProto), origin);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"合并多个对象\"><a href=\"#合并多个对象\" class=\"headerlink\" title=\"合并多个对象\"></a>合并多个对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 将多个对象合并到某个对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">merge</span> = (<span class=\"hljs-params\">target, ...source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, ...source);<br><br><span class=\"hljs-comment\">// 合并后返回一个新对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">merge</span> = (<span class=\"hljs-params\">...source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, ...source);<br></code></pre></td></tr></table></figure>\n<h4 id=\"为属性指定默认值\"><a href=\"#为属性指定默认值\" class=\"headerlink\" title=\"为属性指定默认值\"></a>为属性指定默认值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">DEFAULTS</span> = &#123;<br>    <span class=\"hljs-attr\">logLevel</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">outputFormat</span>: <span class=\"hljs-string\">&#x27;html&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processContent</span>(<span class=\"hljs-params\">options</span>) &#123;<br>    options = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, <span class=\"hljs-variable constant_\">DEFAULTS</span>, options)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"属性的可枚举性\"><a href=\"#属性的可枚举性\" class=\"headerlink\" title=\"属性的可枚举性\"></a>属性的可枚举性</h2><p><code>Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)</code>方法可以获取该属性的描述对象，其中描述对象有一个<code>enumerable</code>属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</p>\n<p>ES6中有下面4个操作会忽略<code>enumerable</code>为false的属性。</p>\n<ul>\n<li><code>for ... in</code> 循环：只遍历对象自身的和继承的可枚举属性；</li>\n<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性键名；</li>\n<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举属性；</li>\n<li><code>Object.assign()</code>：只拷贝对象自身的可枚举属性；</li>\n</ul>\n<p>上面4个操作中，只有<code>for ... in</code>会返回继承的属性。实际上引入<code>enumerable</code>的最初目的，就是让某些可以规避掉<code>for...in</code>的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;toString&#x27;</span>).<span class=\"hljs-property\">enumerable</span> <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>([], <span class=\"hljs-string\">&#x27;length&#x27;</span>).<span class=\"hljs-property\">enumerable</span> <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<p>另外ES6规定，所有Class的原型方法都是不可枚举的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(<span class=\"hljs-keyword\">class</span> &#123;<span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;&#125;&#125;.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;foo&#x27;</span>).<span class=\"hljs-property\">enumerable</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"属性的遍历\"><a href=\"#属性的遍历\" class=\"headerlink\" title=\"属性的遍历\"></a>属性的遍历</h2><p>ES6中一共有5种方法可以遍历对象的属性</p>\n<h4 id=\"（1）for…in\"><a href=\"#（1）for…in\" class=\"headerlink\" title=\"（1）for…in\"></a>（1）for…in</h4><p>遍历对象自身和继承的可枚举属性</p>\n<h4 id=\"（2）Object-keys-obj\"><a href=\"#（2）Object-keys-obj\" class=\"headerlink\" title=\"（2）Object.keys(obj)\"></a>（2）Object.keys(obj)</h4><p>返回一个数组，包括对象自身的（不含继承）所有可枚举属性（不包括Symbol属性）</p>\n<h4 id=\"（3）Object-getOwnPropertyNames-obj\"><a href=\"#（3）Object-getOwnPropertyNames-obj\" class=\"headerlink\" title=\"（3）Object.getOwnPropertyNames(obj)\"></a>（3）Object.getOwnPropertyNames(obj)</h4><p>返回一个数组，包含对象自身的所有属性（不包括Symbol属性）</p>\n<h4 id=\"（4）Object-getOwnPropertySymbols-obj\"><a href=\"#（4）Object-getOwnPropertySymbols-obj\" class=\"headerlink\" title=\"（4）Object.getOwnPropertySymbols(obj)\"></a>（4）Object.getOwnPropertySymbols(obj)</h4><p>返回一个数组，包含对象自身的所有Symbol属性</p>\n<h4 id=\"（5）Reflect-ownKeys-obj\"><a href=\"#（5）Reflect-ownKeys-obj\" class=\"headerlink\" title=\"（5）Reflect.ownKeys(obj)\"></a>（5）Reflect.ownKeys(obj)</h4><p>返回一个数组，包含对象自身的所有属性，不管是属性名还是Symbol还是字符串，也不管是否可枚举。</p>\n<p>上面5种方法遍历对象属性，都遵循同样的属性遍历的次序规则。</p>\n<ul>\n<li>首先遍历所有属性名为数值的字符的属性，按照数字排序；</li>\n<li>其次遍历所有属性名为字符串的属性，按照生成时间排序；</li>\n<li>最后遍历所有属性名为Symbol值得属性，按照生成时间排序；</li>\n</ul>\n<p>一句话概括：遍历规则为数值 &gt; 字符串 &gt; Symbol；数值排序规则为数字，剩下两个排序规则为生成顺序；</p>\n<h2 id=\"proto-属性，Objects-setPrototypeOf-Object-getPrototypeOf\"><a href=\"#proto-属性，Objects-setPrototypeOf-Object-getPrototypeOf\" class=\"headerlink\" title=\"__proto__属性，Objects.setPrototypeOf(), Object.getPrototypeOf()\"></a><code>__proto__</code>属性，<code>Objects.setPrototypeOf()</code>, <code>Object.getPrototypeOf()</code></h2><h4 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__属性\"></a><code>__proto__</code>属性</h4><p>用来读取或设置当前对象的<code>prototype</code>对象。目前所有浏览器都支持这个特性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;...&#125;<br>&#125;;<br>obj.<span class=\"hljs-property\">__proto__</span> = someOtherObj;<br><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(someOtherObj);<br>obj.<span class=\"hljs-property\">method</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;...&#125;;<br></code></pre></td></tr></table></figure>\n<p>这里和Python一样，使用双下划线标注的属性内部属性，而不是一个正式对外的API。因此在正式使用时不建议显示的设置。而是用<code>Object.setPrototypeOf()</code>、<code>Object.getPrototypeOf()</code>、<code>Object.create()</code>代替。</p>\n<h4 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a><code>Object.setPrototypeOf()</code></h4><p>用来设置对象的<code>prototype</code>对象。是ES6推荐的设置原型对象的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> proto = &#123;&#125;;<br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">10</span>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(obj, proto);<br><br>proto.<span class=\"hljs-property\">y</span> = <span class=\"hljs-number\">20</span>;<br>proto.<span class=\"hljs-property\">z</span> = <span class=\"hljs-number\">40</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">x</span>) <span class=\"hljs-comment\">// 10</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">y</span>) <span class=\"hljs-comment\">// 20</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">z</span>) <span class=\"hljs-comment\">// 40</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a><code>Object.getPrototypeOf()</code></h4><p>与上面的set方法相反，用来获取一个对象的prototype对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Rectangle</span> () &#123;<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> rec = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Rectangle</span>();<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(rec) === <span class=\"hljs-title class_\">Rectangle</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(rec, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(rec) === <span class=\"hljs-title class_\">Rectangle</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-values-Object-entries\"><a href=\"#Object-values-Object-entries\" class=\"headerlink\" title=\"Object.values(), Object.entries()\"></a><code>Object.values()</code>, <code>Object.entries()</code></h2><h4 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a><code>Object.keys()</code></h4><p>返回一个数组，成员是参数对象自身的所有可遍历属性的键名（不含继承）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)<br><span class=\"hljs-comment\">// [&quot;foo&quot;, &quot;baz&quot;]</span><br></code></pre></td></tr></table></figure>\n<p>目前ES7有一个新提案，引入了跟<code>Object.keys()</code>配套的<code>Object.values</code>和<code>Object.entries</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123; keys, values, entries &#125; = <span class=\"hljs-title class_\">Object</span>;<br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key  <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">keys</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">values</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><span class=\"hljs-comment\">// 1, 2, 3</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([key, value]);<br>&#125;<br><span class=\"hljs-comment\">//[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-values\"><a href=\"#Object-values\" class=\"headerlink\" title=\"Object.values()\"></a><code>Object.values()</code></h4><p>返回一个数组，成员是参数对象自身的（不含继承）所有可遍历（enumerable）属性的键值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(obj);<br><span class=\"hljs-comment\">// [&#x27;baz&#x27;, 42]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-entries\"><a href=\"#Object-entries\" class=\"headerlink\" title=\"Object.entries\"></a><code>Object.entries</code></h4><p>返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj);<br><span class=\"hljs-comment\">// [ [ &#x27;foo&#x27;, &#x27;bar&#x27; ], [ &#x27;baz&#x27;, 42 ] ]</span><br></code></pre></td></tr></table></figure>\n<p>基本用途为遍历对象的属性，也可以将对象转换为Map</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">one</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">two</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k, v] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(k)&#125;</span> : <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(v)&#125;</span>`</span>)<br>&#125;<br><span class=\"hljs-comment\">// &quot;one&quot;: 1</span><br><span class=\"hljs-comment\">// &quot;two&quot;: 2</span><br><br><span class=\"hljs-comment\">// 另一个用途是将对象转换为Map</span><br><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj));<br>map <span class=\"hljs-comment\">// Map &#123;foo: &quot;bar&quot;, baz: 42 &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"对象的扩展运算符\"><a href=\"#对象的扩展运算符\" class=\"headerlink\" title=\"对象的扩展运算符\"></a>对象的扩展运算符</h2><p>之前提到过扩展运算符（<code>...</code>），在对象中也有运用。</p>\n<h4 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到指定的对象上。所有的键和值，都会拷贝到新对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123; x, y, ...z &#125; = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">4</span> &#125;;<br>x <span class=\"hljs-comment\">// 1</span><br>y <span class=\"hljs-comment\">// 2</span><br>z <span class=\"hljs-comment\">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>解构必须是最后一个参数，否则会报错，这和Java是完全一样的。注意一点：解构赋值时浅拷贝，如果一个键的值是复合类型的值（数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span> &#125;&#125;;<br><span class=\"hljs-keyword\">let</span> &#123;...x&#125; = obj;<br>obj.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>x.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2 (浅拷贝无疑了)</span><br></code></pre></td></tr></table></figure>\n<p>另外解构赋值不会拷贝继承自原型对象的属性。下面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>\n<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">baseFunction</span> (&#123;a, b&#125;) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">wrapperFunction</span> (&#123;x, y, ...restConfig&#125;) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">baseFunction</span>(restConfig);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> z = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">4</span> &#125;;<br><span class=\"hljs-keyword\">let</span> n = &#123; ...z &#125;;<br>n <span class=\"hljs-comment\">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>还可以用于合并两个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> ab = &#123; ...a, ...b &#125;;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">let</span> ab = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, a, b);<br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors()\"></a><code>Object.getOwnPropertyDescriptors()</code></h2><p>前面提到了：这个方法是用来返回某个对象属性的描述对象的。ES7有个提案：返回指定对象所有自身属性（非继承性——的描述对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">123</span>,<br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">bar</span>() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span> &#125;<br>&#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescription</span>(obj)<br><br><span class=\"hljs-comment\">// 返回结果如下</span><br>&#123;<br>  <span class=\"hljs-attr\">foo</span>: &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">123</span>, <span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span> &#125;,<br>  <span class=\"hljs-attr\">bar</span>: &#123;<br>    <span class=\"hljs-attr\">get</span>: [<span class=\"hljs-title class_\">Function</span>: get bar],<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-literal\">undefined</span>,<br>    <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>该方法实现的目的：主要是为了解决<code>Object.assing()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。结合<code>Object.defineProperties</code>方法就可以实现正确拷贝。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> source = &#123;<br>    set foo (value) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> target2 = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperties</span>(target2, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(source));<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target2, <span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><br><span class=\"hljs-comment\">// 返回结果</span><br>&#123;                           <br>  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-literal\">undefined</span>,           <br>  <span class=\"hljs-attr\">set</span>: [<span class=\"hljs-title class_\">Function</span>: set foo], <br>  <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,         <br>  <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span>        <br>&#125;                           <br></code></pre></td></tr></table></figure>\n<p>将上面两部分代码合并起来，就是这样。是不是突然觉得眼熟悉？（就是React Thunk的使用方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shallowMerge</span> = (<span class=\"hljs-params\">target, source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperties</span>(<br>\ttarget,<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(source)<br>);<br><br><span class=\"hljs-comment\">// 浅拷贝对象</span><br><span class=\"hljs-keyword\">const</span> clone = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),<br>                           <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shallowClone</span> = (<span class=\"hljs-params\">obj</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<br>\t<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj)<br>);<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":9564,"excerpt":"","more":"<h1 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h1><h2 id=\"属性的简洁表示法\"><a href=\"#属性的简洁表示法\" class=\"headerlink\" title=\"属性的简洁表示法\"></a>属性的简洁表示法</h2><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更加简洁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> baz = &#123;foo&#125;;<br>baz <span class=\"hljs-comment\">// &#123;foo: &quot;bar&quot;&#125;</span><br><br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">var</span> baz = &#123;<span class=\"hljs-attr\">foo</span>: foo&#125;;<br></code></pre></td></tr></table></figure>\n<p>除了属性可以简写，方法也可以简写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> o = &#123;<br>    <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 等同于</span><br><br><span class=\"hljs-keyword\">var</span> o = &#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>适用于函数返回值，写起来会非常简洁和方便</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPoint</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">return</span> &#123;x, y&#125;;<br>&#125;<br><br><span class=\"hljs-title function_\">getPoint</span>() <span class=\"hljs-comment\">// &#123;x: 1, y: 10&#125;</span><br></code></pre></td></tr></table></figure>\n<p>在使用Common JS中，输出的代码非常适合使用这种简洁写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> ms = &#123;&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-params\">key</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> key <span class=\"hljs-keyword\">in</span> ms ? ms[key] : <span class=\"hljs-literal\">null</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setItem</span>(<span class=\"hljs-params\">key, value</span>) &#123;<br>    ms[key] = value;<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clear</span>(<span class=\"hljs-params\"></span>) &#123;<br>    ms = &#123;&#125;;<br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123; getItem, setItem, clear &#125;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>    <span class=\"hljs-attr\">getItem</span>: getItem,<br>    <span class=\"hljs-attr\">setItem</span>: setItem,<br>    <span class=\"hljs-attr\">clear</span>: clear<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"属性名表达式\"><a href=\"#属性名表达式\" class=\"headerlink\" title=\"属性名表达式\"></a>属性名表达式</h2><p>JavaScript语言定义对象的属性，有如下种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 直接使用标识符作为属性名</span><br><br>obj[<span class=\"hljs-string\">&#x27;a&#x27;</span> + <span class=\"hljs-string\">&#x27;bc&#x27;</span>] = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 使用表达式作为属性名</span><br></code></pre></td></tr></table></figure>\n<p>ES6允许字面量定义对象时，用方法二作为对象的属性名，即将表达式放在括号内</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> propKey = <span class=\"hljs-string\">&#x27;foo&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>    [propKey]: <span class=\"hljs-literal\">true</span>,<br>    [<span class=\"hljs-string\">&#x27;a&#x27;</span> + <span class=\"hljs-string\">&#x27;bc&#x27;</span>]: <span class=\"hljs-number\">123</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这里再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> lastWord = <span class=\"hljs-string\">&#x27;last word&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;<br>    <span class=\"hljs-string\">&#x27;first word&#x27;</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>,<br>    [lastWord]: <span class=\"hljs-string\">&#x27;world&#x27;</span><br>&#125;;<br><br>a[<span class=\"hljs-string\">&#x27;first Word&#x27;</span>] <span class=\"hljs-comment\">// hello</span><br>a[lastWord] <span class=\"hljs-comment\">// World</span><br>a[<span class=\"hljs-string\">&#x27;last word&#x27;</span>] <span class=\"hljs-comment\">// World</span><br></code></pre></td></tr></table></figure>\n<p>注意：属性名表达式如果是一个对象，默认情况下会自动将对象转换为字符串。因此属性名表达式和简洁表示法不可以同时使用。一定要注意。</p>\n<h2 id=\"方法的name属性\"><a href=\"#方法的name属性\" class=\"headerlink\" title=\"方法的name属性\"></a>方法的<code>name</code>属性</h2><p>函数的<code>name</code>属性返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-title function_\">sayName</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;,<br>    <span class=\"hljs-comment\">// get为取值函数，存值用set</span><br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">firstName</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Nicholas&quot;</span>;<br>    &#125;<br>&#125;;<br><br>person.<span class=\"hljs-property\">sayName</span>.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// sayName</span><br>person.<span class=\"hljs-property\">firstName</span>.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// get firstName</span><br></code></pre></td></tr></table></figure>\n<p>有两个特例：如果是<code>bind</code>函数，函数名返回<code>bound</code> + 函数名称；如果是<code>function</code>关键字构造的函数（匿名函数），<code>name</code>属性值返回<code>anonymous</code>。</p>\n<h2 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a><code>Object.is()</code></h2><p>该方法用来比较两个值是否严格相等，与严格比较运算符<code>===</code>的作用一致。不同之处有两个：+0不等于-0；另一个是NaN等于自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">+<span class=\"hljs-number\">0</span> === -<span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">NaN</span> === <span class=\"hljs-title class_\">NaN</span> <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(+<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(<span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-title class_\">NaN</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a><code>Object.assign()</code></h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>用于将对象合并，将源对象的所有可枚举属性赋值到目标对象。如果目标对象与源对象由同名属性，或多个源对象由同名属性，则后面的属性会覆盖前面的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;;<br><br><span class=\"hljs-keyword\">var</span> source1 = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">var</span> source2 = &#123; <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, source1, source2);<br>target <span class=\"hljs-comment\">// &#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>如果只有一个参数，会直接返回该参数；如果该参数不是对象，会先转换为对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转换为对象，所以将它们作为参数传入会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(obj) === obj <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// object</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// error</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// error</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>undefined</code>和<code>null</code>出现在非首参数，首先会尝试着转换为对象，如果转换失败会直接跳过。这意味着只要首参数可以转换为对象，就不会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, <span class=\"hljs-literal\">undefined</span>) === obj <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, <span class=\"hljs-literal\">null</span>) === obj <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>其他类型的值中，只有字符串会以数组的形式拷贝至对象中，其他值都不会产生效果；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> v1 = <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> v2 = <span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">var</span> v3 = <span class=\"hljs-number\">10</span>;<br><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, v1, v2, v3);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj); <span class=\"hljs-comment\">// &#123;&#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n<p><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>&#125;, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(&#123;&#125;, <span class=\"hljs-string\">&#x27;invisible&#x27;</span>, &#123;<br>    \t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span>,<br>    \t<span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span><br>\t&#125;)<br>)<br><span class=\"hljs-comment\">// &#123;b: &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n<p>值得注意的是：<code>Object.assign()</code>执行的是浅拷贝，而不是深拷贝。如果源对象某个属性的值是对象，那么目标对象拷贝得到的仅仅是这个对象的引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj1 = &#123;<span class=\"hljs-attr\">a</span>: &#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>&#125;&#125;;<br><span class=\"hljs-keyword\">var</span> obj2 = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, obj1);<br><br>obj1.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>obj2.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Object-assign-方法有哪些用途呢？\"><a href=\"#Object-assign-方法有哪些用途呢？\" class=\"headerlink\" title=\"Object.assign()方法有哪些用途呢？\"></a>Object.assign()方法有哪些用途呢？</h3><h4 id=\"为对象添加属性\"><a href=\"#为对象添加属性\" class=\"headerlink\" title=\"为对象添加属性\"></a>为对象添加属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x, y</span>) &#123;<br>        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-variable language_\">this</span>, &#123;x, y&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"为对象添加方法\"><a href=\"#为对象添加方法\" class=\"headerlink\" title=\"为对象添加方法\"></a>为对象添加方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, &#123;<br>    <span class=\"hljs-title function_\">someMethod</span>(<span class=\"hljs-params\">arg1, arg2</span>) &#123;<br>        ...<br>    &#125;,<br>    <span class=\"hljs-title function_\">anotherMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>        ...<br>    &#125;<br>&#125;);<br>        <br><span class=\"hljs-comment\">// 等同于下面的写法</span><br><span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">someMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arg1, arg2</span>) &#123; ... &#125;;<br><span class=\"hljs-title class_\">SomeClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">anotherMethod</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; ... &#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"克隆对象\"><a href=\"#克隆对象\" class=\"headerlink\" title=\"克隆对象\"></a>克隆对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 将原始对象拷贝到空对象中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone</span> (origin) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, origin);<br>&#125;<br><br><span class=\"hljs-comment\">// 将原始对象和其继承的值拷贝到新对象中</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">clone</span> (origin) &#123;<br>    <span class=\"hljs-keyword\">let</span> originProto = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(origin);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(originProto), origin);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"合并多个对象\"><a href=\"#合并多个对象\" class=\"headerlink\" title=\"合并多个对象\"></a>合并多个对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 将多个对象合并到某个对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">merge</span> = (<span class=\"hljs-params\">target, ...source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, ...source);<br><br><span class=\"hljs-comment\">// 合并后返回一个新对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">merge</span> = (<span class=\"hljs-params\">...source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, ...source);<br></code></pre></td></tr></table></figure>\n<h4 id=\"为属性指定默认值\"><a href=\"#为属性指定默认值\" class=\"headerlink\" title=\"为属性指定默认值\"></a>为属性指定默认值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">DEFAULTS</span> = &#123;<br>    <span class=\"hljs-attr\">logLevel</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">outputFormat</span>: <span class=\"hljs-string\">&#x27;html&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processContent</span>(<span class=\"hljs-params\">options</span>) &#123;<br>    options = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, <span class=\"hljs-variable constant_\">DEFAULTS</span>, options)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"属性的可枚举性\"><a href=\"#属性的可枚举性\" class=\"headerlink\" title=\"属性的可枚举性\"></a>属性的可枚举性</h2><p><code>Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)</code>方法可以获取该属性的描述对象，其中描述对象有一个<code>enumerable</code>属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</p>\n<p>ES6中有下面4个操作会忽略<code>enumerable</code>为false的属性。</p>\n<ul>\n<li><code>for ... in</code> 循环：只遍历对象自身的和继承的可枚举属性；</li>\n<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性键名；</li>\n<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举属性；</li>\n<li><code>Object.assign()</code>：只拷贝对象自身的可枚举属性；</li>\n</ul>\n<p>上面4个操作中，只有<code>for ... in</code>会返回继承的属性。实际上引入<code>enumerable</code>的最初目的，就是让某些可以规避掉<code>for...in</code>的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;toString&#x27;</span>).<span class=\"hljs-property\">enumerable</span> <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>([], <span class=\"hljs-string\">&#x27;length&#x27;</span>).<span class=\"hljs-property\">enumerable</span> <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<p>另外ES6规定，所有Class的原型方法都是不可枚举的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(<span class=\"hljs-keyword\">class</span> &#123;<span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;&#125;&#125;.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;foo&#x27;</span>).<span class=\"hljs-property\">enumerable</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"属性的遍历\"><a href=\"#属性的遍历\" class=\"headerlink\" title=\"属性的遍历\"></a>属性的遍历</h2><p>ES6中一共有5种方法可以遍历对象的属性</p>\n<h4 id=\"（1）for…in\"><a href=\"#（1）for…in\" class=\"headerlink\" title=\"（1）for…in\"></a>（1）for…in</h4><p>遍历对象自身和继承的可枚举属性</p>\n<h4 id=\"（2）Object-keys-obj\"><a href=\"#（2）Object-keys-obj\" class=\"headerlink\" title=\"（2）Object.keys(obj)\"></a>（2）Object.keys(obj)</h4><p>返回一个数组，包括对象自身的（不含继承）所有可枚举属性（不包括Symbol属性）</p>\n<h4 id=\"（3）Object-getOwnPropertyNames-obj\"><a href=\"#（3）Object-getOwnPropertyNames-obj\" class=\"headerlink\" title=\"（3）Object.getOwnPropertyNames(obj)\"></a>（3）Object.getOwnPropertyNames(obj)</h4><p>返回一个数组，包含对象自身的所有属性（不包括Symbol属性）</p>\n<h4 id=\"（4）Object-getOwnPropertySymbols-obj\"><a href=\"#（4）Object-getOwnPropertySymbols-obj\" class=\"headerlink\" title=\"（4）Object.getOwnPropertySymbols(obj)\"></a>（4）Object.getOwnPropertySymbols(obj)</h4><p>返回一个数组，包含对象自身的所有Symbol属性</p>\n<h4 id=\"（5）Reflect-ownKeys-obj\"><a href=\"#（5）Reflect-ownKeys-obj\" class=\"headerlink\" title=\"（5）Reflect.ownKeys(obj)\"></a>（5）Reflect.ownKeys(obj)</h4><p>返回一个数组，包含对象自身的所有属性，不管是属性名还是Symbol还是字符串，也不管是否可枚举。</p>\n<p>上面5种方法遍历对象属性，都遵循同样的属性遍历的次序规则。</p>\n<ul>\n<li>首先遍历所有属性名为数值的字符的属性，按照数字排序；</li>\n<li>其次遍历所有属性名为字符串的属性，按照生成时间排序；</li>\n<li>最后遍历所有属性名为Symbol值得属性，按照生成时间排序；</li>\n</ul>\n<p>一句话概括：遍历规则为数值 &gt; 字符串 &gt; Symbol；数值排序规则为数字，剩下两个排序规则为生成顺序；</p>\n<h2 id=\"proto-属性，Objects-setPrototypeOf-Object-getPrototypeOf\"><a href=\"#proto-属性，Objects-setPrototypeOf-Object-getPrototypeOf\" class=\"headerlink\" title=\"__proto__属性，Objects.setPrototypeOf(), Object.getPrototypeOf()\"></a><code>__proto__</code>属性，<code>Objects.setPrototypeOf()</code>, <code>Object.getPrototypeOf()</code></h2><h4 id=\"proto-属性\"><a href=\"#proto-属性\" class=\"headerlink\" title=\"__proto__属性\"></a><code>__proto__</code>属性</h4><p>用来读取或设置当前对象的<code>prototype</code>对象。目前所有浏览器都支持这个特性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;...&#125;<br>&#125;;<br>obj.<span class=\"hljs-property\">__proto__</span> = someOtherObj;<br><br><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(someOtherObj);<br>obj.<span class=\"hljs-property\">method</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;...&#125;;<br></code></pre></td></tr></table></figure>\n<p>这里和Python一样，使用双下划线标注的属性内部属性，而不是一个正式对外的API。因此在正式使用时不建议显示的设置。而是用<code>Object.setPrototypeOf()</code>、<code>Object.getPrototypeOf()</code>、<code>Object.create()</code>代替。</p>\n<h4 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a><code>Object.setPrototypeOf()</code></h4><p>用来设置对象的<code>prototype</code>对象。是ES6推荐的设置原型对象的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> proto = &#123;&#125;;<br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">10</span>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(obj, proto);<br><br>proto.<span class=\"hljs-property\">y</span> = <span class=\"hljs-number\">20</span>;<br>proto.<span class=\"hljs-property\">z</span> = <span class=\"hljs-number\">40</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">x</span>) <span class=\"hljs-comment\">// 10</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">y</span>) <span class=\"hljs-comment\">// 20</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">z</span>) <span class=\"hljs-comment\">// 40</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a><code>Object.getPrototypeOf()</code></h4><p>与上面的set方法相反，用来获取一个对象的prototype对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Rectangle</span> () &#123;<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> rec = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Rectangle</span>();<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(rec) === <span class=\"hljs-title class_\">Rectangle</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(rec, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(rec) === <span class=\"hljs-title class_\">Rectangle</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-values-Object-entries\"><a href=\"#Object-values-Object-entries\" class=\"headerlink\" title=\"Object.values(), Object.entries()\"></a><code>Object.values()</code>, <code>Object.entries()</code></h2><h4 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a><code>Object.keys()</code></h4><p>返回一个数组，成员是参数对象自身的所有可遍历属性的键名（不含继承）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)<br><span class=\"hljs-comment\">// [&quot;foo&quot;, &quot;baz&quot;]</span><br></code></pre></td></tr></table></figure>\n<p>目前ES7有一个新提案，引入了跟<code>Object.keys()</code>配套的<code>Object.values</code>和<code>Object.entries</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123; keys, values, entries &#125; = <span class=\"hljs-title class_\">Object</span>;<br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key  <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">keys</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">values</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><span class=\"hljs-comment\">// 1, 2, 3</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([key, value]);<br>&#125;<br><span class=\"hljs-comment\">//[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-values\"><a href=\"#Object-values\" class=\"headerlink\" title=\"Object.values()\"></a><code>Object.values()</code></h4><p>返回一个数组，成员是参数对象自身的（不含继承）所有可遍历（enumerable）属性的键值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(obj);<br><span class=\"hljs-comment\">// [&#x27;baz&#x27;, 42]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"Object-entries\"><a href=\"#Object-entries\" class=\"headerlink\" title=\"Object.entries\"></a><code>Object.entries</code></h4><p>返回一个数组，成员是参数对象自身的（不含继承）所有可遍历属性的键值对数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj);<br><span class=\"hljs-comment\">// [ [ &#x27;foo&#x27;, &#x27;bar&#x27; ], [ &#x27;baz&#x27;, 42 ] ]</span><br></code></pre></td></tr></table></figure>\n<p>基本用途为遍历对象的属性，也可以将对象转换为Map</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">one</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">two</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k, v] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(k)&#125;</span> : <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(v)&#125;</span>`</span>)<br>&#125;<br><span class=\"hljs-comment\">// &quot;one&quot;: 1</span><br><span class=\"hljs-comment\">// &quot;two&quot;: 2</span><br><br><span class=\"hljs-comment\">// 另一个用途是将对象转换为Map</span><br><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">42</span> &#125;;<br><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj));<br>map <span class=\"hljs-comment\">// Map &#123;foo: &quot;bar&quot;, baz: 42 &#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"对象的扩展运算符\"><a href=\"#对象的扩展运算符\" class=\"headerlink\" title=\"对象的扩展运算符\"></a>对象的扩展运算符</h2><p>之前提到过扩展运算符（<code>...</code>），在对象中也有运用。</p>\n<h4 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到指定的对象上。所有的键和值，都会拷贝到新对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123; x, y, ...z &#125; = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">4</span> &#125;;<br>x <span class=\"hljs-comment\">// 1</span><br>y <span class=\"hljs-comment\">// 2</span><br>z <span class=\"hljs-comment\">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>解构必须是最后一个参数，否则会报错，这和Java是完全一样的。注意一点：解构赋值时浅拷贝，如果一个键的值是复合类型的值（数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">a</span>: &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span> &#125;&#125;;<br><span class=\"hljs-keyword\">let</span> &#123;...x&#125; = obj;<br>obj.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> = <span class=\"hljs-number\">2</span>;<br>x.<span class=\"hljs-property\">a</span>.<span class=\"hljs-property\">b</span> <span class=\"hljs-comment\">// 2 (浅拷贝无疑了)</span><br></code></pre></td></tr></table></figure>\n<p>另外解构赋值不会拷贝继承自原型对象的属性。下面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>\n<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">baseFunction</span> (&#123;a, b&#125;) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">wrapperFunction</span> (&#123;x, y, ...restConfig&#125;) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">baseFunction</span>(restConfig);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> z = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">4</span> &#125;;<br><span class=\"hljs-keyword\">let</span> n = &#123; ...z &#125;;<br>n <span class=\"hljs-comment\">// &#123; a: 3, b: 4 &#125;</span><br></code></pre></td></tr></table></figure>\n<p>还可以用于合并两个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> ab = &#123; ...a, ...b &#125;;<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">let</span> ab = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, a, b);<br></code></pre></td></tr></table></figure>\n<h2 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors()\"></a><code>Object.getOwnPropertyDescriptors()</code></h2><p>前面提到了：这个方法是用来返回某个对象属性的描述对象的。ES7有个提案：返回指定对象所有自身属性（非继承性——的描述对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">123</span>,<br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">bar</span>() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span> &#125;<br>&#125;;<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescription</span>(obj)<br><br><span class=\"hljs-comment\">// 返回结果如下</span><br>&#123;<br>  <span class=\"hljs-attr\">foo</span>: &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">123</span>, <span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span> &#125;,<br>  <span class=\"hljs-attr\">bar</span>: &#123;<br>    <span class=\"hljs-attr\">get</span>: [<span class=\"hljs-title class_\">Function</span>: get bar],<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-literal\">undefined</span>,<br>    <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>该方法实现的目的：主要是为了解决<code>Object.assing()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。结合<code>Object.defineProperties</code>方法就可以实现正确拷贝。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> source = &#123;<br>    set foo (value) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> target2 = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperties</span>(target2, <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(source));<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target2, <span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><br><span class=\"hljs-comment\">// 返回结果</span><br>&#123;                           <br>  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-literal\">undefined</span>,           <br>  <span class=\"hljs-attr\">set</span>: [<span class=\"hljs-title class_\">Function</span>: set foo], <br>  <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,         <br>  <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span>        <br>&#125;                           <br></code></pre></td></tr></table></figure>\n<p>将上面两部分代码合并起来，就是这样。是不是突然觉得眼熟悉？（就是React Thunk的使用方法）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shallowMerge</span> = (<span class=\"hljs-params\">target, source</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperties</span>(<br>\ttarget,<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(source)<br>);<br><br><span class=\"hljs-comment\">// 浅拷贝对象</span><br><span class=\"hljs-keyword\">const</span> clone = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),<br>                           <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shallowClone</span> = (<span class=\"hljs-params\">obj</span>) =&gt; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<br>\t<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj),<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj)<br>);<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 编码风格","date":"2022-02-17T14:21:12.000Z","updated":"2022-02-17T14:21:12.000Z","_content":"\n# 编程风格\n\n## 块级作用域\n\n### （1）使用`let`来替代`var`\n\n原因之前讲过，`let`是ES6新增的关键字，和`var`一样可以用来声明变量，主要推荐用`let`的原因是：\n\n- `let`和`var`完全等价，主要是`let`必须先声明再使用；\n- `let`不存在变量提升；因此不会给程序带来副作用；\n\n\n\n### （2）全局常量和线程安全\n\n`let`和`const`主要先使用`const`，理由如下：\n\n- `const`可以提醒阅读代码的人，这个变量不应该被改变；\n- `const`符合函数式编程思想，运算不改变值，只是新建值；\n- JavaScript编译器会对`const`进行优化，这样有利于提供程序的运行效率；\n\n\n\n### （3）字符串\n\n静态字符串一律使用单引号或引号，不使用双引号。动态字符串使用反引号；\n\n```javascript\n// bad\nconst a = \"foobar\";\nconst b = 'foo' + a + 'bar';\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = 'foobar';\nconst b = `foo${a}bar`;\n```\n\n\n\n### （4）解构赋值\n\n遵循下列几个原则：\n\n- 使用数组成员对变量赋值时，优先使用解构赋值；\n- 函数的参数如果是对象成员，优先使用解构赋值；\n- 函数返回多个值，优先使用对象的结构赋值，而不是数组的解构赋值；这样便于以后添加返回值，以及更改返回值的顺序；\n\n例子如下：\n\n```javascript\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr; // 这样它会拿出arr的第一个和第二个值\n```\n\n```javascript\n// bad\nfunction getFullName(user) {\n    const firstName = user.firstName;\n    const secondName = user.secondName;\n}\n\n// good\nfunction getFullName(obj) {\n    const {firstName, lastName} = obj;\n}\n\n// best\nfunction getFullName({firstName, lastName}) {\n    \n}\n```\n\n```javascript\n// bad\nfunction processInput(input) {\n    return [left, right, top, buttom];\n}\n\n// good\nfunction processInput(input) {\n    return {left, right, top, buttom};\n}\nconst {left, right} = processInput(input);\n```\n\n\n\n### （5）对象\n\n单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象；最后一个成员以逗号结尾；\n\n```javascript\n// bad\nconst a = { k1: v1, k2: v2, };\nconst b = {\n    k1: v1,\n    k2: v2\n};\n\n// good\nconst a = { k1: v1, k2: v2 };\nconst b = {\n    k1: v1,\n    k2: v2,\n};\n```\n\n对象尽量静态化，一旦定义就不得随意添加新的属性。如果添加属性不可避免，要使用`Object.assign()`方法；\n\n```javascript\n// bad\nconst a = {};\na.x = 3;\n\n// if reshape unavoidable\nconst a = {};\nObject.assign(a, {x: 3});\n\n// good\ncont a = { x: null };\na.x = 3;\n```\n\n如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义；\n\nPS: [需要计算的内容]：这个语法就叫做计算属性，方括号中的内容需要通过动态计算得到；\n\n```javascript\n// bad\nconst obj = {\n    id: 5,\n    name: 'San Francisco'\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n    id: 5,\n    name: 'San Francisco',\n    [getKey('enabled')]: true\n};\n```\n\n\n\n### （6）数组\n\n使用扩展运算符(...)拷贝数组：\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n    itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n使用`Array.from`方法将类似数组的对象转换为数组；\n\n```javascript\nconst foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n```\n\n\n\n### （7）函数\n\n立即执行函数可以写成箭头函数的形式\n\n```javascript\n(() => {\n    console.log('Welcome to the Internet.')\n})();\n```\n\n需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this\n\n```javascript\n// bad\n[1, 2, 3].map(function(x){\n    return x * x;\n});\n\n// good\n[1, 2, 3].map((x) => {\n    return x * x;\n});\n\n// best\n[1, 2, 3].map(x => x * x);\n```\n\n箭头函数取代`Function.prototype.bind`，不再用self/_this/that绑定this。\n\n```javascript\n// bad\nconst self = this;\nconst boundMethod = function(...params) {\n    return method.apply(self, params);\n}\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) => method.apply(this, params);\n```\n\n简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体比较复杂，行数较多，还是应该采用传统的函数写法。\n\n```javascript\n/* 用rest运算符代替arguments */\n// bad\nfunction concatenateAll() {\n    const args = Array.prototype.slice.call(arguments);\n    return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n    return args.join('');\n}\n\n/* 使用默认值语法设置函数参数的默认值 */\n// bad\nfunction handleThings(opts) {\n    opts = opts || {};\n}\n\n// good\nfunction handleThingd(opts = {}) {\n    // ...\n}\n```\n\n\n\n\n\n### （8）Map结构\n\n只有模拟现实世界的实体对象，才使用Object。如果只是想要`key: value`的数据结构，使用Map结构。因为Map有内建的遍历机制。\n\n```javascript\nlet map = new Map(arr);\n\nfor (let key of map.keys()) {\n    console.log(key);\n}\n\nfor (let value of map.values()) {\n    console.log(value);\n}\n\nfor (let item of map.entries()) {\n    console.log(item[0], item[1]);\n}\n```\n\n\n\n### （9）Class\n\n总是使用Class来替代`prototype`的操作，因为Class写法更简洁，更易于理解；这个就不需要过多解释了。\n\n```javascript\nclass Queue {\n    constructor(contents = []) {\n        this._queue = [...contents];\n    }\n    pop () {\n        const value = this._queue[0];\n        this._queue.splice(0, 1);\n        return value;\n    }\n}\n```\n\n使用`extends`实现继承，因为这样更简单，不会破坏`instanceof`运算的危险，而且如果你是后端程序员，会更加理解这段逻辑想要表达的实际含义。\n\n```javascript\nclass PeekableQueue extends Queue {\n    peek() {\n        return this._queue[0];\n    }\n}\n```\n\n\n\n### （10）模块\n\n首先，Module语法是JavaScript模块的标准写法。坚持使用这种写法。使用`import`取代`require`。\n\n```javascript\n// bad\nconst moduleA = require('moduleA');\nconst func1 = moduleA.func1;\nconst func2 = moduleA.func2;\n\n// good\nimport { func1, func2 } from 'moduleA';\n```\n\n使用`export`取代`module.exports`；\n\n```javascript\n// ES6 Style\nimport React from 'react';\n\nconst Breadcrumbs = React.createClass({\n    render() {\n        return <nav />;\n    }\n});\n\nexport default Breadcrumbs;\n```\n\n\n\n### （11）ESLint使用\n\nESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。所有配置项都写在`.eslintrc`文件中，因此要启用eslint只需要在配置文件中开启相应的规则就可以。如果你是用脚手架工具新建的项目，一般都会集成eslint。\n","source":"_posts/javascript/es6-program-style.md","raw":"---\ntitle: ES6 编码风格\ndate: 2022-02-17 22:21:12\nupdated: 2022-02-17 22:21:12\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 编程风格\n\n## 块级作用域\n\n### （1）使用`let`来替代`var`\n\n原因之前讲过，`let`是ES6新增的关键字，和`var`一样可以用来声明变量，主要推荐用`let`的原因是：\n\n- `let`和`var`完全等价，主要是`let`必须先声明再使用；\n- `let`不存在变量提升；因此不会给程序带来副作用；\n\n\n\n### （2）全局常量和线程安全\n\n`let`和`const`主要先使用`const`，理由如下：\n\n- `const`可以提醒阅读代码的人，这个变量不应该被改变；\n- `const`符合函数式编程思想，运算不改变值，只是新建值；\n- JavaScript编译器会对`const`进行优化，这样有利于提供程序的运行效率；\n\n\n\n### （3）字符串\n\n静态字符串一律使用单引号或引号，不使用双引号。动态字符串使用反引号；\n\n```javascript\n// bad\nconst a = \"foobar\";\nconst b = 'foo' + a + 'bar';\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = 'foobar';\nconst b = `foo${a}bar`;\n```\n\n\n\n### （4）解构赋值\n\n遵循下列几个原则：\n\n- 使用数组成员对变量赋值时，优先使用解构赋值；\n- 函数的参数如果是对象成员，优先使用解构赋值；\n- 函数返回多个值，优先使用对象的结构赋值，而不是数组的解构赋值；这样便于以后添加返回值，以及更改返回值的顺序；\n\n例子如下：\n\n```javascript\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr; // 这样它会拿出arr的第一个和第二个值\n```\n\n```javascript\n// bad\nfunction getFullName(user) {\n    const firstName = user.firstName;\n    const secondName = user.secondName;\n}\n\n// good\nfunction getFullName(obj) {\n    const {firstName, lastName} = obj;\n}\n\n// best\nfunction getFullName({firstName, lastName}) {\n    \n}\n```\n\n```javascript\n// bad\nfunction processInput(input) {\n    return [left, right, top, buttom];\n}\n\n// good\nfunction processInput(input) {\n    return {left, right, top, buttom};\n}\nconst {left, right} = processInput(input);\n```\n\n\n\n### （5）对象\n\n单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象；最后一个成员以逗号结尾；\n\n```javascript\n// bad\nconst a = { k1: v1, k2: v2, };\nconst b = {\n    k1: v1,\n    k2: v2\n};\n\n// good\nconst a = { k1: v1, k2: v2 };\nconst b = {\n    k1: v1,\n    k2: v2,\n};\n```\n\n对象尽量静态化，一旦定义就不得随意添加新的属性。如果添加属性不可避免，要使用`Object.assign()`方法；\n\n```javascript\n// bad\nconst a = {};\na.x = 3;\n\n// if reshape unavoidable\nconst a = {};\nObject.assign(a, {x: 3});\n\n// good\ncont a = { x: null };\na.x = 3;\n```\n\n如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义；\n\nPS: [需要计算的内容]：这个语法就叫做计算属性，方括号中的内容需要通过动态计算得到；\n\n```javascript\n// bad\nconst obj = {\n    id: 5,\n    name: 'San Francisco'\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n    id: 5,\n    name: 'San Francisco',\n    [getKey('enabled')]: true\n};\n```\n\n\n\n### （6）数组\n\n使用扩展运算符(...)拷贝数组：\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n    itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n使用`Array.from`方法将类似数组的对象转换为数组；\n\n```javascript\nconst foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n```\n\n\n\n### （7）函数\n\n立即执行函数可以写成箭头函数的形式\n\n```javascript\n(() => {\n    console.log('Welcome to the Internet.')\n})();\n```\n\n需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this\n\n```javascript\n// bad\n[1, 2, 3].map(function(x){\n    return x * x;\n});\n\n// good\n[1, 2, 3].map((x) => {\n    return x * x;\n});\n\n// best\n[1, 2, 3].map(x => x * x);\n```\n\n箭头函数取代`Function.prototype.bind`，不再用self/_this/that绑定this。\n\n```javascript\n// bad\nconst self = this;\nconst boundMethod = function(...params) {\n    return method.apply(self, params);\n}\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) => method.apply(this, params);\n```\n\n简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体比较复杂，行数较多，还是应该采用传统的函数写法。\n\n```javascript\n/* 用rest运算符代替arguments */\n// bad\nfunction concatenateAll() {\n    const args = Array.prototype.slice.call(arguments);\n    return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n    return args.join('');\n}\n\n/* 使用默认值语法设置函数参数的默认值 */\n// bad\nfunction handleThings(opts) {\n    opts = opts || {};\n}\n\n// good\nfunction handleThingd(opts = {}) {\n    // ...\n}\n```\n\n\n\n\n\n### （8）Map结构\n\n只有模拟现实世界的实体对象，才使用Object。如果只是想要`key: value`的数据结构，使用Map结构。因为Map有内建的遍历机制。\n\n```javascript\nlet map = new Map(arr);\n\nfor (let key of map.keys()) {\n    console.log(key);\n}\n\nfor (let value of map.values()) {\n    console.log(value);\n}\n\nfor (let item of map.entries()) {\n    console.log(item[0], item[1]);\n}\n```\n\n\n\n### （9）Class\n\n总是使用Class来替代`prototype`的操作，因为Class写法更简洁，更易于理解；这个就不需要过多解释了。\n\n```javascript\nclass Queue {\n    constructor(contents = []) {\n        this._queue = [...contents];\n    }\n    pop () {\n        const value = this._queue[0];\n        this._queue.splice(0, 1);\n        return value;\n    }\n}\n```\n\n使用`extends`实现继承，因为这样更简单，不会破坏`instanceof`运算的危险，而且如果你是后端程序员，会更加理解这段逻辑想要表达的实际含义。\n\n```javascript\nclass PeekableQueue extends Queue {\n    peek() {\n        return this._queue[0];\n    }\n}\n```\n\n\n\n### （10）模块\n\n首先，Module语法是JavaScript模块的标准写法。坚持使用这种写法。使用`import`取代`require`。\n\n```javascript\n// bad\nconst moduleA = require('moduleA');\nconst func1 = moduleA.func1;\nconst func2 = moduleA.func2;\n\n// good\nimport { func1, func2 } from 'moduleA';\n```\n\n使用`export`取代`module.exports`；\n\n```javascript\n// ES6 Style\nimport React from 'react';\n\nconst Breadcrumbs = React.createClass({\n    render() {\n        return <nav />;\n    }\n});\n\nexport default Breadcrumbs;\n```\n\n\n\n### （11）ESLint使用\n\nESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。所有配置项都写在`.eslintrc`文件中，因此要启用eslint只需要在配置文件中开启相应的规则就可以。如果你是用脚手架工具新建的项目，一般都会集成eslint。\n","slug":"javascript/es6-program-style","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl35001m2y6185hn3j9u","content":"<h1 id=\"编程风格\"><a href=\"#编程风格\" class=\"headerlink\" title=\"编程风格\"></a>编程风格</h1><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><h3 id=\"（1）使用let来替代var\"><a href=\"#（1）使用let来替代var\" class=\"headerlink\" title=\"（1）使用let来替代var\"></a>（1）使用<code>let</code>来替代<code>var</code></h3><p>原因之前讲过，<code>let</code>是ES6新增的关键字，和<code>var</code>一样可以用来声明变量，主要推荐用<code>let</code>的原因是：</p>\n<ul>\n<li><code>let</code>和<code>var</code>完全等价，主要是<code>let</code>必须先声明再使用；</li>\n<li><code>let</code>不存在变量提升；因此不会给程序带来副作用；</li>\n</ul>\n<h3 id=\"（2）全局常量和线程安全\"><a href=\"#（2）全局常量和线程安全\" class=\"headerlink\" title=\"（2）全局常量和线程安全\"></a>（2）全局常量和线程安全</h3><p><code>let</code>和<code>const</code>主要先使用<code>const</code>，理由如下：</p>\n<ul>\n<li><code>const</code>可以提醒阅读代码的人，这个变量不应该被改变；</li>\n<li><code>const</code>符合函数式编程思想，运算不改变值，只是新建值；</li>\n<li>JavaScript编译器会对<code>const</code>进行优化，这样有利于提供程序的运行效率；</li>\n</ul>\n<h3 id=\"（3）字符串\"><a href=\"#（3）字符串\" class=\"headerlink\" title=\"（3）字符串\"></a>（3）字符串</h3><p>静态字符串一律使用单引号或引号，不使用双引号。动态字符串使用反引号；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&quot;foobar&quot;</span>;<br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&#x27;foo&#x27;</span> + a + <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><br><span class=\"hljs-comment\">// acceptable</span><br><span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-string\">`foobar`</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&#x27;foobar&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">`foo<span class=\"hljs-subst\">$&#123;a&#125;</span>bar`</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）解构赋值\"><a href=\"#（4）解构赋值\" class=\"headerlink\" title=\"（4）解构赋值\"></a>（4）解构赋值</h3><p>遵循下列几个原则：</p>\n<ul>\n<li>使用数组成员对变量赋值时，优先使用解构赋值；</li>\n<li>函数的参数如果是对象成员，优先使用解构赋值；</li>\n<li>函数返回多个值，优先使用对象的结构赋值，而不是数组的解构赋值；这样便于以后添加返回值，以及更改返回值的顺序；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> first = arr[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">const</span> second = arr[<span class=\"hljs-number\">1</span>];<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> [first, second] = arr; <span class=\"hljs-comment\">// 这样它会拿出arr的第一个和第二个值</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">user</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> firstName = user.<span class=\"hljs-property\">firstName</span>;<br>    <span class=\"hljs-keyword\">const</span> secondName = user.<span class=\"hljs-property\">secondName</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123;firstName, lastName&#125; = obj;<br>&#125;<br><br><span class=\"hljs-comment\">// best</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">&#123;firstName, lastName&#125;</span>) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processInput</span>(<span class=\"hljs-params\">input</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [left, right, top, buttom];<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processInput</span>(<span class=\"hljs-params\">input</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;left, right, top, buttom&#125;;<br>&#125;<br><span class=\"hljs-keyword\">const</span> &#123;left, right&#125; = <span class=\"hljs-title function_\">processInput</span>(input);<br></code></pre></td></tr></table></figure>\n<h3 id=\"（5）对象\"><a href=\"#（5）对象\" class=\"headerlink\" title=\"（5）对象\"></a>（5）对象</h3><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象；最后一个成员以逗号结尾；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = &#123; <span class=\"hljs-attr\">k1</span>: v1, <span class=\"hljs-attr\">k2</span>: v2, &#125;;<br><span class=\"hljs-keyword\">const</span> b = &#123;<br>    <span class=\"hljs-attr\">k1</span>: v1,<br>    <span class=\"hljs-attr\">k2</span>: v2<br>&#125;;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> a = &#123; <span class=\"hljs-attr\">k1</span>: v1, <span class=\"hljs-attr\">k2</span>: v2 &#125;;<br><span class=\"hljs-keyword\">const</span> b = &#123;<br>    <span class=\"hljs-attr\">k1</span>: v1,<br>    <span class=\"hljs-attr\">k2</span>: v2,<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>对象尽量静态化，一旦定义就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign()</code>方法；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br>a.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-comment\">// if reshape unavoidable</span><br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;);<br><br><span class=\"hljs-comment\">// good</span><br>cont a = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-literal\">null</span> &#125;;<br>a.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义；</p>\n<p>PS: [需要计算的内容]：这个语法就叫做计算属性，方括号中的内容需要通过动态计算得到；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">5</span>,<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;San Francisco&#x27;</span><br>&#125;;<br>obj[<span class=\"hljs-title function_\">getKey</span>(<span class=\"hljs-string\">&#x27;enabled&#x27;</span>)] = <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">5</span>,<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;San Francisco&#x27;</span>,<br>    [<span class=\"hljs-title function_\">getKey</span>(<span class=\"hljs-string\">&#x27;enabled&#x27;</span>)]: <span class=\"hljs-literal\">true</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（6）数组\"><a href=\"#（6）数组\" class=\"headerlink\" title=\"（6）数组\"></a>（6）数组</h3><p>使用扩展运算符(…)拷贝数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> len = items.<span class=\"hljs-property\">length</span>;<br><span class=\"hljs-keyword\">const</span> itemsCopy = [];<br><span class=\"hljs-keyword\">let</span> i;<br><br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++) &#123;<br>    itemsCopy[i] = items[i];<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> itemsCopy = [...items];<br></code></pre></td></tr></table></figure>\n<p>使用<code>Array.from</code>方法将类似数组的对象转换为数组；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;.foo&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> nodes = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(foo);<br></code></pre></td></tr></table></figure>\n<h3 id=\"（7）函数\"><a href=\"#（7）函数\" class=\"headerlink\" title=\"（7）函数\"></a>（7）函数</h3><p>立即执行函数可以写成箭头函数的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Welcome to the Internet.&#x27;</span>)<br>&#125;)();<br></code></pre></td></tr></table></figure>\n<p>需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;);<br><br><span class=\"hljs-comment\">// good</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;);<br><br><span class=\"hljs-comment\">// best</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * x);<br></code></pre></td></tr></table></figure>\n<p>箭头函数取代<code>Function.prototype.bind</code>，不再用self/_this/that绑定this。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-variable language_\">this</span>;<br><span class=\"hljs-keyword\">const</span> boundMethod = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...params</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> method.<span class=\"hljs-title function_\">apply</span>(self, params);<br>&#125;<br><br><span class=\"hljs-comment\">// acceptable</span><br><span class=\"hljs-keyword\">const</span> boundMethod = method.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-comment\">// best</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">boundMethod</span> = (<span class=\"hljs-params\">...params</span>) =&gt; method.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, params);<br></code></pre></td></tr></table></figure>\n<p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体比较复杂，行数较多，还是应该采用传统的函数写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* 用rest运算符代替arguments */</span><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concatenateAll</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>    <span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concatenateAll</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">/* 使用默认值语法设置函数参数的默认值 */</span><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleThings</span>(<span class=\"hljs-params\">opts</span>) &#123;<br>    opts = opts || &#123;&#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleThingd</span>(<span class=\"hljs-params\">opts = &#123;&#125;</span>) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（8）Map结构\"><a href=\"#（8）Map结构\" class=\"headerlink\" title=\"（8）Map结构\"></a>（8）Map结构</h3><p>只有模拟现实世界的实体对象，才使用Object。如果只是想要<code>key: value</code>的数据结构，使用Map结构。因为Map有内建的遍历机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item[<span class=\"hljs-number\">0</span>], item[<span class=\"hljs-number\">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（9）Class\"><a href=\"#（9）Class\" class=\"headerlink\" title=\"（9）Class\"></a>（9）Class</h3><p>总是使用Class来替代<code>prototype</code>的操作，因为Class写法更简洁，更易于理解；这个就不需要过多解释了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">contents = []</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span> = [...contents];<br>    &#125;<br>    pop () &#123;<br>        <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用<code>extends</code>实现继承，因为这样更简单，不会破坏<code>instanceof</code>运算的危险，而且如果你是后端程序员，会更加理解这段逻辑想要表达的实际含义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PeekableQueue</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Queue</span> &#123;<br>    <span class=\"hljs-title function_\">peek</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>[<span class=\"hljs-number\">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（10）模块\"><a href=\"#（10）模块\" class=\"headerlink\" title=\"（10）模块\"></a>（10）模块</h3><p>首先，Module语法是JavaScript模块的标准写法。坚持使用这种写法。使用<code>import</code>取代<code>require</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> moduleA = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;moduleA&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> func1 = moduleA.<span class=\"hljs-property\">func1</span>;<br><span class=\"hljs-keyword\">const</span> func2 = moduleA.<span class=\"hljs-property\">func2</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">import</span> &#123; func1, func2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;moduleA&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>使用<code>export</code>取代<code>module.exports</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6 Style</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Breadcrumbs</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createClass</span>(&#123;<br>    <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> /&gt;</span></span>;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Breadcrumbs</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（11）ESLint使用\"><a href=\"#（11）ESLint使用\" class=\"headerlink\" title=\"（11）ESLint使用\"></a>（11）ESLint使用</h3><p>ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。所有配置项都写在<code>.eslintrc</code>文件中，因此要启用eslint只需要在配置文件中开启相应的规则就可以。如果你是用脚手架工具新建的项目，一般都会集成eslint。</p>\n","site":{"data":{}},"wordcount":4445,"excerpt":"","more":"<h1 id=\"编程风格\"><a href=\"#编程风格\" class=\"headerlink\" title=\"编程风格\"></a>编程风格</h1><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><h3 id=\"（1）使用let来替代var\"><a href=\"#（1）使用let来替代var\" class=\"headerlink\" title=\"（1）使用let来替代var\"></a>（1）使用<code>let</code>来替代<code>var</code></h3><p>原因之前讲过，<code>let</code>是ES6新增的关键字，和<code>var</code>一样可以用来声明变量，主要推荐用<code>let</code>的原因是：</p>\n<ul>\n<li><code>let</code>和<code>var</code>完全等价，主要是<code>let</code>必须先声明再使用；</li>\n<li><code>let</code>不存在变量提升；因此不会给程序带来副作用；</li>\n</ul>\n<h3 id=\"（2）全局常量和线程安全\"><a href=\"#（2）全局常量和线程安全\" class=\"headerlink\" title=\"（2）全局常量和线程安全\"></a>（2）全局常量和线程安全</h3><p><code>let</code>和<code>const</code>主要先使用<code>const</code>，理由如下：</p>\n<ul>\n<li><code>const</code>可以提醒阅读代码的人，这个变量不应该被改变；</li>\n<li><code>const</code>符合函数式编程思想，运算不改变值，只是新建值；</li>\n<li>JavaScript编译器会对<code>const</code>进行优化，这样有利于提供程序的运行效率；</li>\n</ul>\n<h3 id=\"（3）字符串\"><a href=\"#（3）字符串\" class=\"headerlink\" title=\"（3）字符串\"></a>（3）字符串</h3><p>静态字符串一律使用单引号或引号，不使用双引号。动态字符串使用反引号；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&quot;foobar&quot;</span>;<br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&#x27;foo&#x27;</span> + a + <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br><br><span class=\"hljs-comment\">// acceptable</span><br><span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-string\">`foobar`</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&#x27;foobar&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">`foo<span class=\"hljs-subst\">$&#123;a&#125;</span>bar`</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（4）解构赋值\"><a href=\"#（4）解构赋值\" class=\"headerlink\" title=\"（4）解构赋值\"></a>（4）解构赋值</h3><p>遵循下列几个原则：</p>\n<ul>\n<li>使用数组成员对变量赋值时，优先使用解构赋值；</li>\n<li>函数的参数如果是对象成员，优先使用解构赋值；</li>\n<li>函数返回多个值，优先使用对象的结构赋值，而不是数组的解构赋值；这样便于以后添加返回值，以及更改返回值的顺序；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> first = arr[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">const</span> second = arr[<span class=\"hljs-number\">1</span>];<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> [first, second] = arr; <span class=\"hljs-comment\">// 这样它会拿出arr的第一个和第二个值</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">user</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> firstName = user.<span class=\"hljs-property\">firstName</span>;<br>    <span class=\"hljs-keyword\">const</span> secondName = user.<span class=\"hljs-property\">secondName</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123;firstName, lastName&#125; = obj;<br>&#125;<br><br><span class=\"hljs-comment\">// best</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFullName</span>(<span class=\"hljs-params\">&#123;firstName, lastName&#125;</span>) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processInput</span>(<span class=\"hljs-params\">input</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> [left, right, top, buttom];<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">processInput</span>(<span class=\"hljs-params\">input</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;left, right, top, buttom&#125;;<br>&#125;<br><span class=\"hljs-keyword\">const</span> &#123;left, right&#125; = <span class=\"hljs-title function_\">processInput</span>(input);<br></code></pre></td></tr></table></figure>\n<h3 id=\"（5）对象\"><a href=\"#（5）对象\" class=\"headerlink\" title=\"（5）对象\"></a>（5）对象</h3><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象；最后一个成员以逗号结尾；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = &#123; <span class=\"hljs-attr\">k1</span>: v1, <span class=\"hljs-attr\">k2</span>: v2, &#125;;<br><span class=\"hljs-keyword\">const</span> b = &#123;<br>    <span class=\"hljs-attr\">k1</span>: v1,<br>    <span class=\"hljs-attr\">k2</span>: v2<br>&#125;;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> a = &#123; <span class=\"hljs-attr\">k1</span>: v1, <span class=\"hljs-attr\">k2</span>: v2 &#125;;<br><span class=\"hljs-keyword\">const</span> b = &#123;<br>    <span class=\"hljs-attr\">k1</span>: v1,<br>    <span class=\"hljs-attr\">k2</span>: v2,<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>对象尽量静态化，一旦定义就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign()</code>方法；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br>a.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-comment\">// if reshape unavoidable</span><br><span class=\"hljs-keyword\">const</span> a = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(a, &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;);<br><br><span class=\"hljs-comment\">// good</span><br>cont a = &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-literal\">null</span> &#125;;<br>a.<span class=\"hljs-property\">x</span> = <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义；</p>\n<p>PS: [需要计算的内容]：这个语法就叫做计算属性，方括号中的内容需要通过动态计算得到；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">5</span>,<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;San Francisco&#x27;</span><br>&#125;;<br>obj[<span class=\"hljs-title function_\">getKey</span>(<span class=\"hljs-string\">&#x27;enabled&#x27;</span>)] = <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">5</span>,<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;San Francisco&#x27;</span>,<br>    [<span class=\"hljs-title function_\">getKey</span>(<span class=\"hljs-string\">&#x27;enabled&#x27;</span>)]: <span class=\"hljs-literal\">true</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（6）数组\"><a href=\"#（6）数组\" class=\"headerlink\" title=\"（6）数组\"></a>（6）数组</h3><p>使用扩展运算符(…)拷贝数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> len = items.<span class=\"hljs-property\">length</span>;<br><span class=\"hljs-keyword\">const</span> itemsCopy = [];<br><span class=\"hljs-keyword\">let</span> i;<br><br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++) &#123;<br>    itemsCopy[i] = items[i];<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">const</span> itemsCopy = [...items];<br></code></pre></td></tr></table></figure>\n<p>使用<code>Array.from</code>方法将类似数组的对象转换为数组；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;.foo&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> nodes = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(foo);<br></code></pre></td></tr></table></figure>\n<h3 id=\"（7）函数\"><a href=\"#（7）函数\" class=\"headerlink\" title=\"（7）函数\"></a>（7）函数</h3><p>立即执行函数可以写成箭头函数的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Welcome to the Internet.&#x27;</span>)<br>&#125;)();<br></code></pre></td></tr></table></figure>\n<p>需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;);<br><br><span class=\"hljs-comment\">// good</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;);<br><br><span class=\"hljs-comment\">// best</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * x);<br></code></pre></td></tr></table></figure>\n<p>箭头函数取代<code>Function.prototype.bind</code>，不再用self/_this/that绑定this。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-variable language_\">this</span>;<br><span class=\"hljs-keyword\">const</span> boundMethod = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...params</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> method.<span class=\"hljs-title function_\">apply</span>(self, params);<br>&#125;<br><br><span class=\"hljs-comment\">// acceptable</span><br><span class=\"hljs-keyword\">const</span> boundMethod = method.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-comment\">// best</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">boundMethod</span> = (<span class=\"hljs-params\">...params</span>) =&gt; method.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, params);<br></code></pre></td></tr></table></figure>\n<p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体比较复杂，行数较多，还是应该采用传统的函数写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* 用rest运算符代替arguments */</span><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concatenateAll</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> args = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>    <span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">concatenateAll</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">/* 使用默认值语法设置函数参数的默认值 */</span><br><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleThings</span>(<span class=\"hljs-params\">opts</span>) &#123;<br>    opts = opts || &#123;&#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleThingd</span>(<span class=\"hljs-params\">opts = &#123;&#125;</span>) &#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（8）Map结构\"><a href=\"#（8）Map结构\" class=\"headerlink\" title=\"（8）Map结构\"></a>（8）Map结构</h3><p>只有模拟现实世界的实体对象，才使用Object。如果只是想要<code>key: value</code>的数据结构，使用Map结构。因为Map有内建的遍历机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item[<span class=\"hljs-number\">0</span>], item[<span class=\"hljs-number\">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（9）Class\"><a href=\"#（9）Class\" class=\"headerlink\" title=\"（9）Class\"></a>（9）Class</h3><p>总是使用Class来替代<code>prototype</code>的操作，因为Class写法更简洁，更易于理解；这个就不需要过多解释了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">contents = []</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span> = [...contents];<br>    &#125;<br>    pop () &#123;<br>        <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用<code>extends</code>实现继承，因为这样更简单，不会破坏<code>instanceof</code>运算的危险，而且如果你是后端程序员，会更加理解这段逻辑想要表达的实际含义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PeekableQueue</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Queue</span> &#123;<br>    <span class=\"hljs-title function_\">peek</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_queue</span>[<span class=\"hljs-number\">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（10）模块\"><a href=\"#（10）模块\" class=\"headerlink\" title=\"（10）模块\"></a>（10）模块</h3><p>首先，Module语法是JavaScript模块的标准写法。坚持使用这种写法。使用<code>import</code>取代<code>require</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bad</span><br><span class=\"hljs-keyword\">const</span> moduleA = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;moduleA&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> func1 = moduleA.<span class=\"hljs-property\">func1</span>;<br><span class=\"hljs-keyword\">const</span> func2 = moduleA.<span class=\"hljs-property\">func2</span>;<br><br><span class=\"hljs-comment\">// good</span><br><span class=\"hljs-keyword\">import</span> &#123; func1, func2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;moduleA&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>使用<code>export</code>取代<code>module.exports</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6 Style</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Breadcrumbs</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createClass</span>(&#123;<br>    <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> /&gt;</span></span>;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Breadcrumbs</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"（11）ESLint使用\"><a href=\"#（11）ESLint使用\" class=\"headerlink\" title=\"（11）ESLint使用\"></a>（11）ESLint使用</h3><p>ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。所有配置项都写在<code>.eslintrc</code>文件中，因此要启用eslint只需要在配置文件中开启相应的规则就可以。如果你是用脚手架工具新建的项目，一般都会集成eslint。</p>\n"},{"title":"ES6 Promise对象","date":"2022-02-17T14:20:53.000Z","updated":"2022-02-17T14:20:53.000Z","_content":"\n# Promise对象\n\n## 含义\n\nPromise是异步编程的一种解决方案，最早由社区提出和实现，ES6在次基础上统一了用法并且提供了Promise对象。\n\n所谓的Promise简单来说就是一个容器：里面保存着某个未来才会结束的事件的结果。从语法上说：Promise是一个对象，从它可以获取异步操作的消息。\n\nPromise对象由两个特点：\n\n- 对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这种状态；\n- 一旦状态发生了改变，就不会再变，任何时候都可以得到这个结果。\n\n因此：有了Promise，就可以将异步操作以同步的流程表达出来，避免了蹭蹭嵌套的回调函数。此外，Promise还提供了统一的接口，使得控制异步操作更加容易。\n\n但是Promise也存在缺点：例如一旦创建就会立即执行，无法中途取消，其次，如果不设置回调函数，Promise内部会抛出异常，不会反应到外部。最后，当处于Pending状态的时候，无法得知目前进展到哪一个阶段。\n\n## 基本用法\n\nES6规定，Promise对象是一个构造函数，用来生成Promise实例。\n\n```javascript\nvar promise = new Promise(function(resolve, reject){\n    if (a) {\n        resolve(value); // Pending -> Resolved\n    } else {\n        reject(error); // Pending -> Rejected\n    }\n});\n\npromise.then(function(value){\n    // success\n}, function(error){\n   // failure \n});\n```\n\nPromise新建后会立即执行\n\n```javascript\nlet promise = new Promise(function(resolve, reject){\n    console.log('Promise');\n    resolve();\n});\n\npromise.then(function() {\n    console.log('Resolved.')\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\n## Promise.prototype.then()\n\n`then`方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。该方法返回的是一个新的Promise实例。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\n\n```javascript\ngetJSON(\"/posts.json\").then(function(json){\n    return json.post;\n}).then(function(post){\n    // ...\n});\n```\n\n如果使用箭头函数，可以将上面代码进一步简化。\n\n```javascript\ngetJSON(\"/post/1.json\").then(\n\tpost => getJSON(post.commentURL)\n).then(\n\tcomments => console.log(\"Resolved: \" + comments),\n    err => console.log(\"Rejected: \", err)\n);\n```\n\n## Promise.prototype.catch()\n\n用于指定发生错误时的回调函数。\n\n```javascript\ngetJSON(\"/post.json\").then(function(posts){\n    // ...\n}).catch(function(error){\n    console.log('Error ', error);\n});\n```\n\n如果Promise状态已经变成了Resolved，再抛出错误就是无效的。\n\n```javascript\nvar promise = new Promise(function (resolve, reject){\n    resolve('ok');\n    throw new Error('test');\n});\n\npromise\n\t.then(function(value) {console.log(value)})\n\t.catch(function(value) {console.log(error)});\n// ok\n```\n\nPromise对象错误具有”冒泡“性质，会一直向后传递，直到被捕获为止。也就是说：错误总会被下一个`catch`语句捕获。\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post){\n    return getJSON(post.commentURL);\n}).then(function(comments){\n    // some code\n}).catch(function(error){\n    // error handler\n});\n```\n\n与传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码。但是Chrome不遵守这个规则，还是会抛出异常。好在Node.js提供了一个`unhandledRejection`事件，专门监听未捕获的`reject`错误。\n\n```javascript\nprocess.on('unhandledRejection', function(err, p){\n    console.error(err.stack);\n});\n\nvar someAsyncThing = function() {\n    return new Promise(function(resolve, reject){\n        resolve(x + 2);\n    });\n};\n\nsomeAsyncThing().then(function() {\n    console.log('everything is great');\n});\n```\n\n`catch`方法中还可以继续抛出异常。例如下面的代码：第二个`catch`方法用来捕获，前一个`catch`方法抛出错误。\n\n```javascript\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [ReferenceError: x is not defined]\n// carry on [ReferenceError: y is not defined]\n```\n\n## Promise.all()\n\n`Promise.all`方法用于将多个Promise实例，包装成一个新的Promise实例。语法如下：\n\n```javascript\nvar p = Promise.all([p1, p2, p3]);\n```\n\n例子如下：只有这6个实例的状态都变成了`fulfilled`，或者其中有一个状态变成了`rejected`，才会调用`Promise.all`方法后面的回调函数。\n\n```javascript\nvar promises = [2, 3, 5, 7, 11, 13].map(function (id){\n    return getJSON(\"/post/\" + id + \".json\");\n});\n\nPromise.all(promises).then(function (post){\n    // ...\n}).catch(function(reason){\n    // ...\n});\n```\n\n再例如下面这个例子：只有`booksPromise`和`userPromise`的结果都返回了，才会触发`pickTopRecommentations`这个回调函数。\n\n```javascript\nconst databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise.then(findAllBooks);\n\nconst userPromise = databasrPromise.then(getCurrentUser);\n\nPromise.all([\n    booksPromise,\n    userPromise\n]).then([books, user] => pickTopRecommentations(books, user));\n```\n\n## Promise.race()\n\n跟上面的作用一样，将多个Promise实例合成一个新的Promise实例。\n\n```\nvar p = Promise.race([p1, p2, p3]);\n```\n\n上面的例子中：只要三个状态有其中一个率先改变，新对象的状态就跟着一起改变。率先改变的Promise实例的返回值就是新Promise实例的回调函数的输入。\n\n下面提供一个实例：如果指定时间内没有获得结果，就将Promise的状态变为`reject`，否则就为`resolve`\n\n```javascript\nvar p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n])\np.then(response => console.log(response))\np.catch(error => console.log(error))\n```\n\n## Promise.resolve()\n\n有时需要将现有对象转为Promise对象，Promise.resolve()方法就起这个作用。\n\n```javascript\nPromise.resolve('foo')\n// equal to\nnew Promisr(resolve => resolve('foo'));\n```\n\n`Promise.resolve`方法的参数可以分为4种情况。\n\n- 参数是一个Promise实例：不做任何修改，原封不动返回实例\n- 参数是一个thenable对象：将该对象转换为Promise对象，然后立即执行`thenable`对象的`then`方法；\n- 参数不是具有then方法的对象，或根本就不是对象：返回一个新的`Promise`对象，状态为`Resolved`；\n- 不带有任何参数：直接返回一个状态为`Resolved`的Promise对象；\n\n## Promise.reject()\n\n也会返回一个新的Promise实例，该实例的状态为`rejected`。其参数用法和`Promise.resolve()`方法完全一致；\n\n## 两个有用的附加方法\n\n### done()\n\n提供一个`done`方法，总是处于回调链的尾端，保证抛出任何可能出现的错误\n\n### finally()\n\n用于指定不管Promise对象最后状态如何，都会执行的操作。与`Done`方法最大的区别，接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\n\n## 应用\n\n### 加载图片\n\n我们可以将图片加载写成一个Promise，一旦加载完成，`Promise`的状态就发生变化；\n\n### Generator函数结合Promise\n\n使用Generator函数管理函数流程，遇到异步操作的时候，通常返回一个`Promise`对象；\n\n### Promise.try()\n\n实际开发中还遇到一种情况：不知道或者不想区分函数f是同步还是异步，但还是想用Promise来处理。\n\n实际开发中提供了两种写法来实现这种效果：\n\n```javascript\n// async 写法\nconst f = () => console.log('now');\n(async () => f())();\nconsole.log('next');\n\n// Promise写法\nconst f = () => console.log('now');\n{\n    () => new Promise(\n    \tresolve => resolve(f())\n    )\n}();\nconsole.log('next');\n```\n\n需要注意的是`async () => f()`会吃掉`f()`抛出的异常，因此需要使用`promise.catch`方法来捕获异常；\n","source":"_posts/javascript/es6-promise.md","raw":"---\ntitle: ES6 Promise对象\ndate: 2022-02-17 22:20:53\nupdated: 2022-02-17 22:20:53\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Promise对象\n\n## 含义\n\nPromise是异步编程的一种解决方案，最早由社区提出和实现，ES6在次基础上统一了用法并且提供了Promise对象。\n\n所谓的Promise简单来说就是一个容器：里面保存着某个未来才会结束的事件的结果。从语法上说：Promise是一个对象，从它可以获取异步操作的消息。\n\nPromise对象由两个特点：\n\n- 对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这种状态；\n- 一旦状态发生了改变，就不会再变，任何时候都可以得到这个结果。\n\n因此：有了Promise，就可以将异步操作以同步的流程表达出来，避免了蹭蹭嵌套的回调函数。此外，Promise还提供了统一的接口，使得控制异步操作更加容易。\n\n但是Promise也存在缺点：例如一旦创建就会立即执行，无法中途取消，其次，如果不设置回调函数，Promise内部会抛出异常，不会反应到外部。最后，当处于Pending状态的时候，无法得知目前进展到哪一个阶段。\n\n## 基本用法\n\nES6规定，Promise对象是一个构造函数，用来生成Promise实例。\n\n```javascript\nvar promise = new Promise(function(resolve, reject){\n    if (a) {\n        resolve(value); // Pending -> Resolved\n    } else {\n        reject(error); // Pending -> Rejected\n    }\n});\n\npromise.then(function(value){\n    // success\n}, function(error){\n   // failure \n});\n```\n\nPromise新建后会立即执行\n\n```javascript\nlet promise = new Promise(function(resolve, reject){\n    console.log('Promise');\n    resolve();\n});\n\npromise.then(function() {\n    console.log('Resolved.')\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\n## Promise.prototype.then()\n\n`then`方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。该方法返回的是一个新的Promise实例。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\n\n```javascript\ngetJSON(\"/posts.json\").then(function(json){\n    return json.post;\n}).then(function(post){\n    // ...\n});\n```\n\n如果使用箭头函数，可以将上面代码进一步简化。\n\n```javascript\ngetJSON(\"/post/1.json\").then(\n\tpost => getJSON(post.commentURL)\n).then(\n\tcomments => console.log(\"Resolved: \" + comments),\n    err => console.log(\"Rejected: \", err)\n);\n```\n\n## Promise.prototype.catch()\n\n用于指定发生错误时的回调函数。\n\n```javascript\ngetJSON(\"/post.json\").then(function(posts){\n    // ...\n}).catch(function(error){\n    console.log('Error ', error);\n});\n```\n\n如果Promise状态已经变成了Resolved，再抛出错误就是无效的。\n\n```javascript\nvar promise = new Promise(function (resolve, reject){\n    resolve('ok');\n    throw new Error('test');\n});\n\npromise\n\t.then(function(value) {console.log(value)})\n\t.catch(function(value) {console.log(error)});\n// ok\n```\n\nPromise对象错误具有”冒泡“性质，会一直向后传递，直到被捕获为止。也就是说：错误总会被下一个`catch`语句捕获。\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post){\n    return getJSON(post.commentURL);\n}).then(function(comments){\n    // some code\n}).catch(function(error){\n    // error handler\n});\n```\n\n与传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码。但是Chrome不遵守这个规则，还是会抛出异常。好在Node.js提供了一个`unhandledRejection`事件，专门监听未捕获的`reject`错误。\n\n```javascript\nprocess.on('unhandledRejection', function(err, p){\n    console.error(err.stack);\n});\n\nvar someAsyncThing = function() {\n    return new Promise(function(resolve, reject){\n        resolve(x + 2);\n    });\n};\n\nsomeAsyncThing().then(function() {\n    console.log('everything is great');\n});\n```\n\n`catch`方法中还可以继续抛出异常。例如下面的代码：第二个`catch`方法用来捕获，前一个`catch`方法抛出错误。\n\n```javascript\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [ReferenceError: x is not defined]\n// carry on [ReferenceError: y is not defined]\n```\n\n## Promise.all()\n\n`Promise.all`方法用于将多个Promise实例，包装成一个新的Promise实例。语法如下：\n\n```javascript\nvar p = Promise.all([p1, p2, p3]);\n```\n\n例子如下：只有这6个实例的状态都变成了`fulfilled`，或者其中有一个状态变成了`rejected`，才会调用`Promise.all`方法后面的回调函数。\n\n```javascript\nvar promises = [2, 3, 5, 7, 11, 13].map(function (id){\n    return getJSON(\"/post/\" + id + \".json\");\n});\n\nPromise.all(promises).then(function (post){\n    // ...\n}).catch(function(reason){\n    // ...\n});\n```\n\n再例如下面这个例子：只有`booksPromise`和`userPromise`的结果都返回了，才会触发`pickTopRecommentations`这个回调函数。\n\n```javascript\nconst databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise.then(findAllBooks);\n\nconst userPromise = databasrPromise.then(getCurrentUser);\n\nPromise.all([\n    booksPromise,\n    userPromise\n]).then([books, user] => pickTopRecommentations(books, user));\n```\n\n## Promise.race()\n\n跟上面的作用一样，将多个Promise实例合成一个新的Promise实例。\n\n```\nvar p = Promise.race([p1, p2, p3]);\n```\n\n上面的例子中：只要三个状态有其中一个率先改变，新对象的状态就跟着一起改变。率先改变的Promise实例的返回值就是新Promise实例的回调函数的输入。\n\n下面提供一个实例：如果指定时间内没有获得结果，就将Promise的状态变为`reject`，否则就为`resolve`\n\n```javascript\nvar p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n])\np.then(response => console.log(response))\np.catch(error => console.log(error))\n```\n\n## Promise.resolve()\n\n有时需要将现有对象转为Promise对象，Promise.resolve()方法就起这个作用。\n\n```javascript\nPromise.resolve('foo')\n// equal to\nnew Promisr(resolve => resolve('foo'));\n```\n\n`Promise.resolve`方法的参数可以分为4种情况。\n\n- 参数是一个Promise实例：不做任何修改，原封不动返回实例\n- 参数是一个thenable对象：将该对象转换为Promise对象，然后立即执行`thenable`对象的`then`方法；\n- 参数不是具有then方法的对象，或根本就不是对象：返回一个新的`Promise`对象，状态为`Resolved`；\n- 不带有任何参数：直接返回一个状态为`Resolved`的Promise对象；\n\n## Promise.reject()\n\n也会返回一个新的Promise实例，该实例的状态为`rejected`。其参数用法和`Promise.resolve()`方法完全一致；\n\n## 两个有用的附加方法\n\n### done()\n\n提供一个`done`方法，总是处于回调链的尾端，保证抛出任何可能出现的错误\n\n### finally()\n\n用于指定不管Promise对象最后状态如何，都会执行的操作。与`Done`方法最大的区别，接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\n\n## 应用\n\n### 加载图片\n\n我们可以将图片加载写成一个Promise，一旦加载完成，`Promise`的状态就发生变化；\n\n### Generator函数结合Promise\n\n使用Generator函数管理函数流程，遇到异步操作的时候，通常返回一个`Promise`对象；\n\n### Promise.try()\n\n实际开发中还遇到一种情况：不知道或者不想区分函数f是同步还是异步，但还是想用Promise来处理。\n\n实际开发中提供了两种写法来实现这种效果：\n\n```javascript\n// async 写法\nconst f = () => console.log('now');\n(async () => f())();\nconsole.log('next');\n\n// Promise写法\nconst f = () => console.log('now');\n{\n    () => new Promise(\n    \tresolve => resolve(f())\n    )\n}();\nconsole.log('next');\n```\n\n需要注意的是`async () => f()`会吃掉`f()`抛出的异常，因此需要使用`promise.catch`方法来捕获异常；\n","slug":"javascript/es6-promise","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl37001r2y61a3jdbrlg","content":"<h1 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h1><h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>Promise是异步编程的一种解决方案，最早由社区提出和实现，ES6在次基础上统一了用法并且提供了Promise对象。</p>\n<p>所谓的Promise简单来说就是一个容器：里面保存着某个未来才会结束的事件的结果。从语法上说：Promise是一个对象，从它可以获取异步操作的消息。</p>\n<p>Promise对象由两个特点：</p>\n<ul>\n<li>对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这种状态；</li>\n<li>一旦状态发生了改变，就不会再变，任何时候都可以得到这个结果。</li>\n</ul>\n<p>因此：有了Promise，就可以将异步操作以同步的流程表达出来，避免了蹭蹭嵌套的回调函数。此外，Promise还提供了统一的接口，使得控制异步操作更加容易。</p>\n<p>但是Promise也存在缺点：例如一旦创建就会立即执行，无法中途取消，其次，如果不设置回调函数，Promise内部会抛出异常，不会反应到外部。最后，当处于Pending状态的时候，无法得知目前进展到哪一个阶段。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span> (a) &#123;<br>        <span class=\"hljs-title function_\">resolve</span>(value); <span class=\"hljs-comment\">// Pending -&gt; Resolved</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-title function_\">reject</span>(error); <span class=\"hljs-comment\">// Pending -&gt; Rejected</span><br>    &#125;<br>&#125;);<br><br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>)&#123;<br>    <span class=\"hljs-comment\">// success</span><br>&#125;, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>   <span class=\"hljs-comment\">// failure </span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>Promise新建后会立即执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Promise&#x27;</span>);<br>    <span class=\"hljs-title function_\">resolve</span>();<br>&#125;);<br><br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Resolved.&#x27;</span>)<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hi!&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise</span><br><span class=\"hljs-comment\">// Hi!</span><br><span class=\"hljs-comment\">// Resolved</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h2><p><code>then</code>方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。该方法返回的是一个新的Promise实例。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/posts.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">json</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> json.<span class=\"hljs-property\">post</span>;<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果使用箭头函数，可以将上面代码进一步简化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">post</span> =&gt;</span> <span class=\"hljs-title function_\">getJSON</span>(post.<span class=\"hljs-property\">commentURL</span>)<br>).<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">comments</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Resolved: &quot;</span> + comments),<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Rejected: &quot;</span>, err)<br>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h2><p>用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">posts</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Error &#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果Promise状态已经变成了Resolved，再抛出错误就是无效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;ok&#x27;</span>);<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>);<br>&#125;);<br><br>promise<br>\t.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)&#125;)<br>\t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error)&#125;);<br><span class=\"hljs-comment\">// ok</span><br></code></pre></td></tr></table></figure>\n<p>Promise对象错误具有”冒泡“性质，会一直向后传递，直到被捕获为止。也就是说：错误总会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">getJSON</span>(post.<span class=\"hljs-property\">commentURL</span>);<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">comments</span>)&#123;<br>    <span class=\"hljs-comment\">// some code</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>    <span class=\"hljs-comment\">// error handler</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>与传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码。但是Chrome不遵守这个规则，还是会抛出异常。好在Node.js提供了一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, p</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err.<span class=\"hljs-property\">stack</span>);<br>&#125;);<br><br><span class=\"hljs-keyword\">var</span> someAsyncThing = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>        <span class=\"hljs-title function_\">resolve</span>(x + <span class=\"hljs-number\">2</span>);<br>    &#125;);<br>&#125;;<br><br><span class=\"hljs-title function_\">someAsyncThing</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;everything is great&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p><code>catch</code>方法中还可以继续抛出异常。例如下面的代码：第二个<code>catch</code>方法用来捕获，前一个<code>catch</code>方法抛出错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">someAsyncThing</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">someOtherAsyncThing</span>();<br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;oh no&#x27;</span>, error);<br>  <span class=\"hljs-comment\">// 下面一行会报错，因为y没有声明</span><br>  y + <span class=\"hljs-number\">2</span>;<br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;carry on&#x27;</span>, error);<br>&#125;);<br><span class=\"hljs-comment\">// oh no [ReferenceError: x is not defined]</span><br><span class=\"hljs-comment\">// carry on [ReferenceError: y is not defined]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h2><p><code>Promise.all</code>方法用于将多个Promise实例，包装成一个新的Promise实例。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([p1, p2, p3]);<br></code></pre></td></tr></table></figure>\n<p>例子如下：只有这6个实例的状态都变成了<code>fulfilled</code>，或者其中有一个状态变成了<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promises = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">id</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/&quot;</span> + id + <span class=\"hljs-string\">&quot;.json&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>再例如下面这个例子：只有<code>booksPromise</code>和<code>userPromise</code>的结果都返回了，才会触发<code>pickTopRecommentations</code>这个回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> databasePromise = <span class=\"hljs-title function_\">connectDatabase</span>();<br><br><span class=\"hljs-keyword\">const</span> booksPromise = databasePromise.<span class=\"hljs-title function_\">then</span>(findAllBooks);<br><br><span class=\"hljs-keyword\">const</span> userPromise = databasrPromise.<span class=\"hljs-title function_\">then</span>(getCurrentUser);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<br>    booksPromise,<br>    userPromise<br>]).<span class=\"hljs-title function_\">then</span>([books, user] =&gt; <span class=\"hljs-title function_\">pickTopRecommentations</span>(books, user));<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h2><p>跟上面的作用一样，将多个Promise实例合成一个新的Promise实例。</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">var</span> p = Promise.race([<span class=\"hljs-built_in\">p1</span>, <span class=\"hljs-built_in\">p2</span>, <span class=\"hljs-built_in\">p3</span>])<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n<p>上面的例子中：只要三个状态有其中一个率先改变，新对象的状态就跟着一起改变。率先改变的Promise实例的返回值就是新Promise实例的回调函数的输入。</p>\n<p>下面提供一个实例：如果指定时间内没有获得结果，就将Promise的状态变为<code>reject</code>，否则就为<code>resolve</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([<br>  <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/resource-that-may-take-a-while&#x27;</span>),<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;request timeout&#x27;</span>)), <span class=\"hljs-number\">5000</span>)<br>  &#125;)<br>])<br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(response))<br>p.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error))<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve()方法就起这个作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-comment\">// equal to</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promisr</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>));<br></code></pre></td></tr></table></figure>\n<p><code>Promise.resolve</code>方法的参数可以分为4种情况。</p>\n<ul>\n<li>参数是一个Promise实例：不做任何修改，原封不动返回实例</li>\n<li>参数是一个thenable对象：将该对象转换为Promise对象，然后立即执行<code>thenable</code>对象的<code>then</code>方法；</li>\n<li>参数不是具有then方法的对象，或根本就不是对象：返回一个新的<code>Promise</code>对象，状态为<code>Resolved</code>；</li>\n<li>不带有任何参数：直接返回一个状态为<code>Resolved</code>的Promise对象；</li>\n</ul>\n<h2 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h2><p>也会返回一个新的Promise实例，该实例的状态为<code>rejected</code>。其参数用法和<code>Promise.resolve()</code>方法完全一致；</p>\n<h2 id=\"两个有用的附加方法\"><a href=\"#两个有用的附加方法\" class=\"headerlink\" title=\"两个有用的附加方法\"></a>两个有用的附加方法</h2><h3 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h3><p>提供一个<code>done</code>方法，总是处于回调链的尾端，保证抛出任何可能出现的错误</p>\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h3><p>用于指定不管Promise对象最后状态如何，都会执行的操作。与<code>Done</code>方法最大的区别，接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"加载图片\"><a href=\"#加载图片\" class=\"headerlink\" title=\"加载图片\"></a>加载图片</h3><p>我们可以将图片加载写成一个Promise，一旦加载完成，<code>Promise</code>的状态就发生变化；</p>\n<h3 id=\"Generator函数结合Promise\"><a href=\"#Generator函数结合Promise\" class=\"headerlink\" title=\"Generator函数结合Promise\"></a>Generator函数结合Promise</h3><p>使用Generator函数管理函数流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象；</p>\n<h3 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h3><p>实际开发中还遇到一种情况：不知道或者不想区分函数f是同步还是异步，但还是想用Promise来处理。</p>\n<p>实际开发中提供了两种写法来实现这种效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// async 写法</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>(<span class=\"hljs-keyword\">async</span> () =&gt; <span class=\"hljs-title function_\">f</span>())();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise写法</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>&#123;<br>    <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<br>    \t<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-title function_\">f</span>())<br>    )<br>&#125;();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>需要注意的是<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的异常，因此需要使用<code>promise.catch</code>方法来捕获异常；</p>\n","site":{"data":{}},"wordcount":5446,"excerpt":"","more":"<h1 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h1><h2 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h2><p>Promise是异步编程的一种解决方案，最早由社区提出和实现，ES6在次基础上统一了用法并且提供了Promise对象。</p>\n<p>所谓的Promise简单来说就是一个容器：里面保存着某个未来才会结束的事件的结果。从语法上说：Promise是一个对象，从它可以获取异步操作的消息。</p>\n<p>Promise对象由两个特点：</p>\n<ul>\n<li>对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这种状态；</li>\n<li>一旦状态发生了改变，就不会再变，任何时候都可以得到这个结果。</li>\n</ul>\n<p>因此：有了Promise，就可以将异步操作以同步的流程表达出来，避免了蹭蹭嵌套的回调函数。此外，Promise还提供了统一的接口，使得控制异步操作更加容易。</p>\n<p>但是Promise也存在缺点：例如一旦创建就会立即执行，无法中途取消，其次，如果不设置回调函数，Promise内部会抛出异常，不会反应到外部。最后，当处于Pending状态的时候，无法得知目前进展到哪一个阶段。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span> (a) &#123;<br>        <span class=\"hljs-title function_\">resolve</span>(value); <span class=\"hljs-comment\">// Pending -&gt; Resolved</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-title function_\">reject</span>(error); <span class=\"hljs-comment\">// Pending -&gt; Rejected</span><br>    &#125;<br>&#125;);<br><br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>)&#123;<br>    <span class=\"hljs-comment\">// success</span><br>&#125;, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>   <span class=\"hljs-comment\">// failure </span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>Promise新建后会立即执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Promise&#x27;</span>);<br>    <span class=\"hljs-title function_\">resolve</span>();<br>&#125;);<br><br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Resolved.&#x27;</span>)<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hi!&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise</span><br><span class=\"hljs-comment\">// Hi!</span><br><span class=\"hljs-comment\">// Resolved</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then()\"></a>Promise.prototype.then()</h2><p><code>then</code>方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。该方法返回的是一个新的Promise实例。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/posts.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">json</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> json.<span class=\"hljs-property\">post</span>;<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果使用箭头函数，可以将上面代码进一步简化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">post</span> =&gt;</span> <span class=\"hljs-title function_\">getJSON</span>(post.<span class=\"hljs-property\">commentURL</span>)<br>).<span class=\"hljs-title function_\">then</span>(<br>\t<span class=\"hljs-function\"><span class=\"hljs-params\">comments</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Resolved: &quot;</span> + comments),<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Rejected: &quot;</span>, err)<br>);<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch()\"></a>Promise.prototype.catch()</h2><p>用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">posts</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Error &#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果Promise状态已经变成了Resolved，再抛出错误就是无效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;ok&#x27;</span>);<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;test&#x27;</span>);<br>&#125;);<br><br>promise<br>\t.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)&#125;)<br>\t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error)&#125;);<br><span class=\"hljs-comment\">// ok</span><br></code></pre></td></tr></table></figure>\n<p>Promise对象错误具有”冒泡“性质，会一直向后传递，直到被捕获为止。也就是说：错误总会被下一个<code>catch</code>语句捕获。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/1.json&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">getJSON</span>(post.<span class=\"hljs-property\">commentURL</span>);<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">comments</span>)&#123;<br>    <span class=\"hljs-comment\">// some code</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>)&#123;<br>    <span class=\"hljs-comment\">// error handler</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>与传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码。但是Chrome不遵守这个规则，还是会抛出异常。好在Node.js提供了一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err, p</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err.<span class=\"hljs-property\">stack</span>);<br>&#125;);<br><br><span class=\"hljs-keyword\">var</span> someAsyncThing = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>)&#123;<br>        <span class=\"hljs-title function_\">resolve</span>(x + <span class=\"hljs-number\">2</span>);<br>    &#125;);<br>&#125;;<br><br><span class=\"hljs-title function_\">someAsyncThing</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;everything is great&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p><code>catch</code>方法中还可以继续抛出异常。例如下面的代码：第二个<code>catch</code>方法用来捕获，前一个<code>catch</code>方法抛出错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">someAsyncThing</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">someOtherAsyncThing</span>();<br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;oh no&#x27;</span>, error);<br>  <span class=\"hljs-comment\">// 下面一行会报错，因为y没有声明</span><br>  y + <span class=\"hljs-number\">2</span>;<br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;carry on&#x27;</span>, error);<br>&#125;);<br><span class=\"hljs-comment\">// oh no [ReferenceError: x is not defined]</span><br><span class=\"hljs-comment\">// carry on [ReferenceError: y is not defined]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h2><p><code>Promise.all</code>方法用于将多个Promise实例，包装成一个新的Promise实例。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([p1, p2, p3]);<br></code></pre></td></tr></table></figure>\n<p>例子如下：只有这6个实例的状态都变成了<code>fulfilled</code>，或者其中有一个状态变成了<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> promises = [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">id</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">getJSON</span>(<span class=\"hljs-string\">&quot;/post/&quot;</span> + id + <span class=\"hljs-string\">&quot;.json&quot;</span>);<br>&#125;);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">post</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>)&#123;<br>    <span class=\"hljs-comment\">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>再例如下面这个例子：只有<code>booksPromise</code>和<code>userPromise</code>的结果都返回了，才会触发<code>pickTopRecommentations</code>这个回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> databasePromise = <span class=\"hljs-title function_\">connectDatabase</span>();<br><br><span class=\"hljs-keyword\">const</span> booksPromise = databasePromise.<span class=\"hljs-title function_\">then</span>(findAllBooks);<br><br><span class=\"hljs-keyword\">const</span> userPromise = databasrPromise.<span class=\"hljs-title function_\">then</span>(getCurrentUser);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([<br>    booksPromise,<br>    userPromise<br>]).<span class=\"hljs-title function_\">then</span>([books, user] =&gt; <span class=\"hljs-title function_\">pickTopRecommentations</span>(books, user));<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h2><p>跟上面的作用一样，将多个Promise实例合成一个新的Promise实例。</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">var</span> p = Promise.race([<span class=\"hljs-built_in\">p1</span>, <span class=\"hljs-built_in\">p2</span>, <span class=\"hljs-built_in\">p3</span>])<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n<p>上面的例子中：只要三个状态有其中一个率先改变，新对象的状态就跟着一起改变。率先改变的Promise实例的返回值就是新Promise实例的回调函数的输入。</p>\n<p>下面提供一个实例：如果指定时间内没有获得结果，就将Promise的状态变为<code>reject</code>，否则就为<code>resolve</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([<br>  <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/resource-that-may-take-a-while&#x27;</span>),<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;request timeout&#x27;</span>)), <span class=\"hljs-number\">5000</span>)<br>  &#125;)<br>])<br>p.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(response))<br>p.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error))<br></code></pre></td></tr></table></figure>\n<h2 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve()方法就起这个作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-comment\">// equal to</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promisr</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>));<br></code></pre></td></tr></table></figure>\n<p><code>Promise.resolve</code>方法的参数可以分为4种情况。</p>\n<ul>\n<li>参数是一个Promise实例：不做任何修改，原封不动返回实例</li>\n<li>参数是一个thenable对象：将该对象转换为Promise对象，然后立即执行<code>thenable</code>对象的<code>then</code>方法；</li>\n<li>参数不是具有then方法的对象，或根本就不是对象：返回一个新的<code>Promise</code>对象，状态为<code>Resolved</code>；</li>\n<li>不带有任何参数：直接返回一个状态为<code>Resolved</code>的Promise对象；</li>\n</ul>\n<h2 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h2><p>也会返回一个新的Promise实例，该实例的状态为<code>rejected</code>。其参数用法和<code>Promise.resolve()</code>方法完全一致；</p>\n<h2 id=\"两个有用的附加方法\"><a href=\"#两个有用的附加方法\" class=\"headerlink\" title=\"两个有用的附加方法\"></a>两个有用的附加方法</h2><h3 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h3><p>提供一个<code>done</code>方法，总是处于回调链的尾端，保证抛出任何可能出现的错误</p>\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h3><p>用于指定不管Promise对象最后状态如何，都会执行的操作。与<code>Done</code>方法最大的区别，接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"加载图片\"><a href=\"#加载图片\" class=\"headerlink\" title=\"加载图片\"></a>加载图片</h3><p>我们可以将图片加载写成一个Promise，一旦加载完成，<code>Promise</code>的状态就发生变化；</p>\n<h3 id=\"Generator函数结合Promise\"><a href=\"#Generator函数结合Promise\" class=\"headerlink\" title=\"Generator函数结合Promise\"></a>Generator函数结合Promise</h3><p>使用Generator函数管理函数流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象；</p>\n<h3 id=\"Promise-try\"><a href=\"#Promise-try\" class=\"headerlink\" title=\"Promise.try()\"></a>Promise.try()</h3><p>实际开发中还遇到一种情况：不知道或者不想区分函数f是同步还是异步，但还是想用Promise来处理。</p>\n<p>实际开发中提供了两种写法来实现这种效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// async 写法</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>(<span class=\"hljs-keyword\">async</span> () =&gt; <span class=\"hljs-title function_\">f</span>())();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br><br><span class=\"hljs-comment\">// Promise写法</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">f</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now&#x27;</span>);<br>&#123;<br>    <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<br>    \t<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-title function_\">f</span>())<br>    )<br>&#125;();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;next&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>需要注意的是<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的异常，因此需要使用<code>promise.catch</code>方法来捕获异常；</p>\n"},{"title":"ES6 Proxy和Reflect","date":"2022-02-17T07:18:01.000Z","updated":"2022-02-17T07:18:01.000Z","_content":"\n# Proxy和Reflect\n\n## Proxy\n\n### 概述\n\nProxy用于修改某些操作的默认行为，等同于在语言层面做修改，所以属于一种“元编程”。Proxy可以理解为在目标对象之前架设一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制：可以对外界的访问进行过滤和改写。例子如下：\n\n```javascript\nvar obj = new Proxy({}, {\n    get: function (target, key, receiver) {\n        console.log(`getting ${key}!`);\n        return Reflect.get(target, key, receiver);\n    },\n    set: function (target, key, value, receiver) {\n        console.log(`setting ${key}`);\n        return Reflect.set(target, key, value, receiver);\n    }\n});\n```\n\nES6原生提供了Proxy构造函数，用来生成Proxy实例。\n\n```javascript\nvar proxy = new Proxy(target, handler);\n```\n\n其中target表示所要拦截的对象，handler用来定制拦截行为。例子如下：\n\n```javascript\nvar proxy = new Proxy({}, {\n    get: function(target, property) {\n        return 35;\n    }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.titile // 35\n```\n\n需要说明的是：如果handler没有设置任何拦截对象，那么将继续保持原对象的行为不变。并且同一个拦截函数可以设置多个拦截操作：\n\n```javascript\nvar handler = {\n    get: function(target, name) {\n        if (name === 'prototype') {\n            return Object.prototype;\n        }\n        return 'Hello, ' + name;\n    },\n\n    apply: function(target, thisBinding, args) {\n        return args[0];\n    },\n    construct: function(target, args) {\n        return {value: args[1]};\n    }\n};\n\nvar fproxy = new Proxy(function (x, y){\n    return x + y;\n}, handler);\n\nconsole.log(fproxy(1, 2)); // 1\nconsole.log(new fproxy(1, 2)); // {value: 2}\nconsole.log(fproxy.prototype === Object.prototype); // true\nconsole.log(fproxy.foo) // \"Hello, foo\"\n```\n\n下面是Proxy支持的拦截操作一览：\n\n- get(target, propKey, receiver)：拦截对象属性的读取\n- set(target, propKey, value, receiver)：拦截对象属性的设置\n- has(target, propKey)：拦截`propKey in proxy`的操作，以及对象的`hasOwnProperty`方法，返回一个布尔值\n- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值；\n- ownKeys(target)：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`返回一个数组。该方法返回对象所有自身的属性\n- getOwnPropertyDescriptor(target, propKey)：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`返回属性的描述对象。\n- defineProperty(target, propKey, propDesc)：拦截`Object.defineProperty(proxy, propKey, propDesc)`返回一个布尔值；\n- preventExtensions(target)：拦截`Object.preventExtensions(proxy)`，返回一个布尔值；\n- getPrototypeOf(target)：拦截`Object.getPropertyOf(proxy)`返回一个对象\n- isExtensible(target)：拦截`Object.isExtensible(target)`，返回一个布尔值\n- setPrototypeOf(target, proto)：拦截`Object.setPrototypeOf(proxy, proto)`返回一个布尔值；\n- apply(target, object, args)：拦截Proxy实例作为函数的调用操作\n- construct(target, args)：拦截Proxy实例作为构造函数调用的操作\n\n### 实例方法\n\n#### get()\n\n```javascript\nvar person = {\n    name: \"zhangsan\"\n};\n\nvar proxy = new Proxy(person, {\n    get: function(target, property) {\n        if (property in target) {\n            return target[property];\n        } else {\n            throw new ReferenceError(\"Property \\\"\" + property + \"\\\" doesn't exist.\");\n        }\n    }\n});\n```\n\n#### set()\n\n```javascript\nlet validator = {\n    set: function(target, prop, value) {\n        if (prop === 'age') {\n            if (!Number.isInteger(value)) {\n                throw new TypeError('The age is not an integer');\n            }\n            if (value > 200) {\n                throw new RangeError('The age seems invalid');\n            }\n        }\n\n        target[prop] = value;\n    }\n};\n\nlet person = new Proxy({}, validator);\nperson.age = 100;\n\nconsole.log(person.age);\nperson.age = 'young';\nconsole.log(person.age);\n```\n\n#### apply()\n\n```javascript\nvar target = function () { return \"I am the target;\"; };\nvar handler = {\n    apply: function() {\n        return \"I am the proxy\";\n    }\n};\n\nvar p = new Proxy(target, handler);\n\nconsole.log(p()); // I am the proxy\n```\n\n#### has()\n\n```javascript\nlet stu1 = { name: 'zhangsan', score: 59 };\nlet stu2 = { name: 'lisi', score: 99 };\n\nlet handler = {\n    has(target, prop) {\n        if (prop === 'score' && target[prop] < 60) {\n            console.log(`${target.name} 不及格`);\n            return false;\n        }\n        return prop in target;\n    }\n}\n\nlet oproxy1 = new Proxy(stu1, handler);\nlet oproxy2 = new Proxy(stu2, handler);\n\nconsole.log('score' in oproxy1)\nconsole.log('score' in oproxy2)\n\nfor (let a in oproxy1) {\n    console.log(oproxy1[a]);\n}\n\nfor (let b in oproxy2) {\n    console.log(oproxy2[b]);\n}\n```\n\n#### construct()\n\n```javascript\nvar p = new Proxy(function() {}, {\n    construct: function(target, args) {\n        console.log('called: ' + args.join(', '));\n        return { value: args[0] * 10 };\n    }\n});\n\nconsole.log(new p(1).value);\n```\n\n#### deleteProperty()\n\n```javascript\nvar handler = {\n    deleteProperty(target, key) {\n        invariant(key, 'delete');\n        return true;\n    }\n};\n\nfunction invariant(key, action) {\n    if (key[0] === '_') {\n        throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n    }\n}\n\nvar target = { _prop: 'foo' };\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n```\n\n#### defineProperty()\n\n```javascript\nvar handler = {\n    defineProperty(target, key, descriptor) {\n        return false;\n    }\n};\n\nvar target = {};\nvar proxy = new Proxy(target, handler);\nproxy.foo = 'bar';\n```\n\n#### getOwnPropertyDescriptor()\n\n```javascript\nvar handler = {\n  getOwnPropertyDescriptor (target, key) {\n    if (key[0] === '_') {\n      return;\n    }\n    return Object.getOwnPropertyDescriptor(target, key);\n  }\n};\nvar target = { _foo: 'bar', baz: 'tar' };\nvar proxy = new Proxy(target, handler);\nObject.getOwnPropertyDescriptor(proxy, 'wat')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, '_foo')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n```\n\n#### getPrototypeOf()\n\n```javascript\nvar proto = {};\nvar p = new Proxy({}, {\n    getPrototypeOf(target) {\n        return proto;\n    }\n});\n\nObject.getPrototypeOf(p) === proto // true\n```\n\n#### isExtensible()\n\n```javascript\nvar p = new Proxy({}, {\n    isExtensible: function(target) {\n        console.log('called');\n        return false;\n    }\n});\n\nObject.isExtensible(p)\n```\n\n#### ownKeys()\n\n```javascript\nlet target = {\n    _bar: 'foo',\n    _prop: 'bar',\n    prop: 'baz'\n};\n\nlet handler = {\n    ownKeys(target) {\n        return Reflect.ownKeys(target).filter(key => key[0] !== '_');\n    }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n    console.log(target[key]); // baz\n}\n```\n\n### 取消代理\n\nProxy.revocable()方法返回一个可取消的Proxy实例。\n\n```javascript\nlet target = {};\nlet handler = {};\n\nlet {proxy, revoke} = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n```\n\n### this问题\n\n虽然Proxy可以代理针对目标对象的访问，但不是目标对象的透明代理：即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因是在Proxy代理的情况下，目标对象内部的`this`关键字会指向Proxy代理。\n\n```javascript\nconst _name = new WeakMap();\n\nclass Person {\n    constructor(name) {\n        _name.set(this, name);\n    }\n\n    get name() {\n        return _name.get(this);\n    }\n}\n\nconst jane = new Person('Jane');\njane.name; // \"Jane\"\n\nconst proxy = new Proxy(jane, {});\nproxy.name // undefined\n```\n\n## Reflect\n\n### 概述\n\nReflect也是ES6为了操作对象而提供的新API，其设计目的主要有几个：\n\n1. 将Object对象的一些明显属于语言内部的方法放到Reflect对象上。\n2. 修改某些Object方法返回的结果，让其变得合理。\n3. 让Object的操作都变成函数行为。某些Object操作是命令式的；\n4. Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。\n\n```javascript\nvar loggedObj = new Proxy(obj, {\n    get(target, name) {\n        console.log('get', target, name);\n        return Reflect.get(target, name);\n    },\n    deleteProperty(target, name) {\n        console.log('delete' + name);\n        return Reflect.deleteProperty(target, name);\n    },\n    has(target, name) {\n        console.log('has' + name);\n        return Reflect.has(target, name);\n    }\n});\n```\n\n### Reflect对象的方法\n\n大体上和Object对象的同名方法的作用是相同的，而且与Proxy对象的方法是一一对应的。\n","source":"_posts/javascript/es6-proxy-and-reflect.md","raw":"---\ntitle: ES6 Proxy和Reflect\ndate: 2022-02-17 15:18:01\nupdated: 2022-02-17 15:18:01\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Proxy和Reflect\n\n## Proxy\n\n### 概述\n\nProxy用于修改某些操作的默认行为，等同于在语言层面做修改，所以属于一种“元编程”。Proxy可以理解为在目标对象之前架设一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制：可以对外界的访问进行过滤和改写。例子如下：\n\n```javascript\nvar obj = new Proxy({}, {\n    get: function (target, key, receiver) {\n        console.log(`getting ${key}!`);\n        return Reflect.get(target, key, receiver);\n    },\n    set: function (target, key, value, receiver) {\n        console.log(`setting ${key}`);\n        return Reflect.set(target, key, value, receiver);\n    }\n});\n```\n\nES6原生提供了Proxy构造函数，用来生成Proxy实例。\n\n```javascript\nvar proxy = new Proxy(target, handler);\n```\n\n其中target表示所要拦截的对象，handler用来定制拦截行为。例子如下：\n\n```javascript\nvar proxy = new Proxy({}, {\n    get: function(target, property) {\n        return 35;\n    }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.titile // 35\n```\n\n需要说明的是：如果handler没有设置任何拦截对象，那么将继续保持原对象的行为不变。并且同一个拦截函数可以设置多个拦截操作：\n\n```javascript\nvar handler = {\n    get: function(target, name) {\n        if (name === 'prototype') {\n            return Object.prototype;\n        }\n        return 'Hello, ' + name;\n    },\n\n    apply: function(target, thisBinding, args) {\n        return args[0];\n    },\n    construct: function(target, args) {\n        return {value: args[1]};\n    }\n};\n\nvar fproxy = new Proxy(function (x, y){\n    return x + y;\n}, handler);\n\nconsole.log(fproxy(1, 2)); // 1\nconsole.log(new fproxy(1, 2)); // {value: 2}\nconsole.log(fproxy.prototype === Object.prototype); // true\nconsole.log(fproxy.foo) // \"Hello, foo\"\n```\n\n下面是Proxy支持的拦截操作一览：\n\n- get(target, propKey, receiver)：拦截对象属性的读取\n- set(target, propKey, value, receiver)：拦截对象属性的设置\n- has(target, propKey)：拦截`propKey in proxy`的操作，以及对象的`hasOwnProperty`方法，返回一个布尔值\n- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值；\n- ownKeys(target)：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`返回一个数组。该方法返回对象所有自身的属性\n- getOwnPropertyDescriptor(target, propKey)：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`返回属性的描述对象。\n- defineProperty(target, propKey, propDesc)：拦截`Object.defineProperty(proxy, propKey, propDesc)`返回一个布尔值；\n- preventExtensions(target)：拦截`Object.preventExtensions(proxy)`，返回一个布尔值；\n- getPrototypeOf(target)：拦截`Object.getPropertyOf(proxy)`返回一个对象\n- isExtensible(target)：拦截`Object.isExtensible(target)`，返回一个布尔值\n- setPrototypeOf(target, proto)：拦截`Object.setPrototypeOf(proxy, proto)`返回一个布尔值；\n- apply(target, object, args)：拦截Proxy实例作为函数的调用操作\n- construct(target, args)：拦截Proxy实例作为构造函数调用的操作\n\n### 实例方法\n\n#### get()\n\n```javascript\nvar person = {\n    name: \"zhangsan\"\n};\n\nvar proxy = new Proxy(person, {\n    get: function(target, property) {\n        if (property in target) {\n            return target[property];\n        } else {\n            throw new ReferenceError(\"Property \\\"\" + property + \"\\\" doesn't exist.\");\n        }\n    }\n});\n```\n\n#### set()\n\n```javascript\nlet validator = {\n    set: function(target, prop, value) {\n        if (prop === 'age') {\n            if (!Number.isInteger(value)) {\n                throw new TypeError('The age is not an integer');\n            }\n            if (value > 200) {\n                throw new RangeError('The age seems invalid');\n            }\n        }\n\n        target[prop] = value;\n    }\n};\n\nlet person = new Proxy({}, validator);\nperson.age = 100;\n\nconsole.log(person.age);\nperson.age = 'young';\nconsole.log(person.age);\n```\n\n#### apply()\n\n```javascript\nvar target = function () { return \"I am the target;\"; };\nvar handler = {\n    apply: function() {\n        return \"I am the proxy\";\n    }\n};\n\nvar p = new Proxy(target, handler);\n\nconsole.log(p()); // I am the proxy\n```\n\n#### has()\n\n```javascript\nlet stu1 = { name: 'zhangsan', score: 59 };\nlet stu2 = { name: 'lisi', score: 99 };\n\nlet handler = {\n    has(target, prop) {\n        if (prop === 'score' && target[prop] < 60) {\n            console.log(`${target.name} 不及格`);\n            return false;\n        }\n        return prop in target;\n    }\n}\n\nlet oproxy1 = new Proxy(stu1, handler);\nlet oproxy2 = new Proxy(stu2, handler);\n\nconsole.log('score' in oproxy1)\nconsole.log('score' in oproxy2)\n\nfor (let a in oproxy1) {\n    console.log(oproxy1[a]);\n}\n\nfor (let b in oproxy2) {\n    console.log(oproxy2[b]);\n}\n```\n\n#### construct()\n\n```javascript\nvar p = new Proxy(function() {}, {\n    construct: function(target, args) {\n        console.log('called: ' + args.join(', '));\n        return { value: args[0] * 10 };\n    }\n});\n\nconsole.log(new p(1).value);\n```\n\n#### deleteProperty()\n\n```javascript\nvar handler = {\n    deleteProperty(target, key) {\n        invariant(key, 'delete');\n        return true;\n    }\n};\n\nfunction invariant(key, action) {\n    if (key[0] === '_') {\n        throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n    }\n}\n\nvar target = { _prop: 'foo' };\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n```\n\n#### defineProperty()\n\n```javascript\nvar handler = {\n    defineProperty(target, key, descriptor) {\n        return false;\n    }\n};\n\nvar target = {};\nvar proxy = new Proxy(target, handler);\nproxy.foo = 'bar';\n```\n\n#### getOwnPropertyDescriptor()\n\n```javascript\nvar handler = {\n  getOwnPropertyDescriptor (target, key) {\n    if (key[0] === '_') {\n      return;\n    }\n    return Object.getOwnPropertyDescriptor(target, key);\n  }\n};\nvar target = { _foo: 'bar', baz: 'tar' };\nvar proxy = new Proxy(target, handler);\nObject.getOwnPropertyDescriptor(proxy, 'wat')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, '_foo')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n```\n\n#### getPrototypeOf()\n\n```javascript\nvar proto = {};\nvar p = new Proxy({}, {\n    getPrototypeOf(target) {\n        return proto;\n    }\n});\n\nObject.getPrototypeOf(p) === proto // true\n```\n\n#### isExtensible()\n\n```javascript\nvar p = new Proxy({}, {\n    isExtensible: function(target) {\n        console.log('called');\n        return false;\n    }\n});\n\nObject.isExtensible(p)\n```\n\n#### ownKeys()\n\n```javascript\nlet target = {\n    _bar: 'foo',\n    _prop: 'bar',\n    prop: 'baz'\n};\n\nlet handler = {\n    ownKeys(target) {\n        return Reflect.ownKeys(target).filter(key => key[0] !== '_');\n    }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n    console.log(target[key]); // baz\n}\n```\n\n### 取消代理\n\nProxy.revocable()方法返回一个可取消的Proxy实例。\n\n```javascript\nlet target = {};\nlet handler = {};\n\nlet {proxy, revoke} = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n```\n\n### this问题\n\n虽然Proxy可以代理针对目标对象的访问，但不是目标对象的透明代理：即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因是在Proxy代理的情况下，目标对象内部的`this`关键字会指向Proxy代理。\n\n```javascript\nconst _name = new WeakMap();\n\nclass Person {\n    constructor(name) {\n        _name.set(this, name);\n    }\n\n    get name() {\n        return _name.get(this);\n    }\n}\n\nconst jane = new Person('Jane');\njane.name; // \"Jane\"\n\nconst proxy = new Proxy(jane, {});\nproxy.name // undefined\n```\n\n## Reflect\n\n### 概述\n\nReflect也是ES6为了操作对象而提供的新API，其设计目的主要有几个：\n\n1. 将Object对象的一些明显属于语言内部的方法放到Reflect对象上。\n2. 修改某些Object方法返回的结果，让其变得合理。\n3. 让Object的操作都变成函数行为。某些Object操作是命令式的；\n4. Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。\n\n```javascript\nvar loggedObj = new Proxy(obj, {\n    get(target, name) {\n        console.log('get', target, name);\n        return Reflect.get(target, name);\n    },\n    deleteProperty(target, name) {\n        console.log('delete' + name);\n        return Reflect.deleteProperty(target, name);\n    },\n    has(target, name) {\n        console.log('has' + name);\n        return Reflect.has(target, name);\n    }\n});\n```\n\n### Reflect对象的方法\n\n大体上和Object对象的同名方法的作用是相同的，而且与Proxy对象的方法是一一对应的。\n","slug":"javascript/es6-proxy-and-reflect","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl38001u2y619rc1c1be","content":"<h1 id=\"Proxy和Reflect\"><a href=\"#Proxy和Reflect\" class=\"headerlink\" title=\"Proxy和Reflect\"></a>Proxy和Reflect</h1><h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做修改，所以属于一种“元编程”。Proxy可以理解为在目标对象之前架设一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制：可以对外界的访问进行过滤和改写。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, key, receiver</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`getting <span class=\"hljs-subst\">$&#123;key&#125;</span>!`</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key, receiver);<br>    &#125;,<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, key, value, receiver</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`setting <span class=\"hljs-subst\">$&#123;key&#125;</span>`</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>ES6原生提供了Proxy构造函数，用来生成Proxy实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure>\n<p>其中target表示所要拦截的对象，handler用来定制拦截行为。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">35</span>;<br>    &#125;<br>&#125;);<br><br>proxy.<span class=\"hljs-property\">time</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">titile</span> <span class=\"hljs-comment\">// 35</span><br></code></pre></td></tr></table></figure>\n<p>需要说明的是：如果handler没有设置任何拦截对象，那么将继续保持原对象的行为不变。并且同一个拦截函数可以设置多个拦截操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">&#x27;prototype&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + name;<br>    &#125;,<br><br>    <span class=\"hljs-attr\">apply</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, thisBinding, args</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> args[<span class=\"hljs-number\">0</span>];<br>    &#125;,<br>    <span class=\"hljs-attr\">construct</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, args</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">value</span>: args[<span class=\"hljs-number\">1</span>]&#125;;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> fproxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fproxy</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">fproxy</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// &#123;value: 2&#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fproxy.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> === <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fproxy.<span class=\"hljs-property\">foo</span>) <span class=\"hljs-comment\">// &quot;Hello, foo&quot;</span><br></code></pre></td></tr></table></figure>\n<p>下面是Proxy支持的拦截操作一览：</p>\n<ul>\n<li>get(target, propKey, receiver)：拦截对象属性的读取</li>\n<li>set(target, propKey, value, receiver)：拦截对象属性的设置</li>\n<li>has(target, propKey)：拦截<code>propKey in proxy</code>的操作，以及对象的<code>hasOwnProperty</code>方法，返回一个布尔值</li>\n<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值；</li>\n<li>ownKeys(target)：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>返回一个数组。该方法返回对象所有自身的属性</li>\n<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>返回属性的描述对象。</li>\n<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc)</code>返回一个布尔值；</li>\n<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值；</li>\n<li>getPrototypeOf(target)：拦截<code>Object.getPropertyOf(proxy)</code>返回一个对象</li>\n<li>isExtensible(target)：拦截<code>Object.isExtensible(target)</code>，返回一个布尔值</li>\n<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>返回一个布尔值；</li>\n<li>apply(target, object, args)：拦截Proxy实例作为函数的调用操作</li>\n<li>construct(target, args)：拦截Proxy实例作为构造函数调用的操作</li>\n</ul>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;zhangsan&quot;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(person, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (property <span class=\"hljs-keyword\">in</span> target) &#123;<br>            <span class=\"hljs-keyword\">return</span> target[property];<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReferenceError</span>(<span class=\"hljs-string\">&quot;Property \\&quot;&quot;</span> + property + <span class=\"hljs-string\">&quot;\\&quot; doesn&#x27;t exist.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> validator = &#123;<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, prop, value</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (prop === <span class=\"hljs-string\">&#x27;age&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isInteger</span>(value)) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;The age is not an integer&#x27;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (value &gt; <span class=\"hljs-number\">200</span>) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeError</span>(<span class=\"hljs-string\">&#x27;The age seems invalid&#x27;</span>);<br>            &#125;<br>        &#125;<br><br>        target[prop] = value;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, validator);<br>person.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">100</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>);<br>person.<span class=\"hljs-property\">age</span> = <span class=\"hljs-string\">&#x27;young&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> target = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;I am the target;&quot;</span>; &#125;;<br><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-attr\">apply</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;I am the proxy&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">p</span>()); <span class=\"hljs-comment\">// I am the proxy</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has()\"></a>has()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> stu1 = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span>, <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">59</span> &#125;;<br><span class=\"hljs-keyword\">let</span> stu2 = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;lisi&#x27;</span>, <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">99</span> &#125;;<br><br><span class=\"hljs-keyword\">let</span> handler = &#123;<br>    <span class=\"hljs-title function_\">has</span>(<span class=\"hljs-params\">target, prop</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (prop === <span class=\"hljs-string\">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class=\"hljs-number\">60</span>) &#123;<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;target.name&#125;</span> 不及格`</span>);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> prop <span class=\"hljs-keyword\">in</span> target;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> oproxy1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(stu1, handler);<br><span class=\"hljs-keyword\">let</span> oproxy2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(stu2, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;score&#x27;</span> <span class=\"hljs-keyword\">in</span> oproxy1)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;score&#x27;</span> <span class=\"hljs-keyword\">in</span> oproxy2)<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> a <span class=\"hljs-keyword\">in</span> oproxy1) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(oproxy1[a]);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> b <span class=\"hljs-keyword\">in</span> oproxy2) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(oproxy2[b]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"construct\"><a href=\"#construct\" class=\"headerlink\" title=\"construct()\"></a>construct()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">construct</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, args</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;called: &#x27;</span> + args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;, &#x27;</span>));<br>        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">value</span>: args[<span class=\"hljs-number\">0</span>] * <span class=\"hljs-number\">10</span> &#125;;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">p</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-property\">value</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"deleteProperty\"><a href=\"#deleteProperty\" class=\"headerlink\" title=\"deleteProperty()\"></a>deleteProperty()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-params\">target, key</span>) &#123;<br>        <span class=\"hljs-title function_\">invariant</span>(key, <span class=\"hljs-string\">&#x27;delete&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">invariant</span>(<span class=\"hljs-params\">key, action</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;_&#x27;</span>) &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Invalid attempt to <span class=\"hljs-subst\">$&#123;action&#125;</span> private &quot;<span class=\"hljs-subst\">$&#123;key&#125;</span>&quot; property`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">_prop</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-keyword\">delete</span> proxy.<span class=\"hljs-property\">_prop</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"defineProperty\"><a href=\"#defineProperty\" class=\"headerlink\" title=\"defineProperty()\"></a>defineProperty()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-title function_\">defineProperty</span>(<span class=\"hljs-params\">target, key, descriptor</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> target = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br>proxy.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<h4 id=\"getOwnPropertyDescriptor\"><a href=\"#getOwnPropertyDescriptor\" class=\"headerlink\" title=\"getOwnPropertyDescriptor()\"></a>getOwnPropertyDescriptor()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>  getOwnPropertyDescriptor (target, key) &#123;<br>    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;_&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target, key);<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">_foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-string\">&#x27;tar&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;wat&#x27;</span>)<br><span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;_foo&#x27;</span>)<br><span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><span class=\"hljs-comment\">// &#123; value: &#x27;tar&#x27;, writable: true, enumerable: true, configurable: true &#125;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"getPrototypeOf\"><a href=\"#getPrototypeOf\" class=\"headerlink\" title=\"getPrototypeOf()\"></a>getPrototypeOf()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proto = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-title function_\">getPrototypeOf</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> proto;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(p) === proto <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"isExtensible\"><a href=\"#isExtensible\" class=\"headerlink\" title=\"isExtensible()\"></a>isExtensible()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">isExtensible</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;called&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">isExtensible</span>(p)<br></code></pre></td></tr></table></figure>\n<h4 id=\"ownKeys\"><a href=\"#ownKeys\" class=\"headerlink\" title=\"ownKeys()\"></a>ownKeys()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> target = &#123;<br>    <span class=\"hljs-attr\">_bar</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span>,<br>    <span class=\"hljs-attr\">_prop</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>,<br>    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">&#x27;baz&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> handler = &#123;<br>    <span class=\"hljs-title function_\">ownKeys</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(target).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> key[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">&#x27;_&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(proxy)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(target[key]); <span class=\"hljs-comment\">// baz</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"取消代理\"><a href=\"#取消代理\" class=\"headerlink\" title=\"取消代理\"></a>取消代理</h3><p>Proxy.revocable()方法返回一个可取消的Proxy实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> target = &#123;&#125;;<br><span class=\"hljs-keyword\">let</span> handler = &#123;&#125;;<br><br><span class=\"hljs-keyword\">let</span> &#123;proxy, revoke&#125; = <span class=\"hljs-title class_\">Proxy</span>.<span class=\"hljs-title function_\">revocable</span>(target, handler);<br><br>proxy.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-number\">123</span>;<br>proxy.<span class=\"hljs-property\">foo</span> <span class=\"hljs-comment\">// 123</span><br><br><span class=\"hljs-title function_\">revoke</span>();<br>proxy.<span class=\"hljs-property\">foo</span> <span class=\"hljs-comment\">// TypeError: Revoked</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"this问题\"><a href=\"#this问题\" class=\"headerlink\" title=\"this问题\"></a>this问题</h3><p>虽然Proxy可以代理针对目标对象的访问，但不是目标对象的透明代理：即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因是在Proxy代理的情况下，目标对象内部的<code>this</code>关键字会指向Proxy代理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> _name = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>        _name.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, name);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">name</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> _name.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> jane = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;Jane&#x27;</span>);<br>jane.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">// &quot;Jane&quot;</span><br><br><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(jane, &#123;&#125;);<br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Reflect也是ES6为了操作对象而提供的新API，其设计目的主要有几个：</p>\n<ol>\n<li>将Object对象的一些明显属于语言内部的方法放到Reflect对象上。</li>\n<li>修改某些Object方法返回的结果，让其变得合理。</li>\n<li>让Object的操作都变成函数行为。某些Object操作是命令式的；</li>\n<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> loggedObj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, &#123;<br>    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;get&#x27;</span>, target, name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, name);<br>    &#125;,<br>    <span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;delete&#x27;</span> + name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(target, name);<br>    &#125;,<br>    <span class=\"hljs-title function_\">has</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;has&#x27;</span> + name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">has</span>(target, name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"Reflect对象的方法\"><a href=\"#Reflect对象的方法\" class=\"headerlink\" title=\"Reflect对象的方法\"></a>Reflect对象的方法</h3><p>大体上和Object对象的同名方法的作用是相同的，而且与Proxy对象的方法是一一对应的。</p>\n","site":{"data":{}},"wordcount":7233,"excerpt":"","more":"<h1 id=\"Proxy和Reflect\"><a href=\"#Proxy和Reflect\" class=\"headerlink\" title=\"Proxy和Reflect\"></a>Proxy和Reflect</h1><h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做修改，所以属于一种“元编程”。Proxy可以理解为在目标对象之前架设一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制：可以对外界的访问进行过滤和改写。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, key, receiver</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`getting <span class=\"hljs-subst\">$&#123;key&#125;</span>!`</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key, receiver);<br>    &#125;,<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, key, value, receiver</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`setting <span class=\"hljs-subst\">$&#123;key&#125;</span>`</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>ES6原生提供了Proxy构造函数，用来生成Proxy实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure>\n<p>其中target表示所要拦截的对象，handler用来定制拦截行为。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">35</span>;<br>    &#125;<br>&#125;);<br><br>proxy.<span class=\"hljs-property\">time</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// 35</span><br>proxy.<span class=\"hljs-property\">titile</span> <span class=\"hljs-comment\">// 35</span><br></code></pre></td></tr></table></figure>\n<p>需要说明的是：如果handler没有设置任何拦截对象，那么将继续保持原对象的行为不变。并且同一个拦截函数可以设置多个拦截操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">&#x27;prototype&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + name;<br>    &#125;,<br><br>    <span class=\"hljs-attr\">apply</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, thisBinding, args</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> args[<span class=\"hljs-number\">0</span>];<br>    &#125;,<br>    <span class=\"hljs-attr\">construct</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, args</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">value</span>: args[<span class=\"hljs-number\">1</span>]&#125;;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> fproxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fproxy</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">fproxy</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// &#123;value: 2&#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fproxy.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> === <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fproxy.<span class=\"hljs-property\">foo</span>) <span class=\"hljs-comment\">// &quot;Hello, foo&quot;</span><br></code></pre></td></tr></table></figure>\n<p>下面是Proxy支持的拦截操作一览：</p>\n<ul>\n<li>get(target, propKey, receiver)：拦截对象属性的读取</li>\n<li>set(target, propKey, value, receiver)：拦截对象属性的设置</li>\n<li>has(target, propKey)：拦截<code>propKey in proxy</code>的操作，以及对象的<code>hasOwnProperty</code>方法，返回一个布尔值</li>\n<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值；</li>\n<li>ownKeys(target)：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>返回一个数组。该方法返回对象所有自身的属性</li>\n<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>返回属性的描述对象。</li>\n<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc)</code>返回一个布尔值；</li>\n<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值；</li>\n<li>getPrototypeOf(target)：拦截<code>Object.getPropertyOf(proxy)</code>返回一个对象</li>\n<li>isExtensible(target)：拦截<code>Object.isExtensible(target)</code>，返回一个布尔值</li>\n<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>返回一个布尔值；</li>\n<li>apply(target, object, args)：拦截Proxy实例作为函数的调用操作</li>\n<li>construct(target, args)：拦截Proxy实例作为构造函数调用的操作</li>\n</ul>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;zhangsan&quot;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(person, &#123;<br>    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, property</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (property <span class=\"hljs-keyword\">in</span> target) &#123;<br>            <span class=\"hljs-keyword\">return</span> target[property];<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReferenceError</span>(<span class=\"hljs-string\">&quot;Property \\&quot;&quot;</span> + property + <span class=\"hljs-string\">&quot;\\&quot; doesn&#x27;t exist.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> validator = &#123;<br>    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, prop, value</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (prop === <span class=\"hljs-string\">&#x27;age&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">isInteger</span>(value)) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;The age is not an integer&#x27;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (value &gt; <span class=\"hljs-number\">200</span>) &#123;<br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RangeError</span>(<span class=\"hljs-string\">&#x27;The age seems invalid&#x27;</span>);<br>            &#125;<br>        &#125;<br><br>        target[prop] = value;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, validator);<br>person.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">100</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>);<br>person.<span class=\"hljs-property\">age</span> = <span class=\"hljs-string\">&#x27;young&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> target = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;I am the target;&quot;</span>; &#125;;<br><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-attr\">apply</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;I am the proxy&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">p</span>()); <span class=\"hljs-comment\">// I am the proxy</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has()\"></a>has()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> stu1 = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span>, <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">59</span> &#125;;<br><span class=\"hljs-keyword\">let</span> stu2 = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;lisi&#x27;</span>, <span class=\"hljs-attr\">score</span>: <span class=\"hljs-number\">99</span> &#125;;<br><br><span class=\"hljs-keyword\">let</span> handler = &#123;<br>    <span class=\"hljs-title function_\">has</span>(<span class=\"hljs-params\">target, prop</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (prop === <span class=\"hljs-string\">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class=\"hljs-number\">60</span>) &#123;<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;target.name&#125;</span> 不及格`</span>);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> prop <span class=\"hljs-keyword\">in</span> target;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> oproxy1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(stu1, handler);<br><span class=\"hljs-keyword\">let</span> oproxy2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(stu2, handler);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;score&#x27;</span> <span class=\"hljs-keyword\">in</span> oproxy1)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;score&#x27;</span> <span class=\"hljs-keyword\">in</span> oproxy2)<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> a <span class=\"hljs-keyword\">in</span> oproxy1) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(oproxy1[a]);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> b <span class=\"hljs-keyword\">in</span> oproxy2) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(oproxy2[b]);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"construct\"><a href=\"#construct\" class=\"headerlink\" title=\"construct()\"></a>construct()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">construct</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target, args</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;called: &#x27;</span> + args.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;, &#x27;</span>));<br>        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">value</span>: args[<span class=\"hljs-number\">0</span>] * <span class=\"hljs-number\">10</span> &#125;;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">p</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-property\">value</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"deleteProperty\"><a href=\"#deleteProperty\" class=\"headerlink\" title=\"deleteProperty()\"></a>deleteProperty()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-params\">target, key</span>) &#123;<br>        <span class=\"hljs-title function_\">invariant</span>(key, <span class=\"hljs-string\">&#x27;delete&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">invariant</span>(<span class=\"hljs-params\">key, action</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;_&#x27;</span>) &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Invalid attempt to <span class=\"hljs-subst\">$&#123;action&#125;</span> private &quot;<span class=\"hljs-subst\">$&#123;key&#125;</span>&quot; property`</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">_prop</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-keyword\">delete</span> proxy.<span class=\"hljs-property\">_prop</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"defineProperty\"><a href=\"#defineProperty\" class=\"headerlink\" title=\"defineProperty()\"></a>defineProperty()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>    <span class=\"hljs-title function_\">defineProperty</span>(<span class=\"hljs-params\">target, key, descriptor</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> target = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br>proxy.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<h4 id=\"getOwnPropertyDescriptor\"><a href=\"#getOwnPropertyDescriptor\" class=\"headerlink\" title=\"getOwnPropertyDescriptor()\"></a>getOwnPropertyDescriptor()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> handler = &#123;<br>  getOwnPropertyDescriptor (target, key) &#123;<br>    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;_&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target, key);<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">var</span> target = &#123; <span class=\"hljs-attr\">_foo</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-string\">&#x27;tar&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">var</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;wat&#x27;</span>)<br><span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;_foo&#x27;</span>)<br><span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(proxy, <span class=\"hljs-string\">&#x27;baz&#x27;</span>)<br><span class=\"hljs-comment\">// &#123; value: &#x27;tar&#x27;, writable: true, enumerable: true, configurable: true &#125;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"getPrototypeOf\"><a href=\"#getPrototypeOf\" class=\"headerlink\" title=\"getPrototypeOf()\"></a>getPrototypeOf()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> proto = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-title function_\">getPrototypeOf</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> proto;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(p) === proto <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"isExtensible\"><a href=\"#isExtensible\" class=\"headerlink\" title=\"isExtensible()\"></a>isExtensible()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(&#123;&#125;, &#123;<br>    <span class=\"hljs-attr\">isExtensible</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;called&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;);<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">isExtensible</span>(p)<br></code></pre></td></tr></table></figure>\n<h4 id=\"ownKeys\"><a href=\"#ownKeys\" class=\"headerlink\" title=\"ownKeys()\"></a>ownKeys()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> target = &#123;<br>    <span class=\"hljs-attr\">_bar</span>: <span class=\"hljs-string\">&#x27;foo&#x27;</span>,<br>    <span class=\"hljs-attr\">_prop</span>: <span class=\"hljs-string\">&#x27;bar&#x27;</span>,<br>    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">&#x27;baz&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> handler = &#123;<br>    <span class=\"hljs-title function_\">ownKeys</span>(<span class=\"hljs-params\">target</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(target).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> key[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">&#x27;_&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, handler);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(proxy)) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(target[key]); <span class=\"hljs-comment\">// baz</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"取消代理\"><a href=\"#取消代理\" class=\"headerlink\" title=\"取消代理\"></a>取消代理</h3><p>Proxy.revocable()方法返回一个可取消的Proxy实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> target = &#123;&#125;;<br><span class=\"hljs-keyword\">let</span> handler = &#123;&#125;;<br><br><span class=\"hljs-keyword\">let</span> &#123;proxy, revoke&#125; = <span class=\"hljs-title class_\">Proxy</span>.<span class=\"hljs-title function_\">revocable</span>(target, handler);<br><br>proxy.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-number\">123</span>;<br>proxy.<span class=\"hljs-property\">foo</span> <span class=\"hljs-comment\">// 123</span><br><br><span class=\"hljs-title function_\">revoke</span>();<br>proxy.<span class=\"hljs-property\">foo</span> <span class=\"hljs-comment\">// TypeError: Revoked</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"this问题\"><a href=\"#this问题\" class=\"headerlink\" title=\"this问题\"></a>this问题</h3><p>虽然Proxy可以代理针对目标对象的访问，但不是目标对象的透明代理：即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因是在Proxy代理的情况下，目标对象内部的<code>this</code>关键字会指向Proxy代理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> _name = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>        _name.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, name);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">name</span>() &#123;<br>        <span class=\"hljs-keyword\">return</span> _name.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> jane = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;Jane&#x27;</span>);<br>jane.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">// &quot;Jane&quot;</span><br><br><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(jane, &#123;&#125;);<br>proxy.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Reflect也是ES6为了操作对象而提供的新API，其设计目的主要有几个：</p>\n<ol>\n<li>将Object对象的一些明显属于语言内部的方法放到Reflect对象上。</li>\n<li>修改某些Object方法返回的结果，让其变得合理。</li>\n<li>让Object的操作都变成函数行为。某些Object操作是命令式的；</li>\n<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> loggedObj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, &#123;<br>    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;get&#x27;</span>, target, name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, name);<br>    &#125;,<br>    <span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;delete&#x27;</span> + name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(target, name);<br>    &#125;,<br>    <span class=\"hljs-title function_\">has</span>(<span class=\"hljs-params\">target, name</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;has&#x27;</span> + name);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">has</span>(target, name);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"Reflect对象的方法\"><a href=\"#Reflect对象的方法\" class=\"headerlink\" title=\"Reflect对象的方法\"></a>Reflect对象的方法</h3><p>大体上和Object对象的同名方法的作用是相同的，而且与Proxy对象的方法是一一对应的。</p>\n"},{"title":"ES6 正则表达式","date":"2022-02-17T06:59:44.000Z","updated":"2022-02-17T06:59:44.000Z","_content":"\n# 正则表达式\n\n## 基本概念\n\n用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。模式匹配常用在`RegExp` `exec` `test`方法，以及`String`的`match`、`matchAll`、`replace`、`search`和`split`方法。\n\n## 创建语法\n\n使用下面两种方法都可以创建：\n\n```javascript\n// method 1\nvar re = /abc/ig; // 其中ig为正则对象修饰符\n\n// method 2\nvar re = new RegExp(/abc/ig); // 返回一个原有正则表达式的拷贝\n```\n\n除此之外ES6还提供了带两个参数的`RegExp`函数，但是在ES5这种写法是非法的。ES6中则放款了此项限制：\n\n```javascript\nvar regex = new RegExp(/xyz/, 'i'); // ES5中报错、但是在ES6中是允许的\n// regex \"i\" 第二个参数为指定修饰符，返回的正则表达式对象会忽略原有的修饰符，只使用新指定的修饰符\n```\n\n## ES6新增功能：`u`修饰符\n\n`u字符`为Unicode字符的意思，可以识别码点超过`0xFFFF`的字符。前一章节也讲过ES6加入了Unicode字符表示。因此正则也是可以支持Unicode的模式识别的。例子如下：\n\n```javascript\n/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n```\n\n### 预定义模式\n\n另外`u`字符也会影响预定义模式，能否正确识别大于`0xFFFF`的Unicode字符：\n\n```javascript\nfunction codePointLength(text) {\n    var result = text.match(/[\\s\\S]/gu);\n    return result ? result.length : 0;\n}\n\nvar s = '\\u{20BB7}\\u{20BB7}';\n\ns.length // 4\ncodePointLength(s) // 2\n```\n\n## ES6新增功能：`y`修饰符\n\n`y`字符也称为粘连字符，其作用于`g`修饰符类似。后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于`g`修饰符只要剩余位置中存在匹配即可，而`y`修饰符确保匹配必须从剩余的第一个位置开始；例子如下：\n\n```javascript\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr1.exec(s);\n[ 'aa', index: 4, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\nnull\n\nr1.exec(s);\n[ 'a', index: 7, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr1.exec(s);\nnull\n\nr2.exec(s);\nnull\n```\n\n### 例子：`g`修饰符和`y`修饰符的区别\n\n使用`g`修饰符和`lastIndex`来验证运行方式\n\n```javascript\nconst REGEX = /a/g;\n\nREGEX.lastIndex = 2; // 默认从2开始匹配（数组下标2）\nconst match = REGEX.exec('xaya');\n\nmatch.index // 3 也就是指定位置向后搜索字符'a'\n\nREGEX.lastIndex // 4 从下一次匹配的位置开始\nREGEX.exec('xaya') // null\n```\n\n使用`y`修饰符和`lastIndex`来验证运行方式\n\n```javascript\nconst REGEX = /a/y;\n\nREGEX.lastIndex = 2;\nREGEX.exec('xaya') // null 不是粘连，因为位置2指向的是字符'y'\n\nREGEX.lastIndex = 3;\n\nconst match = REGEX.exec('xaxa');\nmatch.index // 3\nREGEX.lastIndex // 4\n```\n\n### sticky属性\n\nES6正则对象多了`sticky`属性，表示是否设置了`y`修饰符。\n\n```javascript\nvar r = /hello\\d/y;\nr.sticky // true\n```\n\n### flags属性\n\nES6为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。\n\n```javascript\n/abc/ig.source // \"abc\"\n\n/abc/ig.flags // \"gi\"\n```\n\n## ES6新增功能：`s`修饰符\n\n### dotAll模式：即点代表一切字符\n\n正则表达式中`.`是个特殊字符，可以用于表示任意的单个字符。但是它排除了行终止符。而有时候我们希望匹配的是任意单个字符，因此，提案中引入了`/s`修饰符，使得`.`可以匹配任意单个字符。\n\n```javascript\n/foo.bar/s.test('foo\\nbar') // true\n```\n\n### 先行断言\n\nES5中，JavaScript的正则表达式只支持“先行断言”和“先行否定断言”。先行断言的意思是：`x`只有在`y`前面才匹配，对应的正则模式需写成`/x(?=y)/`。同理：先行否定断言是指：`x`只有不在`y`前面才匹配，对应的正则匹配模式为：`/x(?!y)/`\n\n### 后行断言\n\nES7中新增了一个提案，允许正则表达式进行“后行断言”。后行断言的意思是：`x`只有在`y`的后面才匹配，必须写成`/(?<=y)x/`。同理：后行否定断言是指：x只有不在y后面才匹配，对应的正则匹配模式为：`/(?<!y)x/`\n\n## Unicode属性类\n\n目前有一个新提案，允许正则表达式匹配符合Unicode某种属性的所有字符，使用前一定要加上`u`字符：\n\n```javascript\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π'); // true\n```\n\nUnicode属性类要指定属性名和属性值：\n\n```javascript\n// 需要指定Unicode属性名和属性值\n\\p{UnicodePropertyName=UnicodePropertyValue}\n\n// 对于某些属性，可以只写属性名\n\\p{UnicodePropertyName}\n```\n","source":"_posts/javascript/es6-regexp.md","raw":"---\ntitle: ES6 正则表达式\ndate: 2022-02-17 14:59:44\nupdated: 2022-02-17 14:59:44\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 正则表达式\n\n## 基本概念\n\n用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。模式匹配常用在`RegExp` `exec` `test`方法，以及`String`的`match`、`matchAll`、`replace`、`search`和`split`方法。\n\n## 创建语法\n\n使用下面两种方法都可以创建：\n\n```javascript\n// method 1\nvar re = /abc/ig; // 其中ig为正则对象修饰符\n\n// method 2\nvar re = new RegExp(/abc/ig); // 返回一个原有正则表达式的拷贝\n```\n\n除此之外ES6还提供了带两个参数的`RegExp`函数，但是在ES5这种写法是非法的。ES6中则放款了此项限制：\n\n```javascript\nvar regex = new RegExp(/xyz/, 'i'); // ES5中报错、但是在ES6中是允许的\n// regex \"i\" 第二个参数为指定修饰符，返回的正则表达式对象会忽略原有的修饰符，只使用新指定的修饰符\n```\n\n## ES6新增功能：`u`修饰符\n\n`u字符`为Unicode字符的意思，可以识别码点超过`0xFFFF`的字符。前一章节也讲过ES6加入了Unicode字符表示。因此正则也是可以支持Unicode的模式识别的。例子如下：\n\n```javascript\n/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n```\n\n### 预定义模式\n\n另外`u`字符也会影响预定义模式，能否正确识别大于`0xFFFF`的Unicode字符：\n\n```javascript\nfunction codePointLength(text) {\n    var result = text.match(/[\\s\\S]/gu);\n    return result ? result.length : 0;\n}\n\nvar s = '\\u{20BB7}\\u{20BB7}';\n\ns.length // 4\ncodePointLength(s) // 2\n```\n\n## ES6新增功能：`y`修饰符\n\n`y`字符也称为粘连字符，其作用于`g`修饰符类似。后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于`g`修饰符只要剩余位置中存在匹配即可，而`y`修饰符确保匹配必须从剩余的第一个位置开始；例子如下：\n\n```javascript\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr1.exec(s);\n[ 'aa', index: 4, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\nnull\n\nr1.exec(s);\n[ 'a', index: 7, input: 'aaa_aa_a', groups: undefined ]\n\nr2.exec(s);\n[ 'aaa', index: 0, input: 'aaa_aa_a', groups: undefined ]\n\nr1.exec(s);\nnull\n\nr2.exec(s);\nnull\n```\n\n### 例子：`g`修饰符和`y`修饰符的区别\n\n使用`g`修饰符和`lastIndex`来验证运行方式\n\n```javascript\nconst REGEX = /a/g;\n\nREGEX.lastIndex = 2; // 默认从2开始匹配（数组下标2）\nconst match = REGEX.exec('xaya');\n\nmatch.index // 3 也就是指定位置向后搜索字符'a'\n\nREGEX.lastIndex // 4 从下一次匹配的位置开始\nREGEX.exec('xaya') // null\n```\n\n使用`y`修饰符和`lastIndex`来验证运行方式\n\n```javascript\nconst REGEX = /a/y;\n\nREGEX.lastIndex = 2;\nREGEX.exec('xaya') // null 不是粘连，因为位置2指向的是字符'y'\n\nREGEX.lastIndex = 3;\n\nconst match = REGEX.exec('xaxa');\nmatch.index // 3\nREGEX.lastIndex // 4\n```\n\n### sticky属性\n\nES6正则对象多了`sticky`属性，表示是否设置了`y`修饰符。\n\n```javascript\nvar r = /hello\\d/y;\nr.sticky // true\n```\n\n### flags属性\n\nES6为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。\n\n```javascript\n/abc/ig.source // \"abc\"\n\n/abc/ig.flags // \"gi\"\n```\n\n## ES6新增功能：`s`修饰符\n\n### dotAll模式：即点代表一切字符\n\n正则表达式中`.`是个特殊字符，可以用于表示任意的单个字符。但是它排除了行终止符。而有时候我们希望匹配的是任意单个字符，因此，提案中引入了`/s`修饰符，使得`.`可以匹配任意单个字符。\n\n```javascript\n/foo.bar/s.test('foo\\nbar') // true\n```\n\n### 先行断言\n\nES5中，JavaScript的正则表达式只支持“先行断言”和“先行否定断言”。先行断言的意思是：`x`只有在`y`前面才匹配，对应的正则模式需写成`/x(?=y)/`。同理：先行否定断言是指：`x`只有不在`y`前面才匹配，对应的正则匹配模式为：`/x(?!y)/`\n\n### 后行断言\n\nES7中新增了一个提案，允许正则表达式进行“后行断言”。后行断言的意思是：`x`只有在`y`的后面才匹配，必须写成`/(?<=y)x/`。同理：后行否定断言是指：x只有不在y后面才匹配，对应的正则匹配模式为：`/(?<!y)x/`\n\n## Unicode属性类\n\n目前有一个新提案，允许正则表达式匹配符合Unicode某种属性的所有字符，使用前一定要加上`u`字符：\n\n```javascript\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π'); // true\n```\n\nUnicode属性类要指定属性名和属性值：\n\n```javascript\n// 需要指定Unicode属性名和属性值\n\\p{UnicodePropertyName=UnicodePropertyValue}\n\n// 对于某些属性，可以只写属性名\n\\p{UnicodePropertyName}\n```\n","slug":"javascript/es6-regexp","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl39001z2y61arqg962f","content":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。模式匹配常用在<code>RegExp</code> <code>exec</code> <code>test</code>方法，以及<code>String</code>的<code>match</code>、<code>matchAll</code>、<code>replace</code>、<code>search</code>和<code>split</code>方法。</p>\n<h2 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h2><p>使用下面两种方法都可以创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// method 1</span><br><span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-regexp\">/abc/ig</span>; <span class=\"hljs-comment\">// 其中ig为正则对象修饰符</span><br><br><span class=\"hljs-comment\">// method 2</span><br><span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/abc/ig</span>); <span class=\"hljs-comment\">// 返回一个原有正则表达式的拷贝</span><br></code></pre></td></tr></table></figure>\n<p>除此之外ES6还提供了带两个参数的<code>RegExp</code>函数，但是在ES5这种写法是非法的。ES6中则放款了此项限制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> regex = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/xyz/</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>); <span class=\"hljs-comment\">// ES5中报错、但是在ES6中是允许的</span><br><span class=\"hljs-comment\">// regex &quot;i&quot; 第二个参数为指定修饰符，返回的正则表达式对象会忽略原有的修饰符，只使用新指定的修饰符</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：u修饰符\"><a href=\"#ES6新增功能：u修饰符\" class=\"headerlink\" title=\"ES6新增功能：u修饰符\"></a>ES6新增功能：<code>u</code>修饰符</h2><p><code>u字符</code>为Unicode字符的意思，可以识别码点超过<code>0xFFFF</code>的字符。前一章节也讲过ES6加入了Unicode字符表示。因此正则也是可以支持Unicode的模式识别的。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/\\u&#123;<span class=\"hljs-number\">61</span>&#125;/.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-comment\">// false</span><br>/\\u&#123;<span class=\"hljs-number\">61</span>&#125;/u.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>/\\u&#123;20BB7&#125;/u.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;𠮷&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"预定义模式\"><a href=\"#预定义模式\" class=\"headerlink\" title=\"预定义模式\"></a>预定义模式</h3><p>另外<code>u</code>字符也会影响预定义模式，能否正确识别大于<code>0xFFFF</code>的Unicode字符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">codePointLength</span>(<span class=\"hljs-params\">text</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = text.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/[\\s\\S]/gu</span>);<br>    <span class=\"hljs-keyword\">return</span> result ? result.<span class=\"hljs-property\">length</span> : <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&#x27;\\u&#123;20BB7&#125;\\u&#123;20BB7&#125;&#x27;</span>;<br><br>s.<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title function_\">codePointLength</span>(s) <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：y修饰符\"><a href=\"#ES6新增功能：y修饰符\" class=\"headerlink\" title=\"ES6新增功能：y修饰符\"></a>ES6新增功能：<code>y</code>修饰符</h2><p><code>y</code>字符也称为粘连字符，其作用于<code>g</code>修饰符类似。后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于<code>g</code>修饰符只要剩余位置中存在匹配即可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始；例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> r1 = <span class=\"hljs-regexp\">/a+/g</span>;<br><span class=\"hljs-keyword\">var</span> r2 = <span class=\"hljs-regexp\">/a+/y</span>;<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">7</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"例子：g修饰符和y修饰符的区别\"><a href=\"#例子：g修饰符和y修饰符的区别\" class=\"headerlink\" title=\"例子：g修饰符和y修饰符的区别\"></a>例子：<code>g</code>修饰符和<code>y</code>修饰符的区别</h3><p>使用<code>g</code>修饰符和<code>lastIndex</code>来验证运行方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">REGEX</span> = <span class=\"hljs-regexp\">/a/g</span>;<br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 默认从2开始匹配（数组下标2）</span><br><span class=\"hljs-keyword\">const</span> match = <span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>);<br><br>match.<span class=\"hljs-property\">index</span> <span class=\"hljs-comment\">// 3 也就是指定位置向后搜索字符&#x27;a&#x27;</span><br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> <span class=\"hljs-comment\">// 4 从下一次匹配的位置开始</span><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>) <span class=\"hljs-comment\">// null</span><br></code></pre></td></tr></table></figure>\n<p>使用<code>y</code>修饰符和<code>lastIndex</code>来验证运行方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">REGEX</span> = <span class=\"hljs-regexp\">/a/y</span>;<br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>) <span class=\"hljs-comment\">// null 不是粘连，因为位置2指向的是字符&#x27;y&#x27;</span><br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-keyword\">const</span> match = <span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaxa&#x27;</span>);<br>match.<span class=\"hljs-property\">index</span> <span class=\"hljs-comment\">// 3</span><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> <span class=\"hljs-comment\">// 4</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"sticky属性\"><a href=\"#sticky属性\" class=\"headerlink\" title=\"sticky属性\"></a>sticky属性</h3><p>ES6正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> r = <span class=\"hljs-regexp\">/hello\\d/y</span>;<br>r.<span class=\"hljs-property\">sticky</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"flags属性\"><a href=\"#flags属性\" class=\"headerlink\" title=\"flags属性\"></a>flags属性</h3><p>ES6为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/abc/ig.<span class=\"hljs-property\">source</span> <span class=\"hljs-comment\">// &quot;abc&quot;</span><br><br>/abc/ig.<span class=\"hljs-property\">flags</span> <span class=\"hljs-comment\">// &quot;gi&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：s修饰符\"><a href=\"#ES6新增功能：s修饰符\" class=\"headerlink\" title=\"ES6新增功能：s修饰符\"></a>ES6新增功能：<code>s</code>修饰符</h2><h3 id=\"dotAll模式：即点代表一切字符\"><a href=\"#dotAll模式：即点代表一切字符\" class=\"headerlink\" title=\"dotAll模式：即点代表一切字符\"></a>dotAll模式：即点代表一切字符</h3><p>正则表达式中<code>.</code>是个特殊字符，可以用于表示任意的单个字符。但是它排除了行终止符。而有时候我们希望匹配的是任意单个字符，因此，提案中引入了<code>/s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/foo.<span class=\"hljs-property\">bar</span>/s.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;foo\\nbar&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>ES5中，JavaScript的正则表达式只支持“先行断言”和“先行否定断言”。先行断言的意思是：<code>x</code>只有在<code>y</code>前面才匹配，对应的正则模式需写成<code>/x(?=y)/</code>。同理：先行否定断言是指：<code>x</code>只有不在<code>y</code>前面才匹配，对应的正则匹配模式为：<code>/x(?!y)/</code></p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>ES7中新增了一个提案，允许正则表达式进行“后行断言”。后行断言的意思是：<code>x</code>只有在<code>y</code>的后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。同理：后行否定断言是指：x只有不在y后面才匹配，对应的正则匹配模式为：<code>/(?&lt;!y)x/</code></p>\n<h2 id=\"Unicode属性类\"><a href=\"#Unicode属性类\" class=\"headerlink\" title=\"Unicode属性类\"></a>Unicode属性类</h2><p>目前有一个新提案，允许正则表达式匹配符合Unicode某种属性的所有字符，使用前一定要加上<code>u</code>字符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> regexGreekSymbol = <span class=\"hljs-regexp\">/\\p&#123;Script=Greek&#125;/u</span>;<br>regexGreekSymbol.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;π&#x27;</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>Unicode属性类要指定属性名和属性值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 需要指定Unicode属性名和属性值</span><br>\\p&#123;<span class=\"hljs-title class_\">UnicodePropertyName</span>=<span class=\"hljs-title class_\">UnicodePropertyValue</span>&#125;<br><br><span class=\"hljs-comment\">// 对于某些属性，可以只写属性名</span><br>\\p&#123;<span class=\"hljs-title class_\">UnicodePropertyName</span>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2883,"excerpt":"","more":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象。模式匹配常用在<code>RegExp</code> <code>exec</code> <code>test</code>方法，以及<code>String</code>的<code>match</code>、<code>matchAll</code>、<code>replace</code>、<code>search</code>和<code>split</code>方法。</p>\n<h2 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h2><p>使用下面两种方法都可以创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// method 1</span><br><span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-regexp\">/abc/ig</span>; <span class=\"hljs-comment\">// 其中ig为正则对象修饰符</span><br><br><span class=\"hljs-comment\">// method 2</span><br><span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/abc/ig</span>); <span class=\"hljs-comment\">// 返回一个原有正则表达式的拷贝</span><br></code></pre></td></tr></table></figure>\n<p>除此之外ES6还提供了带两个参数的<code>RegExp</code>函数，但是在ES5这种写法是非法的。ES6中则放款了此项限制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> regex = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/xyz/</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>); <span class=\"hljs-comment\">// ES5中报错、但是在ES6中是允许的</span><br><span class=\"hljs-comment\">// regex &quot;i&quot; 第二个参数为指定修饰符，返回的正则表达式对象会忽略原有的修饰符，只使用新指定的修饰符</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：u修饰符\"><a href=\"#ES6新增功能：u修饰符\" class=\"headerlink\" title=\"ES6新增功能：u修饰符\"></a>ES6新增功能：<code>u</code>修饰符</h2><p><code>u字符</code>为Unicode字符的意思，可以识别码点超过<code>0xFFFF</code>的字符。前一章节也讲过ES6加入了Unicode字符表示。因此正则也是可以支持Unicode的模式识别的。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/\\u&#123;<span class=\"hljs-number\">61</span>&#125;/.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-comment\">// false</span><br>/\\u&#123;<span class=\"hljs-number\">61</span>&#125;/u.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>/\\u&#123;20BB7&#125;/u.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;𠮷&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"预定义模式\"><a href=\"#预定义模式\" class=\"headerlink\" title=\"预定义模式\"></a>预定义模式</h3><p>另外<code>u</code>字符也会影响预定义模式，能否正确识别大于<code>0xFFFF</code>的Unicode字符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">codePointLength</span>(<span class=\"hljs-params\">text</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = text.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/[\\s\\S]/gu</span>);<br>    <span class=\"hljs-keyword\">return</span> result ? result.<span class=\"hljs-property\">length</span> : <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&#x27;\\u&#123;20BB7&#125;\\u&#123;20BB7&#125;&#x27;</span>;<br><br>s.<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 4</span><br><span class=\"hljs-title function_\">codePointLength</span>(s) <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：y修饰符\"><a href=\"#ES6新增功能：y修饰符\" class=\"headerlink\" title=\"ES6新增功能：y修饰符\"></a>ES6新增功能：<code>y</code>修饰符</h2><p><code>y</code>字符也称为粘连字符，其作用于<code>g</code>修饰符类似。后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于<code>g</code>修饰符只要剩余位置中存在匹配即可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始；例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> r1 = <span class=\"hljs-regexp\">/a+/g</span>;<br><span class=\"hljs-keyword\">var</span> r2 = <span class=\"hljs-regexp\">/a+/y</span>;<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">7</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br>[ <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">index</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;aaa_aa_a&#x27;</span>, <span class=\"hljs-attr\">groups</span>: <span class=\"hljs-literal\">undefined</span> ]<br><br>r1.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br><br>r2.<span class=\"hljs-title function_\">exec</span>(s);<br><span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"例子：g修饰符和y修饰符的区别\"><a href=\"#例子：g修饰符和y修饰符的区别\" class=\"headerlink\" title=\"例子：g修饰符和y修饰符的区别\"></a>例子：<code>g</code>修饰符和<code>y</code>修饰符的区别</h3><p>使用<code>g</code>修饰符和<code>lastIndex</code>来验证运行方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">REGEX</span> = <span class=\"hljs-regexp\">/a/g</span>;<br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 默认从2开始匹配（数组下标2）</span><br><span class=\"hljs-keyword\">const</span> match = <span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>);<br><br>match.<span class=\"hljs-property\">index</span> <span class=\"hljs-comment\">// 3 也就是指定位置向后搜索字符&#x27;a&#x27;</span><br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> <span class=\"hljs-comment\">// 4 从下一次匹配的位置开始</span><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>) <span class=\"hljs-comment\">// null</span><br></code></pre></td></tr></table></figure>\n<p>使用<code>y</code>修饰符和<code>lastIndex</code>来验证运行方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">REGEX</span> = <span class=\"hljs-regexp\">/a/y</span>;<br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaya&#x27;</span>) <span class=\"hljs-comment\">// null 不是粘连，因为位置2指向的是字符&#x27;y&#x27;</span><br><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-keyword\">const</span> match = <span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;xaxa&#x27;</span>);<br>match.<span class=\"hljs-property\">index</span> <span class=\"hljs-comment\">// 3</span><br><span class=\"hljs-variable constant_\">REGEX</span>.<span class=\"hljs-property\">lastIndex</span> <span class=\"hljs-comment\">// 4</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"sticky属性\"><a href=\"#sticky属性\" class=\"headerlink\" title=\"sticky属性\"></a>sticky属性</h3><p>ES6正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> r = <span class=\"hljs-regexp\">/hello\\d/y</span>;<br>r.<span class=\"hljs-property\">sticky</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"flags属性\"><a href=\"#flags属性\" class=\"headerlink\" title=\"flags属性\"></a>flags属性</h3><p>ES6为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/abc/ig.<span class=\"hljs-property\">source</span> <span class=\"hljs-comment\">// &quot;abc&quot;</span><br><br>/abc/ig.<span class=\"hljs-property\">flags</span> <span class=\"hljs-comment\">// &quot;gi&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"ES6新增功能：s修饰符\"><a href=\"#ES6新增功能：s修饰符\" class=\"headerlink\" title=\"ES6新增功能：s修饰符\"></a>ES6新增功能：<code>s</code>修饰符</h2><h3 id=\"dotAll模式：即点代表一切字符\"><a href=\"#dotAll模式：即点代表一切字符\" class=\"headerlink\" title=\"dotAll模式：即点代表一切字符\"></a>dotAll模式：即点代表一切字符</h3><p>正则表达式中<code>.</code>是个特殊字符，可以用于表示任意的单个字符。但是它排除了行终止符。而有时候我们希望匹配的是任意单个字符，因此，提案中引入了<code>/s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">/foo.<span class=\"hljs-property\">bar</span>/s.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;foo\\nbar&#x27;</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>ES5中，JavaScript的正则表达式只支持“先行断言”和“先行否定断言”。先行断言的意思是：<code>x</code>只有在<code>y</code>前面才匹配，对应的正则模式需写成<code>/x(?=y)/</code>。同理：先行否定断言是指：<code>x</code>只有不在<code>y</code>前面才匹配，对应的正则匹配模式为：<code>/x(?!y)/</code></p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>ES7中新增了一个提案，允许正则表达式进行“后行断言”。后行断言的意思是：<code>x</code>只有在<code>y</code>的后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。同理：后行否定断言是指：x只有不在y后面才匹配，对应的正则匹配模式为：<code>/(?&lt;!y)x/</code></p>\n<h2 id=\"Unicode属性类\"><a href=\"#Unicode属性类\" class=\"headerlink\" title=\"Unicode属性类\"></a>Unicode属性类</h2><p>目前有一个新提案，允许正则表达式匹配符合Unicode某种属性的所有字符，使用前一定要加上<code>u</code>字符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> regexGreekSymbol = <span class=\"hljs-regexp\">/\\p&#123;Script=Greek&#125;/u</span>;<br>regexGreekSymbol.<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">&#x27;π&#x27;</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>Unicode属性类要指定属性名和属性值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 需要指定Unicode属性名和属性值</span><br>\\p&#123;<span class=\"hljs-title class_\">UnicodePropertyName</span>=<span class=\"hljs-title class_\">UnicodePropertyValue</span>&#125;<br><br><span class=\"hljs-comment\">// 对于某些属性，可以只写属性名</span><br>\\p&#123;<span class=\"hljs-title class_\">UnicodePropertyName</span>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 Set和Map","date":"2022-02-17T07:16:56.000Z","updated":"2022-02-17T07:16:56.000Z","_content":"\n# Set和Map\n\n## Set\n\n### 基本用法\n\n类似与数组结构，但是数组中的成员值时唯一不重复的。跟Java中的Set是同样的意思。\n\n```javascript\nvar s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n也可以结合扩展运算符写成下面这样：\n\n```javascript\nvar set = new Set([1,2,3,4,5,2,3]);\n[...set] // 1 2 3 4 5\nset.size() // 5\n```\n\n### 实例的属性和方法\n\n除了构造函数以及返回size的大小，还有下面4个操作的方法：使用基本和Java相同\n\n- add(value)：添加某个值，返回Set结构本身\n- delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；\n- has(value)：返回一个布尔值，表示该值是否为Set成员\n- clear()：清除所有成员，没返回值。\n\n```javascript\nvar s = new Set();\ns.add(1).add(2).add(2);\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n### 遍历操作\n\n遍历器包含下面4个方法，可以用于遍历成员，结合Lambda表示可以有十分简洁的写法，跟Java 8的lambda表达式差不多，这里不再赘述。\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回键值对的遍历器\n- forEach()：使用回调函数遍历每个成员\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries) {\n  console.log(item)\n}\n// ['red', 'red']\n// ['green', 'green']\n// ['blue', 'blue']\n```\n\n### WeakSet\n\n从名字上看，WeakSet也是Set的一种，但是跟Set有下列几个区别：\n\n- 成员只能是对象，不能是其他类型的值；\n- 集合内的对象全都是弱引用，GC不会考虑对WeakSet中的对象的引用，因此WeakSet是不可遍历的。\n\n你可能会问，WeakSet的这种特性有什么用呢？由于不能遍历且内存中的对象随时会丢失，因此十分适合存储DOM节点，而不用担心这些节点从文档移除时引发内存泄露。\n\n```javascript\nconst foos = new WeakSet();\n\nclass foo {\n  constructor() {\n    foos.add(this);\n  }\n  \n  method() {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method智能在Foo实例上调用!')\n    }\n  }\n}\n```\n\n\n\n## Map\n\n### 基本用法\n\nJavaScript的对象本质上也是键值对的集合，但是传统上只能用字符串当键。因为ES6提供了Map这个对象。概念跟Java中的差不多。与JavaScript中对象唯一不同的是：它的键不仅限于字符串，还可以是其他类型。\n\n```javascript\nvar m = new Map();\nvar o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o)\n\nm.has(o)\nm.delete(o)\nm.has(o)\n```\n\n与此同时，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n```javascript\nvar map = new Map([\n    ['name', 'zhangsan'],\n    ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // zhangsan\nmap.has('title') // true\nmap.get('title') // Author\n```\n\n### 实例的属性和方法\n\n跟上面提到的Set一样，Map也有属于自己的实例属性和方法。\n\n- size：返回Map结构的成员总数\n- set(key, value)：设置key对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新；\n- get(key)：读取key对应的键值，如果找不到则返回undefined；\n- has(key)：返回一个布尔值，表示某个键是否在Map数据结构中；\n- delete(key)：删除某个键，返回true，如果删除失败则返回false；\n- clear()：清除所有成员，没有返回值；\n\n### 遍历方法\n\nMap提供了三个原生的遍历器生成函数和一个遍历方法，这个和之前的Set很相似；\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回所有成员的遍历器\n- forEach()：返回Map的所有成员\n\n下面提供一个实例的使用方法：\n\n```javascript\nlet map = new Map([\n    ['F', 'no'],\n    ['T', 'yes']\n]);\n\nfor (let key of map.keys()) {\n    console.log(key);\n}\n\nfor (let value of map.values()) {\n    console.log(value);\n}\n\nfor (let item of map.entries()) {\n    console.log(item)\n}\n\nfor (let [key, value] of map.entries()) {\n    console.log(key, value)\n}\n\nfor (let [key, value] of map) {\n    console.log(key, value)\n}\n```\n\n同样的，使用扩展运算符可以将Map快速转换为数组。\n\n```javascript\nlet map = new Map([\n    [1, 'one'],\n    [2, 'two'],\n    [3, 'three']\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1, 'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1, 'one'], [2, 'two'], [3, 'three']]\n```\n\n结合map和Filter等方法可以实现更加方便简洁的操作。\n\n```javascript\nlet map0 = new Map()\n\t.set(1, 'a')\n\t.set(2, 'b')\n\t.set(3, 'c');\n\nlet map1 = new Map(\n\t[...map0].filter([k, v] => k < 3)\n);\n\nlet map2 = new Map(\n\t[...map0].map([k, v] => [k * 2, '_' + v])\n);\n```\n\n此外，还有forEach方法，可以实现遍历。效果和Set上的forEach完全一样\n\n```javascript\nmap.forEach(function (key, value, map) {\n    console.log(\"key: %s, value: %s\", key, value);\n});\n\n// 还可以绑定this\nmap.forEach(function (key, value, map){\n    this.report(key, value);\n}, reporter);\n```\n\n### 与其他数据结构的互相转换\n\n### Map转数组\n\n前面已经提到，使用扩展运算符可以很好地将Map转换成数组，这里不再赘述；\n\n### 数组转Map\n\n将数组作为参数传入Map的构造函数，就可以将数组转换为Map\n\n### Map转对象\n\n如果Map中的所有键都是字符串，那么就可以将其转换为对象\n\n```javascript\nfunction strMapToObj(strMap) {\n    let obj = Object.create(null);\n    for (let [k, v] of strMap) {\n        obj[k] = v;\n    }\n    return obj;\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToObj(myMap)\n```\n\n### 对象转Map\n\n```javascript\nfunction objToStrMap(obj) {\n    let strMap = new Map();\n    for (let k of Object.keys(obj)) {\n        strMap.set(k, obj[k]);\n    }\n    return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n```\n\n### Map转JSON\n\nMap转JSON要分为两种情况：如果键名都是字符串，那么可以直接转成JSON；如果键名中有非字符串，这时可以选择转为数组JSON。\n\n```javascript\n// Map --> JSON (1)\nfunction strMapToJson(strMap) {\n    return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n\nfunction mapToArrayJson(map) {\n    return JSON.stringify([...map]);\n}\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n```\n\n### JSON转Map\n\n跟上面的情况一样：所有键名都是字符串，随便转；另外一个：整个JSON就是数组，每个数组成员本身又只有一个两个成员的数组。这个时候可以一一对应转换为Map。\n\n```javascript\nfunction jsonToMap(jsonStr) {\n    return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true, 7], [{\"foo\":3}, [\"abc\"]]]')\n```\n\n### WeakMap\n\nWeakMap和Map基本类似，唯一区别就是：它只接受对象作为键名，不接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。跟WeakSet一样，设计它的目的有助于防止内存泄露：\n\n```javascript\nlet myElement = document.getElementById('logo');\nlet myWeakMap = new WeakMap();\n\nmyWeakMap.set(myElement, {timesClicked: 0});\n\nmyElement.addEventListener('click', function(){\n    let logoData = myWeakMap.get(myElement);\n    logoData.timesClicked ++;\n}, false);\n```\n\n上述代码设计了一个机制：每当DOM中节点发生click事件，就更新一下状态。一旦这个DOM节点删除，该状态就会自动消失，不会存在内存泄露的风险。\n\nWeakMap的另一个作用就是部署私有属性\n\n```javascript\nlet _counter = new WeakMap();\nlet _action = new WeakMap();\n\nclass Countdown {\n    constructor(counter, action) {\n        _counter.set(this, counter);\n        _action.set(this, action);\n    }\n    dec() {\n        let counter = _counter.get(this);\n        if (counter < 1) return;\n        counter--;\n        _counter.set(this, counter);\n        if (counter === 0) {\n            _action.get(this)();\n        }\n    }\n}\n\nlet c = new Countdown(2, () => console.log('DONE'));\n\nc.dec()\nc.dec()\n// DONE\n```\n\n上面代码中，Countdown类的两个内部属性`_counter`和`_action`是实例的弱引用，所以如果删除实例，它们也就随之消失。不会造成内存泄露。\n","source":"_posts/javascript/es6-set-and-map.md","raw":"---\ntitle: ES6 Set和Map\ndate: 2022-02-17 15:16:56\nupdated: 2022-02-17 15:16:56\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Set和Map\n\n## Set\n\n### 基本用法\n\n类似与数组结构，但是数组中的成员值时唯一不重复的。跟Java中的Set是同样的意思。\n\n```javascript\nvar s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n也可以结合扩展运算符写成下面这样：\n\n```javascript\nvar set = new Set([1,2,3,4,5,2,3]);\n[...set] // 1 2 3 4 5\nset.size() // 5\n```\n\n### 实例的属性和方法\n\n除了构造函数以及返回size的大小，还有下面4个操作的方法：使用基本和Java相同\n\n- add(value)：添加某个值，返回Set结构本身\n- delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；\n- has(value)：返回一个布尔值，表示该值是否为Set成员\n- clear()：清除所有成员，没返回值。\n\n```javascript\nvar s = new Set();\ns.add(1).add(2).add(2);\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n### 遍历操作\n\n遍历器包含下面4个方法，可以用于遍历成员，结合Lambda表示可以有十分简洁的写法，跟Java 8的lambda表达式差不多，这里不再赘述。\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回键值对的遍历器\n- forEach()：使用回调函数遍历每个成员\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries) {\n  console.log(item)\n}\n// ['red', 'red']\n// ['green', 'green']\n// ['blue', 'blue']\n```\n\n### WeakSet\n\n从名字上看，WeakSet也是Set的一种，但是跟Set有下列几个区别：\n\n- 成员只能是对象，不能是其他类型的值；\n- 集合内的对象全都是弱引用，GC不会考虑对WeakSet中的对象的引用，因此WeakSet是不可遍历的。\n\n你可能会问，WeakSet的这种特性有什么用呢？由于不能遍历且内存中的对象随时会丢失，因此十分适合存储DOM节点，而不用担心这些节点从文档移除时引发内存泄露。\n\n```javascript\nconst foos = new WeakSet();\n\nclass foo {\n  constructor() {\n    foos.add(this);\n  }\n  \n  method() {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method智能在Foo实例上调用!')\n    }\n  }\n}\n```\n\n\n\n## Map\n\n### 基本用法\n\nJavaScript的对象本质上也是键值对的集合，但是传统上只能用字符串当键。因为ES6提供了Map这个对象。概念跟Java中的差不多。与JavaScript中对象唯一不同的是：它的键不仅限于字符串，还可以是其他类型。\n\n```javascript\nvar m = new Map();\nvar o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o)\n\nm.has(o)\nm.delete(o)\nm.has(o)\n```\n\n与此同时，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n```javascript\nvar map = new Map([\n    ['name', 'zhangsan'],\n    ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // zhangsan\nmap.has('title') // true\nmap.get('title') // Author\n```\n\n### 实例的属性和方法\n\n跟上面提到的Set一样，Map也有属于自己的实例属性和方法。\n\n- size：返回Map结构的成员总数\n- set(key, value)：设置key对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新；\n- get(key)：读取key对应的键值，如果找不到则返回undefined；\n- has(key)：返回一个布尔值，表示某个键是否在Map数据结构中；\n- delete(key)：删除某个键，返回true，如果删除失败则返回false；\n- clear()：清除所有成员，没有返回值；\n\n### 遍历方法\n\nMap提供了三个原生的遍历器生成函数和一个遍历方法，这个和之前的Set很相似；\n\n- keys()：返回键名的遍历器\n- values()：返回键值的遍历器\n- entries()：返回所有成员的遍历器\n- forEach()：返回Map的所有成员\n\n下面提供一个实例的使用方法：\n\n```javascript\nlet map = new Map([\n    ['F', 'no'],\n    ['T', 'yes']\n]);\n\nfor (let key of map.keys()) {\n    console.log(key);\n}\n\nfor (let value of map.values()) {\n    console.log(value);\n}\n\nfor (let item of map.entries()) {\n    console.log(item)\n}\n\nfor (let [key, value] of map.entries()) {\n    console.log(key, value)\n}\n\nfor (let [key, value] of map) {\n    console.log(key, value)\n}\n```\n\n同样的，使用扩展运算符可以将Map快速转换为数组。\n\n```javascript\nlet map = new Map([\n    [1, 'one'],\n    [2, 'two'],\n    [3, 'three']\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1, 'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1, 'one'], [2, 'two'], [3, 'three']]\n```\n\n结合map和Filter等方法可以实现更加方便简洁的操作。\n\n```javascript\nlet map0 = new Map()\n\t.set(1, 'a')\n\t.set(2, 'b')\n\t.set(3, 'c');\n\nlet map1 = new Map(\n\t[...map0].filter([k, v] => k < 3)\n);\n\nlet map2 = new Map(\n\t[...map0].map([k, v] => [k * 2, '_' + v])\n);\n```\n\n此外，还有forEach方法，可以实现遍历。效果和Set上的forEach完全一样\n\n```javascript\nmap.forEach(function (key, value, map) {\n    console.log(\"key: %s, value: %s\", key, value);\n});\n\n// 还可以绑定this\nmap.forEach(function (key, value, map){\n    this.report(key, value);\n}, reporter);\n```\n\n### 与其他数据结构的互相转换\n\n### Map转数组\n\n前面已经提到，使用扩展运算符可以很好地将Map转换成数组，这里不再赘述；\n\n### 数组转Map\n\n将数组作为参数传入Map的构造函数，就可以将数组转换为Map\n\n### Map转对象\n\n如果Map中的所有键都是字符串，那么就可以将其转换为对象\n\n```javascript\nfunction strMapToObj(strMap) {\n    let obj = Object.create(null);\n    for (let [k, v] of strMap) {\n        obj[k] = v;\n    }\n    return obj;\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToObj(myMap)\n```\n\n### 对象转Map\n\n```javascript\nfunction objToStrMap(obj) {\n    let strMap = new Map();\n    for (let k of Object.keys(obj)) {\n        strMap.set(k, obj[k]);\n    }\n    return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n```\n\n### Map转JSON\n\nMap转JSON要分为两种情况：如果键名都是字符串，那么可以直接转成JSON；如果键名中有非字符串，这时可以选择转为数组JSON。\n\n```javascript\n// Map --> JSON (1)\nfunction strMapToJson(strMap) {\n    return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n\nfunction mapToArrayJson(map) {\n    return JSON.stringify([...map]);\n}\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n```\n\n### JSON转Map\n\n跟上面的情况一样：所有键名都是字符串，随便转；另外一个：整个JSON就是数组，每个数组成员本身又只有一个两个成员的数组。这个时候可以一一对应转换为Map。\n\n```javascript\nfunction jsonToMap(jsonStr) {\n    return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true, 7], [{\"foo\":3}, [\"abc\"]]]')\n```\n\n### WeakMap\n\nWeakMap和Map基本类似，唯一区别就是：它只接受对象作为键名，不接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。跟WeakSet一样，设计它的目的有助于防止内存泄露：\n\n```javascript\nlet myElement = document.getElementById('logo');\nlet myWeakMap = new WeakMap();\n\nmyWeakMap.set(myElement, {timesClicked: 0});\n\nmyElement.addEventListener('click', function(){\n    let logoData = myWeakMap.get(myElement);\n    logoData.timesClicked ++;\n}, false);\n```\n\n上述代码设计了一个机制：每当DOM中节点发生click事件，就更新一下状态。一旦这个DOM节点删除，该状态就会自动消失，不会存在内存泄露的风险。\n\nWeakMap的另一个作用就是部署私有属性\n\n```javascript\nlet _counter = new WeakMap();\nlet _action = new WeakMap();\n\nclass Countdown {\n    constructor(counter, action) {\n        _counter.set(this, counter);\n        _action.set(this, action);\n    }\n    dec() {\n        let counter = _counter.get(this);\n        if (counter < 1) return;\n        counter--;\n        _counter.set(this, counter);\n        if (counter === 0) {\n            _action.get(this)();\n        }\n    }\n}\n\nlet c = new Countdown(2, () => console.log('DONE'));\n\nc.dec()\nc.dec()\n// DONE\n```\n\n上面代码中，Countdown类的两个内部属性`_counter`和`_action`是实例的弱引用，所以如果删除实例，它们也就随之消失。不会造成内存泄露。\n","slug":"javascript/es6-set-and-map","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3a00222y612jq7fkto","content":"<h1 id=\"Set和Map\"><a href=\"#Set和Map\" class=\"headerlink\" title=\"Set和Map\"></a>Set和Map</h1><h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>类似与数组结构，但是数组中的成员值时唯一不重复的。跟Java中的Set是同样的意思。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><br>[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> s.<span class=\"hljs-title function_\">add</span>(x));<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> s) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br><span class=\"hljs-comment\">// 2 3 5 4</span><br></code></pre></td></tr></table></figure>\n<p>也可以结合扩展运算符写成下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]);<br>[...set] <span class=\"hljs-comment\">// 1 2 3 4 5</span><br>set.<span class=\"hljs-title function_\">size</span>() <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法\"><a href=\"#实例的属性和方法\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><p>除了构造函数以及返回size的大小，还有下面4个操作的方法：使用基本和Java相同</p>\n<ul>\n<li>add(value)：添加某个值，返回Set结构本身</li>\n<li>delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；</li>\n<li>has(value)：返回一个布尔值，表示该值是否为Set成员</li>\n<li>clear()：清除所有成员，没返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>s.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>);<br><br>s.<span class=\"hljs-property\">size</span> <span class=\"hljs-comment\">// 2</span><br><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// false</span><br><br>s.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">2</span>);<br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历操作\"><a href=\"#遍历操作\" class=\"headerlink\" title=\"遍历操作\"></a>遍历操作</h3><p>遍历器包含下面4个方法，可以用于遍历成员，结合Lambda表示可以有十分简洁的写法，跟Java 8的lambda表达式差不多，这里不再赘述。</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回键值对的遍历器</li>\n<li>forEach()：使用回调函数遍历每个成员</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-title function_\">values</span>()) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-property\">entries</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item)<br>&#125;<br><span class=\"hljs-comment\">// [&#x27;red&#x27;, &#x27;red&#x27;]</span><br><span class=\"hljs-comment\">// [&#x27;green&#x27;, &#x27;green&#x27;]</span><br><span class=\"hljs-comment\">// [&#x27;blue&#x27;, &#x27;blue&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>从名字上看，WeakSet也是Set的一种，但是跟Set有下列几个区别：</p>\n<ul>\n<li>成员只能是对象，不能是其他类型的值；</li>\n<li>集合内的对象全都是弱引用，GC不会考虑对WeakSet中的对象的引用，因此WeakSet是不可遍历的。</li>\n</ul>\n<p>你可能会问，WeakSet的这种特性有什么用呢？由于不能遍历且内存中的对象随时会丢失，因此十分适合存储DOM节点，而不用担心这些节点从文档移除时引发内存泄露。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foos = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakSet</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">foo</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    foos.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!foos.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-variable language_\">this</span>)) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Foo.prototype.method智能在Foo实例上调用!&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>JavaScript的对象本质上也是键值对的集合，但是传统上只能用字符串当键。因为ES6提供了Map这个对象。概念跟Java中的差不多。与JavaScript中对象唯一不同的是：它的键不仅限于字符串，还可以是其他类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><span class=\"hljs-keyword\">var</span> o = &#123;<span class=\"hljs-attr\">p</span>: <span class=\"hljs-string\">&#x27;Hello World&#x27;</span>&#125;;<br><br>m.<span class=\"hljs-title function_\">set</span>(o, <span class=\"hljs-string\">&#x27;content&#x27;</span>)<br>m.<span class=\"hljs-title function_\">get</span>(o)<br><br>m.<span class=\"hljs-title function_\">has</span>(o)<br>m.<span class=\"hljs-title function_\">delete</span>(o)<br>m.<span class=\"hljs-title function_\">has</span>(o)<br></code></pre></td></tr></table></figure>\n<p>与此同时，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-string\">&#x27;name&#x27;</span>, <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span>],<br>    [<span class=\"hljs-string\">&#x27;title&#x27;</span>, <span class=\"hljs-string\">&#x27;Author&#x27;</span>]<br>]);<br><br>map.<span class=\"hljs-property\">size</span> <span class=\"hljs-comment\">// 2</span><br>map.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// zhangsan</span><br>map.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// Author</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法-1\"><a href=\"#实例的属性和方法-1\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><p>跟上面提到的Set一样，Map也有属于自己的实例属性和方法。</p>\n<ul>\n<li>size：返回Map结构的成员总数</li>\n<li>set(key, value)：设置key对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新；</li>\n<li>get(key)：读取key对应的键值，如果找不到则返回undefined；</li>\n<li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中；</li>\n<li>delete(key)：删除某个键，返回true，如果删除失败则返回false；</li>\n<li>clear()：清除所有成员，没有返回值；</li>\n</ul>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><p>Map提供了三个原生的遍历器生成函数和一个遍历方法，这个和之前的Set很相似；</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回所有成员的遍历器</li>\n<li>forEach()：返回Map的所有成员</li>\n</ul>\n<p>下面提供一个实例的使用方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-string\">&#x27;F&#x27;</span>, <span class=\"hljs-string\">&#x27;no&#x27;</span>],<br>    [<span class=\"hljs-string\">&#x27;T&#x27;</span>, <span class=\"hljs-string\">&#x27;yes&#x27;</span>]<br>]);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>同样的，使用扩展运算符可以将Map快速转换为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;one&#x27;</span>],<br>    [<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;two&#x27;</span>],<br>    [<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;three&#x27;</span>]<br>]);<br><br>[...map.<span class=\"hljs-title function_\">keys</span>()]<br><span class=\"hljs-comment\">// [1, 2, 3]</span><br><br>[...map.<span class=\"hljs-title function_\">values</span>()]<br><span class=\"hljs-comment\">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span><br><br>[...map.<span class=\"hljs-title function_\">entries</span>()]<br><span class=\"hljs-comment\">// [[1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span><br><br>[...map]<br><span class=\"hljs-comment\">// [[1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span><br></code></pre></td></tr></table></figure>\n<p>结合map和Filter等方法可以实现更加方便简洁的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map0 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>);<br><br><span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<br>\t[...map0].<span class=\"hljs-title function_\">filter</span>([k, v] =&gt; k &lt; <span class=\"hljs-number\">3</span>)<br>);<br><br><span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<br>\t[...map0].<span class=\"hljs-title function_\">map</span>([k, v] =&gt; [k * <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;_&#x27;</span> + v])<br>);<br></code></pre></td></tr></table></figure>\n<p>此外，还有forEach方法，可以实现遍历。效果和Set上的forEach完全一样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">map.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">key, value, map</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;key: %s, value: %s&quot;</span>, key, value);<br>&#125;);<br><br><span class=\"hljs-comment\">// 还可以绑定this</span><br>map.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">key, value, map</span>)&#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">report</span>(key, value);<br>&#125;, reporter);<br></code></pre></td></tr></table></figure>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><h3 id=\"Map转数组\"><a href=\"#Map转数组\" class=\"headerlink\" title=\"Map转数组\"></a>Map转数组</h3><p>前面已经提到，使用扩展运算符可以很好地将Map转换成数组，这里不再赘述；</p>\n<h3 id=\"数组转Map\"><a href=\"#数组转Map\" class=\"headerlink\" title=\"数组转Map\"></a>数组转Map</h3><p>将数组作为参数传入Map的构造函数，就可以将数组转换为Map</p>\n<h3 id=\"Map转对象\"><a href=\"#Map转对象\" class=\"headerlink\" title=\"Map转对象\"></a>Map转对象</h3><p>如果Map中的所有键都是字符串，那么就可以将其转换为对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">strMapToObj</span>(<span class=\"hljs-params\">strMap</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k, v] <span class=\"hljs-keyword\">of</span> strMap) &#123;<br>        obj[k] = v;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> obj;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;yes&#x27;</span>, <span class=\"hljs-literal\">true</span>).<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;no&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-title function_\">strMapToObj</span>(myMap)<br></code></pre></td></tr></table></figure>\n<h3 id=\"对象转Map\"><a href=\"#对象转Map\" class=\"headerlink\" title=\"对象转Map\"></a>对象转Map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">objToStrMap</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> strMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)) &#123;<br>        strMap.<span class=\"hljs-title function_\">set</span>(k, obj[k]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> strMap;<br>&#125;<br><br><span class=\"hljs-title function_\">objToStrMap</span>(&#123;<span class=\"hljs-attr\">yes</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">no</span>: <span class=\"hljs-literal\">false</span>&#125;)<br></code></pre></td></tr></table></figure>\n<h3 id=\"Map转JSON\"><a href=\"#Map转JSON\" class=\"headerlink\" title=\"Map转JSON\"></a>Map转JSON</h3><p>Map转JSON要分为两种情况：如果键名都是字符串，那么可以直接转成JSON；如果键名中有非字符串，这时可以选择转为数组JSON。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Map --&gt; JSON (1)</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">strMapToJson</span>(<span class=\"hljs-params\">strMap</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(<span class=\"hljs-title function_\">strMapToObj</span>(strMap));<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;yes&#x27;</span>, <span class=\"hljs-literal\">true</span>).<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;no&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-title function_\">strMapToJson</span>(myMap)<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mapToArrayJson</span>(<span class=\"hljs-params\">map</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>([...map]);<br>&#125;<br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">7</span>).<span class=\"hljs-title function_\">set</span>(&#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">3</span>&#125;, [<span class=\"hljs-string\">&#x27;abc&#x27;</span>]);<br><span class=\"hljs-title function_\">mapToArrayJson</span>(myMap)<br></code></pre></td></tr></table></figure>\n<h3 id=\"JSON转Map\"><a href=\"#JSON转Map\" class=\"headerlink\" title=\"JSON转Map\"></a>JSON转Map</h3><p>跟上面的情况一样：所有键名都是字符串，随便转；另外一个：整个JSON就是数组，每个数组成员本身又只有一个两个成员的数组。这个时候可以一一对应转换为Map。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">jsonToMap</span>(<span class=\"hljs-params\">jsonStr</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(jsonStr));<br>&#125;<br><br><span class=\"hljs-title function_\">jsonToMap</span>(<span class=\"hljs-string\">&#x27;[[true, 7], [&#123;&quot;foo&quot;:3&#125;, [&quot;abc&quot;]]]&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap和Map基本类似，唯一区别就是：它只接受对象作为键名，不接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。跟WeakSet一样，设计它的目的有助于防止内存泄露：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> myElement = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;logo&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> myWeakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br>myWeakMap.<span class=\"hljs-title function_\">set</span>(myElement, &#123;<span class=\"hljs-attr\">timesClicked</span>: <span class=\"hljs-number\">0</span>&#125;);<br><br>myElement.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">let</span> logoData = myWeakMap.<span class=\"hljs-title function_\">get</span>(myElement);<br>    logoData.<span class=\"hljs-property\">timesClicked</span> ++;<br>&#125;, <span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\n<p>上述代码设计了一个机制：每当DOM中节点发生click事件，就更新一下状态。一旦这个DOM节点删除，该状态就会自动消失，不会存在内存泄露的风险。</p>\n<p>WeakMap的另一个作用就是部署私有属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> _counter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><span class=\"hljs-keyword\">let</span> _action = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Countdown</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">counter, action</span>) &#123;<br>        _counter.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, counter);<br>        _action.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, action);<br>    &#125;<br>    <span class=\"hljs-title function_\">dec</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> counter = _counter.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>);<br>        <span class=\"hljs-keyword\">if</span> (counter &lt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;<br>        counter--;<br>        _counter.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, counter);<br>        <span class=\"hljs-keyword\">if</span> (counter === <span class=\"hljs-number\">0</span>) &#123;<br>            _action.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>)();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Countdown</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;DONE&#x27;</span>));<br><br>c.<span class=\"hljs-title function_\">dec</span>()<br>c.<span class=\"hljs-title function_\">dec</span>()<br><span class=\"hljs-comment\">// DONE</span><br></code></pre></td></tr></table></figure>\n<p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>是实例的弱引用，所以如果删除实例，它们也就随之消失。不会造成内存泄露。</p>\n","site":{"data":{}},"wordcount":5866,"excerpt":"","more":"<h1 id=\"Set和Map\"><a href=\"#Set和Map\" class=\"headerlink\" title=\"Set和Map\"></a>Set和Map</h1><h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>类似与数组结构，但是数组中的成员值时唯一不重复的。跟Java中的Set是同样的意思。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><br>[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> s.<span class=\"hljs-title function_\">add</span>(x));<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> s) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br><span class=\"hljs-comment\">// 2 3 5 4</span><br></code></pre></td></tr></table></figure>\n<p>也可以结合扩展运算符写成下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]);<br>[...set] <span class=\"hljs-comment\">// 1 2 3 4 5</span><br>set.<span class=\"hljs-title function_\">size</span>() <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法\"><a href=\"#实例的属性和方法\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><p>除了构造函数以及返回size的大小，还有下面4个操作的方法：使用基本和Java相同</p>\n<ul>\n<li>add(value)：添加某个值，返回Set结构本身</li>\n<li>delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；</li>\n<li>has(value)：返回一个布尔值，表示该值是否为Set成员</li>\n<li>clear()：清除所有成员，没返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>s.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>);<br><br>s.<span class=\"hljs-property\">size</span> <span class=\"hljs-comment\">// 2</span><br><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// false</span><br><br>s.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">2</span>);<br>s.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历操作\"><a href=\"#遍历操作\" class=\"headerlink\" title=\"遍历操作\"></a>遍历操作</h3><p>遍历器包含下面4个方法，可以用于遍历成员，结合Lambda表示可以有十分简洁的写法，跟Java 8的lambda表达式差不多，这里不再赘述。</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回键值对的遍历器</li>\n<li>forEach()：使用回调函数遍历每个成员</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-title function_\">values</span>()) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item);<br>&#125;<br><span class=\"hljs-comment\">// red</span><br><span class=\"hljs-comment\">// green</span><br><span class=\"hljs-comment\">// blue</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> set.<span class=\"hljs-property\">entries</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item)<br>&#125;<br><span class=\"hljs-comment\">// [&#x27;red&#x27;, &#x27;red&#x27;]</span><br><span class=\"hljs-comment\">// [&#x27;green&#x27;, &#x27;green&#x27;]</span><br><span class=\"hljs-comment\">// [&#x27;blue&#x27;, &#x27;blue&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>从名字上看，WeakSet也是Set的一种，但是跟Set有下列几个区别：</p>\n<ul>\n<li>成员只能是对象，不能是其他类型的值；</li>\n<li>集合内的对象全都是弱引用，GC不会考虑对WeakSet中的对象的引用，因此WeakSet是不可遍历的。</li>\n</ul>\n<p>你可能会问，WeakSet的这种特性有什么用呢？由于不能遍历且内存中的对象随时会丢失，因此十分适合存储DOM节点，而不用担心这些节点从文档移除时引发内存泄露。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> foos = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakSet</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">foo</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    foos.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">method</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!foos.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-variable language_\">this</span>)) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Foo.prototype.method智能在Foo实例上调用!&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>JavaScript的对象本质上也是键值对的集合，但是传统上只能用字符串当键。因为ES6提供了Map这个对象。概念跟Java中的差不多。与JavaScript中对象唯一不同的是：它的键不仅限于字符串，还可以是其他类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><span class=\"hljs-keyword\">var</span> o = &#123;<span class=\"hljs-attr\">p</span>: <span class=\"hljs-string\">&#x27;Hello World&#x27;</span>&#125;;<br><br>m.<span class=\"hljs-title function_\">set</span>(o, <span class=\"hljs-string\">&#x27;content&#x27;</span>)<br>m.<span class=\"hljs-title function_\">get</span>(o)<br><br>m.<span class=\"hljs-title function_\">has</span>(o)<br>m.<span class=\"hljs-title function_\">delete</span>(o)<br>m.<span class=\"hljs-title function_\">has</span>(o)<br></code></pre></td></tr></table></figure>\n<p>与此同时，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-string\">&#x27;name&#x27;</span>, <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span>],<br>    [<span class=\"hljs-string\">&#x27;title&#x27;</span>, <span class=\"hljs-string\">&#x27;Author&#x27;</span>]<br>]);<br><br>map.<span class=\"hljs-property\">size</span> <span class=\"hljs-comment\">// 2</span><br>map.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;name&#x27;</span>) <span class=\"hljs-comment\">// zhangsan</span><br>map.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// true</span><br>map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>) <span class=\"hljs-comment\">// Author</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和方法-1\"><a href=\"#实例的属性和方法-1\" class=\"headerlink\" title=\"实例的属性和方法\"></a>实例的属性和方法</h3><p>跟上面提到的Set一样，Map也有属于自己的实例属性和方法。</p>\n<ul>\n<li>size：返回Map结构的成员总数</li>\n<li>set(key, value)：设置key对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新；</li>\n<li>get(key)：读取key对应的键值，如果找不到则返回undefined；</li>\n<li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中；</li>\n<li>delete(key)：删除某个键，返回true，如果删除失败则返回false；</li>\n<li>clear()：清除所有成员，没有返回值；</li>\n</ul>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><p>Map提供了三个原生的遍历器生成函数和一个遍历方法，这个和之前的Set很相似；</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回所有成员的遍历器</li>\n<li>forEach()：返回Map的所有成员</li>\n</ul>\n<p>下面提供一个实例的使用方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-string\">&#x27;F&#x27;</span>, <span class=\"hljs-string\">&#x27;no&#x27;</span>],<br>    [<span class=\"hljs-string\">&#x27;T&#x27;</span>, <span class=\"hljs-string\">&#x27;yes&#x27;</span>]<br>]);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">keys</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> value <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">values</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(item)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map.<span class=\"hljs-title function_\">entries</span>()) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value)<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key, value)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>同样的，使用扩展运算符可以将Map快速转换为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;one&#x27;</span>],<br>    [<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;two&#x27;</span>],<br>    [<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;three&#x27;</span>]<br>]);<br><br>[...map.<span class=\"hljs-title function_\">keys</span>()]<br><span class=\"hljs-comment\">// [1, 2, 3]</span><br><br>[...map.<span class=\"hljs-title function_\">values</span>()]<br><span class=\"hljs-comment\">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span><br><br>[...map.<span class=\"hljs-title function_\">entries</span>()]<br><span class=\"hljs-comment\">// [[1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span><br><br>[...map]<br><span class=\"hljs-comment\">// [[1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span><br></code></pre></td></tr></table></figure>\n<p>结合map和Filter等方法可以实现更加方便简洁的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> map0 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>);<br><br><span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<br>\t[...map0].<span class=\"hljs-title function_\">filter</span>([k, v] =&gt; k &lt; <span class=\"hljs-number\">3</span>)<br>);<br><br><span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<br>\t[...map0].<span class=\"hljs-title function_\">map</span>([k, v] =&gt; [k * <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;_&#x27;</span> + v])<br>);<br></code></pre></td></tr></table></figure>\n<p>此外，还有forEach方法，可以实现遍历。效果和Set上的forEach完全一样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">map.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">key, value, map</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;key: %s, value: %s&quot;</span>, key, value);<br>&#125;);<br><br><span class=\"hljs-comment\">// 还可以绑定this</span><br>map.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">key, value, map</span>)&#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">report</span>(key, value);<br>&#125;, reporter);<br></code></pre></td></tr></table></figure>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><h3 id=\"Map转数组\"><a href=\"#Map转数组\" class=\"headerlink\" title=\"Map转数组\"></a>Map转数组</h3><p>前面已经提到，使用扩展运算符可以很好地将Map转换成数组，这里不再赘述；</p>\n<h3 id=\"数组转Map\"><a href=\"#数组转Map\" class=\"headerlink\" title=\"数组转Map\"></a>数组转Map</h3><p>将数组作为参数传入Map的构造函数，就可以将数组转换为Map</p>\n<h3 id=\"Map转对象\"><a href=\"#Map转对象\" class=\"headerlink\" title=\"Map转对象\"></a>Map转对象</h3><p>如果Map中的所有键都是字符串，那么就可以将其转换为对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">strMapToObj</span>(<span class=\"hljs-params\">strMap</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [k, v] <span class=\"hljs-keyword\">of</span> strMap) &#123;<br>        obj[k] = v;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> obj;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;yes&#x27;</span>, <span class=\"hljs-literal\">true</span>).<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;no&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-title function_\">strMapToObj</span>(myMap)<br></code></pre></td></tr></table></figure>\n<h3 id=\"对象转Map\"><a href=\"#对象转Map\" class=\"headerlink\" title=\"对象转Map\"></a>对象转Map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">objToStrMap</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> strMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)) &#123;<br>        strMap.<span class=\"hljs-title function_\">set</span>(k, obj[k]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> strMap;<br>&#125;<br><br><span class=\"hljs-title function_\">objToStrMap</span>(&#123;<span class=\"hljs-attr\">yes</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">no</span>: <span class=\"hljs-literal\">false</span>&#125;)<br></code></pre></td></tr></table></figure>\n<h3 id=\"Map转JSON\"><a href=\"#Map转JSON\" class=\"headerlink\" title=\"Map转JSON\"></a>Map转JSON</h3><p>Map转JSON要分为两种情况：如果键名都是字符串，那么可以直接转成JSON；如果键名中有非字符串，这时可以选择转为数组JSON。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Map --&gt; JSON (1)</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">strMapToJson</span>(<span class=\"hljs-params\">strMap</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(<span class=\"hljs-title function_\">strMapToObj</span>(strMap));<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;yes&#x27;</span>, <span class=\"hljs-literal\">true</span>).<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;no&#x27;</span>, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-title function_\">strMapToJson</span>(myMap)<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mapToArrayJson</span>(<span class=\"hljs-params\">map</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>([...map]);<br>&#125;<br><span class=\"hljs-keyword\">let</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>().<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">7</span>).<span class=\"hljs-title function_\">set</span>(&#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">3</span>&#125;, [<span class=\"hljs-string\">&#x27;abc&#x27;</span>]);<br><span class=\"hljs-title function_\">mapToArrayJson</span>(myMap)<br></code></pre></td></tr></table></figure>\n<h3 id=\"JSON转Map\"><a href=\"#JSON转Map\" class=\"headerlink\" title=\"JSON转Map\"></a>JSON转Map</h3><p>跟上面的情况一样：所有键名都是字符串，随便转；另外一个：整个JSON就是数组，每个数组成员本身又只有一个两个成员的数组。这个时候可以一一对应转换为Map。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">jsonToMap</span>(<span class=\"hljs-params\">jsonStr</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(jsonStr));<br>&#125;<br><br><span class=\"hljs-title function_\">jsonToMap</span>(<span class=\"hljs-string\">&#x27;[[true, 7], [&#123;&quot;foo&quot;:3&#125;, [&quot;abc&quot;]]]&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap和Map基本类似，唯一区别就是：它只接受对象作为键名，不接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。跟WeakSet一样，设计它的目的有助于防止内存泄露：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> myElement = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;logo&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> myWeakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br>myWeakMap.<span class=\"hljs-title function_\">set</span>(myElement, &#123;<span class=\"hljs-attr\">timesClicked</span>: <span class=\"hljs-number\">0</span>&#125;);<br><br>myElement.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">let</span> logoData = myWeakMap.<span class=\"hljs-title function_\">get</span>(myElement);<br>    logoData.<span class=\"hljs-property\">timesClicked</span> ++;<br>&#125;, <span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\n<p>上述代码设计了一个机制：每当DOM中节点发生click事件，就更新一下状态。一旦这个DOM节点删除，该状态就会自动消失，不会存在内存泄露的风险。</p>\n<p>WeakMap的另一个作用就是部署私有属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> _counter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><span class=\"hljs-keyword\">let</span> _action = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>();<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Countdown</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">counter, action</span>) &#123;<br>        _counter.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, counter);<br>        _action.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, action);<br>    &#125;<br>    <span class=\"hljs-title function_\">dec</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> counter = _counter.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>);<br>        <span class=\"hljs-keyword\">if</span> (counter &lt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;<br>        counter--;<br>        _counter.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-variable language_\">this</span>, counter);<br>        <span class=\"hljs-keyword\">if</span> (counter === <span class=\"hljs-number\">0</span>) &#123;<br>            _action.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>)();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Countdown</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;DONE&#x27;</span>));<br><br>c.<span class=\"hljs-title function_\">dec</span>()<br>c.<span class=\"hljs-title function_\">dec</span>()<br><span class=\"hljs-comment\">// DONE</span><br></code></pre></td></tr></table></figure>\n<p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>是实例的弱引用，所以如果删除实例，它们也就随之消失。不会造成内存泄露。</p>\n"},{"title":"ES6 字符串","date":"2022-02-17T03:26:20.000Z","updated":"2022-02-17T03:26:20.000Z","_content":"\n# 字符串\n\n和其他类型的编程语言一样，ES6对原有JavaScript字符的基础上进行了扩展和增强；\n\n## Unicode字符表示法\n\n使用`\\uxxxx`的方式表示字符，但是仅仅能表示`\\u0000`到`\\uFFFF`之间的字符串，超出后必须使用两个字符来表示。\n\n## codePointAt函数\n\n对于使用4个字节存储的字符，JavaScript不能很好地处理。因此ES6提供了codePointAt()方法来处理4个字节的字符。`codePointAt()`会返回32位的UTF-16字符，常规码点和`charAt()`返回值相同。如下所示：\n\n```javascript\nvar s = \"𠮷\";\ns.length // 2\ns.charAt(0); // ''\ns.charAt(1); // ''\ns.codePointAt(0); // 55362\ns.codePointAt(1); // 57271\n```\n\n测试一个字符是2字节还是4字节的方法如下：\n\n```javascript\nfunction is32Bit(c) {\n  return c.codePointAt(0) > 0xFFFF;\n}\n```\n\n## String.fromCodePoint()\n\nES5开始提供了该方法，用于从码点返回对应字符，但是无法识别UTF-16的字符（也就是Unicode编号大于0xFFFF），但是在ES6开始，该函数可以识别`0xFFFF`的函数。示例如下：\n\n```javascript\nString.fromCodePoint(0x20BB7);\n\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD830D\\uDE80y'\n```\n\n## 字符串的遍历接口\n\nES6为字符提供了遍历接口（因为实现了Iterator接口），使得字符串可以被`for ... of`遍历循环；\n\n```javascript\nfor (let codePoint of 'foo') {\n  console.log(codePoint);\n}\n\n// \"f\"\n// \"o\"\n// \"o\"\n```\n\n除了遍历字符串还可以识别大于`0xFFFF`的码点，例如：\n\n```javascript\nvar text = String.fromCodePoint(0x20BB7);\n\nfor (let i of text) {\n  console.log(i);\n}\n```\n\n## at()\n\nES5中的charAt()方法不能用于识别码点大于`0xFFFF`的字符，但是ES6提案中的`at()`却可以识别码点大于`0xFFFF`的字符。如下所示：\n\n```javascript\n\t'abc'.at(0)\n'0x20BB7'.at(0) \n```\n\n## normalize()\n\nES6提供的normalize()函数可以将字符的不同表示犯法统一为同样的形式，这样称之为Unicode的正规化；使用正规化的原因时欧洲许多国家的字符存在重音符号。有些字符时通过两个符号合成得到的。但是目前还不支持三个字符的合成分解，所以对于多字符情况还是使用正则表达式吧。\n\n```javascript\n'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize() // true\n```\n\n此外normalize()方法可以接受一个参数来指定normalize的方式，参数可选值如下：\n\n- `NFC`：默认参数，标准等价合成，返回合成字符；即视觉上和语义上的等价；\n- `NFD`：标准等价分解，返回合成字符分解的多个简单字符；\n- `NFKC`：兼容等价合成，返回合成字符。即语义上等价、视觉上不等价；\n- `NFKD`：兼容等价分解，返回合成字符分解的多个简单字符；\n\n## includes(), startsWith(), endsWith()\n\n传统的JavaScript只有一个`indexOf()`方法用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：\n\n- `includes()`：表示是否找到了参数字符串\n- `startsWith()`：表示参数字符串是否在源字符串的头部；\n- `endsWith()`：表示参数字符串是否在源字符串的尾部；\n\n例子如下：\n\n```javascript\nvar s = \"Hello World!\";\n\ns.startsWith('Hello'); // true\ns.endsWith('!'); // true\ns.includes('o'); // true\n```\n\n## repeat()\n\n`repeat()`方法返回一个新字符串，表示将源字符串重复n次，如果n为小数则会向下取整；如果为负数或者`Infinity`会报`Range Error`错误；如果时-1~0之间的数据会先取整再运算，因此当0处理；\n\n```javascript\n'x'.repeat(3); //xxx\n'hello'.repeat(2); //hellohello\n'na'.repeat(0); // \"\"\n'na'.repeat(2.9); // \"nana\"\n'na'.repeat(Infinity); // Range Error\n'na'.repeat(-1); // Range Error\n'na'.repeat(-0.5); // \"\"\n```\n\n## padStart(), padEnd()\n\nES7推出字符串补全长度功能。如果某个字符串不够指定长度，这会在头部和尾部补全。此处不再赘述。\n\n```javascript\n'x'.padStart(5, 'ab'); // 'ababx';\n'x'.padStart(4, 'ab'); // 'abax';\n\n'x'.padEnd(5, 'ab'); // 'xabab';\n'x'.padEnd(4, 'ab'); // 'xaba';\n```\n\n如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。\n\n```javascript\n'xxx'.padStart(2, 'ab'); // xxx\n```\n\n如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串；如果省略第二个字符，则会使用空格来进行填充。\n\n```javascript\n'abc'.padStart(10, '0123456789'); // 0123456abc\n'X'.padStart(4); '   X'\n```\n\n因此也可以看出它主要是用来给数值补全指定位数或者字符串格式化。例子如下：\n\n```javascript\n// 数值补位\n'1'.padStart(10, '0'); // 0000000001\n'12'.padStart(10, '0'); // 0000000012\n'123456'.padStart(10, '0'); // 0000123456\n\n// 字符串格式\n'12'.padStart(10, 'YYYY-MM-DD'); // YYYY-MM-12\n'09-12'.padStart(10, 'YYYY-MM-DD'); // YYYY-09-12\n```\n\n## 模板字符串\n\nES6引用了模板字符串来撰写模板，这样可以在表示上更加简洁。类似的语法在Python和Golang中也有；如下所示：使用`${expression}`包裹的表达式可以作为占位符解析：\n\n```javascript\n$('#result').append(`\n\tThere are <b>${basket.count}</b> items\n\tin your basket, <em>${basket.onSale}</em>\n\tare on sale!\n`);\n```\n\n所有模板字符的空格和换行都是被原样保留的，如果不想要换行，可以加上`trim()`来消除：\n\n```javascript\n$('#list').html(`\n<ul>\n\t<li>first</li>\n\t<li>second</li>\n</ul>\n`.trim());\n```\n\n模板字符串除了可以嵌套JavaScript表达式，还可以调用函数；除此之外，模板表达式还可以嵌套。注意：由于模板字符串可以传入JavaScript，因此变量在使用前必须声明，否则会编译失败；\n\n```javascript\nconst tmpl = addrs => `\n\t<table>\n\t${addrs.map(addr => `\n\t\t<tr><td>${addr.first}</td></tr>\n\t\t<tr><td>${addr.last}</td></tr>\n\t`).join('')}\n\t</table>\n`;\n```\n","source":"_posts/javascript/es6-string.md","raw":"---\ntitle: ES6 字符串\ndate: 2022-02-17 11:26:20\nupdated: 2022-02-17 11:26:20\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 字符串\n\n和其他类型的编程语言一样，ES6对原有JavaScript字符的基础上进行了扩展和增强；\n\n## Unicode字符表示法\n\n使用`\\uxxxx`的方式表示字符，但是仅仅能表示`\\u0000`到`\\uFFFF`之间的字符串，超出后必须使用两个字符来表示。\n\n## codePointAt函数\n\n对于使用4个字节存储的字符，JavaScript不能很好地处理。因此ES6提供了codePointAt()方法来处理4个字节的字符。`codePointAt()`会返回32位的UTF-16字符，常规码点和`charAt()`返回值相同。如下所示：\n\n```javascript\nvar s = \"𠮷\";\ns.length // 2\ns.charAt(0); // ''\ns.charAt(1); // ''\ns.codePointAt(0); // 55362\ns.codePointAt(1); // 57271\n```\n\n测试一个字符是2字节还是4字节的方法如下：\n\n```javascript\nfunction is32Bit(c) {\n  return c.codePointAt(0) > 0xFFFF;\n}\n```\n\n## String.fromCodePoint()\n\nES5开始提供了该方法，用于从码点返回对应字符，但是无法识别UTF-16的字符（也就是Unicode编号大于0xFFFF），但是在ES6开始，该函数可以识别`0xFFFF`的函数。示例如下：\n\n```javascript\nString.fromCodePoint(0x20BB7);\n\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD830D\\uDE80y'\n```\n\n## 字符串的遍历接口\n\nES6为字符提供了遍历接口（因为实现了Iterator接口），使得字符串可以被`for ... of`遍历循环；\n\n```javascript\nfor (let codePoint of 'foo') {\n  console.log(codePoint);\n}\n\n// \"f\"\n// \"o\"\n// \"o\"\n```\n\n除了遍历字符串还可以识别大于`0xFFFF`的码点，例如：\n\n```javascript\nvar text = String.fromCodePoint(0x20BB7);\n\nfor (let i of text) {\n  console.log(i);\n}\n```\n\n## at()\n\nES5中的charAt()方法不能用于识别码点大于`0xFFFF`的字符，但是ES6提案中的`at()`却可以识别码点大于`0xFFFF`的字符。如下所示：\n\n```javascript\n\t'abc'.at(0)\n'0x20BB7'.at(0) \n```\n\n## normalize()\n\nES6提供的normalize()函数可以将字符的不同表示犯法统一为同样的形式，这样称之为Unicode的正规化；使用正规化的原因时欧洲许多国家的字符存在重音符号。有些字符时通过两个符号合成得到的。但是目前还不支持三个字符的合成分解，所以对于多字符情况还是使用正则表达式吧。\n\n```javascript\n'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize() // true\n```\n\n此外normalize()方法可以接受一个参数来指定normalize的方式，参数可选值如下：\n\n- `NFC`：默认参数，标准等价合成，返回合成字符；即视觉上和语义上的等价；\n- `NFD`：标准等价分解，返回合成字符分解的多个简单字符；\n- `NFKC`：兼容等价合成，返回合成字符。即语义上等价、视觉上不等价；\n- `NFKD`：兼容等价分解，返回合成字符分解的多个简单字符；\n\n## includes(), startsWith(), endsWith()\n\n传统的JavaScript只有一个`indexOf()`方法用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：\n\n- `includes()`：表示是否找到了参数字符串\n- `startsWith()`：表示参数字符串是否在源字符串的头部；\n- `endsWith()`：表示参数字符串是否在源字符串的尾部；\n\n例子如下：\n\n```javascript\nvar s = \"Hello World!\";\n\ns.startsWith('Hello'); // true\ns.endsWith('!'); // true\ns.includes('o'); // true\n```\n\n## repeat()\n\n`repeat()`方法返回一个新字符串，表示将源字符串重复n次，如果n为小数则会向下取整；如果为负数或者`Infinity`会报`Range Error`错误；如果时-1~0之间的数据会先取整再运算，因此当0处理；\n\n```javascript\n'x'.repeat(3); //xxx\n'hello'.repeat(2); //hellohello\n'na'.repeat(0); // \"\"\n'na'.repeat(2.9); // \"nana\"\n'na'.repeat(Infinity); // Range Error\n'na'.repeat(-1); // Range Error\n'na'.repeat(-0.5); // \"\"\n```\n\n## padStart(), padEnd()\n\nES7推出字符串补全长度功能。如果某个字符串不够指定长度，这会在头部和尾部补全。此处不再赘述。\n\n```javascript\n'x'.padStart(5, 'ab'); // 'ababx';\n'x'.padStart(4, 'ab'); // 'abax';\n\n'x'.padEnd(5, 'ab'); // 'xabab';\n'x'.padEnd(4, 'ab'); // 'xaba';\n```\n\n如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。\n\n```javascript\n'xxx'.padStart(2, 'ab'); // xxx\n```\n\n如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串；如果省略第二个字符，则会使用空格来进行填充。\n\n```javascript\n'abc'.padStart(10, '0123456789'); // 0123456abc\n'X'.padStart(4); '   X'\n```\n\n因此也可以看出它主要是用来给数值补全指定位数或者字符串格式化。例子如下：\n\n```javascript\n// 数值补位\n'1'.padStart(10, '0'); // 0000000001\n'12'.padStart(10, '0'); // 0000000012\n'123456'.padStart(10, '0'); // 0000123456\n\n// 字符串格式\n'12'.padStart(10, 'YYYY-MM-DD'); // YYYY-MM-12\n'09-12'.padStart(10, 'YYYY-MM-DD'); // YYYY-09-12\n```\n\n## 模板字符串\n\nES6引用了模板字符串来撰写模板，这样可以在表示上更加简洁。类似的语法在Python和Golang中也有；如下所示：使用`${expression}`包裹的表达式可以作为占位符解析：\n\n```javascript\n$('#result').append(`\n\tThere are <b>${basket.count}</b> items\n\tin your basket, <em>${basket.onSale}</em>\n\tare on sale!\n`);\n```\n\n所有模板字符的空格和换行都是被原样保留的，如果不想要换行，可以加上`trim()`来消除：\n\n```javascript\n$('#list').html(`\n<ul>\n\t<li>first</li>\n\t<li>second</li>\n</ul>\n`.trim());\n```\n\n模板字符串除了可以嵌套JavaScript表达式，还可以调用函数；除此之外，模板表达式还可以嵌套。注意：由于模板字符串可以传入JavaScript，因此变量在使用前必须声明，否则会编译失败；\n\n```javascript\nconst tmpl = addrs => `\n\t<table>\n\t${addrs.map(addr => `\n\t\t<tr><td>${addr.first}</td></tr>\n\t\t<tr><td>${addr.last}</td></tr>\n\t`).join('')}\n\t</table>\n`;\n```\n","slug":"javascript/es6-string","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3b00252y61h5yp3ssj","content":"<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><p>和其他类型的编程语言一样，ES6对原有JavaScript字符的基础上进行了扩展和增强；</p>\n<h2 id=\"Unicode字符表示法\"><a href=\"#Unicode字符表示法\" class=\"headerlink\" title=\"Unicode字符表示法\"></a>Unicode字符表示法</h2><p>使用<code>\\uxxxx</code>的方式表示字符，但是仅仅能表示<code>\\u0000</code>到<code>\\uFFFF</code>之间的字符串，超出后必须使用两个字符来表示。</p>\n<h2 id=\"codePointAt函数\"><a href=\"#codePointAt函数\" class=\"headerlink\" title=\"codePointAt函数\"></a>codePointAt函数</h2><p>对于使用4个字节存储的字符，JavaScript不能很好地处理。因此ES6提供了codePointAt()方法来处理4个字节的字符。<code>codePointAt()</code>会返回32位的UTF-16字符，常规码点和<code>charAt()</code>返回值相同。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;𠮷&quot;</span>;<br>s.<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 2</span><br>s.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &#x27;&#x27;</span><br>s.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// &#x27;&#x27;</span><br>s.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 55362</span><br>s.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 57271</span><br></code></pre></td></tr></table></figure>\n<p>测试一个字符是2字节还是4字节的方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">is32Bit</span>(<span class=\"hljs-params\">c</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> c.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">0</span>) &gt; <span class=\"hljs-number\">0xFFFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"String-fromCodePoint\"><a href=\"#String-fromCodePoint\" class=\"headerlink\" title=\"String.fromCodePoint()\"></a>String.fromCodePoint()</h2><p>ES5开始提供了该方法，用于从码点返回对应字符，但是无法识别UTF-16的字符（也就是Unicode编号大于0xFFFF），但是在ES6开始，该函数可以识别<code>0xFFFF</code>的函数。示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x20BB7</span>);<br><br><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x78</span>, <span class=\"hljs-number\">0x1f680</span>, <span class=\"hljs-number\">0x79</span>) === <span class=\"hljs-string\">&#x27;x\\uD830D\\uDE80y&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"字符串的遍历接口\"><a href=\"#字符串的遍历接口\" class=\"headerlink\" title=\"字符串的遍历接口\"></a>字符串的遍历接口</h2><p>ES6为字符提供了遍历接口（因为实现了Iterator接口），使得字符串可以被<code>for ... of</code>遍历循环；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> codePoint <span class=\"hljs-keyword\">of</span> <span class=\"hljs-string\">&#x27;foo&#x27;</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(codePoint);<br>&#125;<br><br><span class=\"hljs-comment\">// &quot;f&quot;</span><br><span class=\"hljs-comment\">// &quot;o&quot;</span><br><span class=\"hljs-comment\">// &quot;o&quot;</span><br></code></pre></td></tr></table></figure>\n<p>除了遍历字符串还可以识别大于<code>0xFFFF</code>的码点，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> text = <span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x20BB7</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> text) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"at\"><a href=\"#at\" class=\"headerlink\" title=\"at()\"></a>at()</h2><p>ES5中的charAt()方法不能用于识别码点大于<code>0xFFFF</code>的字符，但是ES6提案中的<code>at()</code>却可以识别码点大于<code>0xFFFF</code>的字符。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">\t<span class=\"hljs-string\">&#x27;abc&#x27;</span>.<span class=\"hljs-title function_\">at</span>(<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-string\">&#x27;0x20BB7&#x27;</span>.<span class=\"hljs-title function_\">at</span>(<span class=\"hljs-number\">0</span>) <br></code></pre></td></tr></table></figure>\n<h2 id=\"normalize\"><a href=\"#normalize\" class=\"headerlink\" title=\"normalize()\"></a>normalize()</h2><p>ES6提供的normalize()函数可以将字符的不同表示犯法统一为同样的形式，这样称之为Unicode的正规化；使用正规化的原因时欧洲许多国家的字符存在重音符号。有些字符时通过两个符号合成得到的。但是目前还不支持三个字符的合成分解，所以对于多字符情况还是使用正则表达式吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;\\u01D1&#x27;</span>.<span class=\"hljs-title function_\">normalize</span>() === <span class=\"hljs-string\">&#x27;\\u004F\\u030C&#x27;</span>.<span class=\"hljs-title function_\">normalize</span>() <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>此外normalize()方法可以接受一个参数来指定normalize的方式，参数可选值如下：</p>\n<ul>\n<li><code>NFC</code>：默认参数，标准等价合成，返回合成字符；即视觉上和语义上的等价；</li>\n<li><code>NFD</code>：标准等价分解，返回合成字符分解的多个简单字符；</li>\n<li><code>NFKC</code>：兼容等价合成，返回合成字符。即语义上等价、视觉上不等价；</li>\n<li><code>NFKD</code>：兼容等价分解，返回合成字符分解的多个简单字符；</li>\n</ul>\n<h2 id=\"includes-startsWith-endsWith\"><a href=\"#includes-startsWith-endsWith\" class=\"headerlink\" title=\"includes(), startsWith(), endsWith()\"></a>includes(), startsWith(), endsWith()</h2><p>传统的JavaScript只有一个<code>indexOf()</code>方法用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：</p>\n<ul>\n<li><code>includes()</code>：表示是否找到了参数字符串</li>\n<li><code>startsWith()</code>：表示参数字符串是否在源字符串的头部；</li>\n<li><code>endsWith()</code>：表示参数字符串是否在源字符串的尾部；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;Hello World!&quot;</span>;<br><br>s.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>); <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">endsWith</span>(<span class=\"hljs-string\">&#x27;!&#x27;</span>); <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">&#x27;o&#x27;</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h2><p><code>repeat()</code>方法返回一个新字符串，表示将源字符串重复n次，如果n为小数则会向下取整；如果为负数或者<code>Infinity</code>会报<code>Range Error</code>错误；如果时-1~0之间的数据会先取整再运算，因此当0处理；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//xxx</span><br><span class=\"hljs-string\">&#x27;hello&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">//hellohello</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &quot;&quot;</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">2.9</span>); <span class=\"hljs-comment\">// &quot;nana&quot;</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// Range Error</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Range Error</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(-<span class=\"hljs-number\">0.5</span>); <span class=\"hljs-comment\">// &quot;&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"padStart-padEnd\"><a href=\"#padStart-padEnd\" class=\"headerlink\" title=\"padStart(), padEnd()\"></a>padStart(), padEnd()</h2><p>ES7推出字符串补全长度功能。如果某个字符串不够指定长度，这会在头部和尾部补全。此处不再赘述。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;ababx&#x27;;</span><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;abax&#x27;;</span><br><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;xabab&#x27;;</span><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;xaba&#x27;;</span><br></code></pre></td></tr></table></figure>\n<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// xxx</span><br></code></pre></td></tr></table></figure>\n<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串；如果省略第二个字符，则会使用空格来进行填充。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;abc&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0123456789&#x27;</span>); <span class=\"hljs-comment\">// 0123456abc</span><br><span class=\"hljs-string\">&#x27;X&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-string\">&#x27;   X&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>因此也可以看出它主要是用来给数值补全指定位数或者字符串格式化。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 数值补位</span><br><span class=\"hljs-string\">&#x27;1&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000000001</span><br><span class=\"hljs-string\">&#x27;12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000000012</span><br><span class=\"hljs-string\">&#x27;123456&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000123456</span><br><br><span class=\"hljs-comment\">// 字符串格式</span><br><span class=\"hljs-string\">&#x27;12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;YYYY-MM-DD&#x27;</span>); <span class=\"hljs-comment\">// YYYY-MM-12</span><br><span class=\"hljs-string\">&#x27;09-12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;YYYY-MM-DD&#x27;</span>); <span class=\"hljs-comment\">// YYYY-09-12</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>ES6引用了模板字符串来撰写模板，这样可以在表示上更加简洁。类似的语法在Python和Golang中也有；如下所示：使用<code>$&#123;expression&#125;</code>包裹的表达式可以作为占位符解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$(<span class=\"hljs-string\">&#x27;#result&#x27;</span>).<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\tThere are &lt;b&gt;<span class=\"hljs-subst\">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span><br><span class=\"hljs-string\">\tin your basket, &lt;em&gt;<span class=\"hljs-subst\">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span><br><span class=\"hljs-string\">\tare on sale!</span><br><span class=\"hljs-string\">`</span>);<br></code></pre></td></tr></table></figure>\n<p>所有模板字符的空格和换行都是被原样保留的，如果不想要换行，可以加上<code>trim()</code>来消除：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$(<span class=\"hljs-string\">&#x27;#list&#x27;</span>).<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">&lt;ul&gt;</span><br><span class=\"hljs-string\">\t&lt;li&gt;first&lt;/li&gt;</span><br><span class=\"hljs-string\">\t&lt;li&gt;second&lt;/li&gt;</span><br><span class=\"hljs-string\">&lt;/ul&gt;</span><br><span class=\"hljs-string\">`</span>.<span class=\"hljs-title function_\">trim</span>());<br></code></pre></td></tr></table></figure>\n<p>模板字符串除了可以嵌套JavaScript表达式，还可以调用函数；除此之外，模板表达式还可以嵌套。注意：由于模板字符串可以传入JavaScript，因此变量在使用前必须声明，否则会编译失败；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">tmpl</span> = addrs =&gt; <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\t&lt;table&gt;</span><br><span class=\"hljs-string\">\t<span class=\"hljs-subst\">$&#123;addrs.map(addr =&gt; <span class=\"hljs-string\">`</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t\t&lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t\t&lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t`</span>).join(<span class=\"hljs-string\">&#x27;&#x27;</span>)&#125;</span></span><br><span class=\"hljs-string\">\t&lt;/table&gt;</span><br><span class=\"hljs-string\">`</span>;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":3897,"excerpt":"","more":"<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><p>和其他类型的编程语言一样，ES6对原有JavaScript字符的基础上进行了扩展和增强；</p>\n<h2 id=\"Unicode字符表示法\"><a href=\"#Unicode字符表示法\" class=\"headerlink\" title=\"Unicode字符表示法\"></a>Unicode字符表示法</h2><p>使用<code>\\uxxxx</code>的方式表示字符，但是仅仅能表示<code>\\u0000</code>到<code>\\uFFFF</code>之间的字符串，超出后必须使用两个字符来表示。</p>\n<h2 id=\"codePointAt函数\"><a href=\"#codePointAt函数\" class=\"headerlink\" title=\"codePointAt函数\"></a>codePointAt函数</h2><p>对于使用4个字节存储的字符，JavaScript不能很好地处理。因此ES6提供了codePointAt()方法来处理4个字节的字符。<code>codePointAt()</code>会返回32位的UTF-16字符，常规码点和<code>charAt()</code>返回值相同。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;𠮷&quot;</span>;<br>s.<span class=\"hljs-property\">length</span> <span class=\"hljs-comment\">// 2</span><br>s.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &#x27;&#x27;</span><br>s.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// &#x27;&#x27;</span><br>s.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 55362</span><br>s.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 57271</span><br></code></pre></td></tr></table></figure>\n<p>测试一个字符是2字节还是4字节的方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">is32Bit</span>(<span class=\"hljs-params\">c</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> c.<span class=\"hljs-title function_\">codePointAt</span>(<span class=\"hljs-number\">0</span>) &gt; <span class=\"hljs-number\">0xFFFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"String-fromCodePoint\"><a href=\"#String-fromCodePoint\" class=\"headerlink\" title=\"String.fromCodePoint()\"></a>String.fromCodePoint()</h2><p>ES5开始提供了该方法，用于从码点返回对应字符，但是无法识别UTF-16的字符（也就是Unicode编号大于0xFFFF），但是在ES6开始，该函数可以识别<code>0xFFFF</code>的函数。示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x20BB7</span>);<br><br><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x78</span>, <span class=\"hljs-number\">0x1f680</span>, <span class=\"hljs-number\">0x79</span>) === <span class=\"hljs-string\">&#x27;x\\uD830D\\uDE80y&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"字符串的遍历接口\"><a href=\"#字符串的遍历接口\" class=\"headerlink\" title=\"字符串的遍历接口\"></a>字符串的遍历接口</h2><p>ES6为字符提供了遍历接口（因为实现了Iterator接口），使得字符串可以被<code>for ... of</code>遍历循环；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> codePoint <span class=\"hljs-keyword\">of</span> <span class=\"hljs-string\">&#x27;foo&#x27;</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(codePoint);<br>&#125;<br><br><span class=\"hljs-comment\">// &quot;f&quot;</span><br><span class=\"hljs-comment\">// &quot;o&quot;</span><br><span class=\"hljs-comment\">// &quot;o&quot;</span><br></code></pre></td></tr></table></figure>\n<p>除了遍历字符串还可以识别大于<code>0xFFFF</code>的码点，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> text = <span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">fromCodePoint</span>(<span class=\"hljs-number\">0x20BB7</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> text) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"at\"><a href=\"#at\" class=\"headerlink\" title=\"at()\"></a>at()</h2><p>ES5中的charAt()方法不能用于识别码点大于<code>0xFFFF</code>的字符，但是ES6提案中的<code>at()</code>却可以识别码点大于<code>0xFFFF</code>的字符。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">\t<span class=\"hljs-string\">&#x27;abc&#x27;</span>.<span class=\"hljs-title function_\">at</span>(<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-string\">&#x27;0x20BB7&#x27;</span>.<span class=\"hljs-title function_\">at</span>(<span class=\"hljs-number\">0</span>) <br></code></pre></td></tr></table></figure>\n<h2 id=\"normalize\"><a href=\"#normalize\" class=\"headerlink\" title=\"normalize()\"></a>normalize()</h2><p>ES6提供的normalize()函数可以将字符的不同表示犯法统一为同样的形式，这样称之为Unicode的正规化；使用正规化的原因时欧洲许多国家的字符存在重音符号。有些字符时通过两个符号合成得到的。但是目前还不支持三个字符的合成分解，所以对于多字符情况还是使用正则表达式吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;\\u01D1&#x27;</span>.<span class=\"hljs-title function_\">normalize</span>() === <span class=\"hljs-string\">&#x27;\\u004F\\u030C&#x27;</span>.<span class=\"hljs-title function_\">normalize</span>() <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p>此外normalize()方法可以接受一个参数来指定normalize的方式，参数可选值如下：</p>\n<ul>\n<li><code>NFC</code>：默认参数，标准等价合成，返回合成字符；即视觉上和语义上的等价；</li>\n<li><code>NFD</code>：标准等价分解，返回合成字符分解的多个简单字符；</li>\n<li><code>NFKC</code>：兼容等价合成，返回合成字符。即语义上等价、视觉上不等价；</li>\n<li><code>NFKD</code>：兼容等价分解，返回合成字符分解的多个简单字符；</li>\n</ul>\n<h2 id=\"includes-startsWith-endsWith\"><a href=\"#includes-startsWith-endsWith\" class=\"headerlink\" title=\"includes(), startsWith(), endsWith()\"></a>includes(), startsWith(), endsWith()</h2><p>传统的JavaScript只有一个<code>indexOf()</code>方法用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：</p>\n<ul>\n<li><code>includes()</code>：表示是否找到了参数字符串</li>\n<li><code>startsWith()</code>：表示参数字符串是否在源字符串的头部；</li>\n<li><code>endsWith()</code>：表示参数字符串是否在源字符串的尾部；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;Hello World!&quot;</span>;<br><br>s.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>); <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">endsWith</span>(<span class=\"hljs-string\">&#x27;!&#x27;</span>); <span class=\"hljs-comment\">// true</span><br>s.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">&#x27;o&#x27;</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h2><p><code>repeat()</code>方法返回一个新字符串，表示将源字符串重复n次，如果n为小数则会向下取整；如果为负数或者<code>Infinity</code>会报<code>Range Error</code>错误；如果时-1~0之间的数据会先取整再运算，因此当0处理；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//xxx</span><br><span class=\"hljs-string\">&#x27;hello&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">//hellohello</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &quot;&quot;</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">2.9</span>); <span class=\"hljs-comment\">// &quot;nana&quot;</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// Range Error</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Range Error</span><br><span class=\"hljs-string\">&#x27;na&#x27;</span>.<span class=\"hljs-title function_\">repeat</span>(-<span class=\"hljs-number\">0.5</span>); <span class=\"hljs-comment\">// &quot;&quot;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"padStart-padEnd\"><a href=\"#padStart-padEnd\" class=\"headerlink\" title=\"padStart(), padEnd()\"></a>padStart(), padEnd()</h2><p>ES7推出字符串补全长度功能。如果某个字符串不够指定长度，这会在头部和尾部补全。此处不再赘述。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;ababx&#x27;;</span><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;abax&#x27;;</span><br><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;xabab&#x27;;</span><br><span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// &#x27;xaba&#x27;;</span><br></code></pre></td></tr></table></figure>\n<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>); <span class=\"hljs-comment\">// xxx</span><br></code></pre></td></tr></table></figure>\n<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串；如果省略第二个字符，则会使用空格来进行填充。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;abc&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0123456789&#x27;</span>); <span class=\"hljs-comment\">// 0123456abc</span><br><span class=\"hljs-string\">&#x27;X&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-string\">&#x27;   X&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>因此也可以看出它主要是用来给数值补全指定位数或者字符串格式化。例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 数值补位</span><br><span class=\"hljs-string\">&#x27;1&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000000001</span><br><span class=\"hljs-string\">&#x27;12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000000012</span><br><span class=\"hljs-string\">&#x27;123456&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>); <span class=\"hljs-comment\">// 0000123456</span><br><br><span class=\"hljs-comment\">// 字符串格式</span><br><span class=\"hljs-string\">&#x27;12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;YYYY-MM-DD&#x27;</span>); <span class=\"hljs-comment\">// YYYY-MM-12</span><br><span class=\"hljs-string\">&#x27;09-12&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;YYYY-MM-DD&#x27;</span>); <span class=\"hljs-comment\">// YYYY-09-12</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>ES6引用了模板字符串来撰写模板，这样可以在表示上更加简洁。类似的语法在Python和Golang中也有；如下所示：使用<code>$&#123;expression&#125;</code>包裹的表达式可以作为占位符解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$(<span class=\"hljs-string\">&#x27;#result&#x27;</span>).<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\tThere are &lt;b&gt;<span class=\"hljs-subst\">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span><br><span class=\"hljs-string\">\tin your basket, &lt;em&gt;<span class=\"hljs-subst\">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span><br><span class=\"hljs-string\">\tare on sale!</span><br><span class=\"hljs-string\">`</span>);<br></code></pre></td></tr></table></figure>\n<p>所有模板字符的空格和换行都是被原样保留的，如果不想要换行，可以加上<code>trim()</code>来消除：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$(<span class=\"hljs-string\">&#x27;#list&#x27;</span>).<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">&lt;ul&gt;</span><br><span class=\"hljs-string\">\t&lt;li&gt;first&lt;/li&gt;</span><br><span class=\"hljs-string\">\t&lt;li&gt;second&lt;/li&gt;</span><br><span class=\"hljs-string\">&lt;/ul&gt;</span><br><span class=\"hljs-string\">`</span>.<span class=\"hljs-title function_\">trim</span>());<br></code></pre></td></tr></table></figure>\n<p>模板字符串除了可以嵌套JavaScript表达式，还可以调用函数；除此之外，模板表达式还可以嵌套。注意：由于模板字符串可以传入JavaScript，因此变量在使用前必须声明，否则会编译失败；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">tmpl</span> = addrs =&gt; <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">\t&lt;table&gt;</span><br><span class=\"hljs-string\">\t<span class=\"hljs-subst\">$&#123;addrs.map(addr =&gt; <span class=\"hljs-string\">`</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t\t&lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t\t&lt;tr&gt;&lt;td&gt;<span class=\"hljs-subst\">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span><br><span class=\"hljs-string\"><span class=\"hljs-subst\"><span class=\"hljs-string\">\t`</span>).join(<span class=\"hljs-string\">&#x27;&#x27;</span>)&#125;</span></span><br><span class=\"hljs-string\">\t&lt;/table&gt;</span><br><span class=\"hljs-string\">`</span>;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 Symbol","date":"2022-02-17T07:15:26.000Z","updated":"2022-02-17T07:15:26.000Z","_content":"\n# Symbol\n\nES5的对象属性名都是字符串，这容易造成属性名的冲突。如果存在一种机制，能够保证每个属性的名字都是独一无二的就可以解决这个问题。因此ES6中引入了Symbol。\n\nES6引入了一种新的原始数据类型Symbol，表示独一无二的值。可以称之为JavaScript的第七种数据类型。\n\nSymbol是通过symbol函数生成的。也就是说，对象的属性名可以有两种类型，一种是原来就有的字符串，另一种是新增的Symbol类型。凡是属性名属于Symbol的，就是独一无二的，可以保证不会与其他属性名发生冲突。\n\n```javascript\nlet s = Symbol();\ntypeof s // symbol\n```\n\n`Symbol`函数可以接收一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示或者是转为字符串的过程中方便区分。\n\n```javascript\nvar s1 = Symbol('foo');\nvar s2 = Symbol('bar');\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // \"Symbol(foo)\"\ns2.toString() // \"Symbol(bar)\"\n```\n\n如果Symbol的参数是一个对象，那么就会调用该对象的`toString()`方法，将其转换为字符串，然后才生成一个Symbol值。\n\n```javascript\nconst obj = {\n    toString() {\n        return 'abc';\n    }\n};\n\nconst sym = Symbol(obj);\nsym // Symbol(abc)\n```\n\nSymbol值不能与其他类型的值进行运算，会报错；但是却可以显式转换为字符串\n\n```javascript\nvar sym = Symbol('My Symbol');\n\n\"your symbol is \" + sym // Error\n\nString(sym); // Symbol('My symbol')\nsym.toString(); // Symbol(My symbol)\n```\n\n## 作为属性名的Symbol\n\n由于每一个Symbol值都是不相等的，这意味着Symbol可以作为标识符，用在对象的属性名，就能保证不会出现同名的属性。可以防止某一个键被不小心改写或覆盖。\n\n```javascript\nvar mySymbol = Symbol();\n\nvar a = {};\na[mySymbol] = 'Hello!';\n\nvar a = {\n    [mySymbol]: 'Hello'\n};\n\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello' });\n\na[mySymbol] // \"Hello\"\n```\n\nSymbol值作为对象属性名时，不能用作点运算符。\n\n```javascript\nvar mySymbol = Symbol();\nvar a = {};\n\na.mySymbol = 'Hello';\na[mySymbol] // undefined\na['mySymbol'] // Hello\n```\n\nSymbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\n\n```javascript\nlog.levels = {\n    DEBUG: Symbol('debug'),\n    INFO: Symbol('info'),\n    WARN: Symbol('warn')\n};\n\nlog(log.levels.DEBUG, 'debug message');\nlog(log.levels.INFO, 'info message');\n```\n\n还有一个例子：\n\n```javascript\nvar shapeType = {\n    triangle: Symbol()\n};\n\nfunction getArea(shape, options) {\n    var area = 0;\n\n    switch(shape) {\n        case shapeType.triangle:\n            area = .5 * options.width * options.height;\n            break;\n    }\n\n    return area;\n}\n\ngetArea(shapeType.triangle, {width: 100, height: 100}); // 5000\n```\n\n## 属性名的遍历\n\nSymbol作为属性名，不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有Symbol属性名。\n\n```javascript\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n\nobj[a] = 'Hello';\nobj[b] = 'World';\n\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\n\nobjSymbols // [Symbol(a), Symbol(b)]\n```\n\n由于以Symbol值作为名称的属性，不会被常规方法遍历得到。因此可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\n\n```javascript\nvar size = Symbol('size');\n\nclass Collection {\n    constructor() {\n        this[size] = 0;\n    }\n    \n    add(item) {\n        this[this[size]] = item;\n        this[size]++;\n    }\n    \n    static sizeOf(instance) {\n        return instance[size];\n    }\n}\n\nvar x = new Collection();\nCollection.sizeOf(x) // 0\n\nx.add('foo');\nCollection.sizeOf(x) // 1\n\nObject.keys(x) // ['0']\nObject.getOwnPropertyNames(x) // ['0']\nObject.getOwnPropertySymbols(x) // [Symbol(size)]\n```\n\n## Symbol.for(), Symbol.keyFor()\n\n有时候希望重新使用同一个Symbol值，`Symbol.for`可以做到这一点。其接受一个字符串为参数，然后搜索有没有已该参数作为名称的Symbol值，有就返回，没有就以这个名称创建一个Symbol值。\n\n```javascript\nvar s1 = Symbol.for('foo')\nvar s2 = Symbol.for('foo')\ns1 === s2 // true\n```\n\n`Symbol.keyFor`方法返回一个已经登记的Symbol类型值的`key`\n\n```javascript\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // foo\n\nvar s2 = Symbol(\"Foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n### 模块的单例模式\n\n```javascript\nconst FOO_KEY = Symbol.for('foo');\n\nfunction A() {\n  this.foo = 'hello';\n}\n\nif (!global[FOO_KEY]) {\n  global[FOO_KEY] = new A();\n}\n\nmodule.exports = global[FOO_KEY];\n```\n\n上面的代码中，可以保证`global[FOO_KEY]`不会被无意间覆盖，但还是可以被改写。\n\n## 内置的Symbol值\n\n除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。\n\n### Symbol.hasInstance\n\n指向一个内部方法。当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用此方法。例如：\n\n```javascript\nclass MyClass {\n  [Symbol.hasIntance](foo) {\n    return foo instanceof Array;\n  }\n}\n\n[1, 2, 3] instanceof new MyClass() // true\n```\n\n### Symbol.isConcatSpreadable\n\n等于一个布尔值，表示该对象使用`Array.prototype.concat()`时，是否可以展开。默认情况下是可以展开的。\n\n```javascript\nlet arr1 = ['c', 'd'];\n['a', 'b'].concat(arr1, 'e'] // ['a', 'b', 'c', 'd', 'e']\narr1[Symbol.isConcatSpreadable] // undefined\n\nlet arr2 = ['c', 'd'];\narr2[Symbol.isConcatSpreadable] = false;\n['a', 'b'].concat(arr2, 'e'] // ['a', 'b', ['c', 'd'], 'e']\n```\n\n### Symbol.species\n\n指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，如果`this.constructor[Symbol.species]`存在，会使用这个属性作为构造函数，来创造新的实例对象。\n\n```javascript\n// 默认读取器如下\nstatic get [Symbol.species] {\n  return this;\n}\n```\n\n### Symbol.match\n\n指向一个函数，当执行`str.match(myObject)`时，如果该属性存在，会调用它，返回该方法的返回值。\n\n```javascript\nString.prototype.match(regexp);\n// 等同于\nregexp[Symbol.match](this);\n\nclass MyMatcher {\n  [Symbol.match](string) {\n    return 'hello world'.indexOf(string);\n  }\n}\n\n'e'.match(new MyMatcher()]; // 1\n```\n\n### Symbol.replace\n\n指向一个方法，当该对象被`Symbol.prototype.replace`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.replace(searchValue, replaceValue);\n// 等同于\nsearchValue[Symbol.replace](this, replaceValue);\n```\n\n下面有一个例子说明这个问题：\n\n```javascript\nconst x = {};\nx[Symbol.replace] = {...s} => console.log(s);\n\n'Hello'.replace(x, 'World') // [\"Hello\", \"World\"]\n```\n\n第一个参数是replace方法正在坐拥的对象，第二个参数替换后的值。\n\n### Symbol.search\n\n指向一个方法，当该对象被`String.prototype.search`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.search(regexp);\n// 等同于\nregexp[Symbol.search](this);\n\nclass MySearch {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.search](string) {\n    return string.indexOf(this.value);\n  }\n}\n'foobar'.search(new MySearch('foo')) // 0\n```\n\n### Symbol.split\n\n指向一个方法，当该对象被`String.prototype.split`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.split(separator, limit);\n// 等同于\nseparator[Symbol.split](this, limit);\n```\n\n### Symbol.iterator\n\n指向该对象的默认遍历方法\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]\n```\n\n### Symbol.toPrimitive\n\n指向一个方法。该对象被转化为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\n\n该方法被调用时，会接受一个字符串参数，表示当前运算的模式，共有三种模式：\n\n- Number：该场合需要转换成数值\n- String：该场合需要转换成字符串\n- Defaul：该场合既可以转换成数值，也可以转换成字符串\n\n```javascript\nlet obj = {\n  [Symbol.toPrimitive](hint) {\n    switch(hint) {\n      case 'number':\n        return 123;\n      case 'string':\n        return 'str';\n      case 'default':\n        return 'default';\n      default:\n        throw new Error();\n    }\n  }\n};\n\n2 * obj // 246\n3 + obj // 3default\nobj == 'default' // true\nString(obj) // str\n```\n\n### Symbol.toStringTag\n\n指向一个方法，在该对象上面调用`Object.prototye.toString`方法时，如果这个属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型。这个属性可以用于定制`[object Object]`或者`[object Array]`中`object`后面的那个字符串。\n\n```javascript\n({[Symbol.toStringTag]: 'Foo'}.toString())\n// [object Object]\n\nclass Collection {\n  get [Symbol.toStringTag]() {\n    return 'xxx';\n  }\n}\n\nvar x = new Collection();\nObject.prototype.toString.call(x); // [object xxx]\n```\n\n### Symbol.unscopables\n\n指向一个对象。该对象指定了使用`with`关键字时，哪些属性会被`with`环境排除。\n\n```javascript\nArray.prototype[Symbol.unscopables]\n\nObject.keys(Array.prototype[Symbol.unscopables])\n```\n\n上面的代码说明，数组有6个属性，会被`with`命令排除。\n\n```javascript\nclass MyClass {\n  foo() {return 1;}\n}\n\nvar foo = function () {return 2;}\n\nwith [MyClass.prototype] {\n  foo();\n}\n\nclass MyClass {\n  foo() {return 1;}\n  get [Symbol.unscopables]() {\n    return {foo: true};\n  }\n}\n\nvar foo = function() {return 2;}\nwith (MyClass.prototype) {\n  foo();\n}\n```\n","source":"_posts/javascript/es6-symbol.md","raw":"---\ntitle: ES6 Symbol\ndate: 2022-02-17 15:15:26\nupdated: 2022-02-17 15:15:26\ntags: ES6基础\ncategories: JavaScript\n---\n\n# Symbol\n\nES5的对象属性名都是字符串，这容易造成属性名的冲突。如果存在一种机制，能够保证每个属性的名字都是独一无二的就可以解决这个问题。因此ES6中引入了Symbol。\n\nES6引入了一种新的原始数据类型Symbol，表示独一无二的值。可以称之为JavaScript的第七种数据类型。\n\nSymbol是通过symbol函数生成的。也就是说，对象的属性名可以有两种类型，一种是原来就有的字符串，另一种是新增的Symbol类型。凡是属性名属于Symbol的，就是独一无二的，可以保证不会与其他属性名发生冲突。\n\n```javascript\nlet s = Symbol();\ntypeof s // symbol\n```\n\n`Symbol`函数可以接收一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示或者是转为字符串的过程中方便区分。\n\n```javascript\nvar s1 = Symbol('foo');\nvar s2 = Symbol('bar');\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // \"Symbol(foo)\"\ns2.toString() // \"Symbol(bar)\"\n```\n\n如果Symbol的参数是一个对象，那么就会调用该对象的`toString()`方法，将其转换为字符串，然后才生成一个Symbol值。\n\n```javascript\nconst obj = {\n    toString() {\n        return 'abc';\n    }\n};\n\nconst sym = Symbol(obj);\nsym // Symbol(abc)\n```\n\nSymbol值不能与其他类型的值进行运算，会报错；但是却可以显式转换为字符串\n\n```javascript\nvar sym = Symbol('My Symbol');\n\n\"your symbol is \" + sym // Error\n\nString(sym); // Symbol('My symbol')\nsym.toString(); // Symbol(My symbol)\n```\n\n## 作为属性名的Symbol\n\n由于每一个Symbol值都是不相等的，这意味着Symbol可以作为标识符，用在对象的属性名，就能保证不会出现同名的属性。可以防止某一个键被不小心改写或覆盖。\n\n```javascript\nvar mySymbol = Symbol();\n\nvar a = {};\na[mySymbol] = 'Hello!';\n\nvar a = {\n    [mySymbol]: 'Hello'\n};\n\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello' });\n\na[mySymbol] // \"Hello\"\n```\n\nSymbol值作为对象属性名时，不能用作点运算符。\n\n```javascript\nvar mySymbol = Symbol();\nvar a = {};\n\na.mySymbol = 'Hello';\na[mySymbol] // undefined\na['mySymbol'] // Hello\n```\n\nSymbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\n\n```javascript\nlog.levels = {\n    DEBUG: Symbol('debug'),\n    INFO: Symbol('info'),\n    WARN: Symbol('warn')\n};\n\nlog(log.levels.DEBUG, 'debug message');\nlog(log.levels.INFO, 'info message');\n```\n\n还有一个例子：\n\n```javascript\nvar shapeType = {\n    triangle: Symbol()\n};\n\nfunction getArea(shape, options) {\n    var area = 0;\n\n    switch(shape) {\n        case shapeType.triangle:\n            area = .5 * options.width * options.height;\n            break;\n    }\n\n    return area;\n}\n\ngetArea(shapeType.triangle, {width: 100, height: 100}); // 5000\n```\n\n## 属性名的遍历\n\nSymbol作为属性名，不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有Symbol属性名。\n\n```javascript\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n\nobj[a] = 'Hello';\nobj[b] = 'World';\n\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\n\nobjSymbols // [Symbol(a), Symbol(b)]\n```\n\n由于以Symbol值作为名称的属性，不会被常规方法遍历得到。因此可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\n\n```javascript\nvar size = Symbol('size');\n\nclass Collection {\n    constructor() {\n        this[size] = 0;\n    }\n    \n    add(item) {\n        this[this[size]] = item;\n        this[size]++;\n    }\n    \n    static sizeOf(instance) {\n        return instance[size];\n    }\n}\n\nvar x = new Collection();\nCollection.sizeOf(x) // 0\n\nx.add('foo');\nCollection.sizeOf(x) // 1\n\nObject.keys(x) // ['0']\nObject.getOwnPropertyNames(x) // ['0']\nObject.getOwnPropertySymbols(x) // [Symbol(size)]\n```\n\n## Symbol.for(), Symbol.keyFor()\n\n有时候希望重新使用同一个Symbol值，`Symbol.for`可以做到这一点。其接受一个字符串为参数，然后搜索有没有已该参数作为名称的Symbol值，有就返回，没有就以这个名称创建一个Symbol值。\n\n```javascript\nvar s1 = Symbol.for('foo')\nvar s2 = Symbol.for('foo')\ns1 === s2 // true\n```\n\n`Symbol.keyFor`方法返回一个已经登记的Symbol类型值的`key`\n\n```javascript\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // foo\n\nvar s2 = Symbol(\"Foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n### 模块的单例模式\n\n```javascript\nconst FOO_KEY = Symbol.for('foo');\n\nfunction A() {\n  this.foo = 'hello';\n}\n\nif (!global[FOO_KEY]) {\n  global[FOO_KEY] = new A();\n}\n\nmodule.exports = global[FOO_KEY];\n```\n\n上面的代码中，可以保证`global[FOO_KEY]`不会被无意间覆盖，但还是可以被改写。\n\n## 内置的Symbol值\n\n除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。\n\n### Symbol.hasInstance\n\n指向一个内部方法。当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用此方法。例如：\n\n```javascript\nclass MyClass {\n  [Symbol.hasIntance](foo) {\n    return foo instanceof Array;\n  }\n}\n\n[1, 2, 3] instanceof new MyClass() // true\n```\n\n### Symbol.isConcatSpreadable\n\n等于一个布尔值，表示该对象使用`Array.prototype.concat()`时，是否可以展开。默认情况下是可以展开的。\n\n```javascript\nlet arr1 = ['c', 'd'];\n['a', 'b'].concat(arr1, 'e'] // ['a', 'b', 'c', 'd', 'e']\narr1[Symbol.isConcatSpreadable] // undefined\n\nlet arr2 = ['c', 'd'];\narr2[Symbol.isConcatSpreadable] = false;\n['a', 'b'].concat(arr2, 'e'] // ['a', 'b', ['c', 'd'], 'e']\n```\n\n### Symbol.species\n\n指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，如果`this.constructor[Symbol.species]`存在，会使用这个属性作为构造函数，来创造新的实例对象。\n\n```javascript\n// 默认读取器如下\nstatic get [Symbol.species] {\n  return this;\n}\n```\n\n### Symbol.match\n\n指向一个函数，当执行`str.match(myObject)`时，如果该属性存在，会调用它，返回该方法的返回值。\n\n```javascript\nString.prototype.match(regexp);\n// 等同于\nregexp[Symbol.match](this);\n\nclass MyMatcher {\n  [Symbol.match](string) {\n    return 'hello world'.indexOf(string);\n  }\n}\n\n'e'.match(new MyMatcher()]; // 1\n```\n\n### Symbol.replace\n\n指向一个方法，当该对象被`Symbol.prototype.replace`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.replace(searchValue, replaceValue);\n// 等同于\nsearchValue[Symbol.replace](this, replaceValue);\n```\n\n下面有一个例子说明这个问题：\n\n```javascript\nconst x = {};\nx[Symbol.replace] = {...s} => console.log(s);\n\n'Hello'.replace(x, 'World') // [\"Hello\", \"World\"]\n```\n\n第一个参数是replace方法正在坐拥的对象，第二个参数替换后的值。\n\n### Symbol.search\n\n指向一个方法，当该对象被`String.prototype.search`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.search(regexp);\n// 等同于\nregexp[Symbol.search](this);\n\nclass MySearch {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.search](string) {\n    return string.indexOf(this.value);\n  }\n}\n'foobar'.search(new MySearch('foo')) // 0\n```\n\n### Symbol.split\n\n指向一个方法，当该对象被`String.prototype.split`方法调用时，会返回该方法的返回值。\n\n```javascript\nString.prototype.split(separator, limit);\n// 等同于\nseparator[Symbol.split](this, limit);\n```\n\n### Symbol.iterator\n\n指向该对象的默认遍历方法\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]\n```\n\n### Symbol.toPrimitive\n\n指向一个方法。该对象被转化为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\n\n该方法被调用时，会接受一个字符串参数，表示当前运算的模式，共有三种模式：\n\n- Number：该场合需要转换成数值\n- String：该场合需要转换成字符串\n- Defaul：该场合既可以转换成数值，也可以转换成字符串\n\n```javascript\nlet obj = {\n  [Symbol.toPrimitive](hint) {\n    switch(hint) {\n      case 'number':\n        return 123;\n      case 'string':\n        return 'str';\n      case 'default':\n        return 'default';\n      default:\n        throw new Error();\n    }\n  }\n};\n\n2 * obj // 246\n3 + obj // 3default\nobj == 'default' // true\nString(obj) // str\n```\n\n### Symbol.toStringTag\n\n指向一个方法，在该对象上面调用`Object.prototye.toString`方法时，如果这个属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型。这个属性可以用于定制`[object Object]`或者`[object Array]`中`object`后面的那个字符串。\n\n```javascript\n({[Symbol.toStringTag]: 'Foo'}.toString())\n// [object Object]\n\nclass Collection {\n  get [Symbol.toStringTag]() {\n    return 'xxx';\n  }\n}\n\nvar x = new Collection();\nObject.prototype.toString.call(x); // [object xxx]\n```\n\n### Symbol.unscopables\n\n指向一个对象。该对象指定了使用`with`关键字时，哪些属性会被`with`环境排除。\n\n```javascript\nArray.prototype[Symbol.unscopables]\n\nObject.keys(Array.prototype[Symbol.unscopables])\n```\n\n上面的代码说明，数组有6个属性，会被`with`命令排除。\n\n```javascript\nclass MyClass {\n  foo() {return 1;}\n}\n\nvar foo = function () {return 2;}\n\nwith [MyClass.prototype] {\n  foo();\n}\n\nclass MyClass {\n  foo() {return 1;}\n  get [Symbol.unscopables]() {\n    return {foo: true};\n  }\n}\n\nvar foo = function() {return 2;}\nwith (MyClass.prototype) {\n  foo();\n}\n```\n","slug":"javascript/es6-symbol","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3c00282y617vgu2k67","content":"<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。如果存在一种机制，能够保证每个属性的名字都是独一无二的就可以解决这个问题。因此ES6中引入了Symbol。</p>\n<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。可以称之为JavaScript的第七种数据类型。</p>\n<p>Symbol是通过symbol函数生成的。也就是说，对象的属性名可以有两种类型，一种是原来就有的字符串，另一种是新增的Symbol类型。凡是属性名属于Symbol的，就是独一无二的，可以保证不会与其他属性名发生冲突。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-title class_\">Symbol</span>();<br><span class=\"hljs-keyword\">typeof</span> s <span class=\"hljs-comment\">// symbol</span><br></code></pre></td></tr></table></figure>\n<p><code>Symbol</code>函数可以接收一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示或者是转为字符串的过程中方便区分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>);<br><br>s1 <span class=\"hljs-comment\">// Symbol(foo)</span><br>s2 <span class=\"hljs-comment\">// Symbol(bar)</span><br><br>s1.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// &quot;Symbol(foo)&quot;</span><br>s2.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// &quot;Symbol(bar)&quot;</span><br></code></pre></td></tr></table></figure>\n<p>如果Symbol的参数是一个对象，那么就会调用该对象的<code>toString()</code>方法，将其转换为字符串，然后才生成一个Symbol值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> sym = <span class=\"hljs-title class_\">Symbol</span>(obj);<br>sym <span class=\"hljs-comment\">// Symbol(abc)</span><br></code></pre></td></tr></table></figure>\n<p>Symbol值不能与其他类型的值进行运算，会报错；但是却可以显式转换为字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> sym = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;My Symbol&#x27;</span>);<br><br><span class=\"hljs-string\">&quot;your symbol is &quot;</span> + sym <span class=\"hljs-comment\">// Error</span><br><br><span class=\"hljs-title class_\">String</span>(sym); <span class=\"hljs-comment\">// Symbol(&#x27;My symbol&#x27;)</span><br>sym.<span class=\"hljs-title function_\">toString</span>(); <span class=\"hljs-comment\">// Symbol(My symbol)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"作为属性名的Symbol\"><a href=\"#作为属性名的Symbol\" class=\"headerlink\" title=\"作为属性名的Symbol\"></a>作为属性名的Symbol</h2><p>由于每一个Symbol值都是不相等的，这意味着Symbol可以作为标识符，用在对象的属性名，就能保证不会出现同名的属性。可以防止某一个键被不小心改写或覆盖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> mySymbol = <span class=\"hljs-title class_\">Symbol</span>();<br><br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br>a[mySymbol] = <span class=\"hljs-string\">&#x27;Hello!&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;<br>    [mySymbol]: <span class=\"hljs-string\">&#x27;Hello&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(a, mySymbol, &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span> &#125;);<br><br>a[mySymbol] <span class=\"hljs-comment\">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<p>Symbol值作为对象属性名时，不能用作点运算符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> mySymbol = <span class=\"hljs-title class_\">Symbol</span>();<br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br><br>a.<span class=\"hljs-property\">mySymbol</span> = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;<br>a[mySymbol] <span class=\"hljs-comment\">// undefined</span><br>a[<span class=\"hljs-string\">&#x27;mySymbol&#x27;</span>] <span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n<p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">log.<span class=\"hljs-property\">levels</span> = &#123;<br>    <span class=\"hljs-attr\">DEBUG</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;debug&#x27;</span>),<br>    <span class=\"hljs-attr\">INFO</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;info&#x27;</span>),<br>    <span class=\"hljs-attr\">WARN</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;warn&#x27;</span>)<br>&#125;;<br><br><span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-property\">levels</span>.<span class=\"hljs-property\">DEBUG</span>, <span class=\"hljs-string\">&#x27;debug message&#x27;</span>);<br><span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-property\">levels</span>.<span class=\"hljs-property\">INFO</span>, <span class=\"hljs-string\">&#x27;info message&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>还有一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> shapeType = &#123;<br>    <span class=\"hljs-attr\">triangle</span>: <span class=\"hljs-title class_\">Symbol</span>()<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getArea</span>(<span class=\"hljs-params\">shape, options</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> area = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">switch</span>(shape) &#123;<br>        <span class=\"hljs-keyword\">case</span> shapeType.<span class=\"hljs-property\">triangle</span>:<br>            area = <span class=\"hljs-number\">.5</span> * options.<span class=\"hljs-property\">width</span> * options.<span class=\"hljs-property\">height</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> area;<br>&#125;<br><br><span class=\"hljs-title function_\">getArea</span>(shapeType.<span class=\"hljs-property\">triangle</span>, &#123;<span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">100</span>&#125;); <span class=\"hljs-comment\">// 5000</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"属性名的遍历\"><a href=\"#属性名的遍历\" class=\"headerlink\" title=\"属性名的遍历\"></a>属性名的遍历</h2><p>Symbol作为属性名，不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有Symbol属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br><br>obj[a] = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;<br>obj[b] = <span class=\"hljs-string\">&#x27;World&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> objectSymbols = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(obj);<br><br>objSymbols <span class=\"hljs-comment\">// [Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure>\n<p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到。因此可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> size = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;size&#x27;</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Collection</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[size] = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">item</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[<span class=\"hljs-variable language_\">this</span>[size]] = item;<br>        <span class=\"hljs-variable language_\">this</span>[size]++;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">sizeOf</span>(<span class=\"hljs-params\">instance</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> instance[size];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Collection</span>();<br><span class=\"hljs-title class_\">Collection</span>.<span class=\"hljs-title function_\">sizeOf</span>(x) <span class=\"hljs-comment\">// 0</span><br><br>x.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-title class_\">Collection</span>.<span class=\"hljs-title function_\">sizeOf</span>(x) <span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(x) <span class=\"hljs-comment\">// [&#x27;0&#x27;]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyNames</span>(x) <span class=\"hljs-comment\">// [&#x27;0&#x27;]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(x) <span class=\"hljs-comment\">// [Symbol(size)]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Symbol-for-Symbol-keyFor\"><a href=\"#Symbol-for-Symbol-keyFor\" class=\"headerlink\" title=\"Symbol.for(), Symbol.keyFor()\"></a>Symbol.for(), Symbol.keyFor()</h2><p>有时候希望重新使用同一个Symbol值，<code>Symbol.for</code>可以做到这一点。其接受一个字符串为参数，然后搜索有没有已该参数作为名称的Symbol值，有就返回，没有就以这个名称创建一个Symbol值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>s1 === s2 <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p><code>Symbol.keyFor</code>方法返回一个已经登记的Symbol类型值的<code>key</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;foo&quot;</span>);<br><span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(s1) <span class=\"hljs-comment\">// foo</span><br><br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;Foo&quot;</span>);<br><span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(s2) <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"模块的单例模式\"><a href=\"#模块的单例模式\" class=\"headerlink\" title=\"模块的单例模式\"></a>模块的单例模式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">FOO_KEY</span> = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">A</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>]) &#123;<br>  <span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>();<br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>];<br></code></pre></td></tr></table></figure>\n<p>上面的代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>\n<h2 id=\"内置的Symbol值\"><a href=\"#内置的Symbol值\" class=\"headerlink\" title=\"内置的Symbol值\"></a>内置的Symbol值</h2><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>\n<h3 id=\"Symbol-hasInstance\"><a href=\"#Symbol-hasInstance\" class=\"headerlink\" title=\"Symbol.hasInstance\"></a>Symbol.hasInstance</h3><p>指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用此方法。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">hasIntance</span>](foo) &#123;<br>    <span class=\"hljs-keyword\">return</span> foo <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>;<br>  &#125;<br>&#125;<br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClass</span>() <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-isConcatSpreadable\"><a href=\"#Symbol-isConcatSpreadable\" class=\"headerlink\" title=\"Symbol.isConcatSpreadable\"></a>Symbol.isConcatSpreadable</h3><p>等于一个布尔值，表示该对象使用<code>Array.prototype.concat()</code>时，是否可以展开。默认情况下是可以展开的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>];<br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">concat</span>(arr1, <span class=\"hljs-string\">&#x27;e&#x27;</span>] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br>arr1[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">isConcatSpreadable</span>] <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">let</span> arr2 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>];<br>arr2[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">isConcatSpreadable</span>] = <span class=\"hljs-literal\">false</span>;<br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">concat</span>(arr2, <span class=\"hljs-string\">&#x27;e&#x27;</span>] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;, &#x27;d&#x27;], &#x27;e&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-species\"><a href=\"#Symbol-species\" class=\"headerlink\" title=\"Symbol.species\"></a>Symbol.species</h3><p>指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，如果<code>this.constructor[Symbol.species]</code>存在，会使用这个属性作为构造函数，来创造新的实例对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 默认读取器如下</span><br><span class=\"hljs-keyword\">static</span> get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">species</span>] &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-match\"><a href=\"#Symbol-match\" class=\"headerlink\" title=\"Symbol.match\"></a>Symbol.match</h3><p>指向一个函数，当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">match</span>(regexp);<br><span class=\"hljs-comment\">// 等同于</span><br>regexp[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">match</span>](<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyMatcher</span> &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">match</span>](string) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span>.<span class=\"hljs-title function_\">indexOf</span>(string);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-string\">&#x27;e&#x27;</span>.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyMatcher</span>()]; <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-replace\"><a href=\"#Symbol-replace\" class=\"headerlink\" title=\"Symbol.replace\"></a>Symbol.replace</h3><p>指向一个方法，当该对象被<code>Symbol.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">replace</span>(searchValue, replaceValue);<br><span class=\"hljs-comment\">// 等同于</span><br>searchValue[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">replace</span>](<span class=\"hljs-variable language_\">this</span>, replaceValue);<br></code></pre></td></tr></table></figure>\n<p>下面有一个例子说明这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> x = &#123;&#125;;<br>x[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">replace</span>] = &#123;...s&#125; =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s);<br><br><span class=\"hljs-string\">&#x27;Hello&#x27;</span>.<span class=\"hljs-title function_\">replace</span>(x, <span class=\"hljs-string\">&#x27;World&#x27;</span>) <span class=\"hljs-comment\">// [&quot;Hello&quot;, &quot;World&quot;]</span><br></code></pre></td></tr></table></figure>\n<p>第一个参数是replace方法正在坐拥的对象，第二个参数替换后的值。</p>\n<h3 id=\"Symbol-search\"><a href=\"#Symbol-search\" class=\"headerlink\" title=\"Symbol.search\"></a>Symbol.search</h3><p>指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">search</span>(regexp);<br><span class=\"hljs-comment\">// 等同于</span><br>regexp[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">search</span>](<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MySearch</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;<br>  &#125;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">search</span>](string) &#123;<br>    <span class=\"hljs-keyword\">return</span> string.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-string\">&#x27;foobar&#x27;</span>.<span class=\"hljs-title function_\">search</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MySearch</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)) <span class=\"hljs-comment\">// 0</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-split\"><a href=\"#Symbol-split\" class=\"headerlink\" title=\"Symbol.split\"></a>Symbol.split</h3><p>指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">split</span>(separator, limit);<br><span class=\"hljs-comment\">// 等同于</span><br>separator[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">split</span>](<span class=\"hljs-variable language_\">this</span>, limit);<br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-iterator\"><a href=\"#Symbol-iterator\" class=\"headerlink\" title=\"Symbol.iterator\"></a>Symbol.iterator</h3><p>指向该对象的默认遍历方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br><br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-toPrimitive\"><a href=\"#Symbol-toPrimitive\" class=\"headerlink\" title=\"Symbol.toPrimitive\"></a>Symbol.toPrimitive</h3><p>指向一个方法。该对象被转化为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>\n<p>该方法被调用时，会接受一个字符串参数，表示当前运算的模式，共有三种模式：</p>\n<ul>\n<li>Number：该场合需要转换成数值</li>\n<li>String：该场合需要转换成字符串</li>\n<li>Defaul：该场合既可以转换成数值，也可以转换成字符串</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toPrimitive</span>](hint) &#123;<br>    <span class=\"hljs-keyword\">switch</span>(hint) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;number&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">123</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;string&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;str&#x27;</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;default&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;default&#x27;</span>;<br>      <span class=\"hljs-attr\">default</span>:<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-number\">2</span> * obj <span class=\"hljs-comment\">// 246</span><br><span class=\"hljs-number\">3</span> + obj <span class=\"hljs-comment\">// 3default</span><br>obj == <span class=\"hljs-string\">&#x27;default&#x27;</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">String</span>(obj) <span class=\"hljs-comment\">// str</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-toStringTag\"><a href=\"#Symbol-toStringTag\" class=\"headerlink\" title=\"Symbol.toStringTag\"></a>Symbol.toStringTag</h3><p>指向一个方法，在该对象上面调用<code>Object.prototye.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。这个属性可以用于定制<code>[object Object]</code>或者<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(&#123;[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]: <span class=\"hljs-string\">&#x27;Foo&#x27;</span>&#125;.<span class=\"hljs-title function_\">toString</span>())<br><span class=\"hljs-comment\">// [object Object]</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Collection</span> &#123;<br>  get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;xxx&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Collection</span>();<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(x); <span class=\"hljs-comment\">// [object xxx]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-unscopables\"><a href=\"#Symbol-unscopables\" class=\"headerlink\" title=\"Symbol.unscopables\"></a>Symbol.unscopables</h3><p>指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>]<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>])<br></code></pre></td></tr></table></figure>\n<p>上面的代码说明，数组有6个属性，会被<code>with</code>命令排除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;&#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;&#125;<br><br><span class=\"hljs-keyword\">with</span> [<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>] &#123;<br>  <span class=\"hljs-title function_\">foo</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;&#125;<br>  get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>]() &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-literal\">true</span>&#125;;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;&#125;<br><span class=\"hljs-keyword\">with</span> (<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) &#123;<br>  <span class=\"hljs-title function_\">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":7133,"excerpt":"","more":"<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。如果存在一种机制，能够保证每个属性的名字都是独一无二的就可以解决这个问题。因此ES6中引入了Symbol。</p>\n<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。可以称之为JavaScript的第七种数据类型。</p>\n<p>Symbol是通过symbol函数生成的。也就是说，对象的属性名可以有两种类型，一种是原来就有的字符串，另一种是新增的Symbol类型。凡是属性名属于Symbol的，就是独一无二的，可以保证不会与其他属性名发生冲突。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-title class_\">Symbol</span>();<br><span class=\"hljs-keyword\">typeof</span> s <span class=\"hljs-comment\">// symbol</span><br></code></pre></td></tr></table></figure>\n<p><code>Symbol</code>函数可以接收一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示或者是转为字符串的过程中方便区分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>);<br><br>s1 <span class=\"hljs-comment\">// Symbol(foo)</span><br>s2 <span class=\"hljs-comment\">// Symbol(bar)</span><br><br>s1.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// &quot;Symbol(foo)&quot;</span><br>s2.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// &quot;Symbol(bar)&quot;</span><br></code></pre></td></tr></table></figure>\n<p>如果Symbol的参数是一个对象，那么就会调用该对象的<code>toString()</code>方法，将其转换为字符串，然后才生成一个Symbol值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;abc&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> sym = <span class=\"hljs-title class_\">Symbol</span>(obj);<br>sym <span class=\"hljs-comment\">// Symbol(abc)</span><br></code></pre></td></tr></table></figure>\n<p>Symbol值不能与其他类型的值进行运算，会报错；但是却可以显式转换为字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> sym = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;My Symbol&#x27;</span>);<br><br><span class=\"hljs-string\">&quot;your symbol is &quot;</span> + sym <span class=\"hljs-comment\">// Error</span><br><br><span class=\"hljs-title class_\">String</span>(sym); <span class=\"hljs-comment\">// Symbol(&#x27;My symbol&#x27;)</span><br>sym.<span class=\"hljs-title function_\">toString</span>(); <span class=\"hljs-comment\">// Symbol(My symbol)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"作为属性名的Symbol\"><a href=\"#作为属性名的Symbol\" class=\"headerlink\" title=\"作为属性名的Symbol\"></a>作为属性名的Symbol</h2><p>由于每一个Symbol值都是不相等的，这意味着Symbol可以作为标识符，用在对象的属性名，就能保证不会出现同名的属性。可以防止某一个键被不小心改写或覆盖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> mySymbol = <span class=\"hljs-title class_\">Symbol</span>();<br><br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br>a[mySymbol] = <span class=\"hljs-string\">&#x27;Hello!&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;<br>    [mySymbol]: <span class=\"hljs-string\">&#x27;Hello&#x27;</span><br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(a, mySymbol, &#123; <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span> &#125;);<br><br>a[mySymbol] <span class=\"hljs-comment\">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<p>Symbol值作为对象属性名时，不能用作点运算符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> mySymbol = <span class=\"hljs-title class_\">Symbol</span>();<br><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;<br><br>a.<span class=\"hljs-property\">mySymbol</span> = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;<br>a[mySymbol] <span class=\"hljs-comment\">// undefined</span><br>a[<span class=\"hljs-string\">&#x27;mySymbol&#x27;</span>] <span class=\"hljs-comment\">// Hello</span><br></code></pre></td></tr></table></figure>\n<p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">log.<span class=\"hljs-property\">levels</span> = &#123;<br>    <span class=\"hljs-attr\">DEBUG</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;debug&#x27;</span>),<br>    <span class=\"hljs-attr\">INFO</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;info&#x27;</span>),<br>    <span class=\"hljs-attr\">WARN</span>: <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;warn&#x27;</span>)<br>&#125;;<br><br><span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-property\">levels</span>.<span class=\"hljs-property\">DEBUG</span>, <span class=\"hljs-string\">&#x27;debug message&#x27;</span>);<br><span class=\"hljs-title function_\">log</span>(log.<span class=\"hljs-property\">levels</span>.<span class=\"hljs-property\">INFO</span>, <span class=\"hljs-string\">&#x27;info message&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>还有一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> shapeType = &#123;<br>    <span class=\"hljs-attr\">triangle</span>: <span class=\"hljs-title class_\">Symbol</span>()<br>&#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getArea</span>(<span class=\"hljs-params\">shape, options</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> area = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">switch</span>(shape) &#123;<br>        <span class=\"hljs-keyword\">case</span> shapeType.<span class=\"hljs-property\">triangle</span>:<br>            area = <span class=\"hljs-number\">.5</span> * options.<span class=\"hljs-property\">width</span> * options.<span class=\"hljs-property\">height</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> area;<br>&#125;<br><br><span class=\"hljs-title function_\">getArea</span>(shapeType.<span class=\"hljs-property\">triangle</span>, &#123;<span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">100</span>&#125;); <span class=\"hljs-comment\">// 5000</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"属性名的遍历\"><a href=\"#属性名的遍历\" class=\"headerlink\" title=\"属性名的遍历\"></a>属性名的遍历</h2><p>Symbol作为属性名，不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有Symbol属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;&#125;;<br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);<br><br>obj[a] = <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;<br>obj[b] = <span class=\"hljs-string\">&#x27;World&#x27;</span>;<br><br><span class=\"hljs-keyword\">var</span> objectSymbols = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(obj);<br><br>objSymbols <span class=\"hljs-comment\">// [Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure>\n<p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到。因此可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> size = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&#x27;size&#x27;</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Collection</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[size] = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">item</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>[<span class=\"hljs-variable language_\">this</span>[size]] = item;<br>        <span class=\"hljs-variable language_\">this</span>[size]++;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">sizeOf</span>(<span class=\"hljs-params\">instance</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> instance[size];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Collection</span>();<br><span class=\"hljs-title class_\">Collection</span>.<span class=\"hljs-title function_\">sizeOf</span>(x) <span class=\"hljs-comment\">// 0</span><br><br>x.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><span class=\"hljs-title class_\">Collection</span>.<span class=\"hljs-title function_\">sizeOf</span>(x) <span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(x) <span class=\"hljs-comment\">// [&#x27;0&#x27;]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyNames</span>(x) <span class=\"hljs-comment\">// [&#x27;0&#x27;]</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(x) <span class=\"hljs-comment\">// [Symbol(size)]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Symbol-for-Symbol-keyFor\"><a href=\"#Symbol-for-Symbol-keyFor\" class=\"headerlink\" title=\"Symbol.for(), Symbol.keyFor()\"></a>Symbol.for(), Symbol.keyFor()</h2><p>有时候希望重新使用同一个Symbol值，<code>Symbol.for</code>可以做到这一点。其接受一个字符串为参数，然后搜索有没有已该参数作为名称的Symbol值，有就返回，没有就以这个名称创建一个Symbol值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br>s1 === s2 <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<p><code>Symbol.keyFor</code>方法返回一个已经登记的Symbol类型值的<code>key</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;foo&quot;</span>);<br><span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(s1) <span class=\"hljs-comment\">// foo</span><br><br><span class=\"hljs-keyword\">var</span> s2 = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;Foo&quot;</span>);<br><span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(s2) <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"模块的单例模式\"><a href=\"#模块的单例模式\" class=\"headerlink\" title=\"模块的单例模式\"></a>模块的单例模式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">FOO_KEY</span> = <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">A</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">foo</span> = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>]) &#123;<br>  <span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>();<br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-variable language_\">global</span>[<span class=\"hljs-variable constant_\">FOO_KEY</span>];<br></code></pre></td></tr></table></figure>\n<p>上面的代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>\n<h2 id=\"内置的Symbol值\"><a href=\"#内置的Symbol值\" class=\"headerlink\" title=\"内置的Symbol值\"></a>内置的Symbol值</h2><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>\n<h3 id=\"Symbol-hasInstance\"><a href=\"#Symbol-hasInstance\" class=\"headerlink\" title=\"Symbol.hasInstance\"></a>Symbol.hasInstance</h3><p>指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用此方法。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">hasIntance</span>](foo) &#123;<br>    <span class=\"hljs-keyword\">return</span> foo <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>;<br>  &#125;<br>&#125;<br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyClass</span>() <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-isConcatSpreadable\"><a href=\"#Symbol-isConcatSpreadable\" class=\"headerlink\" title=\"Symbol.isConcatSpreadable\"></a>Symbol.isConcatSpreadable</h3><p>等于一个布尔值，表示该对象使用<code>Array.prototype.concat()</code>时，是否可以展开。默认情况下是可以展开的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>];<br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">concat</span>(arr1, <span class=\"hljs-string\">&#x27;e&#x27;</span>] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br>arr1[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">isConcatSpreadable</span>] <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">let</span> arr2 = [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>];<br>arr2[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">isConcatSpreadable</span>] = <span class=\"hljs-literal\">false</span>;<br>[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>].<span class=\"hljs-title function_\">concat</span>(arr2, <span class=\"hljs-string\">&#x27;e&#x27;</span>] <span class=\"hljs-comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;, &#x27;d&#x27;], &#x27;e&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-species\"><a href=\"#Symbol-species\" class=\"headerlink\" title=\"Symbol.species\"></a>Symbol.species</h3><p>指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，如果<code>this.constructor[Symbol.species]</code>存在，会使用这个属性作为构造函数，来创造新的实例对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 默认读取器如下</span><br><span class=\"hljs-keyword\">static</span> get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">species</span>] &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-match\"><a href=\"#Symbol-match\" class=\"headerlink\" title=\"Symbol.match\"></a>Symbol.match</h3><p>指向一个函数，当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">match</span>(regexp);<br><span class=\"hljs-comment\">// 等同于</span><br>regexp[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">match</span>](<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyMatcher</span> &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">match</span>](string) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span>.<span class=\"hljs-title function_\">indexOf</span>(string);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-string\">&#x27;e&#x27;</span>.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyMatcher</span>()]; <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-replace\"><a href=\"#Symbol-replace\" class=\"headerlink\" title=\"Symbol.replace\"></a>Symbol.replace</h3><p>指向一个方法，当该对象被<code>Symbol.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">replace</span>(searchValue, replaceValue);<br><span class=\"hljs-comment\">// 等同于</span><br>searchValue[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">replace</span>](<span class=\"hljs-variable language_\">this</span>, replaceValue);<br></code></pre></td></tr></table></figure>\n<p>下面有一个例子说明这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> x = &#123;&#125;;<br>x[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">replace</span>] = &#123;...s&#125; =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s);<br><br><span class=\"hljs-string\">&#x27;Hello&#x27;</span>.<span class=\"hljs-title function_\">replace</span>(x, <span class=\"hljs-string\">&#x27;World&#x27;</span>) <span class=\"hljs-comment\">// [&quot;Hello&quot;, &quot;World&quot;]</span><br></code></pre></td></tr></table></figure>\n<p>第一个参数是replace方法正在坐拥的对象，第二个参数替换后的值。</p>\n<h3 id=\"Symbol-search\"><a href=\"#Symbol-search\" class=\"headerlink\" title=\"Symbol.search\"></a>Symbol.search</h3><p>指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">search</span>(regexp);<br><span class=\"hljs-comment\">// 等同于</span><br>regexp[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">search</span>](<span class=\"hljs-variable language_\">this</span>);<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MySearch</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;<br>  &#125;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">search</span>](string) &#123;<br>    <span class=\"hljs-keyword\">return</span> string.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-string\">&#x27;foobar&#x27;</span>.<span class=\"hljs-title function_\">search</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MySearch</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)) <span class=\"hljs-comment\">// 0</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-split\"><a href=\"#Symbol-split\" class=\"headerlink\" title=\"Symbol.split\"></a>Symbol.split</h3><p>指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">split</span>(separator, limit);<br><span class=\"hljs-comment\">// 等同于</span><br>separator[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">split</span>](<span class=\"hljs-variable language_\">this</span>, limit);<br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-iterator\"><a href=\"#Symbol-iterator\" class=\"headerlink\" title=\"Symbol.iterator\"></a>Symbol.iterator</h3><p>指向该对象的默认遍历方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myIterable = &#123;&#125;;<br>myIterable[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>] = <span class=\"hljs-keyword\">function</span>* () &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;;<br><br>[...myIterable] <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-toPrimitive\"><a href=\"#Symbol-toPrimitive\" class=\"headerlink\" title=\"Symbol.toPrimitive\"></a>Symbol.toPrimitive</h3><p>指向一个方法。该对象被转化为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>\n<p>该方法被调用时，会接受一个字符串参数，表示当前运算的模式，共有三种模式：</p>\n<ul>\n<li>Number：该场合需要转换成数值</li>\n<li>String：该场合需要转换成字符串</li>\n<li>Defaul：该场合既可以转换成数值，也可以转换成字符串</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123;<br>  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toPrimitive</span>](hint) &#123;<br>    <span class=\"hljs-keyword\">switch</span>(hint) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;number&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">123</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;string&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;str&#x27;</span>;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;default&#x27;</span>:<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;default&#x27;</span>;<br>      <span class=\"hljs-attr\">default</span>:<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-number\">2</span> * obj <span class=\"hljs-comment\">// 246</span><br><span class=\"hljs-number\">3</span> + obj <span class=\"hljs-comment\">// 3default</span><br>obj == <span class=\"hljs-string\">&#x27;default&#x27;</span> <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-title class_\">String</span>(obj) <span class=\"hljs-comment\">// str</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-toStringTag\"><a href=\"#Symbol-toStringTag\" class=\"headerlink\" title=\"Symbol.toStringTag\"></a>Symbol.toStringTag</h3><p>指向一个方法，在该对象上面调用<code>Object.prototye.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。这个属性可以用于定制<code>[object Object]</code>或者<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(&#123;[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]: <span class=\"hljs-string\">&#x27;Foo&#x27;</span>&#125;.<span class=\"hljs-title function_\">toString</span>())<br><span class=\"hljs-comment\">// [object Object]</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Collection</span> &#123;<br>  get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]() &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;xxx&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Collection</span>();<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(x); <span class=\"hljs-comment\">// [object xxx]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Symbol-unscopables\"><a href=\"#Symbol-unscopables\" class=\"headerlink\" title=\"Symbol.unscopables\"></a>Symbol.unscopables</h3><p>指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>]<br><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>])<br></code></pre></td></tr></table></figure>\n<p>上面的代码说明，数组有6个属性，会被<code>with</code>命令排除。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;&#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;&#125;<br><br><span class=\"hljs-keyword\">with</span> [<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>] &#123;<br>  <span class=\"hljs-title function_\">foo</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;<br>  <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;&#125;<br>  get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">unscopables</span>]() &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-literal\">true</span>&#125;;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;&#125;<br><span class=\"hljs-keyword\">with</span> (<span class=\"hljs-title class_\">MyClass</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) &#123;<br>  <span class=\"hljs-title function_\">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"ES6 变量解构","date":"2022-02-17T02:53:06.000Z","updated":"2022-02-17T02:53:06.000Z","_content":"\n# 变量解构与赋值\n\n## 基本用法\n\nES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。写法如下：\n\n```javascript\nlet [a, b, c] = [1, 2, 3];\na // 1\nb // 2\nc // 3\n\n// 与下列写法等价\nvar a = 1;\nvar b = 2;\nvar c = 3;\n```\n\n本质上只有等号两边的模式匹配的情况下，解构变量才会成功，如果解构不成功，那么值就等于undefined；但是即便两边的模式不完全匹配也是可以解构成功的。即：等号右边的模式仅等于等号左边声明的一部分。例如：\n\n```javascript\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n```\n\n## 适用范围\n\n除了`var`变量可以解构赋值，还有`let`和`const`也可以解构，除此之外，一种数据结构只要其有Iterator接口都可以使用数组解构赋值。例如：\n\n```javascript\nlet [a, b, c] = new Set({'aa', 'bb', 'cc'});\na // aa\nb // bb\nc // cc\n\nconst [d, e, f] = new Set({'dd', 'ee', 'ff'});\nd // dd\ne // ee\nf // ff\n```\n\n使用Generator函数解斐波那契数列，内部使用解构赋值，每次循环过程中变量`a`和`b`都会重新赋值；\n\n```javascript\nfunction* fibs() {\n  var a = 0;\n  var b = 1;\n  while(true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nvar [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n\n## 初始化\n\n变量解构可以在声明前初始化，注意：如果解构右侧值不等于`undefined`那么初始化的值就不会生效。例如：\n\n```javascript\nlet [x, y = 'y'] = [x, undefined];\ny // y - 解构初始化成功\n\nlet [x, y = 'y'] = [x, null];\ny // null - 解构初始化失败\n```\n\n如果解构默认值是一个表达式，那么只有在需要使用到表达式的时候才会赋值，否则默认值无效。\n\n```javascript\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\nx // 1\n// 由于x能在后面的数组中获取到数值1，因此默认值中的f()不生效；\n```\n\n## 对象的解构\n\n除了可以对数组做解构，对象同样可以做解构，但是与数组有区别的是：对象解构只有在对象属性名相同的情况下才能解构成功，如下：\n\n```javascript\nlet {foo, bar} = {foo: 'aaa', bar: 'bbb'}\nfoo // aaa\nbar // bbb\n\nlet {baz} = {foo: 'aaa', bar: 'bbb'}\nbaz // undefined\n```\n\n如果变量名和属性名不一样必须写成下面这样才行；\n\n```javascript\nvar {foo: baz} = {foo: 'aaa', bar: 'bbb'}\nbaz // aaa\n\nlet object = {first: 'hello', last: 'world'};\nlet {first: f, last: l} = object;\nf // hello\nl // world\n```\n\n解构也可以用于嵌套结构的对象\n\n```javascript\nvar obj = {\n  p: [\n    'Hello',\n    {y: 'world'}\n  ]\n};\n\nvar {p: [x, {y}]} = obj;\nx // hello\ny // world\n// p 为模式而不是变量，因此也不会被赋值\n```\n\n## 解构已声明的变量\n\n如果需要给已经声明的变量解构，一定要使用圆括号将其包裹起来，否则JavaScript引擎会将其解析为代码块。从而导致解构失败。ES6在解构变量时，除非会造成歧义必须使用圆括号围起来，否则不推荐使用圆括号；\n\n```javascript\n// Wrong syntax\nvar x;\n{x} = {x: 1}\n\n// Correct syntax\nvar x;\n({x} = {x: 1})\n\n// 还可以很方便地将现有对象的方法赋值到某个变量\nlet {log, sin, cos} = Math;\n```\n\n## 字符串的解构\n\n字符串也可以解构，解构出来的结果是当作数组处理。程序代码如下：\n\n```javascript\nconst [a, b, c, d, e] = 'hello';\na // 'h'\nb // 'e'\nc // 'l'\nd // 'l'\ne // 'o'\n\n// 类似数组对象都存在一个length属性，也可以通过解构获得\nlet {length: len} = 'hello';\nlen // 5\n```\n\n## 数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转换为对象；但是`undefined`和`null`无法转为对象，因此会解构失败；\n\n```javascript\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n```\n\n## 函数参数的解构赋值\n\n函数参数也可以解构赋值\n\n```javascript\nfunction add([x, y]) {\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [3, 7]\n```\n\n函数参数的解构也可以使用默认值（这不是废话嘛）\n\n```javascript\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n```\n\n下面这种写法不是解构，而是给函数参数设置默认值\n\n```javascript\nfunction move({x, y} = {x: 0, y: 0}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, undefined]\nmove({}); // [undefined, undefined]\nmove(); // [0, 0]\n```\n\n## 说了那么多，解构有什么用呢？\n\n### 交换变量的值\n\n```javascript\n[x, y] = [y, x]\n```\n\n### 从函数返回多个值\n\n```javascript\nfunction example() {\n  return [1, 2, 3];\n}\n\nvar [a, b, c] = example();\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: \n  };\n}\n  \nvar {foo, bar} = example();\n```\n\n### 函数参数的定义\n\n```javascript\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n```\n\n### 提取JSON数据\n\n```javascript\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet {id, status, data: number} = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n\n### 函数参数的默认值\n\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function() {},\n  cache = true,\n  complete = function() {},\n  crossDomain = false,\n  global = true,\n  // ... more config params\n}) {\n  // ... do stuff\n};\n```\n\n### 遍历Map解构\n\n```javascript\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('last', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n\n// first is hello\n// last is world\n\n// 如果只想获取键名称，可以这样\nfor (let [key] of map) {\n  // ... do something\n}\n\n// 只想获取键值\nfor (let [,value] of map) {\n  // ... do something\n}\n```\n\n### 输入模块的指定方法\n\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n\n// 除此之外使用import也可以使用解构倒入指定方法\nimport { SourceMapConsumer, SourceNode } from 'source-map';\n```\n","source":"_posts/javascript/es6-var-expand.md","raw":"---\ntitle: ES6 变量解构\ndate: 2022-02-17 10:53:06\nupdated: 2022-02-17 10:53:06\ntags: ES6基础\ncategories: JavaScript\n---\n\n# 变量解构与赋值\n\n## 基本用法\n\nES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。写法如下：\n\n```javascript\nlet [a, b, c] = [1, 2, 3];\na // 1\nb // 2\nc // 3\n\n// 与下列写法等价\nvar a = 1;\nvar b = 2;\nvar c = 3;\n```\n\n本质上只有等号两边的模式匹配的情况下，解构变量才会成功，如果解构不成功，那么值就等于undefined；但是即便两边的模式不完全匹配也是可以解构成功的。即：等号右边的模式仅等于等号左边声明的一部分。例如：\n\n```javascript\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n```\n\n## 适用范围\n\n除了`var`变量可以解构赋值，还有`let`和`const`也可以解构，除此之外，一种数据结构只要其有Iterator接口都可以使用数组解构赋值。例如：\n\n```javascript\nlet [a, b, c] = new Set({'aa', 'bb', 'cc'});\na // aa\nb // bb\nc // cc\n\nconst [d, e, f] = new Set({'dd', 'ee', 'ff'});\nd // dd\ne // ee\nf // ff\n```\n\n使用Generator函数解斐波那契数列，内部使用解构赋值，每次循环过程中变量`a`和`b`都会重新赋值；\n\n```javascript\nfunction* fibs() {\n  var a = 0;\n  var b = 1;\n  while(true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nvar [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n\n## 初始化\n\n变量解构可以在声明前初始化，注意：如果解构右侧值不等于`undefined`那么初始化的值就不会生效。例如：\n\n```javascript\nlet [x, y = 'y'] = [x, undefined];\ny // y - 解构初始化成功\n\nlet [x, y = 'y'] = [x, null];\ny // null - 解构初始化失败\n```\n\n如果解构默认值是一个表达式，那么只有在需要使用到表达式的时候才会赋值，否则默认值无效。\n\n```javascript\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\nx // 1\n// 由于x能在后面的数组中获取到数值1，因此默认值中的f()不生效；\n```\n\n## 对象的解构\n\n除了可以对数组做解构，对象同样可以做解构，但是与数组有区别的是：对象解构只有在对象属性名相同的情况下才能解构成功，如下：\n\n```javascript\nlet {foo, bar} = {foo: 'aaa', bar: 'bbb'}\nfoo // aaa\nbar // bbb\n\nlet {baz} = {foo: 'aaa', bar: 'bbb'}\nbaz // undefined\n```\n\n如果变量名和属性名不一样必须写成下面这样才行；\n\n```javascript\nvar {foo: baz} = {foo: 'aaa', bar: 'bbb'}\nbaz // aaa\n\nlet object = {first: 'hello', last: 'world'};\nlet {first: f, last: l} = object;\nf // hello\nl // world\n```\n\n解构也可以用于嵌套结构的对象\n\n```javascript\nvar obj = {\n  p: [\n    'Hello',\n    {y: 'world'}\n  ]\n};\n\nvar {p: [x, {y}]} = obj;\nx // hello\ny // world\n// p 为模式而不是变量，因此也不会被赋值\n```\n\n## 解构已声明的变量\n\n如果需要给已经声明的变量解构，一定要使用圆括号将其包裹起来，否则JavaScript引擎会将其解析为代码块。从而导致解构失败。ES6在解构变量时，除非会造成歧义必须使用圆括号围起来，否则不推荐使用圆括号；\n\n```javascript\n// Wrong syntax\nvar x;\n{x} = {x: 1}\n\n// Correct syntax\nvar x;\n({x} = {x: 1})\n\n// 还可以很方便地将现有对象的方法赋值到某个变量\nlet {log, sin, cos} = Math;\n```\n\n## 字符串的解构\n\n字符串也可以解构，解构出来的结果是当作数组处理。程序代码如下：\n\n```javascript\nconst [a, b, c, d, e] = 'hello';\na // 'h'\nb // 'e'\nc // 'l'\nd // 'l'\ne // 'o'\n\n// 类似数组对象都存在一个length属性，也可以通过解构获得\nlet {length: len} = 'hello';\nlen // 5\n```\n\n## 数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转换为对象；但是`undefined`和`null`无法转为对象，因此会解构失败；\n\n```javascript\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n```\n\n## 函数参数的解构赋值\n\n函数参数也可以解构赋值\n\n```javascript\nfunction add([x, y]) {\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [3, 7]\n```\n\n函数参数的解构也可以使用默认值（这不是废话嘛）\n\n```javascript\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n```\n\n下面这种写法不是解构，而是给函数参数设置默认值\n\n```javascript\nfunction move({x, y} = {x: 0, y: 0}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, undefined]\nmove({}); // [undefined, undefined]\nmove(); // [0, 0]\n```\n\n## 说了那么多，解构有什么用呢？\n\n### 交换变量的值\n\n```javascript\n[x, y] = [y, x]\n```\n\n### 从函数返回多个值\n\n```javascript\nfunction example() {\n  return [1, 2, 3];\n}\n\nvar [a, b, c] = example();\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: \n  };\n}\n  \nvar {foo, bar} = example();\n```\n\n### 函数参数的定义\n\n```javascript\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n```\n\n### 提取JSON数据\n\n```javascript\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet {id, status, data: number} = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n\n### 函数参数的默认值\n\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function() {},\n  cache = true,\n  complete = function() {},\n  crossDomain = false,\n  global = true,\n  // ... more config params\n}) {\n  // ... do stuff\n};\n```\n\n### 遍历Map解构\n\n```javascript\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('last', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n\n// first is hello\n// last is world\n\n// 如果只想获取键名称，可以这样\nfor (let [key] of map) {\n  // ... do something\n}\n\n// 只想获取键值\nfor (let [,value] of map) {\n  // ... do something\n}\n```\n\n### 输入模块的指定方法\n\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n\n// 除此之外使用import也可以使用解构倒入指定方法\nimport { SourceMapConsumer, SourceNode } from 'source-map';\n```\n","slug":"javascript/es6-var-expand","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3c002b2y61gqjt2yk3","content":"<h1 id=\"变量解构与赋值\"><a href=\"#变量解构与赋值\" class=\"headerlink\" title=\"变量解构与赋值\"></a>变量解构与赋值</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>a <span class=\"hljs-comment\">// 1</span><br>b <span class=\"hljs-comment\">// 2</span><br>c <span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// 与下列写法等价</span><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n<p>本质上只有等号两边的模式匹配的情况下，解构变量才会成功，如果解构不成功，那么值就等于undefined；但是即便两边的模式不完全匹配也是可以解构成功的。即：等号右边的模式仅等于等号左边声明的一部分。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [x, y] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>x <span class=\"hljs-comment\">// 1</span><br>y <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"适用范围\"><a href=\"#适用范围\" class=\"headerlink\" title=\"适用范围\"></a>适用范围</h2><p>除了<code>var</code>变量可以解构赋值，还有<code>let</code>和<code>const</code>也可以解构，除此之外，一种数据结构只要其有Iterator接口都可以使用数组解构赋值。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(&#123;<span class=\"hljs-string\">&#x27;aa&#x27;</span>, <span class=\"hljs-string\">&#x27;bb&#x27;</span>, <span class=\"hljs-string\">&#x27;cc&#x27;</span>&#125;);<br>a <span class=\"hljs-comment\">// aa</span><br>b <span class=\"hljs-comment\">// bb</span><br>c <span class=\"hljs-comment\">// cc</span><br><br><span class=\"hljs-keyword\">const</span> [d, e, f] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(&#123;<span class=\"hljs-string\">&#x27;dd&#x27;</span>, <span class=\"hljs-string\">&#x27;ee&#x27;</span>, <span class=\"hljs-string\">&#x27;ff&#x27;</span>&#125;);<br>d <span class=\"hljs-comment\">// dd</span><br>e <span class=\"hljs-comment\">// ee</span><br>f <span class=\"hljs-comment\">// ff</span><br></code></pre></td></tr></table></figure>\n<p>使用Generator函数解斐波那契数列，内部使用解构赋值，每次循环过程中变量<code>a</code>和<code>b</code>都会重新赋值；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibs</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> [first, second, third, fourth, fifth, sixth] = <span class=\"hljs-title function_\">fibs</span>();<br>sixth <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>变量解构可以在声明前初始化，注意：如果解构右侧值不等于<code>undefined</code>那么初始化的值就不会生效。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [x, y = <span class=\"hljs-string\">&#x27;y&#x27;</span>] = [x, <span class=\"hljs-literal\">undefined</span>];<br>y <span class=\"hljs-comment\">// y - 解构初始化成功</span><br><br><span class=\"hljs-keyword\">let</span> [x, y = <span class=\"hljs-string\">&#x27;y&#x27;</span>] = [x, <span class=\"hljs-literal\">null</span>];<br>y <span class=\"hljs-comment\">// null - 解构初始化失败</span><br></code></pre></td></tr></table></figure>\n<p>如果解构默认值是一个表达式，那么只有在需要使用到表达式的时候才会赋值，否则默认值无效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;aaa&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> [x = <span class=\"hljs-title function_\">f</span>()] = [<span class=\"hljs-number\">1</span>];<br>x <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-comment\">// 由于x能在后面的数组中获取到数值1，因此默认值中的f()不生效；</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"对象的解构\"><a href=\"#对象的解构\" class=\"headerlink\" title=\"对象的解构\"></a>对象的解构</h2><p>除了可以对数组做解构，对象同样可以做解构，但是与数组有区别的是：对象解构只有在对象属性名相同的情况下才能解构成功，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123;foo, bar&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>foo <span class=\"hljs-comment\">// aaa</span><br>bar <span class=\"hljs-comment\">// bbb</span><br><br><span class=\"hljs-keyword\">let</span> &#123;baz&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>baz <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>如果变量名和属性名不一样必须写成下面这样才行；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> &#123;<span class=\"hljs-attr\">foo</span>: baz&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>baz <span class=\"hljs-comment\">// aaa</span><br><br><span class=\"hljs-keyword\">let</span> object = &#123;<span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;;<br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">first</span>: f, <span class=\"hljs-attr\">last</span>: l&#125; = object;<br>f <span class=\"hljs-comment\">// hello</span><br>l <span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<p>解构也可以用于嵌套结构的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>  <span class=\"hljs-attr\">p</span>: [<br>    <span class=\"hljs-string\">&#x27;Hello&#x27;</span>,<br>    &#123;<span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;<br>  ]<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> &#123;<span class=\"hljs-attr\">p</span>: [x, &#123;y&#125;]&#125; = obj;<br>x <span class=\"hljs-comment\">// hello</span><br>y <span class=\"hljs-comment\">// world</span><br><span class=\"hljs-comment\">// p 为模式而不是变量，因此也不会被赋值</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"解构已声明的变量\"><a href=\"#解构已声明的变量\" class=\"headerlink\" title=\"解构已声明的变量\"></a>解构已声明的变量</h2><p>如果需要给已经声明的变量解构，一定要使用圆括号将其包裹起来，否则JavaScript引擎会将其解析为代码块。从而导致解构失败。ES6在解构变量时，除非会造成歧义必须使用圆括号围起来，否则不推荐使用圆括号；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Wrong syntax</span><br><span class=\"hljs-keyword\">var</span> x;<br>&#123;x&#125; = &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;<br><br><span class=\"hljs-comment\">// Correct syntax</span><br><span class=\"hljs-keyword\">var</span> x;<br>(&#123;x&#125; = &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;)<br><br><span class=\"hljs-comment\">// 还可以很方便地将现有对象的方法赋值到某个变量</span><br><span class=\"hljs-keyword\">let</span> &#123;log, sin, cos&#125; = <span class=\"hljs-title class_\">Math</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"字符串的解构\"><a href=\"#字符串的解构\" class=\"headerlink\" title=\"字符串的解构\"></a>字符串的解构</h2><p>字符串也可以解构，解构出来的结果是当作数组处理。程序代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [a, b, c, d, e] = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>a <span class=\"hljs-comment\">// &#x27;h&#x27;</span><br>b <span class=\"hljs-comment\">// &#x27;e&#x27;</span><br>c <span class=\"hljs-comment\">// &#x27;l&#x27;</span><br>d <span class=\"hljs-comment\">// &#x27;l&#x27;</span><br>e <span class=\"hljs-comment\">// &#x27;o&#x27;</span><br><br><span class=\"hljs-comment\">// 类似数组对象都存在一个length属性，也可以通过解构获得</span><br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">length</span>: len&#125; = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>len <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转换为对象；但是<code>undefined</code>和<code>null</code>无法转为对象，因此会解构失败；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">toString</span>: s&#125; = <span class=\"hljs-number\">123</span>;<br>s === <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">toString</span>: s&#125; = <span class=\"hljs-literal\">true</span>;<br>s === <span class=\"hljs-title class_\">Boolean</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数参数也可以解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">[x, y]</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// 3</span><br><br>[[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[a, b]</span>) =&gt;</span> a + b);<br><span class=\"hljs-comment\">// [3, 7]</span><br></code></pre></td></tr></table></figure>\n<p>函数参数的解构也可以使用默认值（这不是废话嘛）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">&#123;x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>&#125; = &#123;&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">8</span>&#125;); <span class=\"hljs-comment\">// [3, 8]</span><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;); <span class=\"hljs-comment\">// [3, 0]</span><br><span class=\"hljs-title function_\">move</span>(&#123;&#125;); <span class=\"hljs-comment\">// [0, 0]</span><br><span class=\"hljs-title function_\">move</span>(); <span class=\"hljs-comment\">// [0, 0]</span><br></code></pre></td></tr></table></figure>\n<p>下面这种写法不是解构，而是给函数参数设置默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">&#123;x, y&#125; = &#123;x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">0</span>&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">8</span>&#125;); <span class=\"hljs-comment\">// [3, 8]</span><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;); <span class=\"hljs-comment\">// [3, undefined]</span><br><span class=\"hljs-title function_\">move</span>(&#123;&#125;); <span class=\"hljs-comment\">// [undefined, undefined]</span><br><span class=\"hljs-title function_\">move</span>(); <span class=\"hljs-comment\">// [0, 0]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"说了那么多，解构有什么用呢？\"><a href=\"#说了那么多，解构有什么用呢？\" class=\"headerlink\" title=\"说了那么多，解构有什么用呢？\"></a>说了那么多，解构有什么用呢？</h2><h3 id=\"交换变量的值\"><a href=\"#交换变量的值\" class=\"headerlink\" title=\"交换变量的值\"></a>交换变量的值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[x, y] = [y, x]<br></code></pre></td></tr></table></figure>\n<h3 id=\"从函数返回多个值\"><a href=\"#从函数返回多个值\" class=\"headerlink\" title=\"从函数返回多个值\"></a>从函数返回多个值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">example</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> [a, b, c] = <span class=\"hljs-title function_\">example</span>();<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">example</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">bar</span>: <br>  &#125;;<br>&#125;<br>  <br><span class=\"hljs-keyword\">var</span> &#123;foo, bar&#125; = <span class=\"hljs-title function_\">example</span>();<br></code></pre></td></tr></table></figure>\n<h3 id=\"函数参数的定义\"><a href=\"#函数参数的定义\" class=\"headerlink\" title=\"函数参数的定义\"></a>函数参数的定义</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">[x, y, z]</span>) &#123; ... &#125;<br><span class=\"hljs-title function_\">f</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br></code></pre></td></tr></table></figure>\n<h3 id=\"提取JSON数据\"><a href=\"#提取JSON数据\" class=\"headerlink\" title=\"提取JSON数据\"></a>提取JSON数据</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> jsonData = &#123;<br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">42</span>,<br>  <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">&quot;OK&quot;</span>,<br>  <span class=\"hljs-attr\">data</span>: [<span class=\"hljs-number\">867</span>, <span class=\"hljs-number\">5309</span>]<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> &#123;id, status, <span class=\"hljs-attr\">data</span>: number&#125; = jsonData;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(id, status, number);<br><span class=\"hljs-comment\">// 42, &quot;OK&quot;, [867, 5309]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">jQuery.<span class=\"hljs-property\">ajax</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">url, &#123;</span><br><span class=\"hljs-params\">  <span class=\"hljs-keyword\">async</span> = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  beforeSend = <span class=\"hljs-keyword\">function</span>() &#123;&#125;,</span><br><span class=\"hljs-params\">  cache = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  complete = <span class=\"hljs-keyword\">function</span>() &#123;&#125;,</span><br><span class=\"hljs-params\">  crossDomain = <span class=\"hljs-literal\">false</span>,</span><br><span class=\"hljs-params\">  <span class=\"hljs-variable language_\">global</span> = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  // ... more config params</span><br><span class=\"hljs-params\">&#125;</span>) &#123;<br>  <span class=\"hljs-comment\">// ... do stuff</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历Map解构\"><a href=\"#遍历Map解构\" class=\"headerlink\" title=\"遍历Map解构\"></a>遍历Map解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;first&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;last&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key + <span class=\"hljs-string\">&quot; is &quot;</span> + value);<br>&#125;<br><br><span class=\"hljs-comment\">// first is hello</span><br><span class=\"hljs-comment\">// last is world</span><br><br><span class=\"hljs-comment\">// 如果只想获取键名称，可以这样</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-comment\">// ... do something</span><br>&#125;<br><br><span class=\"hljs-comment\">// 只想获取键值</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [,value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-comment\">// ... do something</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"输入模块的指定方法\"><a href=\"#输入模块的指定方法\" class=\"headerlink\" title=\"输入模块的指定方法\"></a>输入模块的指定方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">SourceMapConsumer</span>, <span class=\"hljs-title class_\">SourceNode</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;source-map&quot;</span>);<br><br><span class=\"hljs-comment\">// 除此之外使用import也可以使用解构倒入指定方法</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">SourceMapConsumer</span>, <span class=\"hljs-title class_\">SourceNode</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;source-map&#x27;</span>;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":4207,"excerpt":"","more":"<h1 id=\"变量解构与赋值\"><a href=\"#变量解构与赋值\" class=\"headerlink\" title=\"变量解构与赋值\"></a>变量解构与赋值</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>a <span class=\"hljs-comment\">// 1</span><br>b <span class=\"hljs-comment\">// 2</span><br>c <span class=\"hljs-comment\">// 3</span><br><br><span class=\"hljs-comment\">// 与下列写法等价</span><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-number\">3</span>;<br></code></pre></td></tr></table></figure>\n<p>本质上只有等号两边的模式匹配的情况下，解构变量才会成功，如果解构不成功，那么值就等于undefined；但是即便两边的模式不完全匹配也是可以解构成功的。即：等号右边的模式仅等于等号左边声明的一部分。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [x, y] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>x <span class=\"hljs-comment\">// 1</span><br>y <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"适用范围\"><a href=\"#适用范围\" class=\"headerlink\" title=\"适用范围\"></a>适用范围</h2><p>除了<code>var</code>变量可以解构赋值，还有<code>let</code>和<code>const</code>也可以解构，除此之外，一种数据结构只要其有Iterator接口都可以使用数组解构赋值。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(&#123;<span class=\"hljs-string\">&#x27;aa&#x27;</span>, <span class=\"hljs-string\">&#x27;bb&#x27;</span>, <span class=\"hljs-string\">&#x27;cc&#x27;</span>&#125;);<br>a <span class=\"hljs-comment\">// aa</span><br>b <span class=\"hljs-comment\">// bb</span><br>c <span class=\"hljs-comment\">// cc</span><br><br><span class=\"hljs-keyword\">const</span> [d, e, f] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(&#123;<span class=\"hljs-string\">&#x27;dd&#x27;</span>, <span class=\"hljs-string\">&#x27;ee&#x27;</span>, <span class=\"hljs-string\">&#x27;ff&#x27;</span>&#125;);<br>d <span class=\"hljs-comment\">// dd</span><br>e <span class=\"hljs-comment\">// ee</span><br>f <span class=\"hljs-comment\">// ff</span><br></code></pre></td></tr></table></figure>\n<p>使用Generator函数解斐波那契数列，内部使用解构赋值，每次循环过程中变量<code>a</code>和<code>b</code>都会重新赋值；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibs</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> [first, second, third, fourth, fifth, sixth] = <span class=\"hljs-title function_\">fibs</span>();<br>sixth <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>变量解构可以在声明前初始化，注意：如果解构右侧值不等于<code>undefined</code>那么初始化的值就不会生效。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> [x, y = <span class=\"hljs-string\">&#x27;y&#x27;</span>] = [x, <span class=\"hljs-literal\">undefined</span>];<br>y <span class=\"hljs-comment\">// y - 解构初始化成功</span><br><br><span class=\"hljs-keyword\">let</span> [x, y = <span class=\"hljs-string\">&#x27;y&#x27;</span>] = [x, <span class=\"hljs-literal\">null</span>];<br>y <span class=\"hljs-comment\">// null - 解构初始化失败</span><br></code></pre></td></tr></table></figure>\n<p>如果解构默认值是一个表达式，那么只有在需要使用到表达式的时候才会赋值，否则默认值无效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;aaa&#x27;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> [x = <span class=\"hljs-title function_\">f</span>()] = [<span class=\"hljs-number\">1</span>];<br>x <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-comment\">// 由于x能在后面的数组中获取到数值1，因此默认值中的f()不生效；</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"对象的解构\"><a href=\"#对象的解构\" class=\"headerlink\" title=\"对象的解构\"></a>对象的解构</h2><p>除了可以对数组做解构，对象同样可以做解构，但是与数组有区别的是：对象解构只有在对象属性名相同的情况下才能解构成功，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123;foo, bar&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>foo <span class=\"hljs-comment\">// aaa</span><br>bar <span class=\"hljs-comment\">// bbb</span><br><br><span class=\"hljs-keyword\">let</span> &#123;baz&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>baz <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>如果变量名和属性名不一样必须写成下面这样才行；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> &#123;<span class=\"hljs-attr\">foo</span>: baz&#125; = &#123;<span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&#x27;bbb&#x27;</span>&#125;<br>baz <span class=\"hljs-comment\">// aaa</span><br><br><span class=\"hljs-keyword\">let</span> object = &#123;<span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;;<br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">first</span>: f, <span class=\"hljs-attr\">last</span>: l&#125; = object;<br>f <span class=\"hljs-comment\">// hello</span><br>l <span class=\"hljs-comment\">// world</span><br></code></pre></td></tr></table></figure>\n<p>解构也可以用于嵌套结构的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>  <span class=\"hljs-attr\">p</span>: [<br>    <span class=\"hljs-string\">&#x27;Hello&#x27;</span>,<br>    &#123;<span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;<br>  ]<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> &#123;<span class=\"hljs-attr\">p</span>: [x, &#123;y&#125;]&#125; = obj;<br>x <span class=\"hljs-comment\">// hello</span><br>y <span class=\"hljs-comment\">// world</span><br><span class=\"hljs-comment\">// p 为模式而不是变量，因此也不会被赋值</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"解构已声明的变量\"><a href=\"#解构已声明的变量\" class=\"headerlink\" title=\"解构已声明的变量\"></a>解构已声明的变量</h2><p>如果需要给已经声明的变量解构，一定要使用圆括号将其包裹起来，否则JavaScript引擎会将其解析为代码块。从而导致解构失败。ES6在解构变量时，除非会造成歧义必须使用圆括号围起来，否则不推荐使用圆括号；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Wrong syntax</span><br><span class=\"hljs-keyword\">var</span> x;<br>&#123;x&#125; = &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;<br><br><span class=\"hljs-comment\">// Correct syntax</span><br><span class=\"hljs-keyword\">var</span> x;<br>(&#123;x&#125; = &#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>&#125;)<br><br><span class=\"hljs-comment\">// 还可以很方便地将现有对象的方法赋值到某个变量</span><br><span class=\"hljs-keyword\">let</span> &#123;log, sin, cos&#125; = <span class=\"hljs-title class_\">Math</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"字符串的解构\"><a href=\"#字符串的解构\" class=\"headerlink\" title=\"字符串的解构\"></a>字符串的解构</h2><p>字符串也可以解构，解构出来的结果是当作数组处理。程序代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [a, b, c, d, e] = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>a <span class=\"hljs-comment\">// &#x27;h&#x27;</span><br>b <span class=\"hljs-comment\">// &#x27;e&#x27;</span><br>c <span class=\"hljs-comment\">// &#x27;l&#x27;</span><br>d <span class=\"hljs-comment\">// &#x27;l&#x27;</span><br>e <span class=\"hljs-comment\">// &#x27;o&#x27;</span><br><br><span class=\"hljs-comment\">// 类似数组对象都存在一个length属性，也可以通过解构获得</span><br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">length</span>: len&#125; = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br>len <span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转换为对象；但是<code>undefined</code>和<code>null</code>无法转为对象，因此会解构失败；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">toString</span>: s&#125; = <span class=\"hljs-number\">123</span>;<br>s === <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// true</span><br><br><span class=\"hljs-keyword\">let</span> &#123;<span class=\"hljs-attr\">toString</span>: s&#125; = <span class=\"hljs-literal\">true</span>;<br>s === <span class=\"hljs-title class_\">Boolean</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数参数也可以解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">[x, y]</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;<br><br><span class=\"hljs-title function_\">add</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// 3</span><br><br>[[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[a, b]</span>) =&gt;</span> a + b);<br><span class=\"hljs-comment\">// [3, 7]</span><br></code></pre></td></tr></table></figure>\n<p>函数参数的解构也可以使用默认值（这不是废话嘛）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">&#123;x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>&#125; = &#123;&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">8</span>&#125;); <span class=\"hljs-comment\">// [3, 8]</span><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;); <span class=\"hljs-comment\">// [3, 0]</span><br><span class=\"hljs-title function_\">move</span>(&#123;&#125;); <span class=\"hljs-comment\">// [0, 0]</span><br><span class=\"hljs-title function_\">move</span>(); <span class=\"hljs-comment\">// [0, 0]</span><br></code></pre></td></tr></table></figure>\n<p>下面这种写法不是解构，而是给函数参数设置默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">move</span>(<span class=\"hljs-params\">&#123;x, y&#125; = &#123;x: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">0</span>&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [x, y];<br>&#125;<br><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">8</span>&#125;); <span class=\"hljs-comment\">// [3, 8]</span><br><span class=\"hljs-title function_\">move</span>(&#123;<span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">3</span>&#125;); <span class=\"hljs-comment\">// [3, undefined]</span><br><span class=\"hljs-title function_\">move</span>(&#123;&#125;); <span class=\"hljs-comment\">// [undefined, undefined]</span><br><span class=\"hljs-title function_\">move</span>(); <span class=\"hljs-comment\">// [0, 0]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"说了那么多，解构有什么用呢？\"><a href=\"#说了那么多，解构有什么用呢？\" class=\"headerlink\" title=\"说了那么多，解构有什么用呢？\"></a>说了那么多，解构有什么用呢？</h2><h3 id=\"交换变量的值\"><a href=\"#交换变量的值\" class=\"headerlink\" title=\"交换变量的值\"></a>交换变量的值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[x, y] = [y, x]<br></code></pre></td></tr></table></figure>\n<h3 id=\"从函数返回多个值\"><a href=\"#从函数返回多个值\" class=\"headerlink\" title=\"从函数返回多个值\"></a>从函数返回多个值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">example</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> [a, b, c] = <span class=\"hljs-title function_\">example</span>();<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">example</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">bar</span>: <br>  &#125;;<br>&#125;<br>  <br><span class=\"hljs-keyword\">var</span> &#123;foo, bar&#125; = <span class=\"hljs-title function_\">example</span>();<br></code></pre></td></tr></table></figure>\n<h3 id=\"函数参数的定义\"><a href=\"#函数参数的定义\" class=\"headerlink\" title=\"函数参数的定义\"></a>函数参数的定义</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">[x, y, z]</span>) &#123; ... &#125;<br><span class=\"hljs-title function_\">f</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br></code></pre></td></tr></table></figure>\n<h3 id=\"提取JSON数据\"><a href=\"#提取JSON数据\" class=\"headerlink\" title=\"提取JSON数据\"></a>提取JSON数据</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> jsonData = &#123;<br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">42</span>,<br>  <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">&quot;OK&quot;</span>,<br>  <span class=\"hljs-attr\">data</span>: [<span class=\"hljs-number\">867</span>, <span class=\"hljs-number\">5309</span>]<br>&#125;;<br><br><span class=\"hljs-keyword\">let</span> &#123;id, status, <span class=\"hljs-attr\">data</span>: number&#125; = jsonData;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(id, status, number);<br><span class=\"hljs-comment\">// 42, &quot;OK&quot;, [867, 5309]</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">jQuery.<span class=\"hljs-property\">ajax</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">url, &#123;</span><br><span class=\"hljs-params\">  <span class=\"hljs-keyword\">async</span> = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  beforeSend = <span class=\"hljs-keyword\">function</span>() &#123;&#125;,</span><br><span class=\"hljs-params\">  cache = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  complete = <span class=\"hljs-keyword\">function</span>() &#123;&#125;,</span><br><span class=\"hljs-params\">  crossDomain = <span class=\"hljs-literal\">false</span>,</span><br><span class=\"hljs-params\">  <span class=\"hljs-variable language_\">global</span> = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"hljs-params\">  // ... more config params</span><br><span class=\"hljs-params\">&#125;</span>) &#123;<br>  <span class=\"hljs-comment\">// ... do stuff</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历Map解构\"><a href=\"#遍历Map解构\" class=\"headerlink\" title=\"遍历Map解构\"></a>遍历Map解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;first&#x27;</span>, <span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;last&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key + <span class=\"hljs-string\">&quot; is &quot;</span> + value);<br>&#125;<br><br><span class=\"hljs-comment\">// first is hello</span><br><span class=\"hljs-comment\">// last is world</span><br><br><span class=\"hljs-comment\">// 如果只想获取键名称，可以这样</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-comment\">// ... do something</span><br>&#125;<br><br><span class=\"hljs-comment\">// 只想获取键值</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [,value] <span class=\"hljs-keyword\">of</span> map) &#123;<br>  <span class=\"hljs-comment\">// ... do something</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"输入模块的指定方法\"><a href=\"#输入模块的指定方法\" class=\"headerlink\" title=\"输入模块的指定方法\"></a>输入模块的指定方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">SourceMapConsumer</span>, <span class=\"hljs-title class_\">SourceNode</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;source-map&quot;</span>);<br><br><span class=\"hljs-comment\">// 除此之外使用import也可以使用解构倒入指定方法</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">SourceMapConsumer</span>, <span class=\"hljs-title class_\">SourceNode</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;source-map&#x27;</span>;<br></code></pre></td></tr></table></figure>\n"},{"title":"Canvas非零环绕原则","date":"2022-02-18T02:59:52.000Z","updated":"2022-02-18T02:59:52.000Z","_content":"\n# 非零环绕原则\n\n## 概述\n\n非零环绕原则描述了一种计算机该如何给封闭图形上色的规则，非常简单，我们只需要记住一个下面一条规则就行。\n\n给封闭图形设置一个渲染方向（假如你的图形是一笔成画的），比如顺时针，那么与之相反的逆时针就是反方向。根据线条的方向来按照下列规则判断：\n\n- 从封闭图形画一条射线，如果与之相交的线条中正向和逆向不等（正多逆少或者逆多正少，只要不是0即可），那么就认为图形内部；\n- 从封闭图形画一条射线，如果与之相交的线条中正向和逆向相等（例如圆环，一正一逆，正好抵消为0），那么就认为图形外部；\n\n这就是“非零环绕原则”。这样说还不直观，我们可以用一个例子来说明这个。\n\n## 圆环\n\n接着之前的代码片段，我们来画一个圆环：\n\n```javascript\nwindow.onload = function() {\n  let canvas = document.getElementById(\"canvas\");\n  canvas.width = 800;\n  canvas.height = 600;\n  \n  let context = canvas.getContext(\"2d\");\n  \n  context.shadowColor = \"#545454\";\n  context.shadowOffsetX = 5;\n  context.shadowOffsetY = 5;\n  context.shadowBlur = 2;\n  \n  context.arc(400, 300, 200, 0, Math.PI * 2, false); // 顺时针画圆\n  context.arc(400, 300, 230, 0, Math.PI * 2, true); // 逆时针画圆\n  \n  context.fillStyle = \"#00AAAA\";\n  context.fill();\n};\n```\n\n 按照“非零环绕”原则，内部圆的方向是顺时针，外部圆的方向是逆时针，正好两个圆的中间部分才是需要填充的部分。这样就完成了一个圆环。是不是非常简单。\n\n## 镂空图形绘制\n\n我们再做一个复杂一些的图形，你可以将其拷贝到浏览器中看效果：\n\n```javascript\nwindow.onload = function() {\n  var canvas = document.getElementById(\"canvas\");\n  canvas.width = 800;\n  canvas.height = 600;\n  var context = canvas.getContext(\"2d\");\n  context.fillStyle = \"#FFF\";\n  context.fillRect(0,0,800,600);\n\n  context.beginPath();\n  context.rect(200,100,400,400);\n  drawPathRect(context, 250, 150, 300, 150);\n  drawPathTriangle(context, 345, 350, 420, 450, 270, 450);\n  context.arc(500, 400, 50, 0, Math.PI * 2, true);\n  context.closePath();\n\n  context.fillStyle = \"#058\";\n  context.shadowColor = \"gray\";\n  context.shadowOffsetX = 10;\n  context.shadowOffsetY = 10;\n  context.shadowBlur = 10;\n  context.fill();\n\n};\n\n//逆时针绘制矩形\nfunction drawPathRect(cxt, x, y, w, h){\n  /**\n         * 这里不能使用beginPath和closePath，\n         * 不然就不属于子路径而是另一个全新的路径，\n         * 无法使用非零环绕原则\n         */\n  cxt.moveTo(x, y);\n  cxt.lineTo(x, y + h);\n  cxt.lineTo(x + w, y + h);\n  cxt.lineTo(x + w, y);\n  cxt.lineTo(x, y);\n\n}\n\n//逆时针绘制三角形\nfunction drawPathTriangle(cxt, x1, y1, x2, y2, x3, y3){\n  cxt.moveTo(x1,y1);\n  cxt.lineTo(x3,y3);\n  cxt.lineTo(x2,y2);\n  cxt.lineTo(x1,y1);\n}\n```\n\n## 结束\n\n就这些\n","source":"_posts/frontend/canvas/canvas-around-principle.md","raw":"---\ntitle: Canvas非零环绕原则\ndate: 2022-02-18 10:59:52\nupdated: 2022-02-18 10:59:52\ntags: HTML\ncategories: 前端\n---\n\n# 非零环绕原则\n\n## 概述\n\n非零环绕原则描述了一种计算机该如何给封闭图形上色的规则，非常简单，我们只需要记住一个下面一条规则就行。\n\n给封闭图形设置一个渲染方向（假如你的图形是一笔成画的），比如顺时针，那么与之相反的逆时针就是反方向。根据线条的方向来按照下列规则判断：\n\n- 从封闭图形画一条射线，如果与之相交的线条中正向和逆向不等（正多逆少或者逆多正少，只要不是0即可），那么就认为图形内部；\n- 从封闭图形画一条射线，如果与之相交的线条中正向和逆向相等（例如圆环，一正一逆，正好抵消为0），那么就认为图形外部；\n\n这就是“非零环绕原则”。这样说还不直观，我们可以用一个例子来说明这个。\n\n## 圆环\n\n接着之前的代码片段，我们来画一个圆环：\n\n```javascript\nwindow.onload = function() {\n  let canvas = document.getElementById(\"canvas\");\n  canvas.width = 800;\n  canvas.height = 600;\n  \n  let context = canvas.getContext(\"2d\");\n  \n  context.shadowColor = \"#545454\";\n  context.shadowOffsetX = 5;\n  context.shadowOffsetY = 5;\n  context.shadowBlur = 2;\n  \n  context.arc(400, 300, 200, 0, Math.PI * 2, false); // 顺时针画圆\n  context.arc(400, 300, 230, 0, Math.PI * 2, true); // 逆时针画圆\n  \n  context.fillStyle = \"#00AAAA\";\n  context.fill();\n};\n```\n\n 按照“非零环绕”原则，内部圆的方向是顺时针，外部圆的方向是逆时针，正好两个圆的中间部分才是需要填充的部分。这样就完成了一个圆环。是不是非常简单。\n\n## 镂空图形绘制\n\n我们再做一个复杂一些的图形，你可以将其拷贝到浏览器中看效果：\n\n```javascript\nwindow.onload = function() {\n  var canvas = document.getElementById(\"canvas\");\n  canvas.width = 800;\n  canvas.height = 600;\n  var context = canvas.getContext(\"2d\");\n  context.fillStyle = \"#FFF\";\n  context.fillRect(0,0,800,600);\n\n  context.beginPath();\n  context.rect(200,100,400,400);\n  drawPathRect(context, 250, 150, 300, 150);\n  drawPathTriangle(context, 345, 350, 420, 450, 270, 450);\n  context.arc(500, 400, 50, 0, Math.PI * 2, true);\n  context.closePath();\n\n  context.fillStyle = \"#058\";\n  context.shadowColor = \"gray\";\n  context.shadowOffsetX = 10;\n  context.shadowOffsetY = 10;\n  context.shadowBlur = 10;\n  context.fill();\n\n};\n\n//逆时针绘制矩形\nfunction drawPathRect(cxt, x, y, w, h){\n  /**\n         * 这里不能使用beginPath和closePath，\n         * 不然就不属于子路径而是另一个全新的路径，\n         * 无法使用非零环绕原则\n         */\n  cxt.moveTo(x, y);\n  cxt.lineTo(x, y + h);\n  cxt.lineTo(x + w, y + h);\n  cxt.lineTo(x + w, y);\n  cxt.lineTo(x, y);\n\n}\n\n//逆时针绘制三角形\nfunction drawPathTriangle(cxt, x1, y1, x2, y2, x3, y3){\n  cxt.moveTo(x1,y1);\n  cxt.lineTo(x3,y3);\n  cxt.lineTo(x2,y2);\n  cxt.lineTo(x1,y1);\n}\n```\n\n## 结束\n\n就这些\n","slug":"frontend/canvas/canvas-around-principle","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3d002e2y615msu7eao","content":"<h1 id=\"非零环绕原则\"><a href=\"#非零环绕原则\" class=\"headerlink\" title=\"非零环绕原则\"></a>非零环绕原则</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>非零环绕原则描述了一种计算机该如何给封闭图形上色的规则，非常简单，我们只需要记住一个下面一条规则就行。</p>\n<p>给封闭图形设置一个渲染方向（假如你的图形是一笔成画的），比如顺时针，那么与之相反的逆时针就是反方向。根据线条的方向来按照下列规则判断：</p>\n<ul>\n<li>从封闭图形画一条射线，如果与之相交的线条中正向和逆向不等（正多逆少或者逆多正少，只要不是0即可），那么就认为图形内部；</li>\n<li>从封闭图形画一条射线，如果与之相交的线条中正向和逆向相等（例如圆环，一正一逆，正好抵消为0），那么就认为图形外部；</li>\n</ul>\n<p>这就是“非零环绕原则”。这样说还不直观，我们可以用一个例子来说明这个。</p>\n<h2 id=\"圆环\"><a href=\"#圆环\" class=\"headerlink\" title=\"圆环\"></a>圆环</h2><p>接着之前的代码片段，我们来画一个圆环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>  canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>  canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>  <br>  <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>  <br>  context.<span class=\"hljs-property\">shadowColor</span> = <span class=\"hljs-string\">&quot;#545454&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetX</span> = <span class=\"hljs-number\">5</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetY</span> = <span class=\"hljs-number\">5</span>;<br>  context.<span class=\"hljs-property\">shadowBlur</span> = <span class=\"hljs-number\">2</span>;<br>  <br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">false</span>); <span class=\"hljs-comment\">// 顺时针画圆</span><br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">230</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 逆时针画圆</span><br>  <br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>  context.<span class=\"hljs-title function_\">fill</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p> 按照“非零环绕”原则，内部圆的方向是顺时针，外部圆的方向是逆时针，正好两个圆的中间部分才是需要填充的部分。这样就完成了一个圆环。是不是非常简单。</p>\n<h2 id=\"镂空图形绘制\"><a href=\"#镂空图形绘制\" class=\"headerlink\" title=\"镂空图形绘制\"></a>镂空图形绘制</h2><p>我们再做一个复杂一些的图形，你可以将其拷贝到浏览器中看效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>  canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>  canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>  <span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#FFF&quot;</span>;<br>  context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">800</span>,<span class=\"hljs-number\">600</span>);<br><br>  context.<span class=\"hljs-title function_\">beginPath</span>();<br>  context.<span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-number\">200</span>,<span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">400</span>,<span class=\"hljs-number\">400</span>);<br>  <span class=\"hljs-title function_\">drawPathRect</span>(context, <span class=\"hljs-number\">250</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">150</span>);<br>  <span class=\"hljs-title function_\">drawPathTriangle</span>(context, <span class=\"hljs-number\">345</span>, <span class=\"hljs-number\">350</span>, <span class=\"hljs-number\">420</span>, <span class=\"hljs-number\">450</span>, <span class=\"hljs-number\">270</span>, <span class=\"hljs-number\">450</span>);<br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>);<br>  context.<span class=\"hljs-title function_\">closePath</span>();<br><br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#058&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowColor</span> = <span class=\"hljs-string\">&quot;gray&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetX</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetY</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-property\">shadowBlur</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-title function_\">fill</span>();<br><br>&#125;;<br><br><span class=\"hljs-comment\">//逆时针绘制矩形</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawPathRect</span>(<span class=\"hljs-params\">cxt, x, y, w, h</span>)&#123;<br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">         * 这里不能使用beginPath和closePath，</span><br><span class=\"hljs-comment\">         * 不然就不属于子路径而是另一个全新的路径，</span><br><span class=\"hljs-comment\">         * 无法使用非零环绕原则</span><br><span class=\"hljs-comment\">         */</span><br>  cxt.<span class=\"hljs-title function_\">moveTo</span>(x, y);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x, y + h);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x + w, y + h);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x + w, y);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x, y);<br><br>&#125;<br><br><span class=\"hljs-comment\">//逆时针绘制三角形</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawPathTriangle</span>(<span class=\"hljs-params\">cxt, x1, y1, x2, y2, x3, y3</span>)&#123;<br>  cxt.<span class=\"hljs-title function_\">moveTo</span>(x1,y1);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x3,y3);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x2,y2);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x1,y1);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h2><p>就这些</p>\n","site":{"data":{}},"wordcount":1894,"excerpt":"","more":"<h1 id=\"非零环绕原则\"><a href=\"#非零环绕原则\" class=\"headerlink\" title=\"非零环绕原则\"></a>非零环绕原则</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>非零环绕原则描述了一种计算机该如何给封闭图形上色的规则，非常简单，我们只需要记住一个下面一条规则就行。</p>\n<p>给封闭图形设置一个渲染方向（假如你的图形是一笔成画的），比如顺时针，那么与之相反的逆时针就是反方向。根据线条的方向来按照下列规则判断：</p>\n<ul>\n<li>从封闭图形画一条射线，如果与之相交的线条中正向和逆向不等（正多逆少或者逆多正少，只要不是0即可），那么就认为图形内部；</li>\n<li>从封闭图形画一条射线，如果与之相交的线条中正向和逆向相等（例如圆环，一正一逆，正好抵消为0），那么就认为图形外部；</li>\n</ul>\n<p>这就是“非零环绕原则”。这样说还不直观，我们可以用一个例子来说明这个。</p>\n<h2 id=\"圆环\"><a href=\"#圆环\" class=\"headerlink\" title=\"圆环\"></a>圆环</h2><p>接着之前的代码片段，我们来画一个圆环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>  canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>  canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>  <br>  <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>  <br>  context.<span class=\"hljs-property\">shadowColor</span> = <span class=\"hljs-string\">&quot;#545454&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetX</span> = <span class=\"hljs-number\">5</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetY</span> = <span class=\"hljs-number\">5</span>;<br>  context.<span class=\"hljs-property\">shadowBlur</span> = <span class=\"hljs-number\">2</span>;<br>  <br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">false</span>); <span class=\"hljs-comment\">// 顺时针画圆</span><br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">230</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 逆时针画圆</span><br>  <br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>  context.<span class=\"hljs-title function_\">fill</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p> 按照“非零环绕”原则，内部圆的方向是顺时针，外部圆的方向是逆时针，正好两个圆的中间部分才是需要填充的部分。这样就完成了一个圆环。是不是非常简单。</p>\n<h2 id=\"镂空图形绘制\"><a href=\"#镂空图形绘制\" class=\"headerlink\" title=\"镂空图形绘制\"></a>镂空图形绘制</h2><p>我们再做一个复杂一些的图形，你可以将其拷贝到浏览器中看效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>  canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>  canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>  <span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#FFF&quot;</span>;<br>  context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">800</span>,<span class=\"hljs-number\">600</span>);<br><br>  context.<span class=\"hljs-title function_\">beginPath</span>();<br>  context.<span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-number\">200</span>,<span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">400</span>,<span class=\"hljs-number\">400</span>);<br>  <span class=\"hljs-title function_\">drawPathRect</span>(context, <span class=\"hljs-number\">250</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">150</span>);<br>  <span class=\"hljs-title function_\">drawPathTriangle</span>(context, <span class=\"hljs-number\">345</span>, <span class=\"hljs-number\">350</span>, <span class=\"hljs-number\">420</span>, <span class=\"hljs-number\">450</span>, <span class=\"hljs-number\">270</span>, <span class=\"hljs-number\">450</span>);<br>  context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>);<br>  context.<span class=\"hljs-title function_\">closePath</span>();<br><br>  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#058&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowColor</span> = <span class=\"hljs-string\">&quot;gray&quot;</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetX</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-property\">shadowOffsetY</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-property\">shadowBlur</span> = <span class=\"hljs-number\">10</span>;<br>  context.<span class=\"hljs-title function_\">fill</span>();<br><br>&#125;;<br><br><span class=\"hljs-comment\">//逆时针绘制矩形</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawPathRect</span>(<span class=\"hljs-params\">cxt, x, y, w, h</span>)&#123;<br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">         * 这里不能使用beginPath和closePath，</span><br><span class=\"hljs-comment\">         * 不然就不属于子路径而是另一个全新的路径，</span><br><span class=\"hljs-comment\">         * 无法使用非零环绕原则</span><br><span class=\"hljs-comment\">         */</span><br>  cxt.<span class=\"hljs-title function_\">moveTo</span>(x, y);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x, y + h);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x + w, y + h);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x + w, y);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x, y);<br><br>&#125;<br><br><span class=\"hljs-comment\">//逆时针绘制三角形</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawPathTriangle</span>(<span class=\"hljs-params\">cxt, x1, y1, x2, y2, x3, y3</span>)&#123;<br>  cxt.<span class=\"hljs-title function_\">moveTo</span>(x1,y1);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x3,y3);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x2,y2);<br>  cxt.<span class=\"hljs-title function_\">lineTo</span>(x1,y1);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h2><p>就这些</p>\n"},{"title":"Canvas绘制图形","date":"2022-02-18T02:59:22.000Z","updated":"2022-02-18T02:59:22.000Z","_content":"\n# Canvas绘图\n\n## 回顾\n\n前一章讲了如何创建绘图的几个基本要素，它们分别是：\n\n- 画布\n- 画笔\n- 颜色\n- 橡皮擦（这个现在还用不着）\n\n光有这些还不够，一幅画主要由线条，形状（圆形或者矩形），弧线组成，所以要学会用代码画图，那么得先知道如何在电脑上画出这些线条。我们直接拿之前的HTML 5页面来使用：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n\t<div id=\"canvas-wrap\">\n\t\t<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n\t</div>\n</body>\n\n<script type=\"text/javascript\">\n\t// 创建画布\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    // 创建画笔\n    let context = canvas.getContext(\"2d\");\n</script>\n</html>\n```\n\n好了，接下来，我们将开始学习如何画出线条、矩形、圆形和弧形；\n\n## 线条\n\n线条比较简单，中学的时候我们都知道，两点就能确定一条直线，所以在计算机中也是一样，只要我给定两个点的坐标，那么他们之间的轨迹就是一条直线。所以直线的绘制方法如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.moveTo(100, 100);\ncontext.lineTo(500, 100);\ncontext.stroke();\n```\n\n其中`moveTo(x, y)`代表了直线的绘制起点，`lineTo(x, y)`代表了直线的绘制终点；\n\n由于canvas是基于状态绘制的，所以每绘制一个图形，都要以`context.beginPath()`起头，如果要上色，可以使用`context.strokeStyle = <color>`给线条上色。\n\n这里的坐标用的同样是笛卡尔坐标系，但是跟我们中学课本上的不一样。在计算机中，屏幕的左上角是坐标顶点，横向是x正轴，纵向是y正轴；\n\n## 矩形\n\n要绘制矩形，可以使用两种办法：\n\n（1）使用之前的`moveTo`和`lineTo`方法，一次性绘制4条直线，那自然就围城了一个矩形；\n\n（2）直接调用canvas封装的API：`rect(x, y, width, height)`来绘制矩形；\n\n这两种方法都可以在页面上绘制出一个矩形，但是使用方法（1）的时候必须要在绘制结束后加上`context.closePath()`，否则图形看上去就会有缺口；\n\n你可以把下面这两段直接拷贝到自己的代码中，就可以看到效果了：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\nlet context = canvas.getContext(\"2d\");\n\n// 方法（1）绘制矩形\ncontext.beginPath();\ncontext.moveTo(100, 100);\ncontext.lineTo(400, 100);\ncontext.lineTo(400, 400);\ncontext.lineTo(100, 400);\ncontext.closePath(); // 要想图形闭合，需要加上这句话\ncontext.strokeStyle = \"blue\";\ncontext.stroke();\n\n// 方法(2)绘制矩形\ncontext.beginPath();\ncontext.rect(100, 100, 300, 300);\ncontext.strokeStyle = \"red\";\ncontext.stroke();\n```\n\n最后，我们再说一下线条属性：\n\n- lineCap：定义上下文中线的端点样式：可以是：butt、round和square；\n- lineJoin：定义两条线相交产生的拐角，可以称为连接，可以是：miter、bevel和round；\n- lindWidth：定义线条宽度，默认是1.0；\n- strokeStyle：定义线和形状边框的颜色样式；\n\n## 弧线\n\n熟悉PS的同学也会知道，绘制圆弧常用的工具有预设的圆弧工具和钢笔工具（贝塞尔曲线）；那么在canvas中也是一样的：\n\n- 标准圆弧：`arc()`\n- 复杂圆弧：`arcTo()`\n- 2阶贝塞尔曲线：`quadraticCurveTo()`\n- 3阶贝塞尔曲线：`bezierCurveTo()`\n\n### `context.arc(x, y, radius, startAngle, endAngle, antiClockWise)`\n\n参数代表的含义分别为：圆心坐标，圆心半径，起始弧度，结束弧度以及是否逆时针；\n\n这里的弧度和中学课本里面讲的弧度是同一个概念，只不过坐标系的参考位置是不一样的；\n\n### `context.arcTo(x1, y1, x2, y2, radius)`\n\n参数代表的含义分别为：两个切点的坐标和圆弧半径。这个方法是依据切线来画弧线，即两条切线就能确定一条弧线；例子如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.moveTo(200, 200);\ncontext.arcTo(600, 200, 600, 400, 100);\n\ncontext.lineWidth = 6;\ncontext.strokeStyle = \"red\";\ncontext.stroke();\n\ncontext.beginPath();\ncontext.moveTo(200, 200);\ncontext.lineTo(600, 200);\ncontext.lineTo(600, 400);\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = \"#0088AA\";\ncontext.stroke();\n```\n\n## 圆形\n\n有了上面绘制圆弧的基础知识，我们就可以绘制圆形了，其实也非常简单。\n\n```javascript\nconst PI = Math.PI;\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.arc(200, 200, 50, 0, PI * 2); // 顺时针绘制\ncontext.arc(400, 400, 50, 0, PI * 2, true); // 逆时针绘制\n```\n\n记住计算机上圆形的弧度顺序：时钟3点对应的是0(PI * 2)，时钟6点对应的是PI / 2，时钟9点对应的是PI，时钟12点对应的是PI * 3 / 2；默认情况下绘图顺序是顺时针方向；\n\n## 曲线\n\n如果你用过PS的钢笔工具，那么一定也画过曲线，钢笔工具画出来的曲线就叫做贝塞尔曲线，这是发过数学家贝塞尔于1962年发现，并以他的名字命名了这种曲线。\n\n曲线由起始点、终止点和控制点组成，每条曲线都具备这三个点。控制点为曲线阶数 - 1，也就是说2阶贝塞尔曲线有2 - 1 = 1个控制点。\n\n### 2阶贝塞尔曲线\n\ncanvas中，绘制二阶贝塞尔曲线的API如下：\n\n```javascript\ncontext.quadraticCurveTo(cpx, cpy, x, y); // 2阶\n```\n\n一个控制点（cpx, cpy）和一个终止点（x, y）；\n\n### 3阶贝塞尔曲线\n\n绘制三阶贝塞尔曲线的API如下：\n\n```javascript\ncontext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); // 3阶\n```\n\n两个控制点（cp1x, cp1y）和（cp2x, cp2y）和终止点（x, y）\n","source":"_posts/frontend/canvas/canvas-draw-shape.md","raw":"---\ntitle: Canvas绘制图形\ndate: 2022-02-18 10:59:22\nupdated: 2022-02-18 10:59:22\ntags: HTML\ncategories: 前端\n---\n\n# Canvas绘图\n\n## 回顾\n\n前一章讲了如何创建绘图的几个基本要素，它们分别是：\n\n- 画布\n- 画笔\n- 颜色\n- 橡皮擦（这个现在还用不着）\n\n光有这些还不够，一幅画主要由线条，形状（圆形或者矩形），弧线组成，所以要学会用代码画图，那么得先知道如何在电脑上画出这些线条。我们直接拿之前的HTML 5页面来使用：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n\t<div id=\"canvas-wrap\">\n\t\t<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n\t</div>\n</body>\n\n<script type=\"text/javascript\">\n\t// 创建画布\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    // 创建画笔\n    let context = canvas.getContext(\"2d\");\n</script>\n</html>\n```\n\n好了，接下来，我们将开始学习如何画出线条、矩形、圆形和弧形；\n\n## 线条\n\n线条比较简单，中学的时候我们都知道，两点就能确定一条直线，所以在计算机中也是一样，只要我给定两个点的坐标，那么他们之间的轨迹就是一条直线。所以直线的绘制方法如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.moveTo(100, 100);\ncontext.lineTo(500, 100);\ncontext.stroke();\n```\n\n其中`moveTo(x, y)`代表了直线的绘制起点，`lineTo(x, y)`代表了直线的绘制终点；\n\n由于canvas是基于状态绘制的，所以每绘制一个图形，都要以`context.beginPath()`起头，如果要上色，可以使用`context.strokeStyle = <color>`给线条上色。\n\n这里的坐标用的同样是笛卡尔坐标系，但是跟我们中学课本上的不一样。在计算机中，屏幕的左上角是坐标顶点，横向是x正轴，纵向是y正轴；\n\n## 矩形\n\n要绘制矩形，可以使用两种办法：\n\n（1）使用之前的`moveTo`和`lineTo`方法，一次性绘制4条直线，那自然就围城了一个矩形；\n\n（2）直接调用canvas封装的API：`rect(x, y, width, height)`来绘制矩形；\n\n这两种方法都可以在页面上绘制出一个矩形，但是使用方法（1）的时候必须要在绘制结束后加上`context.closePath()`，否则图形看上去就会有缺口；\n\n你可以把下面这两段直接拷贝到自己的代码中，就可以看到效果了：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\nlet context = canvas.getContext(\"2d\");\n\n// 方法（1）绘制矩形\ncontext.beginPath();\ncontext.moveTo(100, 100);\ncontext.lineTo(400, 100);\ncontext.lineTo(400, 400);\ncontext.lineTo(100, 400);\ncontext.closePath(); // 要想图形闭合，需要加上这句话\ncontext.strokeStyle = \"blue\";\ncontext.stroke();\n\n// 方法(2)绘制矩形\ncontext.beginPath();\ncontext.rect(100, 100, 300, 300);\ncontext.strokeStyle = \"red\";\ncontext.stroke();\n```\n\n最后，我们再说一下线条属性：\n\n- lineCap：定义上下文中线的端点样式：可以是：butt、round和square；\n- lineJoin：定义两条线相交产生的拐角，可以称为连接，可以是：miter、bevel和round；\n- lindWidth：定义线条宽度，默认是1.0；\n- strokeStyle：定义线和形状边框的颜色样式；\n\n## 弧线\n\n熟悉PS的同学也会知道，绘制圆弧常用的工具有预设的圆弧工具和钢笔工具（贝塞尔曲线）；那么在canvas中也是一样的：\n\n- 标准圆弧：`arc()`\n- 复杂圆弧：`arcTo()`\n- 2阶贝塞尔曲线：`quadraticCurveTo()`\n- 3阶贝塞尔曲线：`bezierCurveTo()`\n\n### `context.arc(x, y, radius, startAngle, endAngle, antiClockWise)`\n\n参数代表的含义分别为：圆心坐标，圆心半径，起始弧度，结束弧度以及是否逆时针；\n\n这里的弧度和中学课本里面讲的弧度是同一个概念，只不过坐标系的参考位置是不一样的；\n\n### `context.arcTo(x1, y1, x2, y2, radius)`\n\n参数代表的含义分别为：两个切点的坐标和圆弧半径。这个方法是依据切线来画弧线，即两条切线就能确定一条弧线；例子如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.moveTo(200, 200);\ncontext.arcTo(600, 200, 600, 400, 100);\n\ncontext.lineWidth = 6;\ncontext.strokeStyle = \"red\";\ncontext.stroke();\n\ncontext.beginPath();\ncontext.moveTo(200, 200);\ncontext.lineTo(600, 200);\ncontext.lineTo(600, 400);\n\ncontext.lineWidth = 1;\ncontext.strokeStyle = \"#0088AA\";\ncontext.stroke();\n```\n\n## 圆形\n\n有了上面绘制圆弧的基础知识，我们就可以绘制圆形了，其实也非常简单。\n\n```javascript\nconst PI = Math.PI;\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.beginPath();\ncontext.arc(200, 200, 50, 0, PI * 2); // 顺时针绘制\ncontext.arc(400, 400, 50, 0, PI * 2, true); // 逆时针绘制\n```\n\n记住计算机上圆形的弧度顺序：时钟3点对应的是0(PI * 2)，时钟6点对应的是PI / 2，时钟9点对应的是PI，时钟12点对应的是PI * 3 / 2；默认情况下绘图顺序是顺时针方向；\n\n## 曲线\n\n如果你用过PS的钢笔工具，那么一定也画过曲线，钢笔工具画出来的曲线就叫做贝塞尔曲线，这是发过数学家贝塞尔于1962年发现，并以他的名字命名了这种曲线。\n\n曲线由起始点、终止点和控制点组成，每条曲线都具备这三个点。控制点为曲线阶数 - 1，也就是说2阶贝塞尔曲线有2 - 1 = 1个控制点。\n\n### 2阶贝塞尔曲线\n\ncanvas中，绘制二阶贝塞尔曲线的API如下：\n\n```javascript\ncontext.quadraticCurveTo(cpx, cpy, x, y); // 2阶\n```\n\n一个控制点（cpx, cpy）和一个终止点（x, y）；\n\n### 3阶贝塞尔曲线\n\n绘制三阶贝塞尔曲线的API如下：\n\n```javascript\ncontext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); // 3阶\n```\n\n两个控制点（cp1x, cp1y）和（cp2x, cp2y）和终止点（x, y）\n","slug":"frontend/canvas/canvas-draw-shape","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3e002h2y6167mpgytk","content":"<h1 id=\"Canvas绘图\"><a href=\"#Canvas绘图\" class=\"headerlink\" title=\"Canvas绘图\"></a>Canvas绘图</h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>前一章讲了如何创建绘图的几个基本要素，它们分别是：</p>\n<ul>\n<li>画布</li>\n<li>画笔</li>\n<li>颜色</li>\n<li>橡皮擦（这个现在还用不着）</li>\n</ul>\n<p>光有这些还不够，一幅画主要由线条，形状（圆形或者矩形），弧线组成，所以要学会用代码画图，那么得先知道如何在电脑上画出这些线条。我们直接拿之前的HTML 5页面来使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas-wrap&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">\t<span class=\"hljs-comment\">// 创建画布</span></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);</span><br><span class=\"language-javascript\">    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;</span><br><span class=\"language-javascript\">    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;</span><br><span class=\"language-javascript\">    <span class=\"hljs-comment\">// 创建画笔</span></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>好了，接下来，我们将开始学习如何画出线条、矩形、圆形和弧形；</p>\n<h2 id=\"线条\"><a href=\"#线条\" class=\"headerlink\" title=\"线条\"></a>线条</h2><p>线条比较简单，中学的时候我们都知道，两点就能确定一条直线，所以在计算机中也是一样，只要我给定两个点的坐标，那么他们之间的轨迹就是一条直线。所以直线的绘制方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<p>其中<code>moveTo(x, y)</code>代表了直线的绘制起点，<code>lineTo(x, y)</code>代表了直线的绘制终点；</p>\n<p>由于canvas是基于状态绘制的，所以每绘制一个图形，都要以<code>context.beginPath()</code>起头，如果要上色，可以使用<code>context.strokeStyle = &lt;color&gt;</code>给线条上色。</p>\n<p>这里的坐标用的同样是笛卡尔坐标系，但是跟我们中学课本上的不一样。在计算机中，屏幕的左上角是坐标顶点，横向是x正轴，纵向是y正轴；</p>\n<h2 id=\"矩形\"><a href=\"#矩形\" class=\"headerlink\" title=\"矩形\"></a>矩形</h2><p>要绘制矩形，可以使用两种办法：</p>\n<p>（1）使用之前的<code>moveTo</code>和<code>lineTo</code>方法，一次性绘制4条直线，那自然就围城了一个矩形；</p>\n<p>（2）直接调用canvas封装的API：<code>rect(x, y, width, height)</code>来绘制矩形；</p>\n<p>这两种方法都可以在页面上绘制出一个矩形，但是使用方法（1）的时候必须要在绘制结束后加上<code>context.closePath()</code>，否则图形看上去就会有缺口；</p>\n<p>你可以把下面这两段直接拷贝到自己的代码中，就可以看到效果了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br><span class=\"hljs-comment\">// 方法（1）绘制矩形</span><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">400</span>);<br>context.<span class=\"hljs-title function_\">closePath</span>(); <span class=\"hljs-comment\">// 要想图形闭合，需要加上这句话</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;blue&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br><br><span class=\"hljs-comment\">// 方法(2)绘制矩形</span><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">300</span>);<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<p>最后，我们再说一下线条属性：</p>\n<ul>\n<li>lineCap：定义上下文中线的端点样式：可以是：butt、round和square；</li>\n<li>lineJoin：定义两条线相交产生的拐角，可以称为连接，可以是：miter、bevel和round；</li>\n<li>lindWidth：定义线条宽度，默认是1.0；</li>\n<li>strokeStyle：定义线和形状边框的颜色样式；</li>\n</ul>\n<h2 id=\"弧线\"><a href=\"#弧线\" class=\"headerlink\" title=\"弧线\"></a>弧线</h2><p>熟悉PS的同学也会知道，绘制圆弧常用的工具有预设的圆弧工具和钢笔工具（贝塞尔曲线）；那么在canvas中也是一样的：</p>\n<ul>\n<li>标准圆弧：<code>arc()</code></li>\n<li>复杂圆弧：<code>arcTo()</code></li>\n<li>2阶贝塞尔曲线：<code>quadraticCurveTo()</code></li>\n<li>3阶贝塞尔曲线：<code>bezierCurveTo()</code></li>\n</ul>\n<h3 id=\"context-arc-x-y-radius-startAngle-endAngle-antiClockWise\"><a href=\"#context-arc-x-y-radius-startAngle-endAngle-antiClockWise\" class=\"headerlink\" title=\"context.arc(x, y, radius, startAngle, endAngle, antiClockWise)\"></a><code>context.arc(x, y, radius, startAngle, endAngle, antiClockWise)</code></h3><p>参数代表的含义分别为：圆心坐标，圆心半径，起始弧度，结束弧度以及是否逆时针；</p>\n<p>这里的弧度和中学课本里面讲的弧度是同一个概念，只不过坐标系的参考位置是不一样的；</p>\n<h3 id=\"context-arcTo-x1-y1-x2-y2-radius\"><a href=\"#context-arcTo-x1-y1-x2-y2-radius\" class=\"headerlink\" title=\"context.arcTo(x1, y1, x2, y2, radius)\"></a><code>context.arcTo(x1, y1, x2, y2, radius)</code></h3><p>参数代表的含义分别为：两个切点的坐标和圆弧半径。这个方法是依据切线来画弧线，即两条切线就能确定一条弧线；例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">arcTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">100</span>);<br><br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">6</span>;<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);<br><br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">1</span>;<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#0088AA&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"圆形\"><a href=\"#圆形\" class=\"headerlink\" title=\"圆形\"></a>圆形</h2><p>有了上面绘制圆弧的基础知识，我们就可以绘制圆形了，其实也非常简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PI</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>;<br><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable constant_\">PI</span> * <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 顺时针绘制</span><br>context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable constant_\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 逆时针绘制</span><br></code></pre></td></tr></table></figure>\n<p>记住计算机上圆形的弧度顺序：时钟3点对应的是0(PI <em> 2)，时钟6点对应的是PI / 2，时钟9点对应的是PI，时钟12点对应的是PI </em> 3 / 2；默认情况下绘图顺序是顺时针方向；</p>\n<h2 id=\"曲线\"><a href=\"#曲线\" class=\"headerlink\" title=\"曲线\"></a>曲线</h2><p>如果你用过PS的钢笔工具，那么一定也画过曲线，钢笔工具画出来的曲线就叫做贝塞尔曲线，这是发过数学家贝塞尔于1962年发现，并以他的名字命名了这种曲线。</p>\n<p>曲线由起始点、终止点和控制点组成，每条曲线都具备这三个点。控制点为曲线阶数 - 1，也就是说2阶贝塞尔曲线有2 - 1 = 1个控制点。</p>\n<h3 id=\"2阶贝塞尔曲线\"><a href=\"#2阶贝塞尔曲线\" class=\"headerlink\" title=\"2阶贝塞尔曲线\"></a>2阶贝塞尔曲线</h3><p>canvas中，绘制二阶贝塞尔曲线的API如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">context.<span class=\"hljs-title function_\">quadraticCurveTo</span>(cpx, cpy, x, y); <span class=\"hljs-comment\">// 2阶</span><br></code></pre></td></tr></table></figure>\n<p>一个控制点（cpx, cpy）和一个终止点（x, y）；</p>\n<h3 id=\"3阶贝塞尔曲线\"><a href=\"#3阶贝塞尔曲线\" class=\"headerlink\" title=\"3阶贝塞尔曲线\"></a>3阶贝塞尔曲线</h3><p>绘制三阶贝塞尔曲线的API如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">context.<span class=\"hljs-title function_\">bezierCurveTo</span>(cp1x, cp1y, cp2x, cp2y, x, y); <span class=\"hljs-comment\">// 3阶</span><br></code></pre></td></tr></table></figure>\n<p>两个控制点（cp1x, cp1y）和（cp2x, cp2y）和终止点（x, y）</p>\n","site":{"data":{}},"wordcount":3684,"excerpt":"","more":"<h1 id=\"Canvas绘图\"><a href=\"#Canvas绘图\" class=\"headerlink\" title=\"Canvas绘图\"></a>Canvas绘图</h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>前一章讲了如何创建绘图的几个基本要素，它们分别是：</p>\n<ul>\n<li>画布</li>\n<li>画笔</li>\n<li>颜色</li>\n<li>橡皮擦（这个现在还用不着）</li>\n</ul>\n<p>光有这些还不够，一幅画主要由线条，形状（圆形或者矩形），弧线组成，所以要学会用代码画图，那么得先知道如何在电脑上画出这些线条。我们直接拿之前的HTML 5页面来使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas-wrap&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">\t<span class=\"hljs-comment\">// 创建画布</span></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);</span><br><span class=\"language-javascript\">    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;</span><br><span class=\"language-javascript\">    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;</span><br><span class=\"language-javascript\">    <span class=\"hljs-comment\">// 创建画笔</span></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>好了，接下来，我们将开始学习如何画出线条、矩形、圆形和弧形；</p>\n<h2 id=\"线条\"><a href=\"#线条\" class=\"headerlink\" title=\"线条\"></a>线条</h2><p>线条比较简单，中学的时候我们都知道，两点就能确定一条直线，所以在计算机中也是一样，只要我给定两个点的坐标，那么他们之间的轨迹就是一条直线。所以直线的绘制方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<p>其中<code>moveTo(x, y)</code>代表了直线的绘制起点，<code>lineTo(x, y)</code>代表了直线的绘制终点；</p>\n<p>由于canvas是基于状态绘制的，所以每绘制一个图形，都要以<code>context.beginPath()</code>起头，如果要上色，可以使用<code>context.strokeStyle = &lt;color&gt;</code>给线条上色。</p>\n<p>这里的坐标用的同样是笛卡尔坐标系，但是跟我们中学课本上的不一样。在计算机中，屏幕的左上角是坐标顶点，横向是x正轴，纵向是y正轴；</p>\n<h2 id=\"矩形\"><a href=\"#矩形\" class=\"headerlink\" title=\"矩形\"></a>矩形</h2><p>要绘制矩形，可以使用两种办法：</p>\n<p>（1）使用之前的<code>moveTo</code>和<code>lineTo</code>方法，一次性绘制4条直线，那自然就围城了一个矩形；</p>\n<p>（2）直接调用canvas封装的API：<code>rect(x, y, width, height)</code>来绘制矩形；</p>\n<p>这两种方法都可以在页面上绘制出一个矩形，但是使用方法（1）的时候必须要在绘制结束后加上<code>context.closePath()</code>，否则图形看上去就会有缺口；</p>\n<p>你可以把下面这两段直接拷贝到自己的代码中，就可以看到效果了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br><span class=\"hljs-comment\">// 方法（1）绘制矩形</span><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">400</span>);<br>context.<span class=\"hljs-title function_\">closePath</span>(); <span class=\"hljs-comment\">// 要想图形闭合，需要加上这句话</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;blue&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br><br><span class=\"hljs-comment\">// 方法(2)绘制矩形</span><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">300</span>);<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<p>最后，我们再说一下线条属性：</p>\n<ul>\n<li>lineCap：定义上下文中线的端点样式：可以是：butt、round和square；</li>\n<li>lineJoin：定义两条线相交产生的拐角，可以称为连接，可以是：miter、bevel和round；</li>\n<li>lindWidth：定义线条宽度，默认是1.0；</li>\n<li>strokeStyle：定义线和形状边框的颜色样式；</li>\n</ul>\n<h2 id=\"弧线\"><a href=\"#弧线\" class=\"headerlink\" title=\"弧线\"></a>弧线</h2><p>熟悉PS的同学也会知道，绘制圆弧常用的工具有预设的圆弧工具和钢笔工具（贝塞尔曲线）；那么在canvas中也是一样的：</p>\n<ul>\n<li>标准圆弧：<code>arc()</code></li>\n<li>复杂圆弧：<code>arcTo()</code></li>\n<li>2阶贝塞尔曲线：<code>quadraticCurveTo()</code></li>\n<li>3阶贝塞尔曲线：<code>bezierCurveTo()</code></li>\n</ul>\n<h3 id=\"context-arc-x-y-radius-startAngle-endAngle-antiClockWise\"><a href=\"#context-arc-x-y-radius-startAngle-endAngle-antiClockWise\" class=\"headerlink\" title=\"context.arc(x, y, radius, startAngle, endAngle, antiClockWise)\"></a><code>context.arc(x, y, radius, startAngle, endAngle, antiClockWise)</code></h3><p>参数代表的含义分别为：圆心坐标，圆心半径，起始弧度，结束弧度以及是否逆时针；</p>\n<p>这里的弧度和中学课本里面讲的弧度是同一个概念，只不过坐标系的参考位置是不一样的；</p>\n<h3 id=\"context-arcTo-x1-y1-x2-y2-radius\"><a href=\"#context-arcTo-x1-y1-x2-y2-radius\" class=\"headerlink\" title=\"context.arcTo(x1, y1, x2, y2, radius)\"></a><code>context.arcTo(x1, y1, x2, y2, radius)</code></h3><p>参数代表的含义分别为：两个切点的坐标和圆弧半径。这个方法是依据切线来画弧线，即两条切线就能确定一条弧线；例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">arcTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">100</span>);<br><br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">6</span>;<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">moveTo</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">200</span>);<br>context.<span class=\"hljs-title function_\">lineTo</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);<br><br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">1</span>;<br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#0088AA&quot;</span>;<br>context.<span class=\"hljs-title function_\">stroke</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"圆形\"><a href=\"#圆形\" class=\"headerlink\" title=\"圆形\"></a>圆形</h2><p>有了上面绘制圆弧的基础知识，我们就可以绘制圆形了，其实也非常简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PI</span> = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>;<br><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-title function_\">beginPath</span>();<br>context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable constant_\">PI</span> * <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 顺时针绘制</span><br>context.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable constant_\">PI</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 逆时针绘制</span><br></code></pre></td></tr></table></figure>\n<p>记住计算机上圆形的弧度顺序：时钟3点对应的是0(PI <em> 2)，时钟6点对应的是PI / 2，时钟9点对应的是PI，时钟12点对应的是PI </em> 3 / 2；默认情况下绘图顺序是顺时针方向；</p>\n<h2 id=\"曲线\"><a href=\"#曲线\" class=\"headerlink\" title=\"曲线\"></a>曲线</h2><p>如果你用过PS的钢笔工具，那么一定也画过曲线，钢笔工具画出来的曲线就叫做贝塞尔曲线，这是发过数学家贝塞尔于1962年发现，并以他的名字命名了这种曲线。</p>\n<p>曲线由起始点、终止点和控制点组成，每条曲线都具备这三个点。控制点为曲线阶数 - 1，也就是说2阶贝塞尔曲线有2 - 1 = 1个控制点。</p>\n<h3 id=\"2阶贝塞尔曲线\"><a href=\"#2阶贝塞尔曲线\" class=\"headerlink\" title=\"2阶贝塞尔曲线\"></a>2阶贝塞尔曲线</h3><p>canvas中，绘制二阶贝塞尔曲线的API如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">context.<span class=\"hljs-title function_\">quadraticCurveTo</span>(cpx, cpy, x, y); <span class=\"hljs-comment\">// 2阶</span><br></code></pre></td></tr></table></figure>\n<p>一个控制点（cpx, cpy）和一个终止点（x, y）；</p>\n<h3 id=\"3阶贝塞尔曲线\"><a href=\"#3阶贝塞尔曲线\" class=\"headerlink\" title=\"3阶贝塞尔曲线\"></a>3阶贝塞尔曲线</h3><p>绘制三阶贝塞尔曲线的API如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">context.<span class=\"hljs-title function_\">bezierCurveTo</span>(cp1x, cp1y, cp2x, cp2y, x, y); <span class=\"hljs-comment\">// 3阶</span><br></code></pre></td></tr></table></figure>\n<p>两个控制点（cp1x, cp1y）和（cp2x, cp2y）和终止点（x, y）</p>\n"},{"title":"Canvas基础入门","date":"2022-02-18T02:59:03.000Z","updated":"2022-02-18T02:59:03.000Z","_content":"\n# Canvas快速上手\n\n## 准备工作\n\n你只需要准备：\n\n- Web Kit内核浏览器：Safari（Apple MacOS）、Google Chrome或者Mozilla Firefox；（由于Canvas的标准是Chrome和Mozilla联合制定的，所以推荐使用Chrome或者Firefox）\n- 你最拿手的编辑器：Sublime Text、Atom或者是Visual Studio Code；（这里我选择了VS Code）\n\n准备好上面这些之后，在你的电脑文件系统中找一个位置，然后创建一个HTML 5的页面，像下面这样：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n</body>\n</html>\n```\n\n准备好页面以后，我们在`<body></body>`标签中写一点东西，来验证一下`<canvas>`的魅力，像下面这样：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n\t<div id=\"canvas-wrap\">\n\t\t<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n\t</div>\n</body>\n</html>\n```\n\n可以发现，当你打开浏览器以后，你的页面上什么都看不到，这恰恰说明你的浏览器是支持Canvas的！你可以找一个老古董浏览器（例如：Internet Explorer）来打开看看，它就会显示“<u>抱歉你的浏览器不支持Canvas！</u>”\n\n## 计算机绘图基础\n\n现实生活中，要想绘图，你需要准备下面这些东西：\n\n- 画布（当然不一定是真的布，纸张也算是画布的一种）\n- 画笔（各种粗细不一，功能不同的笔）\n- 颜料（12色、16色或者24色的颜料板）\n- 橡皮、尺子以及其他辅助工具等等；\n\n那么将这些东西映射到计算机上呢？答案也是一样的，你同样需要准备上面的那几样东西，只不过我们把现实生活中的工具都转换成了JavaScript代码而已。\n\n### 画布\n\n我们再次看`<canvas></canvas>`标签，它有一个id属性，这个id所指向的DOM元素就是我们的画布了。\n\n```html\n<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n```\n\n我们可以给画布添加一些CSS样式，这样在浏览器中你就能看到画布的位置了：\n\n```css\n#canvas {\n    border: 1px solid #aaaaaa;\n    display: block;\n    margin: 50px auto;\n    width: 800;\n    height: 600;\n}\n```\n\n用JavaScript也可以设置画布的宽和高，像下面这样：\n\n```javascript\nwindow.onload = function() {\n    var canvas = document.getElementById(\"canvas\"); // 这样就可以取到画布对象了\n    // 设置画布的大小\n    canvas.width = 800;\n    canvas.height = 600;\n};\n```\n\n到此画布我们就创建好了，今后都会在画布上创建图形。\n\n### 画笔\n\n有了画布，自然就少不了画笔了，一般在其他教程中都会叫做上下文环境，我觉得这个词过于抽象，还是用画笔比较容易理解。\n\n```javascript\nwindow.onload = function () {\n    // 画布\n    var canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    // 画笔\n    var context = canvas.getContext(\"2d\");\n};\n```\n\n那么既然是画笔，自然就可以设置它的粗细，颜色了对吧，说得对，确实是可以设置：\n\n```javascript\nvar context = canvas.getContext(\"2d\");\ncontext.lineWidth = 5; //画笔的粗细\ncontext.strokeStyle = \"#acef4d\"; // 画笔的颜色\n```\n\n### 颜料\n\n说完画布和画笔，我们来说颜料；计算机中的颜色表示相信大家都知道了。你可以用`RGB`或者`HSLA`颜色表示法，也可以像学习CSS那样给图形上颜色；非常简单。\n\n上色的方法也非常简单，只需要再创建画笔之后使用`context.fillStyle`就可以了。上色的方式支持下面这些：\n\n- 颜色字符串，例如：red，blue和purple；\n- 使用十六进制字符串或者其简写形式填充：#FF0000或者#FF0;\n- 使用`rgb()`方法设置颜色；R红色、G绿色、B蓝色；\n- 使用`rgba()`方法设置颜色；A代表(Alpha)，代表透明度；（0 ~ 1）；\n- 使用`hsl()`方法设置颜色；H色相、S饱和度、L明度；\n- 使用`hsla()`方法设置颜色；A代表透明度(Alpha)；（0 ~ 1）；\n\n### 渐变效果\n\n渐变分为两种，熟悉PS的同学应该知道是什么；\n\n- 线性渐变：`context.createLinearGradient(xstart, ystart, xend, yend)`\n- 径向渐变：`context.createRadialGradient(x0, y0, r0, x1, y1, r1)`\n\n添加渐变的步骤有下面3个：\n\n（1）添加渐变线\n\n（2）为渐变线添加关建色；\n\n（3）应用渐变；\n\n转换成代码就是下面这样子：（以线性渐变为例）\n\n```javascript\n// 添加渐变线\nlet grd = context.createLinearGradient(xstart, ystart, xend, yend);\nlet grd2 = context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\n// 添加关建色\n/* stop代表到(xstart, ystart)的距离占整个渐变色长度的比例，为0~1的浮点数 */\ngrd.addColorStop(stop, color)\n\n// 应用渐变\ncontext.fillStyle = grd; // 填充渐变色\ncontext.strokeStyle = grd; // 线框渐变色\n```\n\n贴上一个例子方便理解：\n\n```javascript\n// Code should wrap in HTML script tag\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    let context = canvas.getContext(\"2d\");\n    \n    let grd = context.createRadialGradient(400, 300, 100, 400, 300, 200);\n    \n    grd.addColorStop(0, \"olive\");\n    grd.addColorStop(0.25, \"maroon\");\n    grd.addColorStop(0.5, \"aqua\");\n    grd.addColorStop(0.75, \"fuchsia\");\n    grd.addColorStop(0.25, \"teal\");\n    \n    context.fillStyle = grd;\n    \n    context.fillRect(100, 100, 600, 400);\n};\n```\n\n### 橡皮擦\n\ncanvas提供了一个API叫做`context.clearRect(x, y, w, h)`，这个API就是用来清除画布中的像素的，也就是现实作画中的橡皮擦。\n","source":"_posts/frontend/canvas/canvas-getting-started.md","raw":"---\ntitle: Canvas基础入门\ndate: 2022-02-18 10:59:03\nupdated: 2022-02-18 10:59:03\ntags: HTML\ncategories: 前端\n---\n\n# Canvas快速上手\n\n## 准备工作\n\n你只需要准备：\n\n- Web Kit内核浏览器：Safari（Apple MacOS）、Google Chrome或者Mozilla Firefox；（由于Canvas的标准是Chrome和Mozilla联合制定的，所以推荐使用Chrome或者Firefox）\n- 你最拿手的编辑器：Sublime Text、Atom或者是Visual Studio Code；（这里我选择了VS Code）\n\n准备好上面这些之后，在你的电脑文件系统中找一个位置，然后创建一个HTML 5的页面，像下面这样：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n</body>\n</html>\n```\n\n准备好页面以后，我们在`<body></body>`标签中写一点东西，来验证一下`<canvas>`的魅力，像下面这样：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n\t<title>Canvas Tutorial</title>\n</head>\n<body>\n\t<div id=\"canvas-wrap\">\n\t\t<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n\t</div>\n</body>\n</html>\n```\n\n可以发现，当你打开浏览器以后，你的页面上什么都看不到，这恰恰说明你的浏览器是支持Canvas的！你可以找一个老古董浏览器（例如：Internet Explorer）来打开看看，它就会显示“<u>抱歉你的浏览器不支持Canvas！</u>”\n\n## 计算机绘图基础\n\n现实生活中，要想绘图，你需要准备下面这些东西：\n\n- 画布（当然不一定是真的布，纸张也算是画布的一种）\n- 画笔（各种粗细不一，功能不同的笔）\n- 颜料（12色、16色或者24色的颜料板）\n- 橡皮、尺子以及其他辅助工具等等；\n\n那么将这些东西映射到计算机上呢？答案也是一样的，你同样需要准备上面的那几样东西，只不过我们把现实生活中的工具都转换成了JavaScript代码而已。\n\n### 画布\n\n我们再次看`<canvas></canvas>`标签，它有一个id属性，这个id所指向的DOM元素就是我们的画布了。\n\n```html\n<canvas id=\"canvas\" style=\"border: 1px solid #aaaaaa; display: block; margin: 50px auto;\">\n\t\t\t抱歉你的浏览器不支持Canvas!\n\t\t</canvas>\n```\n\n我们可以给画布添加一些CSS样式，这样在浏览器中你就能看到画布的位置了：\n\n```css\n#canvas {\n    border: 1px solid #aaaaaa;\n    display: block;\n    margin: 50px auto;\n    width: 800;\n    height: 600;\n}\n```\n\n用JavaScript也可以设置画布的宽和高，像下面这样：\n\n```javascript\nwindow.onload = function() {\n    var canvas = document.getElementById(\"canvas\"); // 这样就可以取到画布对象了\n    // 设置画布的大小\n    canvas.width = 800;\n    canvas.height = 600;\n};\n```\n\n到此画布我们就创建好了，今后都会在画布上创建图形。\n\n### 画笔\n\n有了画布，自然就少不了画笔了，一般在其他教程中都会叫做上下文环境，我觉得这个词过于抽象，还是用画笔比较容易理解。\n\n```javascript\nwindow.onload = function () {\n    // 画布\n    var canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    // 画笔\n    var context = canvas.getContext(\"2d\");\n};\n```\n\n那么既然是画笔，自然就可以设置它的粗细，颜色了对吧，说得对，确实是可以设置：\n\n```javascript\nvar context = canvas.getContext(\"2d\");\ncontext.lineWidth = 5; //画笔的粗细\ncontext.strokeStyle = \"#acef4d\"; // 画笔的颜色\n```\n\n### 颜料\n\n说完画布和画笔，我们来说颜料；计算机中的颜色表示相信大家都知道了。你可以用`RGB`或者`HSLA`颜色表示法，也可以像学习CSS那样给图形上颜色；非常简单。\n\n上色的方法也非常简单，只需要再创建画笔之后使用`context.fillStyle`就可以了。上色的方式支持下面这些：\n\n- 颜色字符串，例如：red，blue和purple；\n- 使用十六进制字符串或者其简写形式填充：#FF0000或者#FF0;\n- 使用`rgb()`方法设置颜色；R红色、G绿色、B蓝色；\n- 使用`rgba()`方法设置颜色；A代表(Alpha)，代表透明度；（0 ~ 1）；\n- 使用`hsl()`方法设置颜色；H色相、S饱和度、L明度；\n- 使用`hsla()`方法设置颜色；A代表透明度(Alpha)；（0 ~ 1）；\n\n### 渐变效果\n\n渐变分为两种，熟悉PS的同学应该知道是什么；\n\n- 线性渐变：`context.createLinearGradient(xstart, ystart, xend, yend)`\n- 径向渐变：`context.createRadialGradient(x0, y0, r0, x1, y1, r1)`\n\n添加渐变的步骤有下面3个：\n\n（1）添加渐变线\n\n（2）为渐变线添加关建色；\n\n（3）应用渐变；\n\n转换成代码就是下面这样子：（以线性渐变为例）\n\n```javascript\n// 添加渐变线\nlet grd = context.createLinearGradient(xstart, ystart, xend, yend);\nlet grd2 = context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\n// 添加关建色\n/* stop代表到(xstart, ystart)的距离占整个渐变色长度的比例，为0~1的浮点数 */\ngrd.addColorStop(stop, color)\n\n// 应用渐变\ncontext.fillStyle = grd; // 填充渐变色\ncontext.strokeStyle = grd; // 线框渐变色\n```\n\n贴上一个例子方便理解：\n\n```javascript\n// Code should wrap in HTML script tag\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    let context = canvas.getContext(\"2d\");\n    \n    let grd = context.createRadialGradient(400, 300, 100, 400, 300, 200);\n    \n    grd.addColorStop(0, \"olive\");\n    grd.addColorStop(0.25, \"maroon\");\n    grd.addColorStop(0.5, \"aqua\");\n    grd.addColorStop(0.75, \"fuchsia\");\n    grd.addColorStop(0.25, \"teal\");\n    \n    context.fillStyle = grd;\n    \n    context.fillRect(100, 100, 600, 400);\n};\n```\n\n### 橡皮擦\n\ncanvas提供了一个API叫做`context.clearRect(x, y, w, h)`，这个API就是用来清除画布中的像素的，也就是现实作画中的橡皮擦。\n","slug":"frontend/canvas/canvas-getting-started","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3f002m2y612hz2242p","content":"<h1 id=\"Canvas快速上手\"><a href=\"#Canvas快速上手\" class=\"headerlink\" title=\"Canvas快速上手\"></a>Canvas快速上手</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>你只需要准备：</p>\n<ul>\n<li>Web Kit内核浏览器：Safari（Apple MacOS）、Google Chrome或者Mozilla Firefox；（由于Canvas的标准是Chrome和Mozilla联合制定的，所以推荐使用Chrome或者Firefox）</li>\n<li>你最拿手的编辑器：Sublime Text、Atom或者是Visual Studio Code；（这里我选择了VS Code）</li>\n</ul>\n<p>准备好上面这些之后，在你的电脑文件系统中找一个位置，然后创建一个HTML 5的页面，像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>准备好页面以后，我们在<code>&lt;body&gt;&lt;/body&gt;</code>标签中写一点东西，来验证一下<code>&lt;canvas&gt;</code>的魅力，像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas-wrap&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>可以发现，当你打开浏览器以后，你的页面上什么都看不到，这恰恰说明你的浏览器是支持Canvas的！你可以找一个老古董浏览器（例如：Internet Explorer）来打开看看，它就会显示“<u>抱歉你的浏览器不支持Canvas！</u>”</p>\n<h2 id=\"计算机绘图基础\"><a href=\"#计算机绘图基础\" class=\"headerlink\" title=\"计算机绘图基础\"></a>计算机绘图基础</h2><p>现实生活中，要想绘图，你需要准备下面这些东西：</p>\n<ul>\n<li>画布（当然不一定是真的布，纸张也算是画布的一种）</li>\n<li>画笔（各种粗细不一，功能不同的笔）</li>\n<li>颜料（12色、16色或者24色的颜料板）</li>\n<li>橡皮、尺子以及其他辅助工具等等；</li>\n</ul>\n<p>那么将这些东西映射到计算机上呢？答案也是一样的，你同样需要准备上面的那几样东西，只不过我们把现实生活中的工具都转换成了JavaScript代码而已。</p>\n<h3 id=\"画布\"><a href=\"#画布\" class=\"headerlink\" title=\"画布\"></a>画布</h3><p>我们再次看<code>&lt;canvas&gt;&lt;/canvas&gt;</code>标签，它有一个id属性，这个id所指向的DOM元素就是我们的画布了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>我们可以给画布添加一些CSS样式，这样在浏览器中你就能看到画布的位置了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#canvas</span> &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#aaaaaa</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">50px</span> auto;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">800</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">600</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>用JavaScript也可以设置画布的宽和高，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>); <span class=\"hljs-comment\">// 这样就可以取到画布对象了</span><br>    <span class=\"hljs-comment\">// 设置画布的大小</span><br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>到此画布我们就创建好了，今后都会在画布上创建图形。</p>\n<h3 id=\"画笔\"><a href=\"#画笔\" class=\"headerlink\" title=\"画笔\"></a>画笔</h3><p>有了画布，自然就少不了画笔了，一般在其他教程中都会叫做上下文环境，我觉得这个词过于抽象，还是用画笔比较容易理解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// 画布</span><br>    <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-comment\">// 画笔</span><br>    <span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>那么既然是画笔，自然就可以设置它的粗细，颜色了对吧，说得对，确实是可以设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">//画笔的粗细</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#acef4d&quot;</span>; <span class=\"hljs-comment\">// 画笔的颜色</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"颜料\"><a href=\"#颜料\" class=\"headerlink\" title=\"颜料\"></a>颜料</h3><p>说完画布和画笔，我们来说颜料；计算机中的颜色表示相信大家都知道了。你可以用<code>RGB</code>或者<code>HSLA</code>颜色表示法，也可以像学习CSS那样给图形上颜色；非常简单。</p>\n<p>上色的方法也非常简单，只需要再创建画笔之后使用<code>context.fillStyle</code>就可以了。上色的方式支持下面这些：</p>\n<ul>\n<li>颜色字符串，例如：red，blue和purple；</li>\n<li>使用十六进制字符串或者其简写形式填充：#FF0000或者#FF0;</li>\n<li>使用<code>rgb()</code>方法设置颜色；R红色、G绿色、B蓝色；</li>\n<li>使用<code>rgba()</code>方法设置颜色；A代表(Alpha)，代表透明度；（0 ~ 1）；</li>\n<li>使用<code>hsl()</code>方法设置颜色；H色相、S饱和度、L明度；</li>\n<li>使用<code>hsla()</code>方法设置颜色；A代表透明度(Alpha)；（0 ~ 1）；</li>\n</ul>\n<h3 id=\"渐变效果\"><a href=\"#渐变效果\" class=\"headerlink\" title=\"渐变效果\"></a>渐变效果</h3><p>渐变分为两种，熟悉PS的同学应该知道是什么；</p>\n<ul>\n<li>线性渐变：<code>context.createLinearGradient(xstart, ystart, xend, yend)</code></li>\n<li>径向渐变：<code>context.createRadialGradient(x0, y0, r0, x1, y1, r1)</code></li>\n</ul>\n<p>添加渐变的步骤有下面3个：</p>\n<p>（1）添加渐变线</p>\n<p>（2）为渐变线添加关建色；</p>\n<p>（3）应用渐变；</p>\n<p>转换成代码就是下面这样子：（以线性渐变为例）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 添加渐变线</span><br><span class=\"hljs-keyword\">let</span> grd = context.<span class=\"hljs-title function_\">createLinearGradient</span>(xstart, ystart, xend, yend);<br><span class=\"hljs-keyword\">let</span> grd2 = context.<span class=\"hljs-title function_\">createRadialGradient</span>(x0, y0, r0, x1, y1, r1);<br><br><span class=\"hljs-comment\">// 添加关建色</span><br><span class=\"hljs-comment\">/* stop代表到(xstart, ystart)的距离占整个渐变色长度的比例，为0~1的浮点数 */</span><br>grd.<span class=\"hljs-title function_\">addColorStop</span>(stop, color)<br><br><span class=\"hljs-comment\">// 应用渐变</span><br>context.<span class=\"hljs-property\">fillStyle</span> = grd; <span class=\"hljs-comment\">// 填充渐变色</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = grd; <span class=\"hljs-comment\">// 线框渐变色</span><br></code></pre></td></tr></table></figure>\n<p>贴上一个例子方便理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Code should wrap in HTML script tag</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    <span class=\"hljs-keyword\">let</span> grd = context.<span class=\"hljs-title function_\">createRadialGradient</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>);<br>    <br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;olive&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.25</span>, <span class=\"hljs-string\">&quot;maroon&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-string\">&quot;aqua&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.75</span>, <span class=\"hljs-string\">&quot;fuchsia&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.25</span>, <span class=\"hljs-string\">&quot;teal&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = grd;<br>    <br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"橡皮擦\"><a href=\"#橡皮擦\" class=\"headerlink\" title=\"橡皮擦\"></a>橡皮擦</h3><p>canvas提供了一个API叫做<code>context.clearRect(x, y, w, h)</code>，这个API就是用来清除画布中的像素的，也就是现实作画中的橡皮擦。</p>\n","site":{"data":{}},"wordcount":3497,"excerpt":"","more":"<h1 id=\"Canvas快速上手\"><a href=\"#Canvas快速上手\" class=\"headerlink\" title=\"Canvas快速上手\"></a>Canvas快速上手</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>你只需要准备：</p>\n<ul>\n<li>Web Kit内核浏览器：Safari（Apple MacOS）、Google Chrome或者Mozilla Firefox；（由于Canvas的标准是Chrome和Mozilla联合制定的，所以推荐使用Chrome或者Firefox）</li>\n<li>你最拿手的编辑器：Sublime Text、Atom或者是Visual Studio Code；（这里我选择了VS Code）</li>\n</ul>\n<p>准备好上面这些之后，在你的电脑文件系统中找一个位置，然后创建一个HTML 5的页面，像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>准备好页面以后，我们在<code>&lt;body&gt;&lt;/body&gt;</code>标签中写一点东西，来验证一下<code>&lt;canvas&gt;</code>的魅力，像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;zh&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Canvas Tutorial<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas-wrap&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>可以发现，当你打开浏览器以后，你的页面上什么都看不到，这恰恰说明你的浏览器是支持Canvas的！你可以找一个老古董浏览器（例如：Internet Explorer）来打开看看，它就会显示“<u>抱歉你的浏览器不支持Canvas！</u>”</p>\n<h2 id=\"计算机绘图基础\"><a href=\"#计算机绘图基础\" class=\"headerlink\" title=\"计算机绘图基础\"></a>计算机绘图基础</h2><p>现实生活中，要想绘图，你需要准备下面这些东西：</p>\n<ul>\n<li>画布（当然不一定是真的布，纸张也算是画布的一种）</li>\n<li>画笔（各种粗细不一，功能不同的笔）</li>\n<li>颜料（12色、16色或者24色的颜料板）</li>\n<li>橡皮、尺子以及其他辅助工具等等；</li>\n</ul>\n<p>那么将这些东西映射到计算机上呢？答案也是一样的，你同样需要准备上面的那几样东西，只不过我们把现实生活中的工具都转换成了JavaScript代码而已。</p>\n<h3 id=\"画布\"><a href=\"#画布\" class=\"headerlink\" title=\"画布\"></a>画布</h3><p>我们再次看<code>&lt;canvas&gt;&lt;/canvas&gt;</code>标签，它有一个id属性，这个id所指向的DOM元素就是我们的画布了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;canvas&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;border: 1px solid #aaaaaa; display: block; margin: 50px auto;&quot;</span>&gt;</span><br>\t\t\t抱歉你的浏览器不支持Canvas!<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>我们可以给画布添加一些CSS样式，这样在浏览器中你就能看到画布的位置了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#canvas</span> &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#aaaaaa</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">50px</span> auto;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">800</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">600</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>用JavaScript也可以设置画布的宽和高，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>); <span class=\"hljs-comment\">// 这样就可以取到画布对象了</span><br>    <span class=\"hljs-comment\">// 设置画布的大小</span><br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>到此画布我们就创建好了，今后都会在画布上创建图形。</p>\n<h3 id=\"画笔\"><a href=\"#画笔\" class=\"headerlink\" title=\"画笔\"></a>画笔</h3><p>有了画布，自然就少不了画笔了，一般在其他教程中都会叫做上下文环境，我觉得这个词过于抽象，还是用画笔比较容易理解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// 画布</span><br>    <span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-comment\">// 画笔</span><br>    <span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>那么既然是画笔，自然就可以设置它的粗细，颜色了对吧，说得对，确实是可以设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">//画笔的粗细</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#acef4d&quot;</span>; <span class=\"hljs-comment\">// 画笔的颜色</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"颜料\"><a href=\"#颜料\" class=\"headerlink\" title=\"颜料\"></a>颜料</h3><p>说完画布和画笔，我们来说颜料；计算机中的颜色表示相信大家都知道了。你可以用<code>RGB</code>或者<code>HSLA</code>颜色表示法，也可以像学习CSS那样给图形上颜色；非常简单。</p>\n<p>上色的方法也非常简单，只需要再创建画笔之后使用<code>context.fillStyle</code>就可以了。上色的方式支持下面这些：</p>\n<ul>\n<li>颜色字符串，例如：red，blue和purple；</li>\n<li>使用十六进制字符串或者其简写形式填充：#FF0000或者#FF0;</li>\n<li>使用<code>rgb()</code>方法设置颜色；R红色、G绿色、B蓝色；</li>\n<li>使用<code>rgba()</code>方法设置颜色；A代表(Alpha)，代表透明度；（0 ~ 1）；</li>\n<li>使用<code>hsl()</code>方法设置颜色；H色相、S饱和度、L明度；</li>\n<li>使用<code>hsla()</code>方法设置颜色；A代表透明度(Alpha)；（0 ~ 1）；</li>\n</ul>\n<h3 id=\"渐变效果\"><a href=\"#渐变效果\" class=\"headerlink\" title=\"渐变效果\"></a>渐变效果</h3><p>渐变分为两种，熟悉PS的同学应该知道是什么；</p>\n<ul>\n<li>线性渐变：<code>context.createLinearGradient(xstart, ystart, xend, yend)</code></li>\n<li>径向渐变：<code>context.createRadialGradient(x0, y0, r0, x1, y1, r1)</code></li>\n</ul>\n<p>添加渐变的步骤有下面3个：</p>\n<p>（1）添加渐变线</p>\n<p>（2）为渐变线添加关建色；</p>\n<p>（3）应用渐变；</p>\n<p>转换成代码就是下面这样子：（以线性渐变为例）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 添加渐变线</span><br><span class=\"hljs-keyword\">let</span> grd = context.<span class=\"hljs-title function_\">createLinearGradient</span>(xstart, ystart, xend, yend);<br><span class=\"hljs-keyword\">let</span> grd2 = context.<span class=\"hljs-title function_\">createRadialGradient</span>(x0, y0, r0, x1, y1, r1);<br><br><span class=\"hljs-comment\">// 添加关建色</span><br><span class=\"hljs-comment\">/* stop代表到(xstart, ystart)的距离占整个渐变色长度的比例，为0~1的浮点数 */</span><br>grd.<span class=\"hljs-title function_\">addColorStop</span>(stop, color)<br><br><span class=\"hljs-comment\">// 应用渐变</span><br>context.<span class=\"hljs-property\">fillStyle</span> = grd; <span class=\"hljs-comment\">// 填充渐变色</span><br>context.<span class=\"hljs-property\">strokeStyle</span> = grd; <span class=\"hljs-comment\">// 线框渐变色</span><br></code></pre></td></tr></table></figure>\n<p>贴上一个例子方便理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Code should wrap in HTML script tag</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    <span class=\"hljs-keyword\">let</span> grd = context.<span class=\"hljs-title function_\">createRadialGradient</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>);<br>    <br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;olive&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.25</span>, <span class=\"hljs-string\">&quot;maroon&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-string\">&quot;aqua&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.75</span>, <span class=\"hljs-string\">&quot;fuchsia&quot;</span>);<br>    grd.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-number\">0.25</span>, <span class=\"hljs-string\">&quot;teal&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = grd;<br>    <br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"橡皮擦\"><a href=\"#橡皮擦\" class=\"headerlink\" title=\"橡皮擦\"></a>橡皮擦</h3><p>canvas提供了一个API叫做<code>context.clearRect(x, y, w, h)</code>，这个API就是用来清除画布中的像素的，也就是现实作画中的橡皮擦。</p>\n"},{"title":"Canvas文本","date":"2022-02-18T03:00:01.000Z","updated":"2022-02-18T03:00:01.000Z","_content":"\n# Canvas文本\n\n## 文本API\n\n使用Canvas显示字体分下面三步：\n\n- 使用`font`设置字体；\n- 使用`fillStyle`设置字体颜色；\n- 使用`fillText()`方法显示字体；\n\n默认情况下`font`属性可以不指定，如果不指定字体，则默认使用10px无衬字体；贴上一个例子：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.font = \"50px serif\";\n    context.fillStyle = \"#00AAAA\";\n    context.fillText(\"Canvas -- Draw on the web\", 50, 300);\n};\n```\n\n## 文本渲染\n\n和图形一样，文本也提供了`fillText()`和`strokeText()`两种方法。具体看例子：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.beginPath();\n    context.font = \"50px Verdana\";\n    var gradient = context.createLinearGradient(0, 0, 800, 0);\n    gradient.addColorStop(\"0\", \"magenta\");\n    gradient.addColorStop(\"0.5\", \"blue\");\n    gradient.addColorStop(\"1.0\", \"red\");\n    \n    context.fillStyle = gradient;\n    context.strokeStyle = \"#00AAAA\";\n    context.strokeText(\"Text\", 50, 100);\n    context.fillText(\"Text\", 50, 100);\n    \n    context.fillText(\"Text\", 50, 300, 200);\n};\n```\n","source":"_posts/frontend/canvas/canvas-text.md","raw":"---\ntitle: Canvas文本\ndate: 2022-02-18 11:00:01\nupdated: 2022-02-18 11:00:01\ntags: HTML\ncategories: 前端\n---\n\n# Canvas文本\n\n## 文本API\n\n使用Canvas显示字体分下面三步：\n\n- 使用`font`设置字体；\n- 使用`fillStyle`设置字体颜色；\n- 使用`fillText()`方法显示字体；\n\n默认情况下`font`属性可以不指定，如果不指定字体，则默认使用10px无衬字体；贴上一个例子：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.font = \"50px serif\";\n    context.fillStyle = \"#00AAAA\";\n    context.fillText(\"Canvas -- Draw on the web\", 50, 300);\n};\n```\n\n## 文本渲染\n\n和图形一样，文本也提供了`fillText()`和`strokeText()`两种方法。具体看例子：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.beginPath();\n    context.font = \"50px Verdana\";\n    var gradient = context.createLinearGradient(0, 0, 800, 0);\n    gradient.addColorStop(\"0\", \"magenta\");\n    gradient.addColorStop(\"0.5\", \"blue\");\n    gradient.addColorStop(\"1.0\", \"red\");\n    \n    context.fillStyle = gradient;\n    context.strokeStyle = \"#00AAAA\";\n    context.strokeText(\"Text\", 50, 100);\n    context.fillText(\"Text\", 50, 100);\n    \n    context.fillText(\"Text\", 50, 300, 200);\n};\n```\n","slug":"frontend/canvas/canvas-text","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3g002p2y6164y4hgvr","content":"<h1 id=\"Canvas文本\"><a href=\"#Canvas文本\" class=\"headerlink\" title=\"Canvas文本\"></a>Canvas文本</h1><h2 id=\"文本API\"><a href=\"#文本API\" class=\"headerlink\" title=\"文本API\"></a>文本API</h2><p>使用Canvas显示字体分下面三步：</p>\n<ul>\n<li>使用<code>font</code>设置字体；</li>\n<li>使用<code>fillStyle</code>设置字体颜色；</li>\n<li>使用<code>fillText()</code>方法显示字体；</li>\n</ul>\n<p>默认情况下<code>font</code>属性可以不指定，如果不指定字体，则默认使用10px无衬字体；贴上一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">&quot;50px serif&quot;</span>;<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Canvas -- Draw on the web&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">300</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"文本渲染\"><a href=\"#文本渲染\" class=\"headerlink\" title=\"文本渲染\"></a>文本渲染</h2><p>和图形一样，文本也提供了<code>fillText()</code>和<code>strokeText()</code>两种方法。具体看例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-title function_\">beginPath</span>();<br>    context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">&quot;50px Verdana&quot;</span>;<br>    <span class=\"hljs-keyword\">var</span> gradient = context.<span class=\"hljs-title function_\">createLinearGradient</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">800</span>, <span class=\"hljs-number\">0</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;0&quot;</span>, <span class=\"hljs-string\">&quot;magenta&quot;</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;0.5&quot;</span>, <span class=\"hljs-string\">&quot;blue&quot;</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;1.0&quot;</span>, <span class=\"hljs-string\">&quot;red&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = gradient;<br>    context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">strokeText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">100</span>);<br>    <br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":1170,"excerpt":"","more":"<h1 id=\"Canvas文本\"><a href=\"#Canvas文本\" class=\"headerlink\" title=\"Canvas文本\"></a>Canvas文本</h1><h2 id=\"文本API\"><a href=\"#文本API\" class=\"headerlink\" title=\"文本API\"></a>文本API</h2><p>使用Canvas显示字体分下面三步：</p>\n<ul>\n<li>使用<code>font</code>设置字体；</li>\n<li>使用<code>fillStyle</code>设置字体颜色；</li>\n<li>使用<code>fillText()</code>方法显示字体；</li>\n</ul>\n<p>默认情况下<code>font</code>属性可以不指定，如果不指定字体，则默认使用10px无衬字体；贴上一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">&quot;50px serif&quot;</span>;<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Canvas -- Draw on the web&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">300</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"文本渲染\"><a href=\"#文本渲染\" class=\"headerlink\" title=\"文本渲染\"></a>文本渲染</h2><p>和图形一样，文本也提供了<code>fillText()</code>和<code>strokeText()</code>两种方法。具体看例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-title function_\">beginPath</span>();<br>    context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">&quot;50px Verdana&quot;</span>;<br>    <span class=\"hljs-keyword\">var</span> gradient = context.<span class=\"hljs-title function_\">createLinearGradient</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">800</span>, <span class=\"hljs-number\">0</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;0&quot;</span>, <span class=\"hljs-string\">&quot;magenta&quot;</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;0.5&quot;</span>, <span class=\"hljs-string\">&quot;blue&quot;</span>);<br>    gradient.<span class=\"hljs-title function_\">addColorStop</span>(<span class=\"hljs-string\">&quot;1.0&quot;</span>, <span class=\"hljs-string\">&quot;red&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = gradient;<br>    context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">strokeText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">100</span>);<br>    <br>    context.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">&quot;Text&quot;</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">200</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"Canvas变换","date":"2022-02-18T02:59:34.000Z","updated":"2022-02-18T02:59:34.000Z","_content":"\n# Canvas变换\n\n## 图形变换\n\n图形变换无外乎是利用数学方法调整所绘形状的物理属性，实质上是坐标变形。所有的变换都依赖于后台的数学矩阵运算，所以只需要使用即可，无需理会底层原理。\n\n- 平移变换：`translate(x, y)`\n- 旋转变换：`rotate(deg)`\n- 缩放变换：`scale(sx, sy)`\n\n## 平移变换\n\n顾名思义，就是一般的图形位移。例如我想把位于(100, 100)的矩形平移至(200, 200)点，那么只需要再绘制矩形之前加上`context.translate(100, 100)`即可，例子如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.fillStyle = \"#00AAAA\";\ncontext.fillRect(100, 100, 200, 100);\n\ncontext.fillStyle = \"red\";\ncontext.translate(100, 100);\ncontext.fillRect(100, 100, 200, 100);\n```\n\n如果想平移到(300, 300)的位置，需要重置参考坐标系的位置，也就是重置到原点，再进行平移，有两种方法：\n\n- 绘制下一次平移图形的时候，手动将坐标系换回原点：即：`translate(-x, -y)`；\n- 平移前调用`context.save()`和`context.restore()`。\n\n实例如下：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.fillStyle = \"#00AAAA\";\n    context.fillRect(100, 100, 200, 100);\n    \n    context.save();\n    context.fillStyle = \"red\";\n    context.translate(100, 100);\n    context.fillRect(100, 100, 200, 100);\n    context.restore();\n    \n    context.save();\n    context.fillStyle = \"green\";\n    context.translate(200, 200);\n    context.fillRect(100, 100, 200, 100);\n    context.restore();\n};\n```\n\n## 旋转变换\n\n`rotate(deg)`是指图形以坐标系原点为圆心进行顺时针旋转，因此在使用`rotate()`之前可以配合`translate()`来平移坐标系，确定旋转的圆心。\n\n我们用一个例子来看看：\n\n```javascript\n// 画布\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n// 画笔\nvar context = canvas.getContext(\"2d\");\n\nfor (let i = 0; i <= 12; i++) {\n    context.save();\n    context.translate(70 + i * 50, 50 + i * 40);\n    context.fillStyle = \"#00AAAA\";\n    context.fillRect(0, 0, 20, 20);\n    context.restore();\n\n    context.save();\n    context.translate(70 + i * 50, 50 + i * 40);\n    context.rotate(i * 30 * PI / 180); // 这里是弧度，不是角度\n    context.fillStyle = \"red\";\n    context.fillRect(0, 0, 20, 20);\n    context.restore();\n}\n```\n\n## 缩放变换\n\n缩放变换最简单了，分别是在水平方向和垂直方向上对象的缩放倍数。但是缩放会导致坐标位置改变、线条加粗。所以在实际使用过程中能尽量不使用scale函数做缩放变换是最好的。\n\n```javascript\n// 画布\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n// 画笔\nvar context = canvas.getContext(\"2d\");\n\ncontext.strokeStyle = \"red\";\ncontext.lineWidth = 5;\nfor (let i = 1; i < 4; i++) {\n    context.save();\n    context.scale(i, i);\n    context.strokeRect(50, 50, 150, 100);\n    context.restore();\n}\n```\n\n## 万能的transform函数\n\n前面讲的三种变换函数，使用`transform()`函数就可以做到，\n","source":"_posts/frontend/canvas/canvas-tranverse.md","raw":"---\ntitle: Canvas变换\ndate: 2022-02-18 10:59:34\nupdated: 2022-02-18 10:59:34\ntags: HTML\ncategories: 前端\n---\n\n# Canvas变换\n\n## 图形变换\n\n图形变换无外乎是利用数学方法调整所绘形状的物理属性，实质上是坐标变形。所有的变换都依赖于后台的数学矩阵运算，所以只需要使用即可，无需理会底层原理。\n\n- 平移变换：`translate(x, y)`\n- 旋转变换：`rotate(deg)`\n- 缩放变换：`scale(sx, sy)`\n\n## 平移变换\n\n顾名思义，就是一般的图形位移。例如我想把位于(100, 100)的矩形平移至(200, 200)点，那么只需要再绘制矩形之前加上`context.translate(100, 100)`即可，例子如下：\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n\nlet context = canvas.getContext(\"2d\");\n\ncontext.fillStyle = \"#00AAAA\";\ncontext.fillRect(100, 100, 200, 100);\n\ncontext.fillStyle = \"red\";\ncontext.translate(100, 100);\ncontext.fillRect(100, 100, 200, 100);\n```\n\n如果想平移到(300, 300)的位置，需要重置参考坐标系的位置，也就是重置到原点，再进行平移，有两种方法：\n\n- 绘制下一次平移图形的时候，手动将坐标系换回原点：即：`translate(-x, -y)`；\n- 平移前调用`context.save()`和`context.restore()`。\n\n实例如下：\n\n```javascript\nwindow.onload = function() {\n    let canvas = document.getElementById(\"canvas\");\n    canvas.width = 800;\n    canvas.height = 600;\n    \n    let context = canvas.getContext(\"2d\");\n    \n    context.fillStyle = \"#00AAAA\";\n    context.fillRect(100, 100, 200, 100);\n    \n    context.save();\n    context.fillStyle = \"red\";\n    context.translate(100, 100);\n    context.fillRect(100, 100, 200, 100);\n    context.restore();\n    \n    context.save();\n    context.fillStyle = \"green\";\n    context.translate(200, 200);\n    context.fillRect(100, 100, 200, 100);\n    context.restore();\n};\n```\n\n## 旋转变换\n\n`rotate(deg)`是指图形以坐标系原点为圆心进行顺时针旋转，因此在使用`rotate()`之前可以配合`translate()`来平移坐标系，确定旋转的圆心。\n\n我们用一个例子来看看：\n\n```javascript\n// 画布\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n// 画笔\nvar context = canvas.getContext(\"2d\");\n\nfor (let i = 0; i <= 12; i++) {\n    context.save();\n    context.translate(70 + i * 50, 50 + i * 40);\n    context.fillStyle = \"#00AAAA\";\n    context.fillRect(0, 0, 20, 20);\n    context.restore();\n\n    context.save();\n    context.translate(70 + i * 50, 50 + i * 40);\n    context.rotate(i * 30 * PI / 180); // 这里是弧度，不是角度\n    context.fillStyle = \"red\";\n    context.fillRect(0, 0, 20, 20);\n    context.restore();\n}\n```\n\n## 缩放变换\n\n缩放变换最简单了，分别是在水平方向和垂直方向上对象的缩放倍数。但是缩放会导致坐标位置改变、线条加粗。所以在实际使用过程中能尽量不使用scale函数做缩放变换是最好的。\n\n```javascript\n// 画布\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 800;\ncanvas.height = 600;\n// 画笔\nvar context = canvas.getContext(\"2d\");\n\ncontext.strokeStyle = \"red\";\ncontext.lineWidth = 5;\nfor (let i = 1; i < 4; i++) {\n    context.save();\n    context.scale(i, i);\n    context.strokeRect(50, 50, 150, 100);\n    context.restore();\n}\n```\n\n## 万能的transform函数\n\n前面讲的三种变换函数，使用`transform()`函数就可以做到，\n","slug":"frontend/canvas/canvas-tranverse","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3h002s2y61huimf1vh","content":"<h1 id=\"Canvas变换\"><a href=\"#Canvas变换\" class=\"headerlink\" title=\"Canvas变换\"></a>Canvas变换</h1><h2 id=\"图形变换\"><a href=\"#图形变换\" class=\"headerlink\" title=\"图形变换\"></a>图形变换</h2><p>图形变换无外乎是利用数学方法调整所绘形状的物理属性，实质上是坐标变形。所有的变换都依赖于后台的数学矩阵运算，所以只需要使用即可，无需理会底层原理。</p>\n<ul>\n<li>平移变换：<code>translate(x, y)</code></li>\n<li>旋转变换：<code>rotate(deg)</code></li>\n<li>缩放变换：<code>scale(sx, sy)</code></li>\n</ul>\n<h2 id=\"平移变换\"><a href=\"#平移变换\" class=\"headerlink\" title=\"平移变换\"></a>平移变换</h2><p>顾名思义，就是一般的图形位移。例如我想把位于(100, 100)的矩形平移至(200, 200)点，那么只需要再绘制矩形之前加上<code>context.translate(100, 100)</code>即可，例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br><br>context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br></code></pre></td></tr></table></figure>\n<p>如果想平移到(300, 300)的位置，需要重置参考坐标系的位置，也就是重置到原点，再进行平移，有两种方法：</p>\n<ul>\n<li>绘制下一次平移图形的时候，手动将坐标系换回原点：即：<code>translate(-x, -y)</code>；</li>\n<li>平移前调用<code>context.save()</code>和<code>context.restore()</code>。</li>\n</ul>\n<p>实例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    <br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>    <br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;green&quot;</span>;<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"旋转变换\"><a href=\"#旋转变换\" class=\"headerlink\" title=\"旋转变换\"></a>旋转变换</h2><p><code>rotate(deg)</code>是指图形以坐标系原点为圆心进行顺时针旋转，因此在使用<code>rotate()</code>之前可以配合<code>translate()</code>来平移坐标系，确定旋转的圆心。</p>\n<p>我们用一个例子来看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 画布</span><br><span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><span class=\"hljs-comment\">// 画笔</span><br><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">12</span>; i++) &#123;<br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">70</span> + i * <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span> + i * <span class=\"hljs-number\">40</span>);<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br><br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">70</span> + i * <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span> + i * <span class=\"hljs-number\">40</span>);<br>    context.<span class=\"hljs-title function_\">rotate</span>(i * <span class=\"hljs-number\">30</span> * <span class=\"hljs-variable constant_\">PI</span> / <span class=\"hljs-number\">180</span>); <span class=\"hljs-comment\">// 这里是弧度，不是角度</span><br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"缩放变换\"><a href=\"#缩放变换\" class=\"headerlink\" title=\"缩放变换\"></a>缩放变换</h2><p>缩放变换最简单了，分别是在水平方向和垂直方向上对象的缩放倍数。但是缩放会导致坐标位置改变、线条加粗。所以在实际使用过程中能尽量不使用scale函数做缩放变换是最好的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 画布</span><br><span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><span class=\"hljs-comment\">// 画笔</span><br><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">scale</span>(i, i);<br>    context.<span class=\"hljs-title function_\">strokeRect</span>(<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"万能的transform函数\"><a href=\"#万能的transform函数\" class=\"headerlink\" title=\"万能的transform函数\"></a>万能的transform函数</h2><p>前面讲的三种变换函数，使用<code>transform()</code>函数就可以做到，</p>\n","site":{"data":{}},"wordcount":2307,"excerpt":"","more":"<h1 id=\"Canvas变换\"><a href=\"#Canvas变换\" class=\"headerlink\" title=\"Canvas变换\"></a>Canvas变换</h1><h2 id=\"图形变换\"><a href=\"#图形变换\" class=\"headerlink\" title=\"图形变换\"></a>图形变换</h2><p>图形变换无外乎是利用数学方法调整所绘形状的物理属性，实质上是坐标变形。所有的变换都依赖于后台的数学矩阵运算，所以只需要使用即可，无需理会底层原理。</p>\n<ul>\n<li>平移变换：<code>translate(x, y)</code></li>\n<li>旋转变换：<code>rotate(deg)</code></li>\n<li>缩放变换：<code>scale(sx, sy)</code></li>\n</ul>\n<h2 id=\"平移变换\"><a href=\"#平移变换\" class=\"headerlink\" title=\"平移变换\"></a>平移变换</h2><p>顾名思义，就是一般的图形位移。例如我想把位于(100, 100)的矩形平移至(200, 200)点，那么只需要再绘制矩形之前加上<code>context.translate(100, 100)</code>即可，例子如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><br><span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br><br>context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br></code></pre></td></tr></table></figure>\n<p>如果想平移到(300, 300)的位置，需要重置参考坐标系的位置，也就是重置到原点，再进行平移，有两种方法：</p>\n<ul>\n<li>绘制下一次平移图形的时候，手动将坐标系换回原点：即：<code>translate(-x, -y)</code>；</li>\n<li>平移前调用<code>context.save()</code>和<code>context.restore()</code>。</li>\n</ul>\n<p>实例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>    canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>    canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br>    <br>    <span class=\"hljs-keyword\">let</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br>    <br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    <br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>    <br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;green&quot;</span>;<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">200</span>);<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"旋转变换\"><a href=\"#旋转变换\" class=\"headerlink\" title=\"旋转变换\"></a>旋转变换</h2><p><code>rotate(deg)</code>是指图形以坐标系原点为圆心进行顺时针旋转，因此在使用<code>rotate()</code>之前可以配合<code>translate()</code>来平移坐标系，确定旋转的圆心。</p>\n<p>我们用一个例子来看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 画布</span><br><span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><span class=\"hljs-comment\">// 画笔</span><br><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">12</span>; i++) &#123;<br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">70</span> + i * <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span> + i * <span class=\"hljs-number\">40</span>);<br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;#00AAAA&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br><br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">70</span> + i * <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span> + i * <span class=\"hljs-number\">40</span>);<br>    context.<span class=\"hljs-title function_\">rotate</span>(i * <span class=\"hljs-number\">30</span> * <span class=\"hljs-variable constant_\">PI</span> / <span class=\"hljs-number\">180</span>); <span class=\"hljs-comment\">// 这里是弧度，不是角度</span><br>    context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>    context.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"缩放变换\"><a href=\"#缩放变换\" class=\"headerlink\" title=\"缩放变换\"></a>缩放变换</h2><p>缩放变换最简单了，分别是在水平方向和垂直方向上对象的缩放倍数。但是缩放会导致坐标位置改变、线条加粗。所以在实际使用过程中能尽量不使用scale函数做缩放变换是最好的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 画布</span><br><span class=\"hljs-keyword\">var</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;canvas&quot;</span>);<br>canvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">800</span>;<br>canvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">600</span>;<br><span class=\"hljs-comment\">// 画笔</span><br><span class=\"hljs-keyword\">var</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">&quot;2d&quot;</span>);<br><br>context.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br>context.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>    context.<span class=\"hljs-title function_\">save</span>();<br>    context.<span class=\"hljs-title function_\">scale</span>(i, i);<br>    context.<span class=\"hljs-title function_\">strokeRect</span>(<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">100</span>);<br>    context.<span class=\"hljs-title function_\">restore</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"万能的transform函数\"><a href=\"#万能的transform函数\" class=\"headerlink\" title=\"万能的transform函数\"></a>万能的transform函数</h2><p>前面讲的三种变换函数，使用<code>transform()</code>函数就可以做到，</p>\n"},{"title":"CSS3基础回顾","date":"2022-02-18T12:50:23.000Z","updated":"2022-02-18T12:50:23.000Z","_content":"\n# CSS3 基础回顾\n\n## 简介\n\n全称“层叠样式表”（Cascade Style Sheet），用来修饰HTML元素的外观：包括大小、位置、颜色和形状等等；\n\n## 语法\n\n语法如下：\n\n```css\nselector {\n  property-type: property-value;\n}\n```\n\n简单来说：需要对哪个元素做修饰，首先要选中需要修饰的元素，然后再使用CSS对其作修改。\n\n## 选择器\n\n### 基本\n\n比较常用的选择器有：class选择器和id选择器，除此之外还有一些高级的选择器，在日常使用中我们可以通过查阅文档来了解一些更高级的选择器用法。\n\n- class选择器\n- id选择器\n- nth-child选择器等\n\n一个例子来说明这些选择器的用法：\n\n```css\n.className {\n  width: 200px;\n  height: 150px;\n}\n\n#id-name {\n  width: 200px;\n  height: 150px;\n}\n\n.box:nth-child(2n) {\n  background: #4f5b62;\n}\n```\n\n上面列举了三个选择器的语法：可以看到class选择器的语法是`.className`，id选择器的语法是`#idName`；掌握这两个基本就能满足90%以上的应用场景了；\n\n最后还有一个选择器值得关注：它的语义是：选择className为box并且顺序为偶数序的元素。这属于高级选择器中的其中一个，还有其他的一些可以通过上网查阅来了解；\n\n一般在前端开发中会遵循一个编码规范：就是class选择器专门用来修饰样式；id选择器专门用来编写逻辑；\n\n### 属性选择器\n\n具有特定属性的HTML元素样式不仅仅是class和id，语法如下：\n\n```css\n[title] {\n    color: blue;\n}\n```\n\n举个例子：\n\n```css\ninput[type=\"text\"] {\n    width: 150px;\n    display: block;\n    margin-bottom: 10px;\n    background-color: yellow;\n}\n\ninput[type=\"button\"] {\n    width: 120px;\n    margin-left: 35px;\n    display: block;\n}\n```\n\n### 嵌套和分组\n\n给很多样式相同的元素设置样式，可以使用分组选择器，语法如下：\n\n```css\nh1,\nh2,\np {\n  color: green;\n}\n```\n\n嵌套选择器可以用于选择器内部的样式，有下面几种实践：\n\n- `p{}`：为所有p元素指定一个样式；\n- `.marked {}`：为所有`class=\"marked\"`的元素设置样式；\n- `.marked p {}`为所有`class=\"marked\"`元素内部的`p`元素设置样式；\n- `p.marked {}`为所有`p`元素内部`class=\"marked\"`的元素设置样式；\n\n## 盒子模型\n\n所有的HTML元素都可以看作是盒子，在CSS中，“box model”是用来设计和布局使用的；\n\n一个盒子有下列几部分构成：\n\n- 外边距(margin)：清除边框外的区域，外边距是透明的；\n- 边框(border)：围绕在内边距和内容外的边框，这部分是可以看见的；\n- 内边距(padding)：清除内容周围的区域，内边距是透明的；\n- 内容(content)：盒子的内容，显示文本和图像；\n\n所以你需要知道：给一个元素设置宽高的时候要加上它的外边距、边框、内边距的宽高，这样才是一个元素的宽高；\n\n盒子模型可以通过浏览器的开发者工具看到，如果需要检视页面上的HTML元素，你可以通过查看元素在控制台的信息来查看它的边距情况。\n\n总结一下：最终元素的总宽高计算公式是这样的；\n\n- 总元素的宽度：宽度 + 左右填充 + 左右边框 + 左右边距；\n- 总元素的高度：高度 + 上下填充 + 上下边框 + 上下边距；\n\n## 样式设置\n\n### 颜色\n\n可以给字体，盒子设置颜色，下面举一部分例子：\n\n- 盒子背景：`background-color`，背景有一个简写的属性叫`background`;\n- 字体颜色：`font-color`，同样地，字体也有一个简写属性叫`font`;\n- 边框：边框使用`border`属性也可以给其上色，具体语法可以查阅相关文档；\n- 还有一个CSS属性叫`color`，这个是给文本设置颜色的；\n\n### 字体\n\n字体是HTML中的重要显示元素，CSS中字体的设置有下列几个：\n\n- font：all in one属性，可以设置字体的所有属性\n- font-family：字体\n- font-size：字体大小\n- font-style：字体样式，粗体和斜体之类的\n- font-variant：以小型大写字体或者正常字体显示文本；\n- font-weight：指定字体的粗细；\n\n介绍一下all-on-one属性的语法：\n\n```css\nfont: \"<font-style> <font-variant> <font-weight> <font-size> / <line-height> <font-family>\"\n```\n\n### All-in-one 属性语法\n\n#### 外边距（margin）\n\n语法：\n\n```css\nh1 {\n  marign: 15px 30px 15px 30px; // 次序分别为上、右、下、左\n}\n\nh1 {\n  margin: 15px 30px 15px; // 次序分别为上，左右，下\n}\n\nh1 {\n  margin: 15px 30px; // 上下，左右\n}\n\nh1 {\n  margin: 15px; //上下左右全都一样\n}\n```\n\n#### 填充（padding）\n\n语法：\n\n```css\nh1 {\n  padding: 15px 30px 15px 30px; // 次序分别为上、右、下、左\n}\n\nh1 {\n  padidng: 15px 30px 15px; // 次序为上，左右，下\n}\n\nh1 {\n  padding: 15px; 30px; // 上下，左右\n}\n\nh1 {\n  padding: 25px; // 上下左右全都一样\n}\n```\n\n\n\n## 显示\n\ndisplay设置一个元素该如何在页面上显示，visibility属性指定一个元素应可见还是隐藏；\n\n#### 隐藏元素\n\n这里提供两种方法：\n\n- `display: none`：除了会隐藏，还会清除元素原本占用的页面空间；\n- `visibility: hidden`：虽然也能隐藏，但是并不会清除元素原本占用的页面空间；\n\n#### 块级元素和内联元素\n\n需要注意的是：块级元素默认占用一行，元素在页面上垂直排列；可以设置宽度和高度；\n\n内联元素则相反：其大小由内容决定，只有填满了一行才会在换行继续，默认情况下不能设置宽和高；但是可以设置边距和填充并且只在水平方向有效；\n\n了解了上面的知识以后，我们就会知道，使用display方法可以改变元素的显示方式是以块级来显示还是以内联方式来显示。相应的属性如下：\n\n- block\n- inline\n\n举个例子：加入你想给`<span>`设置元素宽高，但由于其为内联元素，无法设置宽高；这个时候你可以使用display属性为其设置显示模式为`block`，然后就可以给`<span>`设置宽高了；\n\n## 定位\n\n定位属性叫`position`，其指定了元素的定位类型，属性有5个值；\n\n- static：默认设置，没有定位，遵循正常的文档流（即从上到下，从左到右）\n- relative：相对定位元素的定位是相对其正常位置\n- fixed：元素的位置相对于浏览器窗口是固定的\n- absolute：相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于`html`；\n- stickly：基于用户的滚动位置来定位；\n\n除此之外，还有一个元素叫做`z-index`，其指定了一个元素的堆叠顺序（哪个元素该放在前面，哪个元素该放在后面），一个元素可以有正数和负数的堆叠顺序；\n\n## 溢出\n\nCSS overflow属性用于控制内容溢出元素框时的显示方式，有下面5个属性值；\n\n- visible：默认值，内容不会被裁剪，会显示在元素框之外\n- hidden：内容会被裁剪，并且其余部分的内容是不可见的；\n- scroll：内容会被裁剪，但是浏览器会显示滚动条以便于查看其余内容\n- auto：如果内容被裁剪，浏览器会显示滚动条以便于查看其余内容\n- inherit：规定应该从父元素继承overflow属性的值\n\n## 浮动\n\n浮动的框可以向左或者向右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档流的普通流中，所以文档的普通流中的浮动框之后的块框表现地像浮动框不存在一样。\n\n需要注意的是：当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，因此float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。\n\n于是在浮动布局中会存在下面这个现象：\n\n- 如果元素A是浮动元素并且其上一个元素也是浮动元素，那么A元素就会跟随在上一个元素的后边；（如果一行放不下就会挤到下一行）\n- 如果元素A是浮动元素，但是其上一个元素是标准流元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐；\n- 浮动框之后的block元素会认为这个框不存在，但其中的文本依然会认为这个元素让出位置。浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列；\n\n使用浮动的原则如下：\n\n要么都使用浮动，要么都不使用浮动；要么对没使用浮动的DIV设置margin样式；\n\n## 清除浮动\n\n在非IE浏览器的环境下，当容器高度为auto，且容器内容有浮动的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至是破坏）布局的现象。这个现象就叫做浮动溢出，为了防止这个现象出现而进行的CSS处理，就叫做CSS清除浮动。\n\n引用W3C的一个例子来解释浮动溢出：\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news: {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n        </style>\n    </head>\n    <!--虽然从HTML上看news是包裹着图片和文字的-->\n    <div class=\"news\">\n        <!--实际上由于浮动元素不占据空间，所以news的高度直接塌陷了-->\n        <img src=\"news-pic.jpg\"/>\n\t    <p>some text</p>\n    </div>\n</html>\n```\n\n既然出现了元素的“高度塌陷”，那么可以使用清除浮动的方法来解决这个问题：\n\n**方法1：在浮动元素后使用一个空元素，并在CSS中赋予`.clear {clear: both}`属性即可清除浮动；例如：**\n\n```html\n<html>\n    <head>\n    </head>\n    \n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some Text</p>\n            <div class=\"clear\"/>\n        </div>\n    </body>\n</html>\n```\n\n优点：简单、代码少，浏览器兼容性好；\n\n缺点：需要添加大量无语义的html元素，代码不够优雅，后期也不容易维护；\n\n\n\n**方法2：使用CSS的overflow属性（BFC机制）**\n\n给浮动元素的容器添加`overflow: hidden`或者`overflow: auto`可以清除浮动，在添加了相关属性后，浮动元素又回到了容器层，把容器高度撑起，达到清除浮动的效果。\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n                overflow: hidden;\n                /* 触发IE6 / IE7的haslayout机制 */\n                *zoom: 1;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n        </style>\n    </head>\n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>some text</p>\n        </div>\n    </body>\n</html>\n```\n\n\n\n**方法3：给浮动元素的容器添加浮动**\n\n给浮动元素的容器添加浮动属性即可清除内部浮动，但是这样做会使其整体浮动，影响布局，不推荐使用；\n\n\n\n**方法4：使用邻接元素处理**\n\n什么都不做，给浮动元素后面的元素添加clear属性；\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n            \n            .content {\n                clear: both;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some text</p>\n            <div class=\"content\"></div>\n        </div>\n    </body>\n</html>\n```\n\n\n\n**方法5：使用CSS的:after伪元素**\n\n给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个`:after`伪元素实现方法1的那种效果。此方法兼容性好；推荐这种方法；\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n            \n            .clearfix:after {\n                content: \"020\";\n                display: block;\n                height: 0;\n                clear: both;\n                visibility: hidden;\n            }\n            \n            .clearfix {\n                /* 触发 IE6/IE7的haslayout机制 */\n                zoom: 1;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"news clearfix\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some text</p>\n        </div>\n    </body>\n</html>\n```\n\n## 伪类\n\nCSS伪类是用来添加一些选择器的特殊效果，语法如下：\n\n```css\n/* 基础语法 */\nselector:pseudo-class { property: value; }\n\n/* CSS类选择器 */\nselector.class:pseudo-class { property: value; }\n```\n\n### anchor伪类\n\n链接的不同状态都可以以不同的方式显示，例如：\n\n- `a:link`：未访问的链接\n- `a:visited`：已访问的链接\n- `a:hover`：鼠标划过的链接\n- `a:active`：已选中的链接\n\n### CSS伪元素\n\nCSS伪元素用来添加一些选择器的特殊效果，语法如下：\n\n```CSS\n/* 伪元素语法 */\nselector:pseudo-element { property: value; }\n\n/* CSS类也可以使用伪元素 */\nselector.class:pseudo-element { property: value; }\n```\n\n下面列举一些伪元素的使用：\n\n- `:first-line`：用于向文本的首行设置特殊样式；\n- `:first-letter`：用于向文本的首字母设置特殊样式；\n- `:before`：可以在元素的内容前插入新内容；\n- `:after`：可以在元素的内容后插入新内容；\n","source":"_posts/frontend/css3/css3-ch01.md","raw":"---\ntitle: CSS3基础回顾\ndate: 2022-02-18 20:50:23\nupdated: 2022-02-18 20:50:23\ntags: CSS3\ncategories: 前端\n---\n\n# CSS3 基础回顾\n\n## 简介\n\n全称“层叠样式表”（Cascade Style Sheet），用来修饰HTML元素的外观：包括大小、位置、颜色和形状等等；\n\n## 语法\n\n语法如下：\n\n```css\nselector {\n  property-type: property-value;\n}\n```\n\n简单来说：需要对哪个元素做修饰，首先要选中需要修饰的元素，然后再使用CSS对其作修改。\n\n## 选择器\n\n### 基本\n\n比较常用的选择器有：class选择器和id选择器，除此之外还有一些高级的选择器，在日常使用中我们可以通过查阅文档来了解一些更高级的选择器用法。\n\n- class选择器\n- id选择器\n- nth-child选择器等\n\n一个例子来说明这些选择器的用法：\n\n```css\n.className {\n  width: 200px;\n  height: 150px;\n}\n\n#id-name {\n  width: 200px;\n  height: 150px;\n}\n\n.box:nth-child(2n) {\n  background: #4f5b62;\n}\n```\n\n上面列举了三个选择器的语法：可以看到class选择器的语法是`.className`，id选择器的语法是`#idName`；掌握这两个基本就能满足90%以上的应用场景了；\n\n最后还有一个选择器值得关注：它的语义是：选择className为box并且顺序为偶数序的元素。这属于高级选择器中的其中一个，还有其他的一些可以通过上网查阅来了解；\n\n一般在前端开发中会遵循一个编码规范：就是class选择器专门用来修饰样式；id选择器专门用来编写逻辑；\n\n### 属性选择器\n\n具有特定属性的HTML元素样式不仅仅是class和id，语法如下：\n\n```css\n[title] {\n    color: blue;\n}\n```\n\n举个例子：\n\n```css\ninput[type=\"text\"] {\n    width: 150px;\n    display: block;\n    margin-bottom: 10px;\n    background-color: yellow;\n}\n\ninput[type=\"button\"] {\n    width: 120px;\n    margin-left: 35px;\n    display: block;\n}\n```\n\n### 嵌套和分组\n\n给很多样式相同的元素设置样式，可以使用分组选择器，语法如下：\n\n```css\nh1,\nh2,\np {\n  color: green;\n}\n```\n\n嵌套选择器可以用于选择器内部的样式，有下面几种实践：\n\n- `p{}`：为所有p元素指定一个样式；\n- `.marked {}`：为所有`class=\"marked\"`的元素设置样式；\n- `.marked p {}`为所有`class=\"marked\"`元素内部的`p`元素设置样式；\n- `p.marked {}`为所有`p`元素内部`class=\"marked\"`的元素设置样式；\n\n## 盒子模型\n\n所有的HTML元素都可以看作是盒子，在CSS中，“box model”是用来设计和布局使用的；\n\n一个盒子有下列几部分构成：\n\n- 外边距(margin)：清除边框外的区域，外边距是透明的；\n- 边框(border)：围绕在内边距和内容外的边框，这部分是可以看见的；\n- 内边距(padding)：清除内容周围的区域，内边距是透明的；\n- 内容(content)：盒子的内容，显示文本和图像；\n\n所以你需要知道：给一个元素设置宽高的时候要加上它的外边距、边框、内边距的宽高，这样才是一个元素的宽高；\n\n盒子模型可以通过浏览器的开发者工具看到，如果需要检视页面上的HTML元素，你可以通过查看元素在控制台的信息来查看它的边距情况。\n\n总结一下：最终元素的总宽高计算公式是这样的；\n\n- 总元素的宽度：宽度 + 左右填充 + 左右边框 + 左右边距；\n- 总元素的高度：高度 + 上下填充 + 上下边框 + 上下边距；\n\n## 样式设置\n\n### 颜色\n\n可以给字体，盒子设置颜色，下面举一部分例子：\n\n- 盒子背景：`background-color`，背景有一个简写的属性叫`background`;\n- 字体颜色：`font-color`，同样地，字体也有一个简写属性叫`font`;\n- 边框：边框使用`border`属性也可以给其上色，具体语法可以查阅相关文档；\n- 还有一个CSS属性叫`color`，这个是给文本设置颜色的；\n\n### 字体\n\n字体是HTML中的重要显示元素，CSS中字体的设置有下列几个：\n\n- font：all in one属性，可以设置字体的所有属性\n- font-family：字体\n- font-size：字体大小\n- font-style：字体样式，粗体和斜体之类的\n- font-variant：以小型大写字体或者正常字体显示文本；\n- font-weight：指定字体的粗细；\n\n介绍一下all-on-one属性的语法：\n\n```css\nfont: \"<font-style> <font-variant> <font-weight> <font-size> / <line-height> <font-family>\"\n```\n\n### All-in-one 属性语法\n\n#### 外边距（margin）\n\n语法：\n\n```css\nh1 {\n  marign: 15px 30px 15px 30px; // 次序分别为上、右、下、左\n}\n\nh1 {\n  margin: 15px 30px 15px; // 次序分别为上，左右，下\n}\n\nh1 {\n  margin: 15px 30px; // 上下，左右\n}\n\nh1 {\n  margin: 15px; //上下左右全都一样\n}\n```\n\n#### 填充（padding）\n\n语法：\n\n```css\nh1 {\n  padding: 15px 30px 15px 30px; // 次序分别为上、右、下、左\n}\n\nh1 {\n  padidng: 15px 30px 15px; // 次序为上，左右，下\n}\n\nh1 {\n  padding: 15px; 30px; // 上下，左右\n}\n\nh1 {\n  padding: 25px; // 上下左右全都一样\n}\n```\n\n\n\n## 显示\n\ndisplay设置一个元素该如何在页面上显示，visibility属性指定一个元素应可见还是隐藏；\n\n#### 隐藏元素\n\n这里提供两种方法：\n\n- `display: none`：除了会隐藏，还会清除元素原本占用的页面空间；\n- `visibility: hidden`：虽然也能隐藏，但是并不会清除元素原本占用的页面空间；\n\n#### 块级元素和内联元素\n\n需要注意的是：块级元素默认占用一行，元素在页面上垂直排列；可以设置宽度和高度；\n\n内联元素则相反：其大小由内容决定，只有填满了一行才会在换行继续，默认情况下不能设置宽和高；但是可以设置边距和填充并且只在水平方向有效；\n\n了解了上面的知识以后，我们就会知道，使用display方法可以改变元素的显示方式是以块级来显示还是以内联方式来显示。相应的属性如下：\n\n- block\n- inline\n\n举个例子：加入你想给`<span>`设置元素宽高，但由于其为内联元素，无法设置宽高；这个时候你可以使用display属性为其设置显示模式为`block`，然后就可以给`<span>`设置宽高了；\n\n## 定位\n\n定位属性叫`position`，其指定了元素的定位类型，属性有5个值；\n\n- static：默认设置，没有定位，遵循正常的文档流（即从上到下，从左到右）\n- relative：相对定位元素的定位是相对其正常位置\n- fixed：元素的位置相对于浏览器窗口是固定的\n- absolute：相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于`html`；\n- stickly：基于用户的滚动位置来定位；\n\n除此之外，还有一个元素叫做`z-index`，其指定了一个元素的堆叠顺序（哪个元素该放在前面，哪个元素该放在后面），一个元素可以有正数和负数的堆叠顺序；\n\n## 溢出\n\nCSS overflow属性用于控制内容溢出元素框时的显示方式，有下面5个属性值；\n\n- visible：默认值，内容不会被裁剪，会显示在元素框之外\n- hidden：内容会被裁剪，并且其余部分的内容是不可见的；\n- scroll：内容会被裁剪，但是浏览器会显示滚动条以便于查看其余内容\n- auto：如果内容被裁剪，浏览器会显示滚动条以便于查看其余内容\n- inherit：规定应该从父元素继承overflow属性的值\n\n## 浮动\n\n浮动的框可以向左或者向右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档流的普通流中，所以文档的普通流中的浮动框之后的块框表现地像浮动框不存在一样。\n\n需要注意的是：当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，因此float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。\n\n于是在浮动布局中会存在下面这个现象：\n\n- 如果元素A是浮动元素并且其上一个元素也是浮动元素，那么A元素就会跟随在上一个元素的后边；（如果一行放不下就会挤到下一行）\n- 如果元素A是浮动元素，但是其上一个元素是标准流元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐；\n- 浮动框之后的block元素会认为这个框不存在，但其中的文本依然会认为这个元素让出位置。浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列；\n\n使用浮动的原则如下：\n\n要么都使用浮动，要么都不使用浮动；要么对没使用浮动的DIV设置margin样式；\n\n## 清除浮动\n\n在非IE浏览器的环境下，当容器高度为auto，且容器内容有浮动的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至是破坏）布局的现象。这个现象就叫做浮动溢出，为了防止这个现象出现而进行的CSS处理，就叫做CSS清除浮动。\n\n引用W3C的一个例子来解释浮动溢出：\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news: {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n        </style>\n    </head>\n    <!--虽然从HTML上看news是包裹着图片和文字的-->\n    <div class=\"news\">\n        <!--实际上由于浮动元素不占据空间，所以news的高度直接塌陷了-->\n        <img src=\"news-pic.jpg\"/>\n\t    <p>some text</p>\n    </div>\n</html>\n```\n\n既然出现了元素的“高度塌陷”，那么可以使用清除浮动的方法来解决这个问题：\n\n**方法1：在浮动元素后使用一个空元素，并在CSS中赋予`.clear {clear: both}`属性即可清除浮动；例如：**\n\n```html\n<html>\n    <head>\n    </head>\n    \n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some Text</p>\n            <div class=\"clear\"/>\n        </div>\n    </body>\n</html>\n```\n\n优点：简单、代码少，浏览器兼容性好；\n\n缺点：需要添加大量无语义的html元素，代码不够优雅，后期也不容易维护；\n\n\n\n**方法2：使用CSS的overflow属性（BFC机制）**\n\n给浮动元素的容器添加`overflow: hidden`或者`overflow: auto`可以清除浮动，在添加了相关属性后，浮动元素又回到了容器层，把容器高度撑起，达到清除浮动的效果。\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n                overflow: hidden;\n                /* 触发IE6 / IE7的haslayout机制 */\n                *zoom: 1;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n        </style>\n    </head>\n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>some text</p>\n        </div>\n    </body>\n</html>\n```\n\n\n\n**方法3：给浮动元素的容器添加浮动**\n\n给浮动元素的容器添加浮动属性即可清除内部浮动，但是这样做会使其整体浮动，影响布局，不推荐使用；\n\n\n\n**方法4：使用邻接元素处理**\n\n什么都不做，给浮动元素后面的元素添加clear属性；\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n            \n            .content {\n                clear: both;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"news\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some text</p>\n            <div class=\"content\"></div>\n        </div>\n    </body>\n</html>\n```\n\n\n\n**方法5：使用CSS的:after伪元素**\n\n给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个`:after`伪元素实现方法1的那种效果。此方法兼容性好；推荐这种方法；\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .news {\n                background-color: gray;\n                border: 1px solid black;\n            }\n            \n            .news img {\n                float: left;\n            }\n            \n            .news p {\n                float: right;\n            }\n            \n            .clearfix:after {\n                content: \"020\";\n                display: block;\n                height: 0;\n                clear: both;\n                visibility: hidden;\n            }\n            \n            .clearfix {\n                /* 触发 IE6/IE7的haslayout机制 */\n                zoom: 1;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"news clearfix\">\n            <img src=\"news-pic.jpg\"/>\n            <p>Some text</p>\n        </div>\n    </body>\n</html>\n```\n\n## 伪类\n\nCSS伪类是用来添加一些选择器的特殊效果，语法如下：\n\n```css\n/* 基础语法 */\nselector:pseudo-class { property: value; }\n\n/* CSS类选择器 */\nselector.class:pseudo-class { property: value; }\n```\n\n### anchor伪类\n\n链接的不同状态都可以以不同的方式显示，例如：\n\n- `a:link`：未访问的链接\n- `a:visited`：已访问的链接\n- `a:hover`：鼠标划过的链接\n- `a:active`：已选中的链接\n\n### CSS伪元素\n\nCSS伪元素用来添加一些选择器的特殊效果，语法如下：\n\n```CSS\n/* 伪元素语法 */\nselector:pseudo-element { property: value; }\n\n/* CSS类也可以使用伪元素 */\nselector.class:pseudo-element { property: value; }\n```\n\n下面列举一些伪元素的使用：\n\n- `:first-line`：用于向文本的首行设置特殊样式；\n- `:first-letter`：用于向文本的首字母设置特殊样式；\n- `:before`：可以在元素的内容前插入新内容；\n- `:after`：可以在元素的内容后插入新内容；\n","slug":"frontend/css3/css3-ch01","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3i002x2y6131wbc186","content":"<h1 id=\"CSS3-基础回顾\"><a href=\"#CSS3-基础回顾\" class=\"headerlink\" title=\"CSS3 基础回顾\"></a>CSS3 基础回顾</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>全称“层叠样式表”（Cascade Style Sheet），用来修饰HTML元素的外观：包括大小、位置、颜色和形状等等；</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs css\">selector &#123;<br>  property-type: property-value;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>简单来说：需要对哪个元素做修饰，首先要选中需要修饰的元素，然后再使用CSS对其作修改。</p>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><h3 id=\"基本\"><a href=\"#基本\" class=\"headerlink\" title=\"基本\"></a>基本</h3><p>比较常用的选择器有：class选择器和id选择器，除此之外还有一些高级的选择器，在日常使用中我们可以通过查阅文档来了解一些更高级的选择器用法。</p>\n<ul>\n<li>class选择器</li>\n<li>id选择器</li>\n<li>nth-child选择器等</li>\n</ul>\n<p>一个例子来说明这些选择器的用法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.className</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#id-name</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.box</span><span class=\"hljs-selector-pseudo\">:nth-child</span>(<span class=\"hljs-number\">2</span>n) &#123;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#4f5b62</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面列举了三个选择器的语法：可以看到class选择器的语法是<code>.className</code>，id选择器的语法是<code>#idName</code>；掌握这两个基本就能满足90%以上的应用场景了；</p>\n<p>最后还有一个选择器值得关注：它的语义是：选择className为box并且顺序为偶数序的元素。这属于高级选择器中的其中一个，还有其他的一些可以通过上网查阅来了解；</p>\n<p>一般在前端开发中会遵循一个编码规范：就是class选择器专门用来修饰样式；id选择器专门用来编写逻辑；</p>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>具有特定属性的HTML元素样式不仅仅是class和id，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[title]</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-attr\">[type=<span class=\"hljs-string\">&quot;text&quot;</span>]</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">10px</span>;<br>    <span class=\"hljs-attribute\">background-color</span>: yellow;<br>&#125;<br><br><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-attr\">[type=<span class=\"hljs-string\">&quot;button&quot;</span>]</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">120px</span>;<br>    <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">35px</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"嵌套和分组\"><a href=\"#嵌套和分组\" class=\"headerlink\" title=\"嵌套和分组\"></a>嵌套和分组</h3><p>给很多样式相同的元素设置样式，可以使用分组选择器，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span>,<br><span class=\"hljs-selector-tag\">h2</span>,<br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>嵌套选择器可以用于选择器内部的样式，有下面几种实践：</p>\n<ul>\n<li><code>p&#123;&#125;</code>：为所有p元素指定一个样式；</li>\n<li><code>.marked &#123;&#125;</code>：为所有<code>class=&quot;marked&quot;</code>的元素设置样式；</li>\n<li><code>.marked p &#123;&#125;</code>为所有<code>class=&quot;marked&quot;</code>元素内部的<code>p</code>元素设置样式；</li>\n<li><code>p.marked &#123;&#125;</code>为所有<code>p</code>元素内部<code>class=&quot;marked&quot;</code>的元素设置样式；</li>\n</ul>\n<h2 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h2><p>所有的HTML元素都可以看作是盒子，在CSS中，“box model”是用来设计和布局使用的；</p>\n<p>一个盒子有下列几部分构成：</p>\n<ul>\n<li>外边距(margin)：清除边框外的区域，外边距是透明的；</li>\n<li>边框(border)：围绕在内边距和内容外的边框，这部分是可以看见的；</li>\n<li>内边距(padding)：清除内容周围的区域，内边距是透明的；</li>\n<li>内容(content)：盒子的内容，显示文本和图像；</li>\n</ul>\n<p>所以你需要知道：给一个元素设置宽高的时候要加上它的外边距、边框、内边距的宽高，这样才是一个元素的宽高；</p>\n<p>盒子模型可以通过浏览器的开发者工具看到，如果需要检视页面上的HTML元素，你可以通过查看元素在控制台的信息来查看它的边距情况。</p>\n<p>总结一下：最终元素的总宽高计算公式是这样的；</p>\n<ul>\n<li>总元素的宽度：宽度 + 左右填充 + 左右边框 + 左右边距；</li>\n<li>总元素的高度：高度 + 上下填充 + 上下边框 + 上下边距；</li>\n</ul>\n<h2 id=\"样式设置\"><a href=\"#样式设置\" class=\"headerlink\" title=\"样式设置\"></a>样式设置</h2><h3 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h3><p>可以给字体，盒子设置颜色，下面举一部分例子：</p>\n<ul>\n<li>盒子背景：<code>background-color</code>，背景有一个简写的属性叫<code>background</code>;</li>\n<li>字体颜色：<code>font-color</code>，同样地，字体也有一个简写属性叫<code>font</code>;</li>\n<li>边框：边框使用<code>border</code>属性也可以给其上色，具体语法可以查阅相关文档；</li>\n<li>还有一个CSS属性叫<code>color</code>，这个是给文本设置颜色的；</li>\n</ul>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><p>字体是HTML中的重要显示元素，CSS中字体的设置有下列几个：</p>\n<ul>\n<li>font：all in one属性，可以设置字体的所有属性</li>\n<li>font-family：字体</li>\n<li>font-size：字体大小</li>\n<li>font-style：字体样式，粗体和斜体之类的</li>\n<li>font-variant：以小型大写字体或者正常字体显示文本；</li>\n<li>font-weight：指定字体的粗细；</li>\n</ul>\n<p>介绍一下all-on-one属性的语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">font</span>: <span class=\"hljs-string\">&quot;&lt;font-style&gt; &lt;font-variant&gt; &lt;font-weight&gt; &lt;font-size&gt; / &lt;line-height&gt; &lt;font-family&gt;&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"All-in-one-属性语法\"><a href=\"#All-in-one-属性语法\" class=\"headerlink\" title=\"All-in-one 属性语法\"></a>All-in-one 属性语法</h3><h4 id=\"外边距（margin）\"><a href=\"#外边距（margin）\" class=\"headerlink\" title=\"外边距（margin）\"></a>外边距（margin）</h4><p>语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  marign: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 次序分别为上、右、下、左<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span>; // 次序分别为上，左右，下<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 上下，左右<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span>; //上下左右全都一样<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"填充（padding）\"><a href=\"#填充（padding）\" class=\"headerlink\" title=\"填充（padding）\"></a>填充（padding）</h4><p>语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 次序分别为上、右、下、左<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  padidng: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span>; // 次序为上，左右，下<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span>; <span class=\"hljs-number\">30px</span>; // 上下，左右<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">25px</span>; // 上下左右全都一样<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"显示\"><a href=\"#显示\" class=\"headerlink\" title=\"显示\"></a>显示</h2><p>display设置一个元素该如何在页面上显示，visibility属性指定一个元素应可见还是隐藏；</p>\n<h4 id=\"隐藏元素\"><a href=\"#隐藏元素\" class=\"headerlink\" title=\"隐藏元素\"></a>隐藏元素</h4><p>这里提供两种方法：</p>\n<ul>\n<li><code>display: none</code>：除了会隐藏，还会清除元素原本占用的页面空间；</li>\n<li><code>visibility: hidden</code>：虽然也能隐藏，但是并不会清除元素原本占用的页面空间；</li>\n</ul>\n<h4 id=\"块级元素和内联元素\"><a href=\"#块级元素和内联元素\" class=\"headerlink\" title=\"块级元素和内联元素\"></a>块级元素和内联元素</h4><p>需要注意的是：块级元素默认占用一行，元素在页面上垂直排列；可以设置宽度和高度；</p>\n<p>内联元素则相反：其大小由内容决定，只有填满了一行才会在换行继续，默认情况下不能设置宽和高；但是可以设置边距和填充并且只在水平方向有效；</p>\n<p>了解了上面的知识以后，我们就会知道，使用display方法可以改变元素的显示方式是以块级来显示还是以内联方式来显示。相应的属性如下：</p>\n<ul>\n<li>block</li>\n<li>inline</li>\n</ul>\n<p>举个例子：加入你想给<code>&lt;span&gt;</code>设置元素宽高，但由于其为内联元素，无法设置宽高；这个时候你可以使用display属性为其设置显示模式为<code>block</code>，然后就可以给<code>&lt;span&gt;</code>设置宽高了；</p>\n<h2 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h2><p>定位属性叫<code>position</code>，其指定了元素的定位类型，属性有5个值；</p>\n<ul>\n<li>static：默认设置，没有定位，遵循正常的文档流（即从上到下，从左到右）</li>\n<li>relative：相对定位元素的定位是相对其正常位置</li>\n<li>fixed：元素的位置相对于浏览器窗口是固定的</li>\n<li>absolute：相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>html</code>；</li>\n<li>stickly：基于用户的滚动位置来定位；</li>\n</ul>\n<p>除此之外，还有一个元素叫做<code>z-index</code>，其指定了一个元素的堆叠顺序（哪个元素该放在前面，哪个元素该放在后面），一个元素可以有正数和负数的堆叠顺序；</p>\n<h2 id=\"溢出\"><a href=\"#溢出\" class=\"headerlink\" title=\"溢出\"></a>溢出</h2><p>CSS overflow属性用于控制内容溢出元素框时的显示方式，有下面5个属性值；</p>\n<ul>\n<li>visible：默认值，内容不会被裁剪，会显示在元素框之外</li>\n<li>hidden：内容会被裁剪，并且其余部分的内容是不可见的；</li>\n<li>scroll：内容会被裁剪，但是浏览器会显示滚动条以便于查看其余内容</li>\n<li>auto：如果内容被裁剪，浏览器会显示滚动条以便于查看其余内容</li>\n<li>inherit：规定应该从父元素继承overflow属性的值</li>\n</ul>\n<h2 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h2><p>浮动的框可以向左或者向右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档流的普通流中，所以文档的普通流中的浮动框之后的块框表现地像浮动框不存在一样。</p>\n<p>需要注意的是：当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，因此float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。</p>\n<p>于是在浮动布局中会存在下面这个现象：</p>\n<ul>\n<li>如果元素A是浮动元素并且其上一个元素也是浮动元素，那么A元素就会跟随在上一个元素的后边；（如果一行放不下就会挤到下一行）</li>\n<li>如果元素A是浮动元素，但是其上一个元素是标准流元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐；</li>\n<li>浮动框之后的block元素会认为这个框不存在，但其中的文本依然会认为这个元素让出位置。浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列；</li>\n</ul>\n<p>使用浮动的原则如下：</p>\n<p>要么都使用浮动，要么都不使用浮动；要么对没使用浮动的DIV设置margin样式；</p>\n<h2 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h2><p>在非IE浏览器的环境下，当容器高度为auto，且容器内容有浮动的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至是破坏）布局的现象。这个现象就叫做浮动溢出，为了防止这个现象出现而进行的CSS处理，就叫做CSS清除浮动。</p>\n<p>引用W3C的一个例子来解释浮动溢出：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span>: &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!--虽然从HTML上看news是包裹着图片和文字的--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!--实际上由于浮动元素不占据空间，所以news的高度直接塌陷了--&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>\t    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>既然出现了元素的“高度塌陷”，那么可以使用清除浮动的方法来解决这个问题：</p>\n<p><strong>方法1：在浮动元素后使用一个空元素，并在CSS中赋予<code>.clear &#123;clear: both&#125;</code>属性即可清除浮动；例如：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some Text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clear&quot;</span>/&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>优点：简单、代码少，浏览器兼容性好；</p>\n<p>缺点：需要添加大量无语义的html元素，代码不够优雅，后期也不容易维护；</p>\n<p><strong>方法2：使用CSS的overflow属性（BFC机制）</strong></p>\n<p>给浮动元素的容器添加<code>overflow: hidden</code>或者<code>overflow: auto</code>可以清除浮动，在添加了相关属性后，浮动元素又回到了容器层，把容器高度撑起，达到清除浮动的效果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">overflow</span>: hidden;</span><br><span class=\"language-css\">                <span class=\"hljs-comment\">/* 触发IE6 / IE7的haslayout机制 */</span></span><br><span class=\"language-css\">                *zoom: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>方法3：给浮动元素的容器添加浮动</strong></p>\n<p>给浮动元素的容器添加浮动属性即可清除内部浮动，但是这样做会使其整体浮动，影响布局，不推荐使用；</p>\n<p><strong>方法4：使用邻接元素处理</strong></p>\n<p>什么都不做，给浮动元素后面的元素添加clear属性；</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.content</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">clear</span>: both;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>方法5：使用CSS的:after伪元素</strong></p>\n<p>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个<code>:after</code>伪元素实现方法1的那种效果。此方法兼容性好；推荐这种方法；</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.clearfix</span><span class=\"hljs-selector-pseudo\">:after</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;020&quot;</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">display</span>: block;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">clear</span>: both;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">visibility</span>: hidden;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.clearfix</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-comment\">/* 触发 IE6/IE7的haslayout机制 */</span></span><br><span class=\"language-css\">                zoom: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news clearfix&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"伪类\"><a href=\"#伪类\" class=\"headerlink\" title=\"伪类\"></a>伪类</h2><p>CSS伪类是用来添加一些选择器的特殊效果，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 基础语法 */</span><br>selector:pseudo-class &#123; property: value; &#125;<br><br><span class=\"hljs-comment\">/* CSS类选择器 */</span><br>selector<span class=\"hljs-selector-class\">.class</span>:pseudo-class &#123; property: value; &#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"anchor伪类\"><a href=\"#anchor伪类\" class=\"headerlink\" title=\"anchor伪类\"></a>anchor伪类</h3><p>链接的不同状态都可以以不同的方式显示，例如：</p>\n<ul>\n<li><code>a:link</code>：未访问的链接</li>\n<li><code>a:visited</code>：已访问的链接</li>\n<li><code>a:hover</code>：鼠标划过的链接</li>\n<li><code>a:active</code>：已选中的链接</li>\n</ul>\n<h3 id=\"CSS伪元素\"><a href=\"#CSS伪元素\" class=\"headerlink\" title=\"CSS伪元素\"></a>CSS伪元素</h3><p>CSS伪元素用来添加一些选择器的特殊效果，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs CSS\"><span class=\"hljs-comment\">/* 伪元素语法 */</span><br>selector:pseudo-element &#123; property: value; &#125;<br><br><span class=\"hljs-comment\">/* CSS类也可以使用伪元素 */</span><br>selector<span class=\"hljs-selector-class\">.class</span>:pseudo-element &#123; property: value; &#125;<br></code></pre></td></tr></table></figure>\n<p>下面列举一些伪元素的使用：</p>\n<ul>\n<li><code>:first-line</code>：用于向文本的首行设置特殊样式；</li>\n<li><code>:first-letter</code>：用于向文本的首字母设置特殊样式；</li>\n<li><code>:before</code>：可以在元素的内容前插入新内容；</li>\n<li><code>:after</code>：可以在元素的内容后插入新内容；</li>\n</ul>\n","site":{"data":{}},"wordcount":7273,"excerpt":"","more":"<h1 id=\"CSS3-基础回顾\"><a href=\"#CSS3-基础回顾\" class=\"headerlink\" title=\"CSS3 基础回顾\"></a>CSS3 基础回顾</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>全称“层叠样式表”（Cascade Style Sheet），用来修饰HTML元素的外观：包括大小、位置、颜色和形状等等；</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">selector &#123;<br>  property-type: property-value;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>简单来说：需要对哪个元素做修饰，首先要选中需要修饰的元素，然后再使用CSS对其作修改。</p>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><h3 id=\"基本\"><a href=\"#基本\" class=\"headerlink\" title=\"基本\"></a>基本</h3><p>比较常用的选择器有：class选择器和id选择器，除此之外还有一些高级的选择器，在日常使用中我们可以通过查阅文档来了解一些更高级的选择器用法。</p>\n<ul>\n<li>class选择器</li>\n<li>id选择器</li>\n<li>nth-child选择器等</li>\n</ul>\n<p>一个例子来说明这些选择器的用法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.className</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#id-name</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.box</span><span class=\"hljs-selector-pseudo\">:nth-child</span>(<span class=\"hljs-number\">2</span>n) &#123;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#4f5b62</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面列举了三个选择器的语法：可以看到class选择器的语法是<code>.className</code>，id选择器的语法是<code>#idName</code>；掌握这两个基本就能满足90%以上的应用场景了；</p>\n<p>最后还有一个选择器值得关注：它的语义是：选择className为box并且顺序为偶数序的元素。这属于高级选择器中的其中一个，还有其他的一些可以通过上网查阅来了解；</p>\n<p>一般在前端开发中会遵循一个编码规范：就是class选择器专门用来修饰样式；id选择器专门用来编写逻辑；</p>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>具有特定属性的HTML元素样式不仅仅是class和id，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[title]</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-attr\">[type=<span class=\"hljs-string\">&quot;text&quot;</span>]</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">10px</span>;<br>    <span class=\"hljs-attribute\">background-color</span>: yellow;<br>&#125;<br><br><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-attr\">[type=<span class=\"hljs-string\">&quot;button&quot;</span>]</span> &#123;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">120px</span>;<br>    <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">35px</span>;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"嵌套和分组\"><a href=\"#嵌套和分组\" class=\"headerlink\" title=\"嵌套和分组\"></a>嵌套和分组</h3><p>给很多样式相同的元素设置样式，可以使用分组选择器，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span>,<br><span class=\"hljs-selector-tag\">h2</span>,<br><span class=\"hljs-selector-tag\">p</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>嵌套选择器可以用于选择器内部的样式，有下面几种实践：</p>\n<ul>\n<li><code>p&#123;&#125;</code>：为所有p元素指定一个样式；</li>\n<li><code>.marked &#123;&#125;</code>：为所有<code>class=&quot;marked&quot;</code>的元素设置样式；</li>\n<li><code>.marked p &#123;&#125;</code>为所有<code>class=&quot;marked&quot;</code>元素内部的<code>p</code>元素设置样式；</li>\n<li><code>p.marked &#123;&#125;</code>为所有<code>p</code>元素内部<code>class=&quot;marked&quot;</code>的元素设置样式；</li>\n</ul>\n<h2 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h2><p>所有的HTML元素都可以看作是盒子，在CSS中，“box model”是用来设计和布局使用的；</p>\n<p>一个盒子有下列几部分构成：</p>\n<ul>\n<li>外边距(margin)：清除边框外的区域，外边距是透明的；</li>\n<li>边框(border)：围绕在内边距和内容外的边框，这部分是可以看见的；</li>\n<li>内边距(padding)：清除内容周围的区域，内边距是透明的；</li>\n<li>内容(content)：盒子的内容，显示文本和图像；</li>\n</ul>\n<p>所以你需要知道：给一个元素设置宽高的时候要加上它的外边距、边框、内边距的宽高，这样才是一个元素的宽高；</p>\n<p>盒子模型可以通过浏览器的开发者工具看到，如果需要检视页面上的HTML元素，你可以通过查看元素在控制台的信息来查看它的边距情况。</p>\n<p>总结一下：最终元素的总宽高计算公式是这样的；</p>\n<ul>\n<li>总元素的宽度：宽度 + 左右填充 + 左右边框 + 左右边距；</li>\n<li>总元素的高度：高度 + 上下填充 + 上下边框 + 上下边距；</li>\n</ul>\n<h2 id=\"样式设置\"><a href=\"#样式设置\" class=\"headerlink\" title=\"样式设置\"></a>样式设置</h2><h3 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h3><p>可以给字体，盒子设置颜色，下面举一部分例子：</p>\n<ul>\n<li>盒子背景：<code>background-color</code>，背景有一个简写的属性叫<code>background</code>;</li>\n<li>字体颜色：<code>font-color</code>，同样地，字体也有一个简写属性叫<code>font</code>;</li>\n<li>边框：边框使用<code>border</code>属性也可以给其上色，具体语法可以查阅相关文档；</li>\n<li>还有一个CSS属性叫<code>color</code>，这个是给文本设置颜色的；</li>\n</ul>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><p>字体是HTML中的重要显示元素，CSS中字体的设置有下列几个：</p>\n<ul>\n<li>font：all in one属性，可以设置字体的所有属性</li>\n<li>font-family：字体</li>\n<li>font-size：字体大小</li>\n<li>font-style：字体样式，粗体和斜体之类的</li>\n<li>font-variant：以小型大写字体或者正常字体显示文本；</li>\n<li>font-weight：指定字体的粗细；</li>\n</ul>\n<p>介绍一下all-on-one属性的语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">font</span>: <span class=\"hljs-string\">&quot;&lt;font-style&gt; &lt;font-variant&gt; &lt;font-weight&gt; &lt;font-size&gt; / &lt;line-height&gt; &lt;font-family&gt;&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"All-in-one-属性语法\"><a href=\"#All-in-one-属性语法\" class=\"headerlink\" title=\"All-in-one 属性语法\"></a>All-in-one 属性语法</h3><h4 id=\"外边距（margin）\"><a href=\"#外边距（margin）\" class=\"headerlink\" title=\"外边距（margin）\"></a>外边距（margin）</h4><p>语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  marign: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 次序分别为上、右、下、左<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span>; // 次序分别为上，左右，下<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 上下，左右<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span>; //上下左右全都一样<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"填充（padding）\"><a href=\"#填充（padding）\" class=\"headerlink\" title=\"填充（padding）\"></a>填充（padding）</h4><p>语法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>; // 次序分别为上、右、下、左<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  padidng: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">15px</span>; // 次序为上，左右，下<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span>; <span class=\"hljs-number\">30px</span>; // 上下，左右<br>&#125;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">25px</span>; // 上下左右全都一样<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"显示\"><a href=\"#显示\" class=\"headerlink\" title=\"显示\"></a>显示</h2><p>display设置一个元素该如何在页面上显示，visibility属性指定一个元素应可见还是隐藏；</p>\n<h4 id=\"隐藏元素\"><a href=\"#隐藏元素\" class=\"headerlink\" title=\"隐藏元素\"></a>隐藏元素</h4><p>这里提供两种方法：</p>\n<ul>\n<li><code>display: none</code>：除了会隐藏，还会清除元素原本占用的页面空间；</li>\n<li><code>visibility: hidden</code>：虽然也能隐藏，但是并不会清除元素原本占用的页面空间；</li>\n</ul>\n<h4 id=\"块级元素和内联元素\"><a href=\"#块级元素和内联元素\" class=\"headerlink\" title=\"块级元素和内联元素\"></a>块级元素和内联元素</h4><p>需要注意的是：块级元素默认占用一行，元素在页面上垂直排列；可以设置宽度和高度；</p>\n<p>内联元素则相反：其大小由内容决定，只有填满了一行才会在换行继续，默认情况下不能设置宽和高；但是可以设置边距和填充并且只在水平方向有效；</p>\n<p>了解了上面的知识以后，我们就会知道，使用display方法可以改变元素的显示方式是以块级来显示还是以内联方式来显示。相应的属性如下：</p>\n<ul>\n<li>block</li>\n<li>inline</li>\n</ul>\n<p>举个例子：加入你想给<code>&lt;span&gt;</code>设置元素宽高，但由于其为内联元素，无法设置宽高；这个时候你可以使用display属性为其设置显示模式为<code>block</code>，然后就可以给<code>&lt;span&gt;</code>设置宽高了；</p>\n<h2 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h2><p>定位属性叫<code>position</code>，其指定了元素的定位类型，属性有5个值；</p>\n<ul>\n<li>static：默认设置，没有定位，遵循正常的文档流（即从上到下，从左到右）</li>\n<li>relative：相对定位元素的定位是相对其正常位置</li>\n<li>fixed：元素的位置相对于浏览器窗口是固定的</li>\n<li>absolute：相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>html</code>；</li>\n<li>stickly：基于用户的滚动位置来定位；</li>\n</ul>\n<p>除此之外，还有一个元素叫做<code>z-index</code>，其指定了一个元素的堆叠顺序（哪个元素该放在前面，哪个元素该放在后面），一个元素可以有正数和负数的堆叠顺序；</p>\n<h2 id=\"溢出\"><a href=\"#溢出\" class=\"headerlink\" title=\"溢出\"></a>溢出</h2><p>CSS overflow属性用于控制内容溢出元素框时的显示方式，有下面5个属性值；</p>\n<ul>\n<li>visible：默认值，内容不会被裁剪，会显示在元素框之外</li>\n<li>hidden：内容会被裁剪，并且其余部分的内容是不可见的；</li>\n<li>scroll：内容会被裁剪，但是浏览器会显示滚动条以便于查看其余内容</li>\n<li>auto：如果内容被裁剪，浏览器会显示滚动条以便于查看其余内容</li>\n<li>inherit：规定应该从父元素继承overflow属性的值</li>\n</ul>\n<h2 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h2><p>浮动的框可以向左或者向右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档流的普通流中，所以文档的普通流中的浮动框之后的块框表现地像浮动框不存在一样。</p>\n<p>需要注意的是：当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，因此float是一种不彻底的脱离文档流方式。无论多么复杂的布局，其基本出发点均是：“如何在一行显示多个div元素”。</p>\n<p>于是在浮动布局中会存在下面这个现象：</p>\n<ul>\n<li>如果元素A是浮动元素并且其上一个元素也是浮动元素，那么A元素就会跟随在上一个元素的后边；（如果一行放不下就会挤到下一行）</li>\n<li>如果元素A是浮动元素，但是其上一个元素是标准流元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐；</li>\n<li>浮动框之后的block元素会认为这个框不存在，但其中的文本依然会认为这个元素让出位置。浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列；</li>\n</ul>\n<p>使用浮动的原则如下：</p>\n<p>要么都使用浮动，要么都不使用浮动；要么对没使用浮动的DIV设置margin样式；</p>\n<h2 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h2><p>在非IE浏览器的环境下，当容器高度为auto，且容器内容有浮动的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至是破坏）布局的现象。这个现象就叫做浮动溢出，为了防止这个现象出现而进行的CSS处理，就叫做CSS清除浮动。</p>\n<p>引用W3C的一个例子来解释浮动溢出：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span>: &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!--虽然从HTML上看news是包裹着图片和文字的--&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!--实际上由于浮动元素不占据空间，所以news的高度直接塌陷了--&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>\t    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>既然出现了元素的“高度塌陷”，那么可以使用清除浮动的方法来解决这个问题：</p>\n<p><strong>方法1：在浮动元素后使用一个空元素，并在CSS中赋予<code>.clear &#123;clear: both&#125;</code>属性即可清除浮动；例如：</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some Text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clear&quot;</span>/&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>优点：简单、代码少，浏览器兼容性好；</p>\n<p>缺点：需要添加大量无语义的html元素，代码不够优雅，后期也不容易维护；</p>\n<p><strong>方法2：使用CSS的overflow属性（BFC机制）</strong></p>\n<p>给浮动元素的容器添加<code>overflow: hidden</code>或者<code>overflow: auto</code>可以清除浮动，在添加了相关属性后，浮动元素又回到了容器层，把容器高度撑起，达到清除浮动的效果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">overflow</span>: hidden;</span><br><span class=\"language-css\">                <span class=\"hljs-comment\">/* 触发IE6 / IE7的haslayout机制 */</span></span><br><span class=\"language-css\">                *zoom: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>方法3：给浮动元素的容器添加浮动</strong></p>\n<p>给浮动元素的容器添加浮动属性即可清除内部浮动，但是这样做会使其整体浮动，影响布局，不推荐使用；</p>\n<p><strong>方法4：使用邻接元素处理</strong></p>\n<p>什么都不做，给浮动元素后面的元素添加clear属性；</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.content</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">clear</span>: both;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>方法5：使用CSS的:after伪元素</strong></p>\n<p>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个<code>:after</code>伪元素实现方法1的那种效果。此方法兼容性好；推荐这种方法；</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: gray;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">img</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.news</span> <span class=\"hljs-selector-tag\">p</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">float</span>: right;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.clearfix</span><span class=\"hljs-selector-pseudo\">:after</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;020&quot;</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">display</span>: block;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">clear</span>: both;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">visibility</span>: hidden;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.clearfix</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-comment\">/* 触发 IE6/IE7的haslayout机制 */</span></span><br><span class=\"language-css\">                zoom: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;news clearfix&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;news-pic.jpg&quot;</span>/&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Some text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"伪类\"><a href=\"#伪类\" class=\"headerlink\" title=\"伪类\"></a>伪类</h2><p>CSS伪类是用来添加一些选择器的特殊效果，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 基础语法 */</span><br>selector:pseudo-class &#123; property: value; &#125;<br><br><span class=\"hljs-comment\">/* CSS类选择器 */</span><br>selector<span class=\"hljs-selector-class\">.class</span>:pseudo-class &#123; property: value; &#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"anchor伪类\"><a href=\"#anchor伪类\" class=\"headerlink\" title=\"anchor伪类\"></a>anchor伪类</h3><p>链接的不同状态都可以以不同的方式显示，例如：</p>\n<ul>\n<li><code>a:link</code>：未访问的链接</li>\n<li><code>a:visited</code>：已访问的链接</li>\n<li><code>a:hover</code>：鼠标划过的链接</li>\n<li><code>a:active</code>：已选中的链接</li>\n</ul>\n<h3 id=\"CSS伪元素\"><a href=\"#CSS伪元素\" class=\"headerlink\" title=\"CSS伪元素\"></a>CSS伪元素</h3><p>CSS伪元素用来添加一些选择器的特殊效果，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs CSS\"><span class=\"hljs-comment\">/* 伪元素语法 */</span><br>selector:pseudo-element &#123; property: value; &#125;<br><br><span class=\"hljs-comment\">/* CSS类也可以使用伪元素 */</span><br>selector<span class=\"hljs-selector-class\">.class</span>:pseudo-element &#123; property: value; &#125;<br></code></pre></td></tr></table></figure>\n<p>下面列举一些伪元素的使用：</p>\n<ul>\n<li><code>:first-line</code>：用于向文本的首行设置特殊样式；</li>\n<li><code>:first-letter</code>：用于向文本的首字母设置特殊样式；</li>\n<li><code>:before</code>：可以在元素的内容前插入新内容；</li>\n<li><code>:after</code>：可以在元素的内容后插入新内容；</li>\n</ul>\n"},{"title":"CSS3进阶操作","date":"2022-02-18T12:50:27.000Z","updated":"2022-02-18T12:50:27.000Z","_content":"\n# CSS3 进阶操作\n\n## CSS3 边框\n\n在CSS3中你可以创建圆角边框、阴影边框。属性如下：\n\n- border-radius：边框圆角\n- box-shadow：盒子阴影\n- border-image：边框图片\n\n## CSS3 圆角\n\n举个例子：\n\n```css\n#cornenr1 {\n  border-radius: 25px;\n  background: #a8bcf4;\n  padding: 20px;\n  width: 200px;\n  height: 150px;\n}\n\n#corner2 {\n  border-radius:15px 50px 30px 5px;\n  background: #fe5cb9;\n  padding: 10px;\n  width: 150px;\n  height: 100px;\n}\n```\n\n可以发现第二个例子有四个值：顺序为：左上、右上、右下和左下；\n\n一个值就是默认四个角都是一样的，没什么毛病。\n\n初次之外还有其他属性，可以自己熟悉一下：\n\n- border-top-left-radius\n- border-top-right-radius\n- border-bottom-left-radius\n- border-bottom-right-radis\n\n## CSS3 背景\n\nCSS3中新增几个背景属性，提供了更大背景元素控制；\n\n- background-image：添加背景图片，不同背景用逗号分隔开；\n- background-size：指定背景图像的大小；\n- background-origin：指定背景图像的位置区域，有：border-box, padding-box和content-box;\n- background-clip：从指定位置开始绘制背景图形；\n\n## CSS3 渐变\n\n可以在两个或者多个指定的颜色之间显示平稳的过渡，CSS3中定义了两种类型的渐变（gradients）：\n\n- 线性渐变：向上下左右对角方向\n- 径向渐变：由中心定义\n\n语法如下：\n\n```css\nbackground-image: linear-gradient(direction, color-stop1, color-stop2, ...)\n\n/* \n  direction: 默认上下，左右为to right\n  对角渐变：to bottom right\n  还可以使用角度：angle (这里指的是弧度)\n*/\n```\n\n重复的线性渐变\n\n```css\nbackground-image: repeating-linear-gradient(red, yellow 10%, green 20%);\n```\n\n径向渐变\n\n```css\nbackground-image: radial-gradient(shape size at position, start-color, ... ,last-color);\n```\n\nshape参数定义了形状。可以是circle和ellipse，圆形和椭圆形；\n\n和重复地线性渐变一样，径向渐变也有重复地属性，这里就不再演示了。\n\n## CSS3 文本效果 & 字体\n\n文本效果包括下面的这几个：\n\n- text-shadow：文本阴影，可以定义多个，可以做字体发光效果\n- box-shadow：盒子阴影，可以定义多个，做成发光盒子\n- text-overflow：指定用户如何显示溢出内容；\n- word-wrap：自动换行属性允许强制文本换行，这意味着分裂它中间的一个字；\n- word-break：单词拆分换行属性指定换行规则；\n\n需要使用自定义字体可以使用`@font-face`属性。例子如下：\n\n```css\n@font-face {\n  font-family: myFirstFont;\n  src url(font.ttf);\n}\n\ndiv {\n  font-family: myFirstFont;\n}\n```\n\n## CSS3 2D & 3D转换\n\n### 2D转换\n\n2D变换方法有下面5种：\n\n- translate：根据x轴和y轴位置给定的参数，从当前元素位置移动；\n- rotate：在一个给定读书顺时针旋转元素，负值代表逆时针旋转；\n- scale：该元素增加或者减少大小，取决于宽度（x轴）和高度（y轴）的参数；\n- skew：表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负数表示像反方向倾斜；\n- matrix：和2D变换方法合并成一个，一共有六个参数，包括：旋转、缩放、移动和倾斜的功能；\n\n具体语法可以再查阅\n\n### 3D转换\n\n3D转换会使用到两个方法：\n\n- rotateX：围绕其在一个给定度数X轴旋转的元素；\n- rotateY：围绕其在一个给定读书Y轴旋转的元素；\n\n你也可以使用transform属性做2D和3D变换，一般来说建议使用transform属性，特别是在使用一些库来实现高级动画效果的时候；\n\n```css\ndiv {\n    transform: none | transform-functions;\n}\n/*\ntransform-functions包括：\nmatrix, matrix3d;\ntranslate, translate3d, translateX, translateY, translateZ;\nscale, scale3d, scaleX, scaleY, scaleZ;\nrotate, rotate3d, rotateX, rotateY, rotateX;\nskew, skewX, skewY;\nperspective：为3D转换元素定义透视视图；\n*/\n```\n\n## CSS3 过渡\n\nCSS3过渡是元素从一种样式逐渐改变为另一种效果，要实现这一点，必须规定两项内容；\n\n- 指定要添加效果的CSS属性；\n- 指定效果的持续时间；\n\n例子如下：\n\n```css\ndiv {\n    transition: width 2s;\n    -webkit-transition: width 2s; /* Safari or Chrome */\n}\n\n/* 要添加多个样式的变换效果，可以使用逗号分隔属性 */\ndiv {\n    transition: width 2s, height 2s, transform 2s;\n    -webkit-transform: width 2s, height 2s, transform 2s;\n}\n```\n\n## CSS3 动画\n\nCSS3可以创建动画，可以取代一些JavaScript实现的动画效果；\n\nCSS3使用`@keyframes`创建动画，语法如下：\n\n```css\n@keyframes myfirst {\n    from { background: red; }\n    to { background: yellow; }\n}\n\n@-webkit-keyframes myfirst {\n    from { background: red; }\n    to { background: yellow; }\n}\n\ndiv {\n    animation: myfirst 5s;\n}\n\n/* 除此之外还可以这样定义 */\n@keyframes myfirst {\n    0% { background: red; }\n    25% { background: yellow; }\n    50% { background: blue; }\n    100% { background: green; }\n}\n\n@-webkit-keyframes myfirst {\n    0% { background: red; }\n    25% { background: yellow; }\n    50% { background: blue; }\n    100% { background: green; }\n}\n\ndiv {\n    animation: myfirst 5s;\n}\n```\n\n## CSS3媒体查询\n\n顾名思义，针对不同媒体类型的设备定制不同的样式规则，例如：手机、电视、平板、电脑以及阅读器设置不同的样式规则；语法如下：\n\n```css\n@media not | only mediatype and (expression) {\n    /* Write CSS Code here... */\n}\n```\n\n解释一下参数的含义：\n\n- not：用于排除某些特定设备的；\n- only：用来指定某种特别的媒体设备；\n- all：适用于所有媒体设备，这个最常见；\n\n举个例子：\n\n```css\n@media screen and (min-width: 480px) {\n    #leftsidebar { width: 200px; float: left; }\n    #main { margin-left: 216px; }\n}\n```\n\n以上实例在屏幕可视窗口尺寸大于480px像素时将菜单浮动到页面左侧；\n\n## CSS3 Flex布局\n\n弹性布局是CSS3的一种新布局模式，当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为布局方式，引入弹性布局模型的目的是提供一种更加有效地方式来对一个容器中的元素进行排列、对齐和分配空白空间；\n\n下面以例子来说明：\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .flex-container {\n                display: flex;\n                width: 400px;\n                height: 250px;\n                background: lightgray;\n            }\n            \n            .flex-item {\n                background-color: cornflowerblue;\n                width: 100px;\n                height: 100px;\n                margin: 10px;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"flex-container\">\n            <div class=\"flex-item\">flex item 1</div>\n            <div class=\"flex-item\">flex item 2</div>\n            <div class=\"flex-item\">flex item 3</div>\n        </div>\n    </body>\n</html>\n```\n\n### 弹性容器布局属性\n\n#### flex-direction\n\n指定了弹性子元素在父容器中的位置，值有：\n\n- row：默认值，从左到右排列；\n- row-reverse：反转横向排列，从右到左排列；\n- column：纵向排列；\n- column-reverse：反转纵向排列，从后往前排；\n\n#### justify-content\n\n内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐，值有：\n\n- flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。\n- flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。\n- center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。\n- space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。\n- space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。\n\n#### align-items\n\n设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式；值有：\n\n- flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n- strench：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n\n#### flex-wrap\n\n指定弹性盒子的子元素换行方式，值有：\n\n- nowrap：默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\n- wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\n- wrap-reverse：反转 wrap 排列。\n\n#### align-content\n\n用于修改flex-wrap属性的行为，类似align-items，但它不是设置弹性子元素的对齐，而是设置各个行的对齐，值有：\n\n- strench：默认。各行将会伸展以占用剩余的空间。\n- flex-start：各行向弹性盒容器的起始位置堆叠。\n- flex-end：各行向弹性盒容器的结束位置堆叠。\n- center：各行向弹性盒容器的中间位置堆叠。\n- space-between：各行在弹性盒容器中平均分布。\n- space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。\n\n### 弹性元素布局属性\n\n#### 排序order\n\n用整数值来定义排列顺序，数值小的排在前面，可以为负值；例子如下：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 100px;\n    height: 100px;\n    margin: 10px;\n}\n\n.flex-item:first-child {\n    order: -1;\n    -webkit-order: -1;\n}\n```\n\n#### 对齐\n\n设置margin值为auto，自动获取弹性容器中剩余空间，因此设置垂直方向margin值为'auto'\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: 10px;\n}\n\n.flex-item:first-child {\n    margin-right: auto;\n}\n```\n\n#### 完美居中\n\n可以看出，使用弹性盒子后，居中变得非常简单。下面演示一下完美居中的实现方法；\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: auto;\n}\n```\n\n#### align-self\n\n用于设置弹性元素自身在纵轴方向上的对齐方式，值有：\n\n- auto：如果'align-self'的值为'auto'，则其计算值为元素的父元素的'align-items'值，如果其没有父元素，则计算值为'stretch'。\n- flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n- strench：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n\n以下演示了不同值的效果，可以在[Code Pen](https://codepen.io)上直接试验：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 60px;\n    min-height: 100px;\n    margin: 10px;\n}\n\n.item1 {\n    align-self: flex-start;\n    -webkit-align-self: flex-start;\n}\n\n.item2 {\n    align-self: flex-end;\n    -webkit-align-self: flex-end;\n}\n\n.item3 {\n    align-self: center;\n    -webkit-align-self: center;\n}\n\n.item4 {\n    align-self: baseline;\n    -webkit-align-self: baseline;\n}\n\n.item5 {\n    align-self: strench;\n    -webkit-align-self: strench;\n}\n```\n\n#### flex\n\n用于指定弹性子元素如何分配空间，值有：\n\n- auto：计算值为1 1 auto\n- initial：计算值为0 1 auto\n- none：计算值为0 0 auto\n- inherit：从父元素继承\n- flex-grow：定义弹性盒子元素的扩展比率\n- flex-shrink：定义弹性盒子元素的搜索比率\n- flex-basis：定义弹性盒子元素的默认基准值\n\n例子：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    margin: 10px;\n}\n\n.item1 {\n    -webkit-flex: 2;\n    flex: 2;\n}\n\n.item2 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n\n.item3 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n```\n","source":"_posts/frontend/css3/css3-ch02.md","raw":"---\ntitle: CSS3进阶操作\ndate: 2022-02-18 20:50:27\nupdated: 2022-02-18 20:50:27\ntags: CSS3\ncategories: 前端\n---\n\n# CSS3 进阶操作\n\n## CSS3 边框\n\n在CSS3中你可以创建圆角边框、阴影边框。属性如下：\n\n- border-radius：边框圆角\n- box-shadow：盒子阴影\n- border-image：边框图片\n\n## CSS3 圆角\n\n举个例子：\n\n```css\n#cornenr1 {\n  border-radius: 25px;\n  background: #a8bcf4;\n  padding: 20px;\n  width: 200px;\n  height: 150px;\n}\n\n#corner2 {\n  border-radius:15px 50px 30px 5px;\n  background: #fe5cb9;\n  padding: 10px;\n  width: 150px;\n  height: 100px;\n}\n```\n\n可以发现第二个例子有四个值：顺序为：左上、右上、右下和左下；\n\n一个值就是默认四个角都是一样的，没什么毛病。\n\n初次之外还有其他属性，可以自己熟悉一下：\n\n- border-top-left-radius\n- border-top-right-radius\n- border-bottom-left-radius\n- border-bottom-right-radis\n\n## CSS3 背景\n\nCSS3中新增几个背景属性，提供了更大背景元素控制；\n\n- background-image：添加背景图片，不同背景用逗号分隔开；\n- background-size：指定背景图像的大小；\n- background-origin：指定背景图像的位置区域，有：border-box, padding-box和content-box;\n- background-clip：从指定位置开始绘制背景图形；\n\n## CSS3 渐变\n\n可以在两个或者多个指定的颜色之间显示平稳的过渡，CSS3中定义了两种类型的渐变（gradients）：\n\n- 线性渐变：向上下左右对角方向\n- 径向渐变：由中心定义\n\n语法如下：\n\n```css\nbackground-image: linear-gradient(direction, color-stop1, color-stop2, ...)\n\n/* \n  direction: 默认上下，左右为to right\n  对角渐变：to bottom right\n  还可以使用角度：angle (这里指的是弧度)\n*/\n```\n\n重复的线性渐变\n\n```css\nbackground-image: repeating-linear-gradient(red, yellow 10%, green 20%);\n```\n\n径向渐变\n\n```css\nbackground-image: radial-gradient(shape size at position, start-color, ... ,last-color);\n```\n\nshape参数定义了形状。可以是circle和ellipse，圆形和椭圆形；\n\n和重复地线性渐变一样，径向渐变也有重复地属性，这里就不再演示了。\n\n## CSS3 文本效果 & 字体\n\n文本效果包括下面的这几个：\n\n- text-shadow：文本阴影，可以定义多个，可以做字体发光效果\n- box-shadow：盒子阴影，可以定义多个，做成发光盒子\n- text-overflow：指定用户如何显示溢出内容；\n- word-wrap：自动换行属性允许强制文本换行，这意味着分裂它中间的一个字；\n- word-break：单词拆分换行属性指定换行规则；\n\n需要使用自定义字体可以使用`@font-face`属性。例子如下：\n\n```css\n@font-face {\n  font-family: myFirstFont;\n  src url(font.ttf);\n}\n\ndiv {\n  font-family: myFirstFont;\n}\n```\n\n## CSS3 2D & 3D转换\n\n### 2D转换\n\n2D变换方法有下面5种：\n\n- translate：根据x轴和y轴位置给定的参数，从当前元素位置移动；\n- rotate：在一个给定读书顺时针旋转元素，负值代表逆时针旋转；\n- scale：该元素增加或者减少大小，取决于宽度（x轴）和高度（y轴）的参数；\n- skew：表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负数表示像反方向倾斜；\n- matrix：和2D变换方法合并成一个，一共有六个参数，包括：旋转、缩放、移动和倾斜的功能；\n\n具体语法可以再查阅\n\n### 3D转换\n\n3D转换会使用到两个方法：\n\n- rotateX：围绕其在一个给定度数X轴旋转的元素；\n- rotateY：围绕其在一个给定读书Y轴旋转的元素；\n\n你也可以使用transform属性做2D和3D变换，一般来说建议使用transform属性，特别是在使用一些库来实现高级动画效果的时候；\n\n```css\ndiv {\n    transform: none | transform-functions;\n}\n/*\ntransform-functions包括：\nmatrix, matrix3d;\ntranslate, translate3d, translateX, translateY, translateZ;\nscale, scale3d, scaleX, scaleY, scaleZ;\nrotate, rotate3d, rotateX, rotateY, rotateX;\nskew, skewX, skewY;\nperspective：为3D转换元素定义透视视图；\n*/\n```\n\n## CSS3 过渡\n\nCSS3过渡是元素从一种样式逐渐改变为另一种效果，要实现这一点，必须规定两项内容；\n\n- 指定要添加效果的CSS属性；\n- 指定效果的持续时间；\n\n例子如下：\n\n```css\ndiv {\n    transition: width 2s;\n    -webkit-transition: width 2s; /* Safari or Chrome */\n}\n\n/* 要添加多个样式的变换效果，可以使用逗号分隔属性 */\ndiv {\n    transition: width 2s, height 2s, transform 2s;\n    -webkit-transform: width 2s, height 2s, transform 2s;\n}\n```\n\n## CSS3 动画\n\nCSS3可以创建动画，可以取代一些JavaScript实现的动画效果；\n\nCSS3使用`@keyframes`创建动画，语法如下：\n\n```css\n@keyframes myfirst {\n    from { background: red; }\n    to { background: yellow; }\n}\n\n@-webkit-keyframes myfirst {\n    from { background: red; }\n    to { background: yellow; }\n}\n\ndiv {\n    animation: myfirst 5s;\n}\n\n/* 除此之外还可以这样定义 */\n@keyframes myfirst {\n    0% { background: red; }\n    25% { background: yellow; }\n    50% { background: blue; }\n    100% { background: green; }\n}\n\n@-webkit-keyframes myfirst {\n    0% { background: red; }\n    25% { background: yellow; }\n    50% { background: blue; }\n    100% { background: green; }\n}\n\ndiv {\n    animation: myfirst 5s;\n}\n```\n\n## CSS3媒体查询\n\n顾名思义，针对不同媒体类型的设备定制不同的样式规则，例如：手机、电视、平板、电脑以及阅读器设置不同的样式规则；语法如下：\n\n```css\n@media not | only mediatype and (expression) {\n    /* Write CSS Code here... */\n}\n```\n\n解释一下参数的含义：\n\n- not：用于排除某些特定设备的；\n- only：用来指定某种特别的媒体设备；\n- all：适用于所有媒体设备，这个最常见；\n\n举个例子：\n\n```css\n@media screen and (min-width: 480px) {\n    #leftsidebar { width: 200px; float: left; }\n    #main { margin-left: 216px; }\n}\n```\n\n以上实例在屏幕可视窗口尺寸大于480px像素时将菜单浮动到页面左侧；\n\n## CSS3 Flex布局\n\n弹性布局是CSS3的一种新布局模式，当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为布局方式，引入弹性布局模型的目的是提供一种更加有效地方式来对一个容器中的元素进行排列、对齐和分配空白空间；\n\n下面以例子来说明：\n\n```html\n<html>\n    <head>\n        <style type=\"text/css\">\n            .flex-container {\n                display: flex;\n                width: 400px;\n                height: 250px;\n                background: lightgray;\n            }\n            \n            .flex-item {\n                background-color: cornflowerblue;\n                width: 100px;\n                height: 100px;\n                margin: 10px;\n            }\n        </style>\n    </head>\n    \n    <body>\n        <div class=\"flex-container\">\n            <div class=\"flex-item\">flex item 1</div>\n            <div class=\"flex-item\">flex item 2</div>\n            <div class=\"flex-item\">flex item 3</div>\n        </div>\n    </body>\n</html>\n```\n\n### 弹性容器布局属性\n\n#### flex-direction\n\n指定了弹性子元素在父容器中的位置，值有：\n\n- row：默认值，从左到右排列；\n- row-reverse：反转横向排列，从右到左排列；\n- column：纵向排列；\n- column-reverse：反转纵向排列，从后往前排；\n\n#### justify-content\n\n内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐，值有：\n\n- flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。\n- flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。\n- center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。\n- space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。\n- space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。\n\n#### align-items\n\n设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式；值有：\n\n- flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n- strench：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n\n#### flex-wrap\n\n指定弹性盒子的子元素换行方式，值有：\n\n- nowrap：默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\n- wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\n- wrap-reverse：反转 wrap 排列。\n\n#### align-content\n\n用于修改flex-wrap属性的行为，类似align-items，但它不是设置弹性子元素的对齐，而是设置各个行的对齐，值有：\n\n- strench：默认。各行将会伸展以占用剩余的空间。\n- flex-start：各行向弹性盒容器的起始位置堆叠。\n- flex-end：各行向弹性盒容器的结束位置堆叠。\n- center：各行向弹性盒容器的中间位置堆叠。\n- space-between：各行在弹性盒容器中平均分布。\n- space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。\n\n### 弹性元素布局属性\n\n#### 排序order\n\n用整数值来定义排列顺序，数值小的排在前面，可以为负值；例子如下：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 100px;\n    height: 100px;\n    margin: 10px;\n}\n\n.flex-item:first-child {\n    order: -1;\n    -webkit-order: -1;\n}\n```\n\n#### 对齐\n\n设置margin值为auto，自动获取弹性容器中剩余空间，因此设置垂直方向margin值为'auto'\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: 10px;\n}\n\n.flex-item:first-child {\n    margin-right: auto;\n}\n```\n\n#### 完美居中\n\n可以看出，使用弹性盒子后，居中变得非常简单。下面演示一下完美居中的实现方法；\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 75px;\n    height: 75px;\n    margin: auto;\n}\n```\n\n#### align-self\n\n用于设置弹性元素自身在纵轴方向上的对齐方式，值有：\n\n- auto：如果'align-self'的值为'auto'，则其计算值为元素的父元素的'align-items'值，如果其没有父元素，则计算值为'stretch'。\n- flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\n- flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\n- center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\n- baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。\n- strench：如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。\n\n以下演示了不同值的效果，可以在[Code Pen](https://codepen.io)上直接试验：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    width: 60px;\n    min-height: 100px;\n    margin: 10px;\n}\n\n.item1 {\n    align-self: flex-start;\n    -webkit-align-self: flex-start;\n}\n\n.item2 {\n    align-self: flex-end;\n    -webkit-align-self: flex-end;\n}\n\n.item3 {\n    align-self: center;\n    -webkit-align-self: center;\n}\n\n.item4 {\n    align-self: baseline;\n    -webkit-align-self: baseline;\n}\n\n.item5 {\n    align-self: strench;\n    -webkit-align-self: strench;\n}\n```\n\n#### flex\n\n用于指定弹性子元素如何分配空间，值有：\n\n- auto：计算值为1 1 auto\n- initial：计算值为0 1 auto\n- none：计算值为0 0 auto\n- inherit：从父元素继承\n- flex-grow：定义弹性盒子元素的扩展比率\n- flex-shrink：定义弹性盒子元素的搜索比率\n- flex-basis：定义弹性盒子元素的默认基准值\n\n例子：\n\n```css\n.flex-item {\n    background-color: cornflowerblue;\n    margin: 10px;\n}\n\n.item1 {\n    -webkit-flex: 2;\n    flex: 2;\n}\n\n.item2 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n\n.item3 {\n    -webkit-flex: 1;\n    flex: 1;\n}\n```\n","slug":"frontend/css3/css3-ch02","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3j00302y61c39b7ejk","content":"<h1 id=\"CSS3-进阶操作\"><a href=\"#CSS3-进阶操作\" class=\"headerlink\" title=\"CSS3 进阶操作\"></a>CSS3 进阶操作</h1><h2 id=\"CSS3-边框\"><a href=\"#CSS3-边框\" class=\"headerlink\" title=\"CSS3 边框\"></a>CSS3 边框</h2><p>在CSS3中你可以创建圆角边框、阴影边框。属性如下：</p>\n<ul>\n<li>border-radius：边框圆角</li>\n<li>box-shadow：盒子阴影</li>\n<li>border-image：边框图片</li>\n</ul>\n<h2 id=\"CSS3-圆角\"><a href=\"#CSS3-圆角\" class=\"headerlink\" title=\"CSS3 圆角\"></a>CSS3 圆角</h2><p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#cornenr1</span> &#123;<br>  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">25px</span>;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#a8bcf4</span>;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#corner2</span> &#123;<br>  <span class=\"hljs-attribute\">border-radius</span>:<span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">50px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">5px</span>;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#fe5cb9</span>;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">10px</span>;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以发现第二个例子有四个值：顺序为：左上、右上、右下和左下；</p>\n<p>一个值就是默认四个角都是一样的，没什么毛病。</p>\n<p>初次之外还有其他属性，可以自己熟悉一下：</p>\n<ul>\n<li>border-top-left-radius</li>\n<li>border-top-right-radius</li>\n<li>border-bottom-left-radius</li>\n<li>border-bottom-right-radis</li>\n</ul>\n<h2 id=\"CSS3-背景\"><a href=\"#CSS3-背景\" class=\"headerlink\" title=\"CSS3 背景\"></a>CSS3 背景</h2><p>CSS3中新增几个背景属性，提供了更大背景元素控制；</p>\n<ul>\n<li>background-image：添加背景图片，不同背景用逗号分隔开；</li>\n<li>background-size：指定背景图像的大小；</li>\n<li>background-origin：指定背景图像的位置区域，有：border-box, padding-box和content-box;</li>\n<li>background-clip：从指定位置开始绘制背景图形；</li>\n</ul>\n<h2 id=\"CSS3-渐变\"><a href=\"#CSS3-渐变\" class=\"headerlink\" title=\"CSS3 渐变\"></a>CSS3 渐变</h2><p>可以在两个或者多个指定的颜色之间显示平稳的过渡，CSS3中定义了两种类型的渐变（gradients）：</p>\n<ul>\n<li>线性渐变：向上下左右对角方向</li>\n<li>径向渐变：由中心定义</li>\n</ul>\n<p>语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(direction, color-stop1, color-stop2, ...)<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">  direction: 默认上下，左右为to right</span><br><span class=\"hljs-comment\">  对角渐变：to bottom right</span><br><span class=\"hljs-comment\">  还可以使用角度：angle (这里指的是弧度)</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p>重复的线性渐变</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">repeating-linear-gradient</span>(red, yellow <span class=\"hljs-number\">10%</span>, green <span class=\"hljs-number\">20%</span>);<br></code></pre></td></tr></table></figure>\n<p>径向渐变</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">radial-gradient</span>(shape size at position, start-color, ... ,last-color);<br></code></pre></td></tr></table></figure>\n<p>shape参数定义了形状。可以是circle和ellipse，圆形和椭圆形；</p>\n<p>和重复地线性渐变一样，径向渐变也有重复地属性，这里就不再演示了。</p>\n<h2 id=\"CSS3-文本效果-amp-字体\"><a href=\"#CSS3-文本效果-amp-字体\" class=\"headerlink\" title=\"CSS3 文本效果 &amp; 字体\"></a>CSS3 文本效果 &amp; 字体</h2><p>文本效果包括下面的这几个：</p>\n<ul>\n<li>text-shadow：文本阴影，可以定义多个，可以做字体发光效果</li>\n<li>box-shadow：盒子阴影，可以定义多个，做成发光盒子</li>\n<li>text-overflow：指定用户如何显示溢出内容；</li>\n<li>word-wrap：自动换行属性允许强制文本换行，这意味着分裂它中间的一个字；</li>\n<li>word-break：单词拆分换行属性指定换行规则；</li>\n</ul>\n<p>需要使用自定义字体可以使用<code>@font-face</code>属性。例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@font-face</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: myFirstFont;<br>  <span class=\"hljs-attribute\">src</span> url(<span class=\"hljs-attribute\">font</span><span class=\"hljs-selector-class\">.ttf</span>);<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: myFirstFont;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-2D-amp-3D转换\"><a href=\"#CSS3-2D-amp-3D转换\" class=\"headerlink\" title=\"CSS3 2D &amp; 3D转换\"></a>CSS3 2D &amp; 3D转换</h2><h3 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a>2D转换</h3><p>2D变换方法有下面5种：</p>\n<ul>\n<li>translate：根据x轴和y轴位置给定的参数，从当前元素位置移动；</li>\n<li>rotate：在一个给定读书顺时针旋转元素，负值代表逆时针旋转；</li>\n<li>scale：该元素增加或者减少大小，取决于宽度（x轴）和高度（y轴）的参数；</li>\n<li>skew：表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负数表示像反方向倾斜；</li>\n<li>matrix：和2D变换方法合并成一个，一共有六个参数，包括：旋转、缩放、移动和倾斜的功能；</li>\n</ul>\n<p>具体语法可以再查阅</p>\n<h3 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a>3D转换</h3><p>3D转换会使用到两个方法：</p>\n<ul>\n<li>rotateX：围绕其在一个给定度数X轴旋转的元素；</li>\n<li>rotateY：围绕其在一个给定读书Y轴旋转的元素；</li>\n</ul>\n<p>你也可以使用transform属性做2D和3D变换，一般来说建议使用transform属性，特别是在使用一些库来实现高级动画效果的时候；</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transform</span>: none | transform-functions;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">transform-functions包括：</span><br><span class=\"hljs-comment\">matrix, matrix3d;</span><br><span class=\"hljs-comment\">translate, translate3d, translateX, translateY, translateZ;</span><br><span class=\"hljs-comment\">scale, scale3d, scaleX, scaleY, scaleZ;</span><br><span class=\"hljs-comment\">rotate, rotate3d, rotateX, rotateY, rotateX;</span><br><span class=\"hljs-comment\">skew, skewX, skewY;</span><br><span class=\"hljs-comment\">perspective：为3D转换元素定义透视视图；</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-过渡\"><a href=\"#CSS3-过渡\" class=\"headerlink\" title=\"CSS3 过渡\"></a>CSS3 过渡</h2><p>CSS3过渡是元素从一种样式逐渐改变为另一种效果，要实现这一点，必须规定两项内容；</p>\n<ul>\n<li>指定要添加效果的CSS属性；</li>\n<li>指定效果的持续时间；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>;<br>    -webkit-<span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>; <span class=\"hljs-comment\">/* Safari or Chrome */</span><br>&#125;<br><br><span class=\"hljs-comment\">/* 要添加多个样式的变换效果，可以使用逗号分隔属性 */</span><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>, height <span class=\"hljs-number\">2s</span>, transform <span class=\"hljs-number\">2s</span>;<br>    -webkit-<span class=\"hljs-attribute\">transform</span>: width <span class=\"hljs-number\">2s</span>, height <span class=\"hljs-number\">2s</span>, transform <span class=\"hljs-number\">2s</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-动画\"><a href=\"#CSS3-动画\" class=\"headerlink\" title=\"CSS3 动画\"></a>CSS3 动画</h2><p>CSS3可以创建动画，可以取代一些JavaScript实现的动画效果；</p>\n<p>CSS3使用<code>@keyframes</code>创建动画，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@keyframes</span> myfirst &#123;<br>    <span class=\"hljs-selector-tag\">from</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-selector-tag\">to</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">@-webkit-keyframes</span> myfirst &#123;<br>    <span class=\"hljs-selector-tag\">from</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-selector-tag\">to</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">animation</span>: myfirst <span class=\"hljs-number\">5s</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 除此之外还可以这样定义 */</span><br><span class=\"hljs-keyword\">@keyframes</span> myfirst &#123;<br>    <span class=\"hljs-number\">0%</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-number\">25%</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>    <span class=\"hljs-number\">50%</span> &#123; <span class=\"hljs-attribute\">background</span>: blue; &#125;<br>    <span class=\"hljs-number\">100%</span> &#123; <span class=\"hljs-attribute\">background</span>: green; &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">@-webkit-keyframes</span> myfirst &#123;<br>    <span class=\"hljs-number\">0%</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-number\">25%</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>    <span class=\"hljs-number\">50%</span> &#123; <span class=\"hljs-attribute\">background</span>: blue; &#125;<br>    <span class=\"hljs-number\">100%</span> &#123; <span class=\"hljs-attribute\">background</span>: green; &#125;<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">animation</span>: myfirst <span class=\"hljs-number\">5s</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3媒体查询\"><a href=\"#CSS3媒体查询\" class=\"headerlink\" title=\"CSS3媒体查询\"></a>CSS3媒体查询</h2><p>顾名思义，针对不同媒体类型的设备定制不同的样式规则，例如：手机、电视、平板、电脑以及阅读器设置不同的样式规则；语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">not</span> | <span class=\"hljs-keyword\">only</span> mediatype <span class=\"hljs-keyword\">and</span> (expression) &#123;<br>    <span class=\"hljs-comment\">/* Write CSS Code here... */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>解释一下参数的含义：</p>\n<ul>\n<li>not：用于排除某些特定设备的；</li>\n<li>only：用来指定某种特别的媒体设备；</li>\n<li>all：适用于所有媒体设备，这个最常见；</li>\n</ul>\n<p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">480px</span>) &#123;<br>    <span class=\"hljs-selector-id\">#leftsidebar</span> &#123; <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>; <span class=\"hljs-attribute\">float</span>: left; &#125;<br>    <span class=\"hljs-selector-id\">#main</span> &#123; <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">216px</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上实例在屏幕可视窗口尺寸大于480px像素时将菜单浮动到页面左侧；</p>\n<h2 id=\"CSS3-Flex布局\"><a href=\"#CSS3-Flex布局\" class=\"headerlink\" title=\"CSS3 Flex布局\"></a>CSS3 Flex布局</h2><p>弹性布局是CSS3的一种新布局模式，当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为布局方式，引入弹性布局模型的目的是提供一种更加有效地方式来对一个容器中的元素进行排列、对齐和分配空白空间；</p>\n<p>下面以例子来说明：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.flex-container</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">400px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">250px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background</span>: lightgray;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.flex-item</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-container&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"弹性容器布局属性\"><a href=\"#弹性容器布局属性\" class=\"headerlink\" title=\"弹性容器布局属性\"></a>弹性容器布局属性</h3><h4 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a>flex-direction</h4><p>指定了弹性子元素在父容器中的位置，值有：</p>\n<ul>\n<li>row：默认值，从左到右排列；</li>\n<li>row-reverse：反转横向排列，从右到左排列；</li>\n<li>column：纵向排列；</li>\n<li>column-reverse：反转纵向排列，从后往前排；</li>\n</ul>\n<h4 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h4><p>内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐，值有：</p>\n<ul>\n<li>flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。</li>\n<li>flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。</li>\n<li>center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。</li>\n<li>space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。</li>\n<li>space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。</li>\n</ul>\n<h4 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h4><p>设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式；值有：</p>\n<ul>\n<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>\n<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>\n<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>\n<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>\n<li>strench：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>\n</ul>\n<h4 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a>flex-wrap</h4><p>指定弹性盒子的子元素换行方式，值有：</p>\n<ul>\n<li>nowrap：默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>\n<li>wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse：反转 wrap 排列。</li>\n</ul>\n<h4 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a>align-content</h4><p>用于修改flex-wrap属性的行为，类似align-items，但它不是设置弹性子元素的对齐，而是设置各个行的对齐，值有：</p>\n<ul>\n<li>strench：默认。各行将会伸展以占用剩余的空间。</li>\n<li>flex-start：各行向弹性盒容器的起始位置堆叠。</li>\n<li>flex-end：各行向弹性盒容器的结束位置堆叠。</li>\n<li>center：各行向弹性盒容器的中间位置堆叠。</li>\n<li>space-between：各行在弹性盒容器中平均分布。</li>\n<li>space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。</li>\n</ul>\n<h3 id=\"弹性元素布局属性\"><a href=\"#弹性元素布局属性\" class=\"headerlink\" title=\"弹性元素布局属性\"></a>弹性元素布局属性</h3><h4 id=\"排序order\"><a href=\"#排序order\" class=\"headerlink\" title=\"排序order\"></a>排序order</h4><p>用整数值来定义排列顺序，数值小的排在前面，可以为负值；例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.flex-item</span><span class=\"hljs-selector-pseudo\">:first</span>-child &#123;<br>    <span class=\"hljs-attribute\">order</span>: -<span class=\"hljs-number\">1</span>;<br>    -webkit-<span class=\"hljs-attribute\">order</span>: -<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h4><p>设置margin值为auto，自动获取弹性容器中剩余空间，因此设置垂直方向margin值为’auto’</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.flex-item</span><span class=\"hljs-selector-pseudo\">:first</span>-child &#123;<br>    <span class=\"hljs-attribute\">margin-right</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"完美居中\"><a href=\"#完美居中\" class=\"headerlink\" title=\"完美居中\"></a>完美居中</h4><p>可以看出，使用弹性盒子后，居中变得非常简单。下面演示一下完美居中的实现方法；</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a>align-self</h4><p>用于设置弹性元素自身在纵轴方向上的对齐方式，值有：</p>\n<ul>\n<li>auto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。</li>\n<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>\n<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>\n<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>\n<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>\n<li>strench：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>\n</ul>\n<p>以下演示了不同值的效果，可以在<a href=\"https://codepen.io\">Code Pen</a>上直接试验：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">60px</span>;<br>    <span class=\"hljs-attribute\">min-height</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item1</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: flex-start;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: flex-start;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item2</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: flex-end;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: flex-end;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item3</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: center;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: center;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item4</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: baseline;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: baseline;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item5</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: strench;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: strench;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h4><p>用于指定弹性子元素如何分配空间，值有：</p>\n<ul>\n<li>auto：计算值为1 1 auto</li>\n<li>initial：计算值为0 1 auto</li>\n<li>none：计算值为0 0 auto</li>\n<li>inherit：从父元素继承</li>\n<li>flex-grow：定义弹性盒子元素的扩展比率</li>\n<li>flex-shrink：定义弹性盒子元素的搜索比率</li>\n<li>flex-basis：定义弹性盒子元素的默认基准值</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item1</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item2</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item3</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":7454,"excerpt":"","more":"<h1 id=\"CSS3-进阶操作\"><a href=\"#CSS3-进阶操作\" class=\"headerlink\" title=\"CSS3 进阶操作\"></a>CSS3 进阶操作</h1><h2 id=\"CSS3-边框\"><a href=\"#CSS3-边框\" class=\"headerlink\" title=\"CSS3 边框\"></a>CSS3 边框</h2><p>在CSS3中你可以创建圆角边框、阴影边框。属性如下：</p>\n<ul>\n<li>border-radius：边框圆角</li>\n<li>box-shadow：盒子阴影</li>\n<li>border-image：边框图片</li>\n</ul>\n<h2 id=\"CSS3-圆角\"><a href=\"#CSS3-圆角\" class=\"headerlink\" title=\"CSS3 圆角\"></a>CSS3 圆角</h2><p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#cornenr1</span> &#123;<br>  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">25px</span>;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#a8bcf4</span>;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;<br>&#125;<br><br><span class=\"hljs-selector-id\">#corner2</span> &#123;<br>  <span class=\"hljs-attribute\">border-radius</span>:<span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">50px</span> <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">5px</span>;<br>  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#fe5cb9</span>;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">10px</span>;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;<br>  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>可以发现第二个例子有四个值：顺序为：左上、右上、右下和左下；</p>\n<p>一个值就是默认四个角都是一样的，没什么毛病。</p>\n<p>初次之外还有其他属性，可以自己熟悉一下：</p>\n<ul>\n<li>border-top-left-radius</li>\n<li>border-top-right-radius</li>\n<li>border-bottom-left-radius</li>\n<li>border-bottom-right-radis</li>\n</ul>\n<h2 id=\"CSS3-背景\"><a href=\"#CSS3-背景\" class=\"headerlink\" title=\"CSS3 背景\"></a>CSS3 背景</h2><p>CSS3中新增几个背景属性，提供了更大背景元素控制；</p>\n<ul>\n<li>background-image：添加背景图片，不同背景用逗号分隔开；</li>\n<li>background-size：指定背景图像的大小；</li>\n<li>background-origin：指定背景图像的位置区域，有：border-box, padding-box和content-box;</li>\n<li>background-clip：从指定位置开始绘制背景图形；</li>\n</ul>\n<h2 id=\"CSS3-渐变\"><a href=\"#CSS3-渐变\" class=\"headerlink\" title=\"CSS3 渐变\"></a>CSS3 渐变</h2><p>可以在两个或者多个指定的颜色之间显示平稳的过渡，CSS3中定义了两种类型的渐变（gradients）：</p>\n<ul>\n<li>线性渐变：向上下左右对角方向</li>\n<li>径向渐变：由中心定义</li>\n</ul>\n<p>语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">linear-gradient</span>(direction, color-stop1, color-stop2, ...)<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">  direction: 默认上下，左右为to right</span><br><span class=\"hljs-comment\">  对角渐变：to bottom right</span><br><span class=\"hljs-comment\">  还可以使用角度：angle (这里指的是弧度)</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p>重复的线性渐变</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">repeating-linear-gradient</span>(red, yellow <span class=\"hljs-number\">10%</span>, green <span class=\"hljs-number\">20%</span>);<br></code></pre></td></tr></table></figure>\n<p>径向渐变</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">background-image</span>: <span class=\"hljs-built_in\">radial-gradient</span>(shape size at position, start-color, ... ,last-color);<br></code></pre></td></tr></table></figure>\n<p>shape参数定义了形状。可以是circle和ellipse，圆形和椭圆形；</p>\n<p>和重复地线性渐变一样，径向渐变也有重复地属性，这里就不再演示了。</p>\n<h2 id=\"CSS3-文本效果-amp-字体\"><a href=\"#CSS3-文本效果-amp-字体\" class=\"headerlink\" title=\"CSS3 文本效果 &amp; 字体\"></a>CSS3 文本效果 &amp; 字体</h2><p>文本效果包括下面的这几个：</p>\n<ul>\n<li>text-shadow：文本阴影，可以定义多个，可以做字体发光效果</li>\n<li>box-shadow：盒子阴影，可以定义多个，做成发光盒子</li>\n<li>text-overflow：指定用户如何显示溢出内容；</li>\n<li>word-wrap：自动换行属性允许强制文本换行，这意味着分裂它中间的一个字；</li>\n<li>word-break：单词拆分换行属性指定换行规则；</li>\n</ul>\n<p>需要使用自定义字体可以使用<code>@font-face</code>属性。例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@font-face</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: myFirstFont;<br>  <span class=\"hljs-attribute\">src</span> url(<span class=\"hljs-attribute\">font</span><span class=\"hljs-selector-class\">.ttf</span>);<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: myFirstFont;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-2D-amp-3D转换\"><a href=\"#CSS3-2D-amp-3D转换\" class=\"headerlink\" title=\"CSS3 2D &amp; 3D转换\"></a>CSS3 2D &amp; 3D转换</h2><h3 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a>2D转换</h3><p>2D变换方法有下面5种：</p>\n<ul>\n<li>translate：根据x轴和y轴位置给定的参数，从当前元素位置移动；</li>\n<li>rotate：在一个给定读书顺时针旋转元素，负值代表逆时针旋转；</li>\n<li>scale：该元素增加或者减少大小，取决于宽度（x轴）和高度（y轴）的参数；</li>\n<li>skew：表示x轴和y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负数表示像反方向倾斜；</li>\n<li>matrix：和2D变换方法合并成一个，一共有六个参数，包括：旋转、缩放、移动和倾斜的功能；</li>\n</ul>\n<p>具体语法可以再查阅</p>\n<h3 id=\"3D转换\"><a href=\"#3D转换\" class=\"headerlink\" title=\"3D转换\"></a>3D转换</h3><p>3D转换会使用到两个方法：</p>\n<ul>\n<li>rotateX：围绕其在一个给定度数X轴旋转的元素；</li>\n<li>rotateY：围绕其在一个给定读书Y轴旋转的元素；</li>\n</ul>\n<p>你也可以使用transform属性做2D和3D变换，一般来说建议使用transform属性，特别是在使用一些库来实现高级动画效果的时候；</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transform</span>: none | transform-functions;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">transform-functions包括：</span><br><span class=\"hljs-comment\">matrix, matrix3d;</span><br><span class=\"hljs-comment\">translate, translate3d, translateX, translateY, translateZ;</span><br><span class=\"hljs-comment\">scale, scale3d, scaleX, scaleY, scaleZ;</span><br><span class=\"hljs-comment\">rotate, rotate3d, rotateX, rotateY, rotateX;</span><br><span class=\"hljs-comment\">skew, skewX, skewY;</span><br><span class=\"hljs-comment\">perspective：为3D转换元素定义透视视图；</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-过渡\"><a href=\"#CSS3-过渡\" class=\"headerlink\" title=\"CSS3 过渡\"></a>CSS3 过渡</h2><p>CSS3过渡是元素从一种样式逐渐改变为另一种效果，要实现这一点，必须规定两项内容；</p>\n<ul>\n<li>指定要添加效果的CSS属性；</li>\n<li>指定效果的持续时间；</li>\n</ul>\n<p>例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>;<br>    -webkit-<span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>; <span class=\"hljs-comment\">/* Safari or Chrome */</span><br>&#125;<br><br><span class=\"hljs-comment\">/* 要添加多个样式的变换效果，可以使用逗号分隔属性 */</span><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">transition</span>: width <span class=\"hljs-number\">2s</span>, height <span class=\"hljs-number\">2s</span>, transform <span class=\"hljs-number\">2s</span>;<br>    -webkit-<span class=\"hljs-attribute\">transform</span>: width <span class=\"hljs-number\">2s</span>, height <span class=\"hljs-number\">2s</span>, transform <span class=\"hljs-number\">2s</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3-动画\"><a href=\"#CSS3-动画\" class=\"headerlink\" title=\"CSS3 动画\"></a>CSS3 动画</h2><p>CSS3可以创建动画，可以取代一些JavaScript实现的动画效果；</p>\n<p>CSS3使用<code>@keyframes</code>创建动画，语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@keyframes</span> myfirst &#123;<br>    <span class=\"hljs-selector-tag\">from</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-selector-tag\">to</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">@-webkit-keyframes</span> myfirst &#123;<br>    <span class=\"hljs-selector-tag\">from</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-selector-tag\">to</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">animation</span>: myfirst <span class=\"hljs-number\">5s</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 除此之外还可以这样定义 */</span><br><span class=\"hljs-keyword\">@keyframes</span> myfirst &#123;<br>    <span class=\"hljs-number\">0%</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-number\">25%</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>    <span class=\"hljs-number\">50%</span> &#123; <span class=\"hljs-attribute\">background</span>: blue; &#125;<br>    <span class=\"hljs-number\">100%</span> &#123; <span class=\"hljs-attribute\">background</span>: green; &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">@-webkit-keyframes</span> myfirst &#123;<br>    <span class=\"hljs-number\">0%</span> &#123; <span class=\"hljs-attribute\">background</span>: red; &#125;<br>    <span class=\"hljs-number\">25%</span> &#123; <span class=\"hljs-attribute\">background</span>: yellow; &#125;<br>    <span class=\"hljs-number\">50%</span> &#123; <span class=\"hljs-attribute\">background</span>: blue; &#125;<br>    <span class=\"hljs-number\">100%</span> &#123; <span class=\"hljs-attribute\">background</span>: green; &#125;<br>&#125;<br><br><span class=\"hljs-selector-tag\">div</span> &#123;<br>    <span class=\"hljs-attribute\">animation</span>: myfirst <span class=\"hljs-number\">5s</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"CSS3媒体查询\"><a href=\"#CSS3媒体查询\" class=\"headerlink\" title=\"CSS3媒体查询\"></a>CSS3媒体查询</h2><p>顾名思义，针对不同媒体类型的设备定制不同的样式规则，例如：手机、电视、平板、电脑以及阅读器设置不同的样式规则；语法如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">not</span> | <span class=\"hljs-keyword\">only</span> mediatype <span class=\"hljs-keyword\">and</span> (expression) &#123;<br>    <span class=\"hljs-comment\">/* Write CSS Code here... */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>解释一下参数的含义：</p>\n<ul>\n<li>not：用于排除某些特定设备的；</li>\n<li>only：用来指定某种特别的媒体设备；</li>\n<li>all：适用于所有媒体设备，这个最常见；</li>\n</ul>\n<p>举个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">480px</span>) &#123;<br>    <span class=\"hljs-selector-id\">#leftsidebar</span> &#123; <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>; <span class=\"hljs-attribute\">float</span>: left; &#125;<br>    <span class=\"hljs-selector-id\">#main</span> &#123; <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">216px</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上实例在屏幕可视窗口尺寸大于480px像素时将菜单浮动到页面左侧；</p>\n<h2 id=\"CSS3-Flex布局\"><a href=\"#CSS3-Flex布局\" class=\"headerlink\" title=\"CSS3 Flex布局\"></a>CSS3 Flex布局</h2><p>弹性布局是CSS3的一种新布局模式，当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为布局方式，引入弹性布局模型的目的是提供一种更加有效地方式来对一个容器中的元素进行排列、对齐和分配空白空间；</p>\n<p>下面以例子来说明：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.flex-container</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">400px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">250px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background</span>: lightgray;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">            </span><br><span class=\"language-css\">            <span class=\"hljs-selector-class\">.flex-item</span> &#123;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">                <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            &#125;</span><br><span class=\"language-css\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-container&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;flex-item&quot;</span>&gt;</span>flex item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"弹性容器布局属性\"><a href=\"#弹性容器布局属性\" class=\"headerlink\" title=\"弹性容器布局属性\"></a>弹性容器布局属性</h3><h4 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a>flex-direction</h4><p>指定了弹性子元素在父容器中的位置，值有：</p>\n<ul>\n<li>row：默认值，从左到右排列；</li>\n<li>row-reverse：反转横向排列，从右到左排列；</li>\n<li>column：纵向排列；</li>\n<li>column-reverse：反转纵向排列，从后往前排；</li>\n</ul>\n<h4 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h4><p>内容对齐属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线对齐，值有：</p>\n<ul>\n<li>flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。</li>\n<li>flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。</li>\n<li>center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。</li>\n<li>space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。</li>\n<li>space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。</li>\n</ul>\n<h4 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h4><p>设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式；值有：</p>\n<ul>\n<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>\n<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>\n<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>\n<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>\n<li>strench：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>\n</ul>\n<h4 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a>flex-wrap</h4><p>指定弹性盒子的子元素换行方式，值有：</p>\n<ul>\n<li>nowrap：默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>\n<li>wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse：反转 wrap 排列。</li>\n</ul>\n<h4 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a>align-content</h4><p>用于修改flex-wrap属性的行为，类似align-items，但它不是设置弹性子元素的对齐，而是设置各个行的对齐，值有：</p>\n<ul>\n<li>strench：默认。各行将会伸展以占用剩余的空间。</li>\n<li>flex-start：各行向弹性盒容器的起始位置堆叠。</li>\n<li>flex-end：各行向弹性盒容器的结束位置堆叠。</li>\n<li>center：各行向弹性盒容器的中间位置堆叠。</li>\n<li>space-between：各行在弹性盒容器中平均分布。</li>\n<li>space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。</li>\n</ul>\n<h3 id=\"弹性元素布局属性\"><a href=\"#弹性元素布局属性\" class=\"headerlink\" title=\"弹性元素布局属性\"></a>弹性元素布局属性</h3><h4 id=\"排序order\"><a href=\"#排序order\" class=\"headerlink\" title=\"排序order\"></a>排序order</h4><p>用整数值来定义排列顺序，数值小的排在前面，可以为负值；例子如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.flex-item</span><span class=\"hljs-selector-pseudo\">:first</span>-child &#123;<br>    <span class=\"hljs-attribute\">order</span>: -<span class=\"hljs-number\">1</span>;<br>    -webkit-<span class=\"hljs-attribute\">order</span>: -<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h4><p>设置margin值为auto，自动获取弹性容器中剩余空间，因此设置垂直方向margin值为’auto’</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.flex-item</span><span class=\"hljs-selector-pseudo\">:first</span>-child &#123;<br>    <span class=\"hljs-attribute\">margin-right</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"完美居中\"><a href=\"#完美居中\" class=\"headerlink\" title=\"完美居中\"></a>完美居中</h4><p>可以看出，使用弹性盒子后，居中变得非常简单。下面演示一下完美居中的实现方法；</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">75px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a>align-self</h4><p>用于设置弹性元素自身在纵轴方向上的对齐方式，值有：</p>\n<ul>\n<li>auto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。</li>\n<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>\n<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>\n<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>\n<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>\n<li>strench：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>\n</ul>\n<p>以下演示了不同值的效果，可以在<a href=\"https://codepen.io\">Code Pen</a>上直接试验：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">60px</span>;<br>    <span class=\"hljs-attribute\">min-height</span>: <span class=\"hljs-number\">100px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item1</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: flex-start;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: flex-start;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item2</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: flex-end;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: flex-end;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item3</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: center;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: center;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item4</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: baseline;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: baseline;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item5</span> &#123;<br>    <span class=\"hljs-attribute\">align-self</span>: strench;<br>    -webkit-<span class=\"hljs-attribute\">align-self</span>: strench;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h4><p>用于指定弹性子元素如何分配空间，值有：</p>\n<ul>\n<li>auto：计算值为1 1 auto</li>\n<li>initial：计算值为0 1 auto</li>\n<li>none：计算值为0 0 auto</li>\n<li>inherit：从父元素继承</li>\n<li>flex-grow：定义弹性盒子元素的扩展比率</li>\n<li>flex-shrink：定义弹性盒子元素的搜索比率</li>\n<li>flex-basis：定义弹性盒子元素的默认基准值</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.flex-item</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: cornflowerblue;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item1</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item2</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.item3</span> &#123;<br>    -webkit-<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"CSS3之Sass学习","date":"2022-02-18T12:50:30.000Z","updated":"2022-02-18T12:50:30.000Z","_content":"\n# Sass 基本教程\n\n## 简介\n\nSass一个CSS预处理器，属于CSS的扩展语言，因此语法完全兼容CSS；最早是由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass全称（Syntactically Awesome Stylesheets）\n\nSass的文件后缀为`.scss`，因此Scss生成的格式化良好的代码，易于组织和维护；出现Scss的原因是CSS原本的语法不够强大，导致重复编写一些代码，无法实现复用，而且维护起来也不方便；\n\n## 环境安装\n\n安装也非常简单，可以用NPM来安装，如果是苹果用户可以用Homebrew；\n\n```sh\n$ npm install -g sass\n\n$ brew install sass/sass/sass\n```\n\n## 语法\n\n### 基础示例\n\n安装好scss后就可以使用了，可以贴上一个例子：\n\n```scss\n$bgcolor: lightblue;\n$textcolor: darkblue;\n$fontsize: 18px;\n\nbody {\n    background-color: $bgcolor;\n    color: $textcolor;\n    font-size: $fontsize;\n}\n```\n\n### 变量\n\n变量用于存储一些信息，它可以重复使用，可以存储以下信息：\n\n- 字符串\n- 数字\n- 颜色值\n- 布尔值\n- 列表\n- null值\n\nSass变量使用`$`符号，Sass变量的作用域只能在当前层级上有效果\n\n如果要设置全局作用域，可以使用`!global`关键词来设置，例子如下：\n\n```scss\n$myColor: red;\n\nh1 {\n    $myColor: green !global;\n    color: $myColor;\n}\n```\n\n## 嵌套规则与属性\n\nSass嵌套CSS选择器类似于HTML的嵌套规则，例如：\n\n```scss\nnav {\n    ul {\n        margin: 0;\n        padding: 0;\n        list-style: none;\n    }\n    \n    li {\n        display: inline-block;\n    }\n    \n    a {\n        display: block;\n        padding: 6px 12px;\n        text-decoration: none;\n    }\n}\n```\n\n很多CSS属性都有同样的前缀，例如font-family，font-size和font-weight，text-align，text-transform和text-overflow，在Sass中可以使用嵌套属性来编写，例如：\n\n```scss\nfont: {\n    family: Helvetica, sans-serif;\n    size: 18px;\n    weight: bold;\n}\n\ntext: {\n    align: center;\n    transform: lowercase;\n    overflow: hidden;\n}\n```\n\n以上代码会被转换成如下：\n\n```css\nfont-family: Helvetica, sans-serif;\nfont-size: 18px;\nfont-weight: bold;\n\ntext-align: center;\ntext-transform: lowercase;\ntext-overflow: hidden;\n```\n\n## @import 和 Partials\n\n### @import\n\nSass可以帮助减少重复的CSS代码，节省开发时间。\n\n类似CSS，Sass支持`@import`指令，可以让我们导入其他文件等内容；例如：\n\n创建一个`reset.scss`文件\n\n```scss\nhtml,\nbody,\nul,\nol {\n    margin: 0;\n    padding: 0;\n}\n```\n\n然后在`standard.scss`文件中使用`@import`指令导入`reser.scss`文件；\n\n```scss\n@import \"reset\";\n\nbody {\n    font-family: Helvetica, sans-serif;\n    font-size: 18px;\n    color: red;\n}\n```\n\n### Partials\n\n如果你不希望将一个Sass代码编译到CSS文件中，可以在文件名的开头添加一个下划线。这将告诉Sass不要将Sass编译到CSS文件中。\n\n例如我创建一个`_colors.sass`文件，但是不会被编译成`_colors.css`；\n\n```scss\n$myPink: #ee82ee;\n$myBlue: #4169e1;\n$myGreen: #8fbc8f;\n```\n\n如果需要导入该文件，则不需要使用下划线；\n\n```scss\n@import \"colors\";\n\nbody {\n    font-family: Helvetica, sans-serif;\n    font-size: 18px;\n    color: $myBlue;\n}\n```\n\n需要注意的是：不要将待下划线与不带下划线的同名文件放置在同一个文件目录下，比如：`_colors.scss`和`colors.scss`不能同时存在于一个目录下，否则带下划线的文件将会被忽略；\n\n## @mixin 和 @include\n\n`@mixin`指令允许我们定义一个可以在争个光样式表中重复使用的样式，语法为`@mixin name {property: value}`\n\n```scss\n@mixin important-text {\n    color: red;\n    font-size: 25px;\n    font-weight: bold;\n    border: 1px solid blue;\n}\n```\n\n`@include`指令可以将混入（mixin）引入文档中；同样地，包含important-text混入代码如下：\n\n```scss\n.danger {\n    @include important-text;\n    background-color: green;\n}\n```\n\n除此之外，混入可以接收参数，我们可以向混入传递变量，定义可以接收参数的混入：\n\n```scss\n@mixin bordered($color, $width) {\n    border: $width solid $color;\n}\n\n.myArticle {\n    @include bordered(blue, 1px);\n}\n\n.myNotes {\n    @include bordered(red, 2px);\n}\n```\n\n除此之外，混入也可以定义默认值，语法格式如下：\n\n```scss\n@mixin bordered($color: blue, $width: 1px) {\n    border: $width solid $color;\n}\n```\n\n有时候不能确定混入（mixin）或者一个函数（function）使用多少个参数，这个时候我们就可以使用`...`来设置可变参数，例如：\n\n```scss\n@mixin box-shadow($shadows...) {\n    -moz-box-shadow: $shadows;\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n}\n\n.shadows {\n    @include: box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n浏览器前缀使用混入也是十分方便的；\n\n```scss\n@mixin transform($property) {\n    -webkit-transform: $property;\n    -ms-transform: $property;\n    transform: $property;\n}\n\n.myBox {\n    @include: transform(rotate(20deg));\n}\n```\n\n## @extend 和继承\n\n`@extend`指令告诉Sass一个选择器的样式从另一个选择器继承；\n\n如果一个样式与另一个样式几乎相同，只有少量区别，则使用@extend就显得更有用；例如：\n\n```scss\n.button-basic {\n    border: none;\n    padding: 15px 30px;\n    text-align: center;\n    font-size: 16px;\n    cursor: pointer;\n}\n\n.button-reporter {\n    @extend .button-basic;\n    background-color: red;\n}\n\n.button-submit {\n    @extend .button-basic;\n    background-color: green;\n    color: white;\n}\n```\n\n通过将公共代码抽离出来公用给其他CSS样式从而实现代码的复用，真棒；\n\n## Sass函数\n\nSass定义了各种类型的函数，可以通过CSS语句直接调用；这里就不再赘述，有需要可以自行查询文档了解；\n\n- 字符串相关函数\n- 数字相关函数\n- 列表相关函数\n- 映射相关函数\n- 选择器相关函数\n- Introspection相关函数\n- 颜色相关函数\n","source":"_posts/frontend/css3/css3-ch03.md","raw":"---\ntitle: CSS3之Sass学习\ndate: 2022-02-18 20:50:30\nupdated: 2022-02-18 20:50:30\ntags: CSS3\ncategories: 前端\n---\n\n# Sass 基本教程\n\n## 简介\n\nSass一个CSS预处理器，属于CSS的扩展语言，因此语法完全兼容CSS；最早是由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass全称（Syntactically Awesome Stylesheets）\n\nSass的文件后缀为`.scss`，因此Scss生成的格式化良好的代码，易于组织和维护；出现Scss的原因是CSS原本的语法不够强大，导致重复编写一些代码，无法实现复用，而且维护起来也不方便；\n\n## 环境安装\n\n安装也非常简单，可以用NPM来安装，如果是苹果用户可以用Homebrew；\n\n```sh\n$ npm install -g sass\n\n$ brew install sass/sass/sass\n```\n\n## 语法\n\n### 基础示例\n\n安装好scss后就可以使用了，可以贴上一个例子：\n\n```scss\n$bgcolor: lightblue;\n$textcolor: darkblue;\n$fontsize: 18px;\n\nbody {\n    background-color: $bgcolor;\n    color: $textcolor;\n    font-size: $fontsize;\n}\n```\n\n### 变量\n\n变量用于存储一些信息，它可以重复使用，可以存储以下信息：\n\n- 字符串\n- 数字\n- 颜色值\n- 布尔值\n- 列表\n- null值\n\nSass变量使用`$`符号，Sass变量的作用域只能在当前层级上有效果\n\n如果要设置全局作用域，可以使用`!global`关键词来设置，例子如下：\n\n```scss\n$myColor: red;\n\nh1 {\n    $myColor: green !global;\n    color: $myColor;\n}\n```\n\n## 嵌套规则与属性\n\nSass嵌套CSS选择器类似于HTML的嵌套规则，例如：\n\n```scss\nnav {\n    ul {\n        margin: 0;\n        padding: 0;\n        list-style: none;\n    }\n    \n    li {\n        display: inline-block;\n    }\n    \n    a {\n        display: block;\n        padding: 6px 12px;\n        text-decoration: none;\n    }\n}\n```\n\n很多CSS属性都有同样的前缀，例如font-family，font-size和font-weight，text-align，text-transform和text-overflow，在Sass中可以使用嵌套属性来编写，例如：\n\n```scss\nfont: {\n    family: Helvetica, sans-serif;\n    size: 18px;\n    weight: bold;\n}\n\ntext: {\n    align: center;\n    transform: lowercase;\n    overflow: hidden;\n}\n```\n\n以上代码会被转换成如下：\n\n```css\nfont-family: Helvetica, sans-serif;\nfont-size: 18px;\nfont-weight: bold;\n\ntext-align: center;\ntext-transform: lowercase;\ntext-overflow: hidden;\n```\n\n## @import 和 Partials\n\n### @import\n\nSass可以帮助减少重复的CSS代码，节省开发时间。\n\n类似CSS，Sass支持`@import`指令，可以让我们导入其他文件等内容；例如：\n\n创建一个`reset.scss`文件\n\n```scss\nhtml,\nbody,\nul,\nol {\n    margin: 0;\n    padding: 0;\n}\n```\n\n然后在`standard.scss`文件中使用`@import`指令导入`reser.scss`文件；\n\n```scss\n@import \"reset\";\n\nbody {\n    font-family: Helvetica, sans-serif;\n    font-size: 18px;\n    color: red;\n}\n```\n\n### Partials\n\n如果你不希望将一个Sass代码编译到CSS文件中，可以在文件名的开头添加一个下划线。这将告诉Sass不要将Sass编译到CSS文件中。\n\n例如我创建一个`_colors.sass`文件，但是不会被编译成`_colors.css`；\n\n```scss\n$myPink: #ee82ee;\n$myBlue: #4169e1;\n$myGreen: #8fbc8f;\n```\n\n如果需要导入该文件，则不需要使用下划线；\n\n```scss\n@import \"colors\";\n\nbody {\n    font-family: Helvetica, sans-serif;\n    font-size: 18px;\n    color: $myBlue;\n}\n```\n\n需要注意的是：不要将待下划线与不带下划线的同名文件放置在同一个文件目录下，比如：`_colors.scss`和`colors.scss`不能同时存在于一个目录下，否则带下划线的文件将会被忽略；\n\n## @mixin 和 @include\n\n`@mixin`指令允许我们定义一个可以在争个光样式表中重复使用的样式，语法为`@mixin name {property: value}`\n\n```scss\n@mixin important-text {\n    color: red;\n    font-size: 25px;\n    font-weight: bold;\n    border: 1px solid blue;\n}\n```\n\n`@include`指令可以将混入（mixin）引入文档中；同样地，包含important-text混入代码如下：\n\n```scss\n.danger {\n    @include important-text;\n    background-color: green;\n}\n```\n\n除此之外，混入可以接收参数，我们可以向混入传递变量，定义可以接收参数的混入：\n\n```scss\n@mixin bordered($color, $width) {\n    border: $width solid $color;\n}\n\n.myArticle {\n    @include bordered(blue, 1px);\n}\n\n.myNotes {\n    @include bordered(red, 2px);\n}\n```\n\n除此之外，混入也可以定义默认值，语法格式如下：\n\n```scss\n@mixin bordered($color: blue, $width: 1px) {\n    border: $width solid $color;\n}\n```\n\n有时候不能确定混入（mixin）或者一个函数（function）使用多少个参数，这个时候我们就可以使用`...`来设置可变参数，例如：\n\n```scss\n@mixin box-shadow($shadows...) {\n    -moz-box-shadow: $shadows;\n    -webkit-box-shadow: $shadows;\n    box-shadow: $shadows;\n}\n\n.shadows {\n    @include: box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n浏览器前缀使用混入也是十分方便的；\n\n```scss\n@mixin transform($property) {\n    -webkit-transform: $property;\n    -ms-transform: $property;\n    transform: $property;\n}\n\n.myBox {\n    @include: transform(rotate(20deg));\n}\n```\n\n## @extend 和继承\n\n`@extend`指令告诉Sass一个选择器的样式从另一个选择器继承；\n\n如果一个样式与另一个样式几乎相同，只有少量区别，则使用@extend就显得更有用；例如：\n\n```scss\n.button-basic {\n    border: none;\n    padding: 15px 30px;\n    text-align: center;\n    font-size: 16px;\n    cursor: pointer;\n}\n\n.button-reporter {\n    @extend .button-basic;\n    background-color: red;\n}\n\n.button-submit {\n    @extend .button-basic;\n    background-color: green;\n    color: white;\n}\n```\n\n通过将公共代码抽离出来公用给其他CSS样式从而实现代码的复用，真棒；\n\n## Sass函数\n\nSass定义了各种类型的函数，可以通过CSS语句直接调用；这里就不再赘述，有需要可以自行查询文档了解；\n\n- 字符串相关函数\n- 数字相关函数\n- 列表相关函数\n- 映射相关函数\n- 选择器相关函数\n- Introspection相关函数\n- 颜色相关函数\n","slug":"frontend/css3/css3-ch03","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckztvdl3k00352y61hlpo7mdq","content":"<h1 id=\"Sass-基本教程\"><a href=\"#Sass-基本教程\" class=\"headerlink\" title=\"Sass 基本教程\"></a>Sass 基本教程</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sass一个CSS预处理器，属于CSS的扩展语言，因此语法完全兼容CSS；最早是由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass全称（Syntactically Awesome Stylesheets）</p>\n<p>Sass的文件后缀为<code>.scss</code>，因此Scss生成的格式化良好的代码，易于组织和维护；出现Scss的原因是CSS原本的语法不够强大，导致重复编写一些代码，无法实现复用，而且维护起来也不方便；</p>\n<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><p>安装也非常简单，可以用NPM来安装，如果是苹果用户可以用Homebrew；</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs sh\">$ npm install -g sass<br><br>$ brew install sass/sass/sass<br></code></pre></td></tr></table></figure>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h3><p>安装好scss后就可以使用了，可以贴上一个例子：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$bgcolor</span>: lightblue;<br><span class=\"hljs-variable\">$textcolor</span>: darkblue;<br><span class=\"hljs-variable\">$fontsize</span>: <span class=\"hljs-number\">18px</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-variable\">$bgcolor</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$textcolor</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-variable\">$fontsize</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>变量用于存储一些信息，它可以重复使用，可以存储以下信息：</p>\n<ul>\n<li>字符串</li>\n<li>数字</li>\n<li>颜色值</li>\n<li>布尔值</li>\n<li>列表</li>\n<li>null值</li>\n</ul>\n<p>Sass变量使用<code>$</code>符号，Sass变量的作用域只能在当前层级上有效果</p>\n<p>如果要设置全局作用域，可以使用<code>!global</code>关键词来设置，例子如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$myColor</span>: red;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>    <span class=\"hljs-variable\">$myColor</span>: green !global;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$myColor</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"嵌套规则与属性\"><a href=\"#嵌套规则与属性\" class=\"headerlink\" title=\"嵌套规则与属性\"></a>嵌套规则与属性</h2><p>Sass嵌套CSS选择器类似于HTML的嵌套规则，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">nav</span> &#123;<br>    <span class=\"hljs-selector-tag\">ul</span> &#123;<br>        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-attribute\">list-style</span>: none;<br>    &#125;<br>    <br>    <span class=\"hljs-selector-tag\">li</span> &#123;<br>        <span class=\"hljs-attribute\">display</span>: inline-block;<br>    &#125;<br>    <br>    <span class=\"hljs-selector-tag\">a</span> &#123;<br>        <span class=\"hljs-attribute\">display</span>: block;<br>        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">12px</span>;<br>        <span class=\"hljs-attribute\">text-decoration</span>: none;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>很多CSS属性都有同样的前缀，例如font-family，font-size和font-weight，text-align，text-transform和text-overflow，在Sass中可以使用嵌套属性来编写，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-attribute\">font</span>: &#123;<br>    family: Helvetica, sans-serif;<br>    size: <span class=\"hljs-number\">18px</span>;<br>    weight: bold;<br>&#125;<br><br>text: &#123;<br>    align: center;<br>    <span class=\"hljs-attribute\">transform</span>: lowercase;<br>    <span class=\"hljs-attribute\">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上代码会被转换成如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br><span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br><span class=\"hljs-attribute\">font-weight</span>: bold;<br><br><span class=\"hljs-attribute\">text-align</span>: center;<br><span class=\"hljs-attribute\">text-transform</span>: lowercase;<br><span class=\"hljs-attribute\">text-overflow</span>: hidden;<br></code></pre></td></tr></table></figure>\n<h2 id=\"import-和-Partials\"><a href=\"#import-和-Partials\" class=\"headerlink\" title=\"@import 和 Partials\"></a>@import 和 Partials</h2><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"@import\"></a>@import</h3><p>Sass可以帮助减少重复的CSS代码，节省开发时间。</p>\n<p>类似CSS，Sass支持<code>@import</code>指令，可以让我们导入其他文件等内容；例如：</p>\n<p>创建一个<code>reset.scss</code>文件</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">html</span>,<br><span class=\"hljs-selector-tag\">body</span>,<br><span class=\"hljs-selector-tag\">ul</span>,<br><span class=\"hljs-selector-tag\">ol</span> &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>然后在<code>standard.scss</code>文件中使用<code>@import</code>指令导入<code>reser.scss</code>文件；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;reset&quot;</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Partials\"><a href=\"#Partials\" class=\"headerlink\" title=\"Partials\"></a>Partials</h3><p>如果你不希望将一个Sass代码编译到CSS文件中，可以在文件名的开头添加一个下划线。这将告诉Sass不要将Sass编译到CSS文件中。</p>\n<p>例如我创建一个<code>_colors.sass</code>文件，但是不会被编译成<code>_colors.css</code>；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$myPink</span>: <span class=\"hljs-number\">#ee82ee</span>;<br><span class=\"hljs-variable\">$myBlue</span>: <span class=\"hljs-number\">#4169e1</span>;<br><span class=\"hljs-variable\">$myGreen</span>: <span class=\"hljs-number\">#8fbc8f</span>;<br></code></pre></td></tr></table></figure>\n<p>如果需要导入该文件，则不需要使用下划线；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;colors&quot;</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$myBlue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：不要将待下划线与不带下划线的同名文件放置在同一个文件目录下，比如：<code>_colors.scss</code>和<code>colors.scss</code>不能同时存在于一个目录下，否则带下划线的文件将会被忽略；</p>\n<h2 id=\"mixin-和-include\"><a href=\"#mixin-和-include\" class=\"headerlink\" title=\"@mixin 和 @include\"></a>@mixin 和 @include</h2><p><code>@mixin</code>指令允许我们定义一个可以在争个光样式表中重复使用的样式，语法为<code>@mixin name &#123;property: value&#125;</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> important-text &#123;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">25px</span>;<br>    <span class=\"hljs-attribute\">font-weight</span>: bold;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>@include</code>指令可以将混入（mixin）引入文档中；同样地，包含important-text混入代码如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.danger</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> important-text;<br>    <span class=\"hljs-attribute\">background-color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，混入可以接收参数，我们可以向混入传递变量，定义可以接收参数的混入：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> bordered(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-variable\">$width</span>) &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-variable\">$width</span> solid <span class=\"hljs-variable\">$color</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.myArticle</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> bordered(blue, <span class=\"hljs-number\">1px</span>);<br>&#125;<br><br><span class=\"hljs-selector-class\">.myNotes</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> bordered(red, <span class=\"hljs-number\">2px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，混入也可以定义默认值，语法格式如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> bordered(<span class=\"hljs-variable\">$color</span>: blue, <span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">1px</span>) &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-variable\">$width</span> solid <span class=\"hljs-variable\">$color</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>有时候不能确定混入（mixin）或者一个函数（function）使用多少个参数，这个时候我们就可以使用<code>...</code>来设置可变参数，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> box-shadow(<span class=\"hljs-variable\">$shadows</span>...) &#123;<br>    -moz-<span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>    -webkit-<span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>    <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.shadows</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span>: box-shadow(<span class=\"hljs-number\">0px</span> <span class=\"hljs-number\">4px</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">#666</span>, <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">#999</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>浏览器前缀使用混入也是十分方便的；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> transform(<span class=\"hljs-variable\">$property</span>) &#123;<br>    -webkit-<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>    -ms-<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.myBox</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span>: transform(rotate(<span class=\"hljs-number\">20deg</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"extend-和继承\"><a href=\"#extend-和继承\" class=\"headerlink\" title=\"@extend 和继承\"></a>@extend 和继承</h2><p><code>@extend</code>指令告诉Sass一个选择器的样式从另一个选择器继承；</p>\n<p>如果一个样式与另一个样式几乎相同，只有少量区别，则使用@extend就显得更有用；例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.button-basic</span> &#123;<br>    <span class=\"hljs-attribute\">border</span>: none;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>;<br>    <span class=\"hljs-attribute\">text-align</span>: center;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;<br>    <span class=\"hljs-attribute\">cursor</span>: pointer;<br>&#125;<br><br><span class=\"hljs-selector-class\">.button-reporter</span> &#123;<br>    <span class=\"hljs-keyword\">@extend</span> .button-basic;<br>    <span class=\"hljs-attribute\">background-color</span>: red;<br>&#125;<br><br><span class=\"hljs-selector-class\">.button-submit</span> &#123;<br>    <span class=\"hljs-keyword\">@extend</span> .button-basic;<br>    <span class=\"hljs-attribute\">background-color</span>: green;<br>    <span class=\"hljs-attribute\">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通过将公共代码抽离出来公用给其他CSS样式从而实现代码的复用，真棒；</p>\n<h2 id=\"Sass函数\"><a href=\"#Sass函数\" class=\"headerlink\" title=\"Sass函数\"></a>Sass函数</h2><p>Sass定义了各种类型的函数，可以通过CSS语句直接调用；这里就不再赘述，有需要可以自行查询文档了解；</p>\n<ul>\n<li>字符串相关函数</li>\n<li>数字相关函数</li>\n<li>列表相关函数</li>\n<li>映射相关函数</li>\n<li>选择器相关函数</li>\n<li>Introspection相关函数</li>\n<li>颜色相关函数</li>\n</ul>\n","site":{"data":{}},"wordcount":3588,"excerpt":"","more":"<h1 id=\"Sass-基本教程\"><a href=\"#Sass-基本教程\" class=\"headerlink\" title=\"Sass 基本教程\"></a>Sass 基本教程</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sass一个CSS预处理器，属于CSS的扩展语言，因此语法完全兼容CSS；最早是由Hampton Catlin设计并由Natalie Weizenbaum开发的层叠样式表语言。Sass全称（Syntactically Awesome Stylesheets）</p>\n<p>Sass的文件后缀为<code>.scss</code>，因此Scss生成的格式化良好的代码，易于组织和维护；出现Scss的原因是CSS原本的语法不够强大，导致重复编写一些代码，无法实现复用，而且维护起来也不方便；</p>\n<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><p>安装也非常简单，可以用NPM来安装，如果是苹果用户可以用Homebrew；</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ npm install -g sass<br><br>$ brew install sass/sass/sass<br></code></pre></td></tr></table></figure>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h3><p>安装好scss后就可以使用了，可以贴上一个例子：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$bgcolor</span>: lightblue;<br><span class=\"hljs-variable\">$textcolor</span>: darkblue;<br><span class=\"hljs-variable\">$fontsize</span>: <span class=\"hljs-number\">18px</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-variable\">$bgcolor</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$textcolor</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-variable\">$fontsize</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>变量用于存储一些信息，它可以重复使用，可以存储以下信息：</p>\n<ul>\n<li>字符串</li>\n<li>数字</li>\n<li>颜色值</li>\n<li>布尔值</li>\n<li>列表</li>\n<li>null值</li>\n</ul>\n<p>Sass变量使用<code>$</code>符号，Sass变量的作用域只能在当前层级上有效果</p>\n<p>如果要设置全局作用域，可以使用<code>!global</code>关键词来设置，例子如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$myColor</span>: red;<br><br><span class=\"hljs-selector-tag\">h1</span> &#123;<br>    <span class=\"hljs-variable\">$myColor</span>: green !global;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$myColor</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"嵌套规则与属性\"><a href=\"#嵌套规则与属性\" class=\"headerlink\" title=\"嵌套规则与属性\"></a>嵌套规则与属性</h2><p>Sass嵌套CSS选择器类似于HTML的嵌套规则，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">nav</span> &#123;<br>    <span class=\"hljs-selector-tag\">ul</span> &#123;<br>        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-attribute\">list-style</span>: none;<br>    &#125;<br>    <br>    <span class=\"hljs-selector-tag\">li</span> &#123;<br>        <span class=\"hljs-attribute\">display</span>: inline-block;<br>    &#125;<br>    <br>    <span class=\"hljs-selector-tag\">a</span> &#123;<br>        <span class=\"hljs-attribute\">display</span>: block;<br>        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">12px</span>;<br>        <span class=\"hljs-attribute\">text-decoration</span>: none;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>很多CSS属性都有同样的前缀，例如font-family，font-size和font-weight，text-align，text-transform和text-overflow，在Sass中可以使用嵌套属性来编写，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-attribute\">font</span>: &#123;<br>    family: Helvetica, sans-serif;<br>    size: <span class=\"hljs-number\">18px</span>;<br>    weight: bold;<br>&#125;<br><br>text: &#123;<br>    align: center;<br>    <span class=\"hljs-attribute\">transform</span>: lowercase;<br>    <span class=\"hljs-attribute\">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>以上代码会被转换成如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br><span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br><span class=\"hljs-attribute\">font-weight</span>: bold;<br><br><span class=\"hljs-attribute\">text-align</span>: center;<br><span class=\"hljs-attribute\">text-transform</span>: lowercase;<br><span class=\"hljs-attribute\">text-overflow</span>: hidden;<br></code></pre></td></tr></table></figure>\n<h2 id=\"import-和-Partials\"><a href=\"#import-和-Partials\" class=\"headerlink\" title=\"@import 和 Partials\"></a>@import 和 Partials</h2><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"@import\"></a>@import</h3><p>Sass可以帮助减少重复的CSS代码，节省开发时间。</p>\n<p>类似CSS，Sass支持<code>@import</code>指令，可以让我们导入其他文件等内容；例如：</p>\n<p>创建一个<code>reset.scss</code>文件</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-tag\">html</span>,<br><span class=\"hljs-selector-tag\">body</span>,<br><span class=\"hljs-selector-tag\">ul</span>,<br><span class=\"hljs-selector-tag\">ol</span> &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>然后在<code>standard.scss</code>文件中使用<code>@import</code>指令导入<code>reser.scss</code>文件；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;reset&quot;</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Partials\"><a href=\"#Partials\" class=\"headerlink\" title=\"Partials\"></a>Partials</h3><p>如果你不希望将一个Sass代码编译到CSS文件中，可以在文件名的开头添加一个下划线。这将告诉Sass不要将Sass编译到CSS文件中。</p>\n<p>例如我创建一个<code>_colors.sass</code>文件，但是不会被编译成<code>_colors.css</code>；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-variable\">$myPink</span>: <span class=\"hljs-number\">#ee82ee</span>;<br><span class=\"hljs-variable\">$myBlue</span>: <span class=\"hljs-number\">#4169e1</span>;<br><span class=\"hljs-variable\">$myGreen</span>: <span class=\"hljs-number\">#8fbc8f</span>;<br></code></pre></td></tr></table></figure>\n<p>如果需要导入该文件，则不需要使用下划线；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&quot;colors&quot;</span>;<br><br><span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">font-family</span>: Helvetica, sans-serif;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$myBlue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>需要注意的是：不要将待下划线与不带下划线的同名文件放置在同一个文件目录下，比如：<code>_colors.scss</code>和<code>colors.scss</code>不能同时存在于一个目录下，否则带下划线的文件将会被忽略；</p>\n<h2 id=\"mixin-和-include\"><a href=\"#mixin-和-include\" class=\"headerlink\" title=\"@mixin 和 @include\"></a>@mixin 和 @include</h2><p><code>@mixin</code>指令允许我们定义一个可以在争个光样式表中重复使用的样式，语法为<code>@mixin name &#123;property: value&#125;</code></p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> important-text &#123;<br>    <span class=\"hljs-attribute\">color</span>: red;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">25px</span>;<br>    <span class=\"hljs-attribute\">font-weight</span>: bold;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>@include</code>指令可以将混入（mixin）引入文档中；同样地，包含important-text混入代码如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.danger</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> important-text;<br>    <span class=\"hljs-attribute\">background-color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，混入可以接收参数，我们可以向混入传递变量，定义可以接收参数的混入：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> bordered(<span class=\"hljs-variable\">$color</span>, <span class=\"hljs-variable\">$width</span>) &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-variable\">$width</span> solid <span class=\"hljs-variable\">$color</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.myArticle</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> bordered(blue, <span class=\"hljs-number\">1px</span>);<br>&#125;<br><br><span class=\"hljs-selector-class\">.myNotes</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span> bordered(red, <span class=\"hljs-number\">2px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>除此之外，混入也可以定义默认值，语法格式如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> bordered(<span class=\"hljs-variable\">$color</span>: blue, <span class=\"hljs-variable\">$width</span>: <span class=\"hljs-number\">1px</span>) &#123;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-variable\">$width</span> solid <span class=\"hljs-variable\">$color</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>有时候不能确定混入（mixin）或者一个函数（function）使用多少个参数，这个时候我们就可以使用<code>...</code>来设置可变参数，例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> box-shadow(<span class=\"hljs-variable\">$shadows</span>...) &#123;<br>    -moz-<span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>    -webkit-<span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>    <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-variable\">$shadows</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.shadows</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span>: box-shadow(<span class=\"hljs-number\">0px</span> <span class=\"hljs-number\">4px</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">#666</span>, <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">6px</span> <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">#999</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>浏览器前缀使用混入也是十分方便的；</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-keyword\">@mixin</span> transform(<span class=\"hljs-variable\">$property</span>) &#123;<br>    -webkit-<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>    -ms-<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-variable\">$property</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.myBox</span> &#123;<br>    <span class=\"hljs-keyword\">@include</span>: transform(rotate(<span class=\"hljs-number\">20deg</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"extend-和继承\"><a href=\"#extend-和继承\" class=\"headerlink\" title=\"@extend 和继承\"></a>@extend 和继承</h2><p><code>@extend</code>指令告诉Sass一个选择器的样式从另一个选择器继承；</p>\n<p>如果一个样式与另一个样式几乎相同，只有少量区别，则使用@extend就显得更有用；例如：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-selector-class\">.button-basic</span> &#123;<br>    <span class=\"hljs-attribute\">border</span>: none;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">30px</span>;<br>    <span class=\"hljs-attribute\">text-align</span>: center;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;<br>    <span class=\"hljs-attribute\">cursor</span>: pointer;<br>&#125;<br><br><span class=\"hljs-selector-class\">.button-reporter</span> &#123;<br>    <span class=\"hljs-keyword\">@extend</span> .button-basic;<br>    <span class=\"hljs-attribute\">background-color</span>: red;<br>&#125;<br><br><span class=\"hljs-selector-class\">.button-submit</span> &#123;<br>    <span class=\"hljs-keyword\">@extend</span> .button-basic;<br>    <span class=\"hljs-attribute\">background-color</span>: green;<br>    <span class=\"hljs-attribute\">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通过将公共代码抽离出来公用给其他CSS样式从而实现代码的复用，真棒；</p>\n<h2 id=\"Sass函数\"><a href=\"#Sass函数\" class=\"headerlink\" title=\"Sass函数\"></a>Sass函数</h2><p>Sass定义了各种类型的函数，可以通过CSS语句直接调用；这里就不再赘述，有需要可以自行查询文档了解；</p>\n<ul>\n<li>字符串相关函数</li>\n<li>数字相关函数</li>\n<li>列表相关函数</li>\n<li>映射相关函数</li>\n<li>选择器相关函数</li>\n<li>Introspection相关函数</li>\n<li>颜色相关函数</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckztvdl2l00072y61g72ce4k4","category_id":"ckztvdl2i00042y61adq4f9oz","_id":"ckztvdl2q000f2y61glmq60y6"},{"post_id":"ckztvdl2g00022y61cwa4cx2v","category_id":"ckztvdl2i00042y61adq4f9oz","_id":"ckztvdl2s000k2y615hv6bze4"},{"post_id":"ckztvdl2m00082y615d9j7bav","category_id":"ckztvdl2i00042y61adq4f9oz","_id":"ckztvdl2t000n2y614sci46c3"},{"post_id":"ckztvdl2o000c2y61fm9z9f0z","category_id":"ckztvdl2i00042y61adq4f9oz","_id":"ckztvdl2v000s2y61cwjz7jul"},{"post_id":"ckztvdl2h00032y61b2y182ui","category_id":"ckztvdl2i00042y61adq4f9oz","_id":"ckztvdl2w000v2y61btsagwaw"},{"post_id":"ckztvdl2k00062y613y7k6c9w","category_id":"ckztvdl2i00042y61adq4f9oz","_id":"ckztvdl2x000z2y61ej43850v"},{"post_id":"ckztvdl2p000e2y618wm8hbn5","category_id":"ckztvdl2t000o2y61howq7sdi","_id":"ckztvdl2y00132y61f0h0gf7s"},{"post_id":"ckztvdl2r000j2y61a229cfvf","category_id":"ckztvdl2t000o2y61howq7sdi","_id":"ckztvdl3200182y616neeed7a"},{"post_id":"ckztvdl2z00152y616npratl2","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl34001f2y616fiqa48b"},{"post_id":"ckztvdl2s000m2y61ahq7bwcs","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl35001k2y611tf56dzd"},{"post_id":"ckztvdl3100172y61bvpa4k6u","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl36001n2y61d9ih855z"},{"post_id":"ckztvdl2u000r2y61hjka4qyw","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl37001s2y61fzit5tt5"},{"post_id":"ckztvdl33001e2y61a4xw6u2k","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl38001v2y61a78j1y0i"},{"post_id":"ckztvdl34001j2y618ip0d92n","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3900202y615dxaftao"},{"post_id":"ckztvdl2v000u2y6159xu9gcu","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3a00232y616ehpc7yf"},{"post_id":"ckztvdl35001m2y6185hn3j9u","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3b00262y61epi52z7u"},{"post_id":"ckztvdl37001r2y61a3jdbrlg","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3c00292y61azgf1ug8"},{"post_id":"ckztvdl2w000y2y617s926vql","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3d002c2y6180sy566e"},{"post_id":"ckztvdl38001u2y619rc1c1be","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3e002f2y614wh19teb"},{"post_id":"ckztvdl39001z2y61arqg962f","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3f002i2y616cgn39mz"},{"post_id":"ckztvdl2x00112y615f20fd98","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3g002n2y61bhmwbgua"},{"post_id":"ckztvdl3a00222y612jq7fkto","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3h002q2y610e1tcjya"},{"post_id":"ckztvdl3b00252y61h5yp3ssj","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3i002v2y61daawcel3"},{"post_id":"ckztvdl3c00282y617vgu2k67","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3j002y2y61703734yd"},{"post_id":"ckztvdl3c002b2y61gqjt2yk3","category_id":"ckztvdl2y00122y61hgms3lr7","_id":"ckztvdl3k00332y616wr23x4g"},{"post_id":"ckztvdl3g002p2y6164y4hgvr","category_id":"ckztvdl3f002j2y61cb4ufind","_id":"ckztvdl3l00362y618ug3gimz"},{"post_id":"ckztvdl3d002e2y615msu7eao","category_id":"ckztvdl3f002j2y61cb4ufind","_id":"ckztvdl3m00392y6127b32gop"},{"post_id":"ckztvdl3h002s2y61huimf1vh","category_id":"ckztvdl3f002j2y61cb4ufind","_id":"ckztvdl3m003b2y61gy824cdt"},{"post_id":"ckztvdl3i002x2y6131wbc186","category_id":"ckztvdl3f002j2y61cb4ufind","_id":"ckztvdl3m003d2y61elr87j4u"},{"post_id":"ckztvdl3e002h2y6167mpgytk","category_id":"ckztvdl3f002j2y61cb4ufind","_id":"ckztvdl3n003g2y612d830c2w"},{"post_id":"ckztvdl3j00302y61c39b7ejk","category_id":"ckztvdl3f002j2y61cb4ufind","_id":"ckztvdl3n003h2y61a3vjgomx"},{"post_id":"ckztvdl3k00352y61hlpo7mdq","category_id":"ckztvdl3f002j2y61cb4ufind","_id":"ckztvdl3n003k2y614axx8j5r"},{"post_id":"ckztvdl3f002m2y612hz2242p","category_id":"ckztvdl3f002j2y61cb4ufind","_id":"ckztvdl3n003l2y614t7p9857"}],"PostTag":[{"post_id":"ckztvdl2l00072y61g72ce4k4","tag_id":"ckztvdl2k00052y611wz14qrg","_id":"ckztvdl2o000b2y61hn0dd04q"},{"post_id":"ckztvdl2g00022y61cwa4cx2v","tag_id":"ckztvdl2k00052y611wz14qrg","_id":"ckztvdl2p000d2y617zcvbk9e"},{"post_id":"ckztvdl2m00082y615d9j7bav","tag_id":"ckztvdl2k00052y611wz14qrg","_id":"ckztvdl2r000i2y61492u6kud"},{"post_id":"ckztvdl2o000c2y61fm9z9f0z","tag_id":"ckztvdl2k00052y611wz14qrg","_id":"ckztvdl2s000l2y61el806r9g"},{"post_id":"ckztvdl2h00032y61b2y182ui","tag_id":"ckztvdl2k00052y611wz14qrg","_id":"ckztvdl2t000q2y616gz33b4h"},{"post_id":"ckztvdl2k00062y613y7k6c9w","tag_id":"ckztvdl2k00052y611wz14qrg","_id":"ckztvdl2v000t2y618gi120q9"},{"post_id":"ckztvdl2p000e2y618wm8hbn5","tag_id":"ckztvdl2t000p2y61am7g6hhs","_id":"ckztvdl2x00102y61ekrp8l6n"},{"post_id":"ckztvdl2r000j2y61a229cfvf","tag_id":"ckztvdl2t000p2y61am7g6hhs","_id":"ckztvdl3100162y61h52qdfqz"},{"post_id":"ckztvdl2z00152y616npratl2","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl32001b2y619rsfbdfj"},{"post_id":"ckztvdl2s000m2y61ahq7bwcs","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl33001d2y614e191svq"},{"post_id":"ckztvdl3100172y61bvpa4k6u","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl34001i2y610d69dv8w"},{"post_id":"ckztvdl2u000r2y61hjka4qyw","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl35001l2y61d0xs6730"},{"post_id":"ckztvdl33001e2y61a4xw6u2k","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl36001q2y61erkm2o61"},{"post_id":"ckztvdl34001j2y618ip0d92n","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl37001t2y61c3h37siv"},{"post_id":"ckztvdl2v000u2y6159xu9gcu","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl39001y2y619z670xjo"},{"post_id":"ckztvdl35001m2y6185hn3j9u","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3a00212y616435emzh"},{"post_id":"ckztvdl37001r2y61a3jdbrlg","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3b00242y61dki6hxpf"},{"post_id":"ckztvdl2w000y2y617s926vql","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3c00272y6109vr0p2d"},{"post_id":"ckztvdl38001u2y619rc1c1be","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3c002a2y614kxsggdp"},{"post_id":"ckztvdl39001z2y61arqg962f","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3d002d2y611uso60rz"},{"post_id":"ckztvdl2x00112y615f20fd98","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3e002g2y61f2jg70up"},{"post_id":"ckztvdl3a00222y612jq7fkto","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3f002l2y611uuj62hk"},{"post_id":"ckztvdl3b00252y61h5yp3ssj","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3g002o2y61325q6igm"},{"post_id":"ckztvdl3c00282y617vgu2k67","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3h002r2y614dntfk3n"},{"post_id":"ckztvdl3c002b2y61gqjt2yk3","tag_id":"ckztvdl2y00142y610j04db45","_id":"ckztvdl3i002w2y614uhrglnb"},{"post_id":"ckztvdl3g002p2y6164y4hgvr","tag_id":"ckztvdl3f002k2y61e8sbgzw9","_id":"ckztvdl3j002z2y61g6p77hym"},{"post_id":"ckztvdl3d002e2y615msu7eao","tag_id":"ckztvdl3f002k2y61e8sbgzw9","_id":"ckztvdl3k00342y613fmfa1c0"},{"post_id":"ckztvdl3h002s2y61huimf1vh","tag_id":"ckztvdl3f002k2y61e8sbgzw9","_id":"ckztvdl3l00372y6183o90t2w"},{"post_id":"ckztvdl3e002h2y6167mpgytk","tag_id":"ckztvdl3f002k2y61e8sbgzw9","_id":"ckztvdl3m003a2y61eystb3qn"},{"post_id":"ckztvdl3f002m2y612hz2242p","tag_id":"ckztvdl3f002k2y61e8sbgzw9","_id":"ckztvdl3m003c2y6101bi2i4n"},{"post_id":"ckztvdl3i002x2y6131wbc186","tag_id":"ckztvdl3l00382y619bmy4wm2","_id":"ckztvdl3n003f2y61gluef43w"},{"post_id":"ckztvdl3j00302y61c39b7ejk","tag_id":"ckztvdl3l00382y619bmy4wm2","_id":"ckztvdl3n003j2y610w32fyv7"},{"post_id":"ckztvdl3k00352y61hlpo7mdq","tag_id":"ckztvdl3l00382y619bmy4wm2","_id":"ckztvdl3n003m2y61d3hvcgu6"}],"Tag":[{"name":"Java基础","_id":"ckztvdl2k00052y611wz14qrg"},{"name":"Spring Cloud","_id":"ckztvdl2t000p2y61am7g6hhs"},{"name":"ES6基础","_id":"ckztvdl2y00142y610j04db45"},{"name":"HTML","_id":"ckztvdl3f002k2y61e8sbgzw9"},{"name":"CSS3","_id":"ckztvdl3l00382y619bmy4wm2"}]}}